<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一蓑烟雨任平生</title>
  
  <subtitle>个人成长日记</subtitle>
  <link href="https://www.sunliaodong.cn/atom.xml" rel="self"/>
  
  <link href="https://www.sunliaodong.cn/"/>
  <updated>2021-02-07T03:18:59.156Z</updated>
  <id>https://www.sunliaodong.cn/</id>
  
  <author>
    <name>Theodore Sun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发编程之Executors</title>
    <link href="https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BExecutors/"/>
    <id>https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BExecutors/</id>
    <published>2021-02-07T03:16:17.000Z</published>
    <updated>2021-02-07T03:18:59.156Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;newCachedThreadPool&quot;&gt;&lt;a href=&quot;#newCachedThreadPool&quot; class=&quot;headerlink&quot; title=&quot;newCachedThreadPool&quot;&gt;&lt;/a&gt;newCachedThreadPool&lt;/h2&gt;&lt;p&gt;创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行&lt;strong&gt;很多短期异步任务&lt;/strong&gt;的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。因此，长时间保持空闲的线程池不会使用任何资源。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Java线程池" scheme="https://www.sunliaodong.cn/categories/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程池" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="Executors" scheme="https://www.sunliaodong.cn/tags/Executors/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之ScheduledThreadPoolExecutor</title>
    <link href="https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BScheduledThreadPoolExecutor/"/>
    <id>https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BScheduledThreadPoolExecutor/</id>
    <published>2021-02-07T03:09:00.000Z</published>
    <updated>2021-02-07T03:15:33.627Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;任务执行&quot;&gt;&lt;a href=&quot;#任务执行&quot; class=&quot;headerlink&quot; title=&quot;任务执行&quot;&gt;&lt;/a&gt;任务执行&lt;/h2&gt;&lt;p&gt;当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWith-FixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了RunnableScheduledFuture接口的ScheduledFutureTask。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Java线程池" scheme="https://www.sunliaodong.cn/categories/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="ScheduledThreadPoolExecutor" scheme="https://www.sunliaodong.cn/tags/ScheduledThreadPoolExecutor/"/>
    
    <category term="线程池" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程池总体架构</title>
    <link href="https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</id>
    <published>2021-02-07T03:03:43.000Z</published>
    <updated>2021-02-07T03:07:13.999Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Executor&quot;&gt;&lt;a href=&quot;#Executor&quot; class=&quot;headerlink&quot; title=&quot;Executor&quot;&gt;&lt;/a&gt;Executor&lt;/h2&gt;&lt;p&gt;为了方便并发执行任务，出现了一种专门用来执行任务的实现，也就是&lt;code&gt;Executor&lt;/code&gt;。&lt;br&gt;由此，任务提交者不需要再创建管理线程，使用更方便，也减少了开销。Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 &lt;code&gt;ExecutorService&lt;/code&gt;。Executor定义规范。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Java线程池" scheme="https://www.sunliaodong.cn/categories/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程池" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="Executor" scheme="https://www.sunliaodong.cn/tags/Executor/"/>
    
    <category term="ExecutorService" scheme="https://www.sunliaodong.cn/tags/ExecutorService/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程池概述</title>
    <link href="https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0/</id>
    <published>2021-02-07T03:02:16.000Z</published>
    <updated>2021-02-07T03:03:05.421Z</updated>
    
    
    <summary type="html">&lt;p&gt;使用线程池可以有以下优点：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java线程池" scheme="https://www.sunliaodong.cn/categories/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程池" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之ThreadPoolExecutor</title>
    <link href="https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadPoolExecutor/"/>
    <id>https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadPoolExecutor/</id>
    <published>2021-02-07T02:58:07.000Z</published>
    <updated>2021-02-07T03:01:53.046Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;构建函数&quot;&gt;&lt;a href=&quot;#构建函数&quot; class=&quot;headerlink&quot; title=&quot;构建函数&quot;&gt;&lt;/a&gt;构建函数&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Creates a new &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; ThreadPoolExecutor&amp;#125; with the given initial&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * parameters.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; corePoolSize the number of threads to keep in the pool, even&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        if they are idle, unless &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; allowCoreThreadTimeOut&amp;#125; is set&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 当提交一个任务到线程池时，线程池会创建一个线程来执行任务，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 即使其他空闲的基本线程能够执行新任务也会创建线程，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 等到需要执行的任务数大于线程池基本大小时就不再创建。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 调用prestartAllCoreThreads()后，线程池会提前创建并启动所有基本线程。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; maximumPoolSize the maximum number of threads to allow in the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        pool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 则线程池会再创建新的线程执行任务（无线队列会使该参数失效）。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; keepAliveTime when the number of threads is greater than&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        the core, this is the maximum time that excess idle threads&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        will wait for new tasks before terminating.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 线程池的工作线程空闲后，保持存活的时间。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; unit the time unit for the &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; keepAliveTime&amp;#125; argument&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 		  -- 天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; workQueue the queue to use for holding tasks before they are&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        executed.  This queue will hold only the &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; Runnable&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        tasks submitted by the &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; execute&amp;#125; method.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 用于保存等待执行的任务的阻塞队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- ❑ ArrayBlockingQueue：基于数组结构的有界阻塞队列，排序规则：FIFO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- ❑ LinkedBlockingQueue：基于链表结构的阻塞队列，排序规则：FIFO，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                                    吞吐量通常要高于ArrayBlockingQueue。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                                    Executors.newFixedThreadPool()使用了这个队列。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- ❑ SynchronousQueue：一个不存储元素的阻塞队列（读写交换执行，否则会阻塞。）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                                  吞吐量通常要高于Linked-BlockingQueue，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                                  Executors.newCachedThreadPool使用了这个队列。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- ❑ PriorityBlockingQueue：一个具有优先级的无限阻塞队列。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; threadFactory the factory to use when the executor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        creates a new thread&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 使用开源框架guava提供的ThreadFactoryBuilder&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;             可以快速给线程池里的线程设置有意义的名字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; handler the handler to use when execution is blocked&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        because the thread bounds and queue capacities are reached&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 当队列和线程池都满了（饱和状态），那么必须采取一种策略处理提交的新任务。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- ❑ AbortPolicy：直接抛出异常。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- ❑ CallerRunsPolicy：只用调用者所在线程来运行任务。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- ❑ DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- ❑ DiscardPolicy：不处理，丢弃掉。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *        -- 实现RejectedExecutionHandler接口自定义策略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; IllegalArgumentException if one of the following holds:&amp;lt;br&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *         &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; corePoolSize &amp;lt; 0&amp;#125;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *         &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; keepAliveTime &amp;lt; 0&amp;#125;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *         &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; maximumPoolSize &amp;lt;= 0&amp;#125;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *         &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; maximumPoolSize &amp;lt; corePoolSize&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; NullPointerException if &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; workQueue&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *         or &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; threadFactory&amp;#125; or &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; handler&amp;#125; is null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; corePoolSize,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maximumPoolSize,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; keepAliveTime,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          TimeUnit unit,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          ThreadFactory threadFactory,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          RejectedExecutionHandler handler)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (corePoolSize &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maximumPoolSize &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maximumPoolSize &amp;lt; corePoolSize ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        keepAliveTime &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (workQueue == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || threadFactory == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || handler == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.acc = System.getSecurityManager() == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            AccessController.getContext();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.corePoolSize = corePoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maximumPoolSize = maximumPoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.workQueue = workQueue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keepAliveTime = unit.toNanos(keepAliveTime);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.threadFactory = threadFactory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handler = handler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Java线程池" scheme="https://www.sunliaodong.cn/categories/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程池" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="ThreadPoolExecutor" scheme="https://www.sunliaodong.cn/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之ThreadLocal</title>
    <link href="https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal/"/>
    <id>https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal/</id>
    <published>2021-02-07T02:24:20.000Z</published>
    <updated>2021-02-07T02:45:21.978Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;API描述&quot;&gt;&lt;a href=&quot;#API描述&quot; class=&quot;headerlink&quot; title=&quot;API描述&quot;&gt;&lt;/a&gt;API描述&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* This &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;provides&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;thread&lt;/span&gt;-&lt;span class=&quot;title&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;variables&lt;/span&gt;.  &lt;span class=&quot;title&quot;&gt;These&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;variables&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;differ&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;from&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;* &lt;span class=&quot;title&quot;&gt;their&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;normal&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;counterparts&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;that&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;that&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;accesses&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;one&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;via&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;its&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;* &lt;/span&gt;&amp;#123;&lt;span class=&quot;meta&quot;&gt;@code&lt;/span&gt; get&amp;#125; or &amp;#123;&lt;span class=&quot;meta&quot;&gt;@code&lt;/span&gt; set&amp;#125; method) has its own, independently initialized&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* copy of the variable.  &amp;#123;&lt;span class=&quot;meta&quot;&gt;@code&lt;/span&gt; ThreadLocal&amp;#125; instances are typically &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; fields in classes that wish to associate state with a &lt;span class=&quot;title&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(e.g.,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;* a user ID or Transaction ID)&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;提供一种线程本地变量。这种变量是一种副本的概念，在多线程环境下访问（get、set）能够保证各个线程间的变量互相隔离。&lt;code&gt;ThreadLocal&lt;/code&gt;通常定义为了&lt;code&gt;private static&lt;/code&gt;，用来关联线程和线程上下文（比如userId或事物ID）。&lt;code&gt;ThreadLocal&lt;/code&gt; 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程控制" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    
    <category term="ThreadLocal" scheme="https://www.sunliaodong.cn/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之LockSupport</title>
    <link href="https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLockSupport/"/>
    <id>https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLockSupport/</id>
    <published>2021-02-07T02:21:46.000Z</published>
    <updated>2021-02-07T02:23:57.254Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;类结构&quot;&gt;&lt;a href=&quot;#类结构&quot; class=&quot;headerlink&quot; title=&quot;类结构&quot;&gt;&lt;/a&gt;类结构&lt;/h2&gt;&lt;div align=&quot;center&quot;&gt;

&lt;img src=&quot;/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLockSupport/1590712088254.png&quot; class title=&quot;LocalSupport类图&quot;&gt;

&lt;/div&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="LockSupport" scheme="https://www.sunliaodong.cn/tags/LockSupport/"/>
    
    <category term="线程控制" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之Condition</title>
    <link href="https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/"/>
    <id>https://www.sunliaodong.cn/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/</id>
    <published>2021-02-07T02:16:30.000Z</published>
    <updated>2021-02-07T02:22:11.908Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Condition在jdk1.5中开始出现，主要是用来替代传统Object对象中的wait和notify方法，Object的wait和notify/notify是与&lt;font color=&quot;red&quot;&gt;对象监视器&lt;/font&gt;配合完成线程间的等待/通知机制，而Condition与Lock配合完成等待通知机制，前者是java底层级别的（配合synchronized），后者是语言级别的（配合Lock），具有更高的可控制性和扩展性相比来说更加安全和  高效。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程控制" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    
    <category term="Condition" scheme="https://www.sunliaodong.cn/tags/Condition/"/>
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</id>
    <published>2021-02-05T12:28:00.000Z</published>
    <updated>2021-02-05T12:31:30.219Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;测试分类&quot;&gt;&lt;a href=&quot;#测试分类&quot; class=&quot;headerlink&quot; title=&quot;测试分类&quot;&gt;&lt;/a&gt;测试分类&lt;/h2&gt;&lt;h3 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class=&quot;headerlink&quot; title=&quot;单元测试&quot;&gt;&lt;/a&gt;单元测试&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;软件测试的最基本单元，针对软件中的基本组成部分进行测试，比如一个模块、一个方法；&lt;/li&gt;
&lt;li&gt;目的是验证最小单位的正确性，其正确性依赖详细设计&lt;/li&gt;
&lt;li&gt;主要方法有控制流测试、数据流测试、排错测试、分域测试等等。&lt;/li&gt;
&lt;li&gt;过程：研发整个过程中需要实施，尤其是针对关键核心代码的准确性测试&lt;/li&gt;
&lt;li&gt;优点： &lt;ul&gt;
&lt;li&gt;一个好的单元测试将会在产品开发的阶段发现大部分的缺陷，并且修改他们的成本也很低；&lt;/li&gt;
&lt;li&gt;在软件开发的后期阶段，缺陷的修改将会变得更加困难，要消耗大量的时间和费用。&lt;/li&gt;
&lt;li&gt;经过单元测试的系统，系统集成过程将会达达的简化。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="测试" scheme="https://www.sunliaodong.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="研发效能" scheme="https://www.sunliaodong.cn/categories/%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD/"/>
    
    
    <category term="测试" scheme="https://www.sunliaodong.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="python" scheme="https://www.sunliaodong.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之索引</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/</id>
    <published>2021-02-05T12:23:48.000Z</published>
    <updated>2021-02-05T12:24:42.956Z</updated>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;索引是存储引擎用于快速找到记录的一种数据结构；对于性能的好坏起到决定性的作用&lt;/li&gt;
&lt;li&gt;通过索引号找到对应的数据编号，然后根据编号或对应数据的详细信息&lt;/li&gt;
&lt;li&gt;MySQL中的索引在存储引擎中实现&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://www.sunliaodong.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://www.sunliaodong.cn/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.sunliaodong.cn/tags/MySQL/"/>
    
    <category term="索引" scheme="https://www.sunliaodong.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之调度方式</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/</id>
    <published>2021-02-05T11:32:04.000Z</published>
    <updated>2021-02-05T12:04:17.134Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;抢占式调度&quot;&gt;&lt;a href=&quot;#抢占式调度&quot; class=&quot;headerlink&quot; title=&quot;抢占式调度&quot;&gt;&lt;/a&gt;抢占式调度&lt;/h2&gt;&lt;p&gt;抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。&lt;/p&gt;
&lt;h2 id=&quot;协同式调度&quot;&gt;&lt;a href=&quot;#协同式调度&quot; class=&quot;headerlink&quot; title=&quot;协同式调度&quot;&gt;&lt;/a&gt;协同式调度&lt;/h2&gt;&lt;p&gt;协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程调度" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程优先级</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</id>
    <published>2021-02-05T11:31:54.000Z</published>
    <updated>2021-02-05T12:02:08.746Z</updated>
    
    
    <summary type="html">&lt;p&gt;现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。优先级高的线程分配时间片的数量要多于优先级低的线程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程优先级" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之守护线程</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-02-05T11:31:42.000Z</published>
    <updated>2021-02-05T12:01:07.188Z</updated>
    
    
    <summary type="html">&lt;p&gt;java中线程的分类：用户线程 (User Thread)、守护线程 (Daemon Thread)。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;守护线程&lt;/strong&gt;：在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;：用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Java中的定义&quot;&gt;&lt;a href=&quot;#Java中的定义&quot; class=&quot;headerlink&quot; title=&quot;Java中的定义&quot;&gt;&lt;/a&gt;Java中的定义&lt;/h2&gt;&lt;p&gt;通过Thread中的setDaemon方法完成设置。通过源码分析得知：&lt;strong&gt;当线程只剩下守护线程的时候，JVM就会退出.但是如果还有其他的任意一个用户线程还在，JVM就不会退出&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="守护线程" scheme="https://www.sunliaodong.cn/tags/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程常用方法</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-02-05T11:31:31.000Z</published>
    <updated>2021-02-05T11:59:54.246Z</updated>
    
    
    <summary type="html">&lt;div align=&quot;center&quot;&gt;

&lt;img src=&quot;/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/1590711795506.png&quot; class title=&quot;Runnable类图&quot;&gt;

&lt;/div&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程常用方法" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
    <category term="sleep" scheme="https://www.sunliaodong.cn/tags/sleep/"/>
    
    <category term="wait" scheme="https://www.sunliaodong.cn/tags/wait/"/>
    
    <category term="join" scheme="https://www.sunliaodong.cn/tags/join/"/>
    
    <category term="yield" scheme="https://www.sunliaodong.cn/tags/yield/"/>
    
    <category term="start" scheme="https://www.sunliaodong.cn/tags/start/"/>
    
    <category term="run" scheme="https://www.sunliaodong.cn/tags/run/"/>
    
    <category term="park" scheme="https://www.sunliaodong.cn/tags/park/"/>
    
    <category term="unpark" scheme="https://www.sunliaodong.cn/tags/unpark/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程中断</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</id>
    <published>2021-02-05T11:31:20.000Z</published>
    <updated>2021-02-05T11:55:59.325Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;正常结束-执行完成&quot;&gt;&lt;a href=&quot;#正常结束-执行完成&quot; class=&quot;headerlink&quot; title=&quot;正常结束(执行完成)&quot;&gt;&lt;/a&gt;正常结束(执行完成)&lt;/h2&gt;&lt;h2 id=&quot;使用退出标志退出线程&quot;&gt;&lt;a href=&quot;#使用退出标志退出线程&quot; class=&quot;headerlink&quot; title=&quot;使用退出标志退出线程&quot;&gt;&lt;/a&gt;使用退出标志退出线程&lt;/h2&gt;&lt;p&gt;一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是&lt;strong&gt;伺服线程&lt;/strong&gt;。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false 来控制while 循环是否退出，代码示例：&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程中断" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    
    <category term="Interrupt" scheme="https://www.sunliaodong.cn/tags/Interrupt/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程创建</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/</id>
    <published>2021-02-05T11:31:12.000Z</published>
    <updated>2021-02-05T12:08:56.579Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;通过Thread构建&quot;&gt;&lt;a href=&quot;#通过Thread构建&quot; class=&quot;headerlink&quot; title=&quot;通过Thread构建&quot;&gt;&lt;/a&gt;通过Thread构建&lt;/h2&gt;&lt;p&gt;Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="源码分析" scheme="https://www.sunliaodong.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程创建" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    
    <category term="Thread" scheme="https://www.sunliaodong.cn/tags/Thread/"/>
    
    <category term="Runnable" scheme="https://www.sunliaodong.cn/tags/Runnable/"/>
    
    <category term="Callable" scheme="https://www.sunliaodong.cn/tags/Callable/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程状态</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</id>
    <published>2021-02-05T11:31:03.000Z</published>
    <updated>2021-02-05T11:50:19.130Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;操作系统中的状态&quot;&gt;&lt;a href=&quot;#操作系统中的状态&quot; class=&quot;headerlink&quot; title=&quot;操作系统中的状态&quot;&gt;&lt;/a&gt;操作系统中的状态&lt;/h2&gt;&lt;div align=&quot;center&quot;&gt;

&lt;img src=&quot;/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1590649906474.png&quot; class title=&quot;操作系统中的状态&quot;&gt;

&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联&lt;/li&gt;
&lt;li&gt;【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行&lt;/li&gt;
&lt;li&gt;【运行状态】指获取了 CPU 时间片运行中的状态&lt;ul&gt;
&lt;li&gt;当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;【阻塞状态】&lt;ul&gt;
&lt;li&gt;如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】&lt;/li&gt;
&lt;li&gt;等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】&lt;/li&gt;
&lt;li&gt;与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程状态" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程的概念</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2021-02-05T11:30:55.000Z</published>
    <updated>2021-02-05T11:47:01.993Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;线程与进程&quot;&gt;&lt;a href=&quot;#线程与进程&quot; class=&quot;headerlink&quot; title=&quot;线程与进程&quot;&gt;&lt;/a&gt;线程与进程&lt;/h3&gt;&lt;h4 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;用来加载指令、管理内存、管理IO、磁盘读写&lt;/li&gt;
&lt;li&gt;当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。&lt;/li&gt;
&lt;li&gt;进程就可以视为程序的一个实例比如java.exe&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行&lt;/li&gt;
&lt;li&gt;在一个进程里可以创建多个线程，一个标准的线程包括&lt;strong&gt;线程ID，当前指令指针(PC），寄存器集合和堆栈组成&lt;/strong&gt;，堆中的内容可共享。处理器在这些线程上高速切换（涉及到上下文切换），让使用者感觉到这些线程在同时执行。&lt;strong&gt;如果没有明确的协同机制&lt;/strong&gt;，线程将彼此独立执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。  &lt;/li&gt;
&lt;li&gt;线程是进程的一个实体（一个进程包含多个进程），是被系统独立调度和分配的最小单元，，也叫轻量级线程（Light Weight Process），并且线程拥有独立的资源包括：栈、线程ID、寄存器和指令指针，其他堆中的资源在内存中共享。共享资源在并发编程中需要增加同步机制防止资源数据处理不对。  &lt;/li&gt;
&lt;li&gt;一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有&lt;strong&gt;就绪、阻塞和运行&lt;/strong&gt;三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。  &lt;/li&gt;
&lt;li&gt;线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="线程" scheme="https://www.sunliaodong.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="进程" scheme="https://www.sunliaodong.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之内存模型</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-02-05T11:30:40.000Z</published>
    <updated>2021-02-05T11:45:03.042Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;作用：屏蔽各种硬件和操作系统内存的访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果，定义了Java虚拟机与计算机内存是如何协同工作的，是一种主存与工作内存的抽象概念，并且底层对应CPU的寄存器、缓存、硬件内存以及CPU指令优化等&lt;/li&gt;
&lt;li&gt;简称：Java Memory Model简称JMM&lt;/li&gt;
&lt;li&gt;目的：定义程序中各个变量的访问规则，以及在必须时如何同步地访问共享变量，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="JVM" scheme="https://www.sunliaodong.cn/categories/JVM/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="内存模型" scheme="https://www.sunliaodong.cn/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之面临的问题</title>
    <link href="https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.sunliaodong.cn/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-02-05T11:30:29.000Z</published>
    <updated>2021-02-05T12:07:03.484Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;上线文切换&quot;&gt;&lt;a href=&quot;#上线文切换&quot; class=&quot;headerlink&quot; title=&quot;上线文切换&quot;&gt;&lt;/a&gt;上线文切换&lt;/h2&gt;&lt;p&gt;巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做&lt;strong&gt;上下文切换&lt;/strong&gt;。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://www.sunliaodong.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.sunliaodong.cn/tags/Java/"/>
    
    <category term="上线文切换" scheme="https://www.sunliaodong.cn/tags/%E4%B8%8A%E7%BA%BF%E6%96%87%E5%88%87%E6%8D%A2/"/>
    
    <category term="死锁" scheme="https://www.sunliaodong.cn/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
</feed>
