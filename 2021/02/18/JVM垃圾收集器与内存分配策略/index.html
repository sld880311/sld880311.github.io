<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png">
  <link rel="mask-icon" href="/images/avatar.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sunliaodong.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="对象已死引用计数算法（reference-counting）定义：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 缺点：无法简单的处理对象循环引用       可达性算法（GC Roots Tracing）定义：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM垃圾收集器与内存分配策略">
<meta property="og:url" content="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/index.html">
<meta property="og:site_name" content="一蓑烟雨任平生">
<meta property="og:description" content="对象已死引用计数算法（reference-counting）定义：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 缺点：无法简单的处理对象循环引用       可达性算法（GC Roots Tracing）定义：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%BC%95%E7%94%A8%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB.png">
<meta property="article:published_time" content="2021-02-18T03:19:49.000Z">
<meta property="article:modified_time" content="2021-02-18T11:07:11.861Z">
<meta property="article:author" content="Theodore Sun">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="垃圾收集器">
<meta property="article:tag" content="内存分配策略">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%BC%95%E7%94%A8%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95.png">

<link rel="canonical" href="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM垃圾收集器与内存分配策略 | 一蓑烟雨任平生</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="一蓑烟雨任平生" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">一蓑烟雨任平生</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人成长日记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">144</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">92</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.sunliaodong.cn/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Theodore Sun">
      <meta itemprop="description" content="心之所向，素履以往">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一蓑烟雨任平生">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM垃圾收集器与内存分配策略
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-18 11:19:49 / 修改时间：19:07:11" itemprop="dateCreated datePublished" datetime="2021-02-18T11:19:49+08:00">2021-02-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="对象已死"><a href="#对象已死" class="headerlink" title="对象已死"></a>对象已死</h2><h3 id="引用计数算法（reference-counting）"><a href="#引用计数算法（reference-counting）" class="headerlink" title="引用计数算法（reference-counting）"></a>引用计数算法（reference-counting）</h3><p><strong>定义</strong>：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p><strong>缺点</strong>：无法简单的处理对象循环引用</p>
<div align="center">

<img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%BC%95%E7%94%A8%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95.png" class title="引用计算算法">

</div>

<h3 id="可达性算法（GC-Roots-Tracing）"><a href="#可达性算法（GC-Roots-Tracing）" class="headerlink" title="可达性算法（GC Roots Tracing）"></a>可达性算法（GC Roots Tracing）</h3><p><strong>定义</strong>：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<a id="more"></a>

<div align="center">

<img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png" class title="可达性算法">

</div>

<h4 id="GCRoot对象"><a href="#GCRoot对象" class="headerlink" title="GCRoot对象"></a>GCRoot对象</h4><ol>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（StringTable）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<h4 id="对象死亡"><a href="#对象死亡" class="headerlink" title="对象死亡"></a>对象死亡</h4><div align="center">

<img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB.png" class title="对象已死">

</div>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><strong>定义</strong>：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>在程序代码之中普遍存在的，类似<code>Object obj = new Object()</code>这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象；</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>描述一些还有用但非必需的对象。对于软引用关联着的对象，<strong>在系统将要发生内存溢出异常之前</strong>，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常；</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象；</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知；</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>废弃常量和无用的类</strong>。</p>
<h4 id="回收废弃常量"><a href="#回收废弃常量" class="headerlink" title="回收废弃常量"></a>回收废弃常量</h4><ol>
<li>与Java堆中的对象回收类似</li>
<li>举例：字符串常量“java”，如果jvm中没有其他地方引用这个字面量并且没有任何字符串对象已用这个常量；jvm有可能会把该常量移除常量池</li>
<li>类（接口）、方法、自动的符号引用类似</li>
</ol>
<h4 id="如何判断一个类是否是无用的类"><a href="#如何判断一个类是否是无用的类" class="headerlink" title="如何判断一个类是否是无用的类"></a>如何判断一个类是否是无用的类</h4><ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li>
<li>加载该类的<strong>ClassLoader</strong>已经被回收；</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；</li>
</ol>
<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是可以，而并不是和对象一样，不使用了就必然会回收。</p>
<blockquote>
<p>关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p>
</blockquote>
<h2 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h2><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">GC类型</th>
    <th class="tg-0lax">触发条件</th>
    <th class="tg-0lax">触发时发生的事情</th>
    <th class="tg-0lax">注意</th>
    <th class="tg-0lax">查看方式</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>YGC&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>eden空间不足&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">清空eden+from survivor中的所有no ref对象占用的内存<br>将eden+from survivor中所有存活的对象copy到to survivor中<br>一些对象升级到old中：to survivor放不下、存储次数超过turing threshold<br>重新计算tenuring threshold(serial parallel   GC会触发此项)<br>重新调整Eden 和from的大小(parallel GC会触发此项)   </td>
    <td class="tg-0lax">全部暂停应用<br>是否为多线程处理由具体的GC决定   </td>
    <td class="tg-0lax">jstat -gcutil<br>gc log   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>FGC&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">old空间不足<br>perm空间不足<br>显示调用System.GC，RMI等定时触发<br>YGC的悲观策略<br>Dump live内存信息时（jmap   -dump:live）   </td>
    <td class="tg-0lax">清空heap中的no ref的对象<br>permgen中已经呗卸载的classloader中加载的class信息<br>如果配置了CollectGenOFirst/ScavengeBeforeFullGC，则先触发YGC（针对serival GC）   </td>
    <td class="tg-0lax">全部暂停应用<br>是否为多线程处理由具体的GC决定<br>是否压缩需要看配置的具体GC   </td>
    <td class="tg-0lax">jstat -gcutil<br>gc log   </td>
  </tr>
</tbody>
</table>

<p>permanent generation空间不足会引发Full GC,仍然不够会引发PermGen Space错误。</p>
<h3 id="GC信息的选项"><a href="#GC信息的选项" class="headerlink" title="GC信息的选项"></a>GC信息的选项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails 显示GC的详细信息</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime 打印应用执行的时间</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime 打印应用被暂停的时间</span><br></pre></td></tr></table></figure>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-z9od{font-size:12px;text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 791px">
<colgroup>
<col style="width: 82px">
<col style="width: 218px">
<col style="width: 250px">
<col style="width: 241px">
</colgroup>
<thead>
  <tr>
    <th class="tg-z9od"><span style="font-weight:bold">类别</span></th>
    <th class="tg-z9od"><span style="font-weight:bold">Serial collector串行</span></th>
    <th class="tg-z9od"><span style="font-weight:bold">Parallel</span>&nbsp;&nbsp;<span style="font-weight:bold">Collector并行</span><br><span style="font-weight:bold">（throughput collector</span></th>
    <th class="tg-z9od"><span style="font-weight:bold">Concurrent&nbsp;&nbsp;&nbsp;collector并发</span><br><br><span style="font-weight:bold">（concurrent low pause collector）</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-z9od">   <br>介绍   </td>
    <td class="tg-z9od">单线程收集器<br>使用单线程完成所有的gc工作，没有线程间的通信，这种方式会相对较高效&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">并行收集器<br>使用多线程的方式，利用多CPU来提高GC的效率，主要以达到<span style="color:red">一定的吞吐量</span>为目标&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">并发收集器<br>使用多线程的方式，利用多CPU来提高GC的效率<span style="color:red">并发</span>完成大部分工作，提高gc&nbsp;&nbsp;&nbsp;pause&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-z9od">使用场景&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">单处理器且没有pause time的要求&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">科学计算和后台处理有中规模/大规模数据集大小的应用且运行在多个处理器上，<span style="color:red">关注吞吐量（throughput）</span>&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">中规模/大规模数据集大小的应用，应用服务，电信领域。<span style="color:red">关注响应时间</span>&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-z9od">&nbsp;&nbsp;&nbsp;<br>使用&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">Client模式下默认<br>可使用-XX:UseSerialGC强制使用<br>优点：对server应用没有优点<br>缺点：不能充分使用硬件资源&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">Server模式下默认 <br>--YGC:PS&nbsp;&nbsp;&nbsp;FGC:Parallel MSC <br>可用-XX:+UseParallelGC或-XX+UseParallelOldGC强制指定<br>--ParallelGC代表FGC为Parallel MSC<br>--ParallelOldGC代表FGC为Parallel Compacting<br>优点:高效<br>缺点:当heap变大后,造成的暂停时间会变得比较长</td>
    <td class="tg-z9od">可用-XX:+UseConcMarkSweepGC强制指定<br>优点:<br>对old进行回收时,对应用造成的暂停时间非常短,适合对latency要求比较高的应用<br>缺点:<br>1.内存碎片和浮动垃圾<br>2.old去的内存分配效率低<br>3.回收的整个耗时比较长<br>4.和应用争抢CPU&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-z9od">   <br>内存回收触发   </td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>eden空间不足<br><span style="font-weight:bold">FGC</span><br>old空间不足<br>perm空间不足<br>显示调用System.gc()&nbsp;&nbsp;&nbsp;,包括RMI等的定时触发<br>YGC时的悲观策略<br>dump live的内存信息时(jmap&nbsp;&nbsp;&nbsp;–dump:live)&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>eden空间不足<br><span style="font-weight:bold">FGC</span><br>old空间不足<br>perm空间不足<br>显示调用System.gc()&nbsp;&nbsp;&nbsp;,包括RMI等的定时触发<br>YGC时的悲观策略--YGC前&amp;YGC后<br>dump live的内存信息时(jmap&nbsp;&nbsp;&nbsp;–dump:live)&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>eden空间不足<br><span style="font-weight:bold">CMS GC</span><br>1.old Gen的使用率大于一定的比率 默认为92%<br>2.配置了CMSClassUnloadingEnabled,且Perm Gen的使用达到一定的比率 默认为92%<br>3.Hotspot自己根据估计决定是否要触法<br>4.在配置了ExplictGCInvokesConcurrent的情况下显示调用了System.gc.<br>Full GC(Serial MSC)<br>promotion failed 或 concurrent&nbsp;&nbsp;&nbsp;Mode Failure时;&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-z9od">   <br>发生的事情   </td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>eden空间不足<br><span style="font-weight:bold">FGC</span><br>old空间不足<br>perm空间不足<br>显示调用System.gc()&nbsp;&nbsp;&nbsp;,包括RMI等的定时触发<br>YGC时的悲观策略<br>dump live的内存信息时(jmap&nbsp;&nbsp;&nbsp;–dump:live)&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>同serial动作基本相同,不同点:<br>1.多线程处理<br>2.YGC的最后不仅重新计算Tenuring&nbsp;&nbsp;&nbsp;Threshold,还会重新调整Eden和From的大小<br><span style="font-weight:bold">FGC</span><br>1.如配置了ScavengeBeforeFullGC(默认),则先触发YGC(??)<br>2.MSC:清空heap中的no ref对象,permgen中已经被卸载的classloader中加载的class信息,并进行压缩<br>3.Compacting:清空heap中部分no ref的对象,permgen中已经被卸载的classloader中加载的class信息,并进行部分压缩<br>多线程做以上动作.&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>同serial动作基本相同,不同点:<br>1.多线程处理<br><span style="font-weight:bold">CMSGC</span>:<br>1.old gen到达比率时只清除old&nbsp;&nbsp;&nbsp;gen中no ref的对象所占用的空间<br>2.perm gen到达比率时只清除已被清除的classloader加载的class信息<br><span style="font-weight:bold">FGC</span><br>同serial&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-z9od">   <br>细节参数   </td>
    <td class="tg-z9od">可用-XX:+UseSerialGC强制使用<br>-XX:SurvivorRatio=x,控制eden/s0/s1的大小<br>-XX:MaxTenuringThreshold,用于控制对象在新生代存活的最大次数<br>-XX:PretenureSizeThreshold=x,控制超过多大的字节的对象就在old分配.&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od"><span style="font-weight:bold">-</span>XX:SurvivorRatio=x,控制eden/s0/s1的大小<br>-XX:MaxTenuringThreshold,用于控制对象在新生代存活的最大次数<br>-XX:UseAdaptiveSizePolicy 去掉YGC后动态调整eden from已经tenuringthreshold的动作<br>-XX:ParallelGCThreads&nbsp;&nbsp;&nbsp;设置并行的线程数&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">-XX:CMSInitiatingOccupancyFraction 设置old gen使用到达多少比率时触发<br>-XX:CMSInitiatingPermOccupancyFraction,设置Perm Gen使用到达多少比率时触发<br>-XX:+UseCMSInitiatingOccupancyOnly禁止hostspot自行触发CMS GC&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 776px">
<colgroup>
<col style="width: 130px">
<col style="width: 646px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"><span style="font-weight:bold">算法</span></th>
    <th class="tg-0lax"><span style="font-weight:bold">说明</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>标记-清除&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">基础算法（以下算法以此为基础）<br>标记：标记出所有需要回收的对象<br>回收：回收掉所有被标记的对象<br>缺点：<br>效率太低<br>出现大量碎片空间打，只后续无法分配大对象   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>复制&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<br>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>标记-压缩&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>分代收集&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">GC分代的基本假设：<span style="color:red">绝大部分对象的生命周期都非常短暂，存活时间短。</span><br>“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，<span style="color:red">只有少量存活，那就选用复制算法</span>，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<span style="color:red">“标记-清理”或“标记-整理”</span>算法来进行回收。   </td>
  </tr>
</tbody>
</table>

<h3 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 799px">
<colgroup>
<col style="width: 149px">
<col style="width: 650px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"><span style="font-weight:bold">收集器</span><br></th>
    <th class="tg-0lax"><span style="font-weight:bold">说明</span><br></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>Serial收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。<br><span style="color:red">新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩</span>；垃圾收集的过程中会Stop The World（服务暂停）<br>参数控制：-XX:+UseSerialGC  串行收集器   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>ParNew收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">ParNew收集器其实就是Serial收集器的多线程版本。<span style="color:red">新生代并行，老年代串行；新生代复制算法、老年代标记-压缩</span><br>参数控制：-XX:+UseParNewGC  ParNew收集器<br>-XX:ParallelGCThreads   限制线程数量   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>Parallel收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax"><span style="color:red">Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量</span>。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；<span style="color:red">新生代复制算法、老年代标记-压缩</span><br>参数控制：-XX:+UseParallelGC  使用Parallel收集器+ 老年代串行   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>Parallel&nbsp;&nbsp;&nbsp;Old 收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">Parallel Old是Parallel   Scavenge收集器的老年代版本，使用多线程和“<span style="color:red">标记－整理</span>”算法。这个收集器是在JDK 1.6中才开始提供<br>参数控制：   -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>CMS收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>G1收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">特点：<br>1. <span style="color:red">空间整合</span>，<span style="color:red">G1收集器采用标记整理算法，不会产生内存空间碎片。</span><br>2. <span style="color:red">可预测停顿</span>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能<span style="color:red">建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内</span>，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。<br>将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。<br><span style="font-weight:bold">收集步骤：</span><br>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop   the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)<br>2、Root Region   Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。<br>3、Concurrent   Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young   GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<br>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集   并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning   (SATB)。<br>5、Copy/Clean   up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。<br>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</td>
  </tr>
</tbody>
</table>

<h2 id="如何选择收集器"><a href="#如何选择收集器" class="headerlink" title="如何选择收集器"></a>如何选择收集器</h2><ol>
<li>app运行在单处理器机器上且没有pause time的要求，让vm选择UseSerialGC.</li>
<li>重点考虑peak application performance(高性能)，没有pause time太严格要求，让vm选择或者UseParallelGC+UseParallelOldGC(optionally).</li>
<li>重点考虑response time,pause time要小，UseConcMarkSweepGC.</li>
<li>默认情况下，<strong>JDK5.0以前都是使用串行收集器</strong>，如果需要使用其他收集器需要在启动的是时候加入相应的参数。JDK5.0以后，JVM会根据当前系统的配置进行判断。</li>
</ol>
<p><strong>并行</strong>：指多条垃圾收集器线程并行工作，但此时仍是“Stop The World”状态，即用户线程处于等待状态；<br><strong>并发</strong>：指用户线程和垃圾收集线程同时执行（不一定是并行的，很有可能是线程交替运行），用户线程继续运行，而垃圾收集程序运行在另一个CPU上。</p>
<h3 id="吞吐量优先的并行收集器"><a href="#吞吐量优先的并行收集器" class="headerlink" title="吞吐量优先的并行收集器"></a>吞吐量优先的并行收集器</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>并行收集器主要以达到一定的吞吐量为目标，适用于科学技术和后台处理。分为两种：</p>
<ol>
<li>并行收集器（-XX:+ UseParallelGC）在次要回收中使用多线程来执行，在主要回收中使用单线程执行；</li>
<li>并行旧生代收集器（Parallet Old Collection）(XX:+UseParallelOldGC),在次要回收和主要回收都使用多线程，当年老区填满后会触发主要回收</li>
</ol>
<h4 id="典型配置"><a href="#典型配置" class="headerlink" title="典型配置"></a>典型配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:UseParallelGC -XX:ParallelGCThreans = <span class="number">20</span></span><br><span class="line">java -Xmx3500m -Xms3500m -Xmn2g -Xss128k -XX:+UseparallelGC - XX:ParallelGCThreans = <span class="number">20</span> -XX:+UseParallelOldGC</span><br><span class="line">java -Xms3550m -Xmm3550m -Xmn2g -Xss128k -XX:+UseparallelGC -XX:MaxGCPauseMillis = <span class="number">100</span></span><br><span class="line">java -Xms3550m -Xmm3550m -Xmn2g -Xss128k -XX:+UseparallelGC -XX:MaxGCPauseMillis = <span class="number">100</span> -XX:+UseAdaptiveSizePolicy</span><br></pre></td></tr></table></figure>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 808px">
<colgroup>
<col style="width: 214px">
<col style="width: 594px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"><span style="font-weight:bold">参数</span></th>
    <th class="tg-0lax"><span style="font-weight:bold">说明</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-Xmx3800m</span>   </td>
    <td class="tg-0lax">最大堆大小   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-Xms3800m</span>   </td>
    <td class="tg-0lax">初始堆大小,此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-Xmn2g</span>   </td>
    <td class="tg-0lax">设置<span style="color:red">年轻</span>代大小为2G。<span style="font-weight:bold;color:red">整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小</span>。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-Xss128k</span>   </td>
    <td class="tg-0lax">设置每个线程的<span style="color:red">堆栈大小</span>。JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。<span style="font-weight:bold;color:red">在相同物理内存下，减小这个值能生成更多的线程</span>。但是操作系统对一个进程内的线程数还是有限制的，<br>不能无限生成，经验值在3000~5000左右。   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:+UseParallelGC</span>   </td>
    <td class="tg-0lax">选择垃圾收集器为并行收集器。<span style="font-weight:bold;color:red">此配置仅对年轻代有效</span>。即该配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:ParallelGCThreans = 20</span>   </td>
    <td class="tg-0lax">配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。<span style="font-weight:bold;color:red">此值的配置最好与处理器数目相等</span>。   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:+UseParallelOldGC</span>   </td>
    <td class="tg-0lax">配置老年代垃圾收集器为并行收集。JDK6.0支持对老年代并行收集   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:MaxGCPauseMillis = 100</span>   </td>
    <td class="tg-0lax">设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:+UseAdaptiveSizePolicy</span>   </td>
    <td class="tg-0lax">设置此项以后，并行收集器会自动选择年轻代大小和相应的Surivior区比例，以达到目标系统规定的最低响应时间或者收集频率等，<span style="color:red">此值建议使用并行收集器时一直打开</span>   </td>
  </tr>
</tbody>
</table>

<h3 id="响应时间优先并发收集器"><a href="#响应时间优先并发收集器" class="headerlink" title="响应时间优先并发收集器"></a>响应时间优先并发收集器</h3><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>并发收集器主要保证系统的响应时间，减少垃圾收集的停顿时间。适用于应用服务器、电信领域。<br>CMS（Concurrent Mark Sweep）并发标记清理收集器<br>CMS（-XX:+UseConcMarkSweepGC）收集器在老年代使用，专门收集那些在主要回收中不可能到达的年老对象。它与应用程序并发执行，在年老代保持一直有足够的空间以保证不会发生年轻代晋升失败。</p>
<h4 id="典型配置-1"><a href="#典型配置-1" class="headerlink" title="典型配置"></a>典型配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xmm3550m -Xmn2g -Xss128K -XX:ParallelGCThread = <span class="number">20</span> -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFULLGCsBeforCompaction=<span class="number">5</span> -XX:+UseCMSCompactAtFullCollection</span><br></pre></td></tr></table></figure>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-rz5g{background-color:#92D050;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 808px">
<colgroup>
<col style="width: 284px">
<col style="width: 524px">
</colgroup>
<thead>
  <tr>
    <th class="tg-rz5g">参数</th>
    <th class="tg-rz5g">说明<br></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:+UseConcMarkSweepGC</span>   <br></td>
    <td class="tg-0lax">设置年老代为并发收集   </td>
  </tr>
  <tr>
    <td class="tg-0lax">-<span style="font-weight:bold">XX:+UseParNewGC</span>   <br></td>
    <td class="tg-0lax">设置年轻代为并行收集。可以和CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行配置，所以无需再配置此值。   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:CMSFULLGCsBeforCompaction=5</span>   </td>
    <td class="tg-0lax">由于并发收集器不对内粗空间进行压缩、整理，所以运行一段时间会产生“碎片”，使得运行效率低。此值设置运行多少次GC以后对内训空间进行压缩、整理   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:+UseCMSCompactAtFullCollection</span>   </td>
    <td class="tg-0lax">打开对年老代的压缩。可能会影响性能，但是可以消除碎片   </td>
  </tr>
</tbody>
</table>

<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><h3 id="JAVA-OPTS"><a href="#JAVA-OPTS" class="headerlink" title="JAVA_OPTS"></a>JAVA_OPTS</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 749px">
<colgroup>
<col style="width: 170px">
<col style="width: 192px">
<col style="width: 122px">
<col style="width: 265px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"><span style="font-weight:bold">参数名称</span></th>
    <th class="tg-0lax"><span style="font-weight:bold">含义</span></th>
    <th class="tg-0lax"><span style="font-weight:bold">默认值</span></th>
    <th class="tg-0lax"><span style="background-color:#FFF">详细说明</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xms</span><br></td>
    <td class="tg-0lax"><span style="color:#333">初始堆大小</span><br></td>
    <td class="tg-0lax">物理内存的1/64(&lt;1GB)<br></td>
    <td class="tg-0lax">默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xmx</span><br></td>
    <td class="tg-0lax"><span style="color:#333">最大堆大小</span><br></td>
    <td class="tg-0lax">物理内存的1/4(&lt;1GB)<br></td>
    <td class="tg-0lax">默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xmn</span><br></td>
    <td class="tg-0lax">年轻代大小(1.4or lator)<br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"><span style="font-weight:bold">注意</span>：此处的大小是（eden+ 2 survivor space).与jmap   -heap中显示的New gen是不同的。<br><span style="background-color:red">整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.</span><br>增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:NewSize</span></td>
    <td class="tg-0lax">设置年轻代大小(for   1.3/1.4)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:MaxNewSize</span></td>
    <td class="tg-0lax">年轻代最大值(for 1.3/1.4)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:PermSize</span></td>
    <td class="tg-0lax">设置持久代(perm gen)初始值</td>
    <td class="tg-0lax">物理内存的1/64</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:MaxPermSize</span></td>
    <td class="tg-0lax"><span style="color:#333">设置持久代最大值</span></td>
    <td class="tg-0lax">物理内存的1/4</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xss</span><br></td>
    <td class="tg-0lax"><span style="color:#333">每个线程的堆栈大小</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K. 根据应用的线程所需内存大小进行   调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右<br>一般小的应用， 如果栈不是很深， 应该128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。<br>和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named   ThreadStackSize”. 一般设置128k或者256k这个值就可以了。</td>
  </tr>
  <tr>
    <td class="tg-0lax">-<span style="font-style:italic">XX:ThreadStackSize</span></td>
    <td class="tg-0lax"><span style="color:#333">Thread   Stack Size</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"><span style="color:#333">(0   means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in   5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and   earlier); all others 0.]</span></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:NewRatio</span></td>
    <td class="tg-0lax">年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5<br>Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:SurvivorRatio</span></td>
    <td class="tg-0lax">Eden区与Survivor区的大小比值<br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:LargePageSizeIn</span><br><span style="color:#333">Bytes</span></td>
    <td class="tg-0lax">内存页的大小不可设置过大， 会影响Perm的大小</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"><span style="color:#333">=128m</span><br></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseFastAccessor</span><br><span style="color:#333">Methods</span><br></td>
    <td class="tg-0lax"><span style="color:#333">原始类型的快速优化</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+DisableExplicitGC</span></td>
    <td class="tg-0lax">关闭System.gc()</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"><span style="color:#333">这个参数需要严格的测试</span></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:MaxTenuring</span><br><span style="color:#333">Threshold</span><br></td>
    <td class="tg-0lax"><span style="color:#333">垃圾最大年龄</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活   时间,增加在年轻代即被回收的概率<br>该参数只有在串行GC时才有效.</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+AggressiveOpts</span></td>
    <td class="tg-0lax"><span style="color:#333">加快编译</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseBiasedLocking</span></td>
    <td class="tg-0lax"><span style="color:#333">锁机制的性能改善</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xnoclassgc</span></td>
    <td class="tg-0lax"><span style="color:#333">禁用垃圾回收</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:SoftRefLRUPolicy</span><br><span style="color:#333">MSPerMB</span></td>
    <td class="tg-0lax">每兆堆空闲空间中SoftReference的存活时间</td>
    <td class="tg-0lax"><span style="color:#333">1s</span><br></td>
    <td class="tg-0lax"><span style="color:#333">softly   reachable objects will remain alive for some amount of time after the last   time they were referenced. The default value is one second of lifetime per   free megabyte in the heap</span></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:PretenureSize</span><br><span style="color:#333">Threshold</span></td>
    <td class="tg-0lax"><span style="color:#333">对象超过多大是直接在旧生代分配</span><br></td>
    <td class="tg-0lax"><span style="background-color:#FFF">0</span></td>
    <td class="tg-0lax">单位字节 新生代采用Parallel   Scavenge GC时无效<br>另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:TLABWasteTarget</span><br><span style="color:#333">Percent</span><br></td>
    <td class="tg-0lax">TLAB占eden区的百分比<br></td>
    <td class="tg-0lax"><span style="color:#333">1%</span><br></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+</span><span style="font-style:italic">CollectGen0First</span></td>
    <td class="tg-0lax">FullGC时是否先YGC</td>
    <td class="tg-0lax"><span style="color:#333">false</span></td>
    <td class="tg-0lax"></td>
  </tr>
</tbody>
</table>

<h3 id="并行收集器相关参数设置"><a href="#并行收集器相关参数设置" class="headerlink" title="并行收集器相关参数设置"></a>并行收集器相关参数设置</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 814px">
<colgroup>
<col style="width: 190px">
<col style="width: 186px">
<col style="width: 53px">
<col style="width: 385px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax">参数</th>
    <th class="tg-0lax">说明</th>
    <th class="tg-0lax">默认值</th>
    <th class="tg-0lax">详细说明</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseParallelGC</span></td>
    <td class="tg-0lax">Full GC采用parallel MSC<br>(此项待验证)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseParNewGC</span></td>
    <td class="tg-0lax"><span style="color:#333">设置年轻代为并行收集</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">可与CMS收集同时使用<br>JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:ParallelGCThreads</span><br></td>
    <td class="tg-0lax"><span style="color:#333">并行收集器的线程数</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">此值最好配置与处理器数目相等 同样适用于CMS</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseParallelOldGC</span></td>
    <td class="tg-0lax">年老代垃圾收集方式为并行收集(Parallel   Compacting)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">这个是JAVA 6出现的参数选项</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:MaxGCPauseMillis</span></td>
    <td class="tg-0lax">每次年轻代垃圾回收的最长时间(最大暂停时间)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseAdaptiveSizePolicy</span></td>
    <td class="tg-0lax">自动选择年轻代区大小和相应的Survivor区比例</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:GCTimeRatio</span></td>
    <td class="tg-0lax"><span style="color:#333">设置垃圾回收时间占程序运行时间的百分比</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">公式为1/(1+n)<br></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+</span><span style="font-style:italic">ScavengeBeforeFullGC</span></td>
    <td class="tg-0lax">Full GC前调用YGC</td>
    <td class="tg-0lax"><span style="color:#333">true</span></td>
    <td class="tg-0lax"><span style="color:#333">Do   young generation GC prior to a full GC. (Introduced in 1.4.1.)</span></td>
  </tr>
</tbody>
</table>

<h3 id="CMS相关参数设置"><a href="#CMS相关参数设置" class="headerlink" title="CMS相关参数设置"></a>CMS相关参数设置</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 777px">
<colgroup>
<col style="width: 210px">
<col style="width: 165px">
<col style="width: 53px">
<col style="width: 349px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax">参数</th>
    <th class="tg-0lax">说明</th>
    <th class="tg-0lax">默认值</th>
    <th class="tg-0lax">详细说明</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseConcMarkSweepGC</span><br></td>
    <td class="tg-0lax">使用CMS内存收集<br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.???</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+AggressiveHeap</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"><span style="color:#333">试图是使用大量的物理内存</span><br><span style="color:#333">长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）</span><br>至少需要256MB内存<br>大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:CMSFullGCsBefore</span><br><span style="color:#333">Compaction</span></td>
    <td class="tg-0lax"><span style="color:#333">多少次后进行内存压缩</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生"碎片",使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+CMSParallelRemark</span><br><span style="color:#333">Enabled</span></td>
    <td class="tg-0lax"><span style="color:#333">降低标记停顿</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX+UseCMSCompact</span><br><span style="color:#333">AtFullCollection</span></td>
    <td class="tg-0lax">在FULL GC的时候， 对年老代的压缩</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">CMS是不会移动内存的， 因此，   这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。<br>可能会影响性能,但是可以消除碎片</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseCMSInitiating</span><br><span style="color:#333">OccupancyOnly</span></td>
    <td class="tg-0lax">使用手动定义初始化定义开始CMS收集</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">禁止hostspot自行触发CMS GC</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:CMSInitiating</span><br><span style="color:#333">OccupancyFraction=70</span></td>
    <td class="tg-0lax">使用cms作为垃圾回收<br>使用70％后开始CMS收集</td>
    <td class="tg-0lax"><span style="color:#333">92</span></td>
    <td class="tg-0lax"><span style="color:#333">为了保证不出现promotion   failed(见下面介绍)错误,该值的设置需要满足以下公式</span><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html#CMSInitiatingOccupancyFraction_value" target="_blank" rel="noopener noreferrer"><span style="font-weight:bold">CMSInitiatingOccupancyFraction计算公式</span></a></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:CMSInitiating</span><br><span style="color:#333">PermOccupancyFraction</span></td>
    <td class="tg-0lax">设置Perm Gen使用到达多少比率时触发<br></td>
    <td class="tg-0lax"><span style="color:#333">92</span><br></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+CMSIncrementalMode</span></td>
    <td class="tg-0lax"><span style="color:#333">设置为增量模式</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">用于单CPU情况</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+CMSClassUnloading</span><br><span style="color:#333">Enabled</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
</tbody>
</table>

<h3 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 761px">
<colgroup>
<col style="width: 188px">
<col style="width: 188px">
<col style="width: 385px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"><span style="color:#333">-XX:+PrintGC</span></th>
    <th class="tg-0lax"></th>
    <th class="tg-0lax">输出形式:<br><span style="color:#333">[GC   118250K-&gt;113543K(130112K), 0.0094143 secs]</span><br><span style="color:#333">[Full   GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintGCDetails</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">输出形式:[GC [DefNew:   8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K),   0.0124633 secs]<br><span style="color:#333">[GC   [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured:   112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K),   0.0436268 secs]</span></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintGCTimeStamps</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintGC:PrintGCTime</span><br><span style="color:#333">Stamps</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">可与-XX:+PrintGC   -XX:+PrintGCDetails混合使用<br>输出形式:11.851: [GC   98328K-&gt;93620K(130112K), 0.0082960 secs]</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintGCApplication</span><br><span style="color:#333">StoppedTime</span></td>
    <td class="tg-0lax">打印垃圾回收期间程序暂停的时间.可与上面混合使用</td>
    <td class="tg-0lax">输出形式:Total time for   which application threads were stopped: 0.0468229 seconds<br></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintGCApplication</span><br><span style="color:#333">ConcurrentTime</span></td>
    <td class="tg-0lax">打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td>
    <td class="tg-0lax">输出形式:Application   time: 0.5291524 seconds</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintHeapAtGC</span></td>
    <td class="tg-0lax">打印GC前后的详细堆栈信息</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xloggc:filename</span></td>
    <td class="tg-0lax">把相关日志信息记录到文件以便分析.<br><span style="color:#333">与上面几个配合使用</span></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintClassHistogram</span></td>
    <td class="tg-0lax"><span style="color:#333">garbage   collects before printing the histogram.</span></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintTLAB</span></td>
    <td class="tg-0lax">查看TLAB空间的使用情况</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="background-color:#FFF">-</span><span style="color:#333">XX:+PrintTenuring</span><br><span style="color:#333">Distribution</span></td>
    <td class="tg-0lax">查看每次minor GC后新的存活周期的阈值<br></td>
    <td class="tg-0lax"><span style="color:#333">Desired   survivor size 1048576 bytes, new threshold 7 (max 15)</span><br>new threshold 7即标识新的存活周期的阈值为7。</td>
  </tr>
</tbody>
</table>

<h2 id="收集器组合"><a href="#收集器组合" class="headerlink" title="收集器组合"></a>收集器组合</h2><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-rz5g{background-color:#92D050;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 819px">
<colgroup>
<col style="width: 142px">
<col style="width: 137px">
<col style="width: 540px">
</colgroup>
<thead>
  <tr>
    <th class="tg-rz5g"><span style="font-weight:bold">YGC</span></th>
    <th class="tg-rz5g"><span style="font-weight:bold">FGC</span></th>
    <th class="tg-rz5g"><span style="font-weight:bold">说明</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">Serial   </td>
    <td class="tg-0lax">Serial   Old   </td>
    <td class="tg-0lax">Serial和Serial   Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td>
  </tr>
  <tr>
    <td class="tg-0lax">Serial   </td>
    <td class="tg-0lax">CMS+Serial   Old   </td>
    <td class="tg-0lax">CMS（Concurrent Mark   Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。   </td>
  </tr>
  <tr>
    <td class="tg-0lax">ParNew   </td>
    <td class="tg-0lax">CMS   </td>
    <td class="tg-0lax">使用-XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。<br>如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew   GC策略。   </td>
  </tr>
  <tr>
    <td class="tg-0lax">ParNew   </td>
    <td class="tg-0lax">Serial   Old   </td>
    <td class="tg-0lax">使用-XX:+UseParNewGC选项来开启。新生代使用ParNew   GC策略，年老代默认使用Serial Old GC策略。   </td>
  </tr>
  <tr>
    <td class="tg-0lax">Parallel   Scavenge  </td>
    <td class="tg-0lax">Serial   Old   </td>
    <td class="tg-0lax">Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间   / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。   </td>
  </tr>
  <tr>
    <td class="tg-0lax">Parallel   Scavenge </td>
    <td class="tg-0lax">Parallel   Old   </td>
    <td class="tg-0lax">Parallel Old是Serial Old的并行版本   </td>
  </tr>
  <tr>
    <td class="tg-0lax">G1GC   </td>
    <td class="tg-0lax">G1GC   </td>
    <td class="tg-0lax">-XX:+UnlockExperimentalVMOptions   -XX:+UseG1GC        #开启<br>-XX:MaxGCPauseMillis   =50                  #暂停时间目标<br>-XX:GCPauseIntervalMillis   =200          #暂停间隔目标<br>-XX:+G1YoungGenSize=512m            #年轻代大小<br>-XX:SurvivorRatio=6                            #幸存区比例   </td>
  </tr>
</tbody>
</table>

<h2 id="调优技巧"><a href="#调优技巧" class="headerlink" title="调优技巧"></a>调优技巧</h2><h3 id="年轻代大小选择"><a href="#年轻代大小选择" class="headerlink" title="年轻代大小选择"></a>年轻代大小选择</h3><ol>
<li><strong>响应时间优先的应用</strong>：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象</li>
<li><strong>吞吐量优先的应用</strong>：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用</li>
</ol>
<h3 id="年老代大小选择"><a href="#年老代大小选择" class="headerlink" title="年老代大小选择"></a>年老代大小选择</h3><ol>
<li><p><strong>响应时间优先的应用</strong>：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</p>
<ul>
<li>并发垃圾收集信息</li>
<li>持久代并发收集次数</li>
<li>传统GC信息</li>
<li>花在年轻代和年老代回收上的时间比例</li>
<li>减少年轻代和年老代花费的时间，一般会提高应用的效率</li>
</ul>
</li>
<li><p><strong>吞吐量优先的应用</strong>：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="较小堆引起的碎片问题"><a href="#较小堆引起的碎片问题" class="headerlink" title="较小堆引起的碎片问题"></a>较小堆引起的碎片问题</h4><p>因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：<code>-XX:+UseCMSCompactAtFullCollection</code>：使用并发收集器时，开启对年老代的压缩。<code>-XX:CMSFullGCsBeforeCompaction=0：</code>上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/parryyang/p/5750146.html">Java GC收集器配置说明</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ityouknow/p/5614961.html">GC算法 垃圾收集器</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020483916">垃圾收集器与内存分配策略</a></li>
</ol>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Theodore Sun 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Theodore Sun 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" rel="tag"><i class="fa fa-tag"></i> 垃圾收集器</a>
              <a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" rel="tag"><i class="fa fa-tag"></i> 内存分配策略</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/17/MySQL%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="prev" title="MySQL之查询性能优化">
      <i class="fa fa-chevron-left"></i> MySQL之查询性能优化
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
      <!--网易云插件-->
      <iframe frameborder="no" border="0" marginwidth="0" 
          marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569213220&auto=0&height=66">
      </iframe>

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB"><span class="nav-number">1.</span> <span class="nav-text">对象已死</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95%EF%BC%88reference-counting%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">引用计数算法（reference-counting）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95%EF%BC%88GC-Roots-Tracing%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">可达性算法（GC Roots Tracing）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GCRoot%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.1.</span> <span class="nav-text">GCRoot对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1"><span class="nav-number">1.2.2.</span> <span class="nav-text">对象死亡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">强引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">软引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.3.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">虚引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.4.</span> <span class="nav-text">回收方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">回收废弃常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="nav-number">1.4.2.</span> <span class="nav-text">如何判断一个类是否是无用的类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">GC触发条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E4%BF%A1%E6%81%AF%E7%9A%84%E9%80%89%E9%A1%B9"><span class="nav-number">2.1.</span> <span class="nav-text">GC信息的选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">垃圾收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-1"><span class="nav-number">3.3.</span> <span class="nav-text">垃圾收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">如何选择收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.1.</span> <span class="nav-text">吞吐量优先的并行收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">4.1.1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%85%8D%E7%BD%AE"><span class="nav-number">4.1.2.</span> <span class="nav-text">典型配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E5%B9%B6%E5%8F%91%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.</span> <span class="nav-text">响应时间优先并发收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%85%8D%E7%BD%AE-1"><span class="nav-number">4.2.2.</span> <span class="nav-text">典型配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">5.</span> <span class="nav-text">常用配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA-OPTS"><span class="nav-number">5.1.</span> <span class="nav-text">JAVA_OPTS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">5.2.</span> <span class="nav-text">并行收集器相关参数设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">5.3.</span> <span class="nav-text">CMS相关参数设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E4%BF%A1%E6%81%AF"><span class="nav-number">5.4.</span> <span class="nav-text">辅助信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88"><span class="nav-number">6.</span> <span class="nav-text">收集器组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E6%8A%80%E5%B7%A7"><span class="nav-number">7.</span> <span class="nav-text">调优技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%A4%A7%E5%B0%8F%E9%80%89%E6%8B%A9"><span class="nav-number">7.1.</span> <span class="nav-text">年轻代大小选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B4%E8%80%81%E4%BB%A3%E5%A4%A7%E5%B0%8F%E9%80%89%E6%8B%A9"><span class="nav-number">7.2.</span> <span class="nav-text">年老代大小选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">7.3.</span> <span class="nav-text">注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%83%E5%B0%8F%E5%A0%86%E5%BC%95%E8%B5%B7%E7%9A%84%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="nav-number">7.3.1.</span> <span class="nav-text">较小堆引起的碎片问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Theodore Sun"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Theodore Sun</p>
  <div class="site-description" itemprop="description">心之所向，素履以往</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">144</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sld880311" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sld880311" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.csdn.net/" title="https:&#x2F;&#x2F;www.csdn.net" rel="noopener" target="_blank">CSDN</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="">
      
        <option value="zh-CN" data-href="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" selected="">
          English
        </option>
      
    </select>
  </div>

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Theodore Sun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">788k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:56</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '1c5d7704f735e90e9f0a',
      clientSecret: 'b4d961f25b2fd71d6744910fdc43f332b259c401',
      repo        : 'sld880311.github.io',
      owner       : 'sld880311',
      admin       : ['sld880311'],
      id          : '3a93166eba4c91d0a36f093482675600',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>
