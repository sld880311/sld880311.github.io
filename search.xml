<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos7.2 安装zookeeper3.4.11</title>
    <url>/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/</url>
    <content><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ol>
<li><a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></li>
<li>tar -zxvf zookeeper-3.4.11.tar.gz</li>
<li>官方参考文档：<a href="https://zookeeper.apache.org/doc/r3.4.11/zookeeperStarted.html">https://zookeeper.apache.org/doc/r3.4.11/zookeeperStarted.html</a><a id="more"></a>

</li>
</ol>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><div align="center">

<img src="/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/1590062355168.png" class>

</div>

<h3 id="bin目录"><a href="#bin目录" class="headerlink" title="bin目录"></a>bin目录</h3><p>zk的可执行脚本目录，包括zk服务进程，zk客户端，等脚本。其中，.sh是Linux环境下的脚本，.cmd是Windows环境下的脚本。使用文本编辑器打开zkServer.cmd或者zkServer.sh文件，可以看到其会调用zkEnv.cmd或者zkEnv.sh脚本。zkEnv脚本的作用是设置zk运行的一些环境变量，例如配置文件的位置和名称等。</p>
<div align="center">

<img src="/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/1590062387358.png" class>

</div>

<h3 id="conf目录"><a href="#conf目录" class="headerlink" title="conf目录"></a>conf目录</h3><p>配置文件目录。zoo_sample.cfg为样例配置文件，需要修改为自己的名称，一般为zoo.cfg。log4j.properties为日志配置文件.</p>
<div align="center">

<img src="/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/1590062455419.png" class>

</div>

<h3 id="lib-zk依赖的包"><a href="#lib-zk依赖的包" class="headerlink" title="lib:zk依赖的包"></a>lib:zk依赖的包</h3><div align="center">

<img src="/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/1590062486254.png" class>

</div>

<h3 id="contrib目录-一些用于操作zk的工具包"><a href="#contrib目录-一些用于操作zk的工具包" class="headerlink" title="contrib目录:一些用于操作zk的工具包"></a>contrib目录:一些用于操作zk的工具包</h3><div align="center">

<img src="/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/1590062514381.png" class>

</div>

<h3 id="recipes目录-zk某些用法的代码示例"><a href="#recipes目录-zk某些用法的代码示例" class="headerlink" title="recipes目录:zk某些用法的代码示例"></a>recipes目录:zk某些用法的代码示例</h3><div align="center">

<img src="/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/1590062542777.png" class>

</div>

<h2 id="安装模式"><a href="#安装模式" class="headerlink" title="安装模式"></a>安装模式</h2><h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line"># 时长单位为毫秒（默认2000ms），为zk使用的基本时间度量单位。</span><br><span class="line"># 例如，1*tickTime是客户端与张昆服务端的心跳时间，2*tickTime是客户端会话的超时时间。</span><br><span class="line"># 更低的tickTime可以更快的发现超时问题，但是也会导致更高的网络流量（心跳消息）和更高的cpu使用率（会话的跟踪处理）。</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial initLimit*tickTime</span><br><span class="line"># synchronization phase can take</span><br><span class="line"># ZooKeeper集群模式下包含多个zk进程，其中一个进程为leader，余下的进程为follower。 </span><br><span class="line"># 当follower最初与leader建立连接时，它们之间会传输相当多的数据，尤其是follower的数据落后leader很多。</span><br><span class="line"># initLimit配置follower与leader之间建立连接后进行同步的最长时间。</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between syncLimit*tickTime</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line"># 配置follower和leader之间发送消息，请求和应答的最大时间长度。</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 无默认配置，必须配置，用于配置存储快照文件的目录。如果没有配置dataLogDir，那么事务日志也会存储在此目录。</span><br><span class="line"># 集群模式下还有一个myid文件。myid文件的内容只有一行，且内容只能为1 - 255之间的数字，</span><br><span class="line"># 这个数字即是server.id中的id，表示zk进程的id。</span><br><span class="line">dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line"># zk服务进程监听的TCP端口，默认情况下，服务端会监听2181端口</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line">#其中id为一个数字，表示zk进程的id，这个id也是dataDir目录下myid文件的内容。 </span><br><span class="line">#host是该zk进程所在的IP地址，port1表示follower和leader交换消息所使用的端口，port2表示选举leader所使用的端口。</span><br><span class="line">#server.id&#x3D;host:port1:port2</span><br></pre></td></tr></table></figure>
<h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在conf下配置zoo.cfg配置文件内容参考如下：</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line">dataDir&#x3D;&#x2F;app&#x2F;zookeeper-3.4.11&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;app&#x2F;zookeeper-3.4.11&#x2F;logs</span><br><span class="line">clientPort&#x3D;2181</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/1590062617814.png" class>

</div>

<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">initLimit&#x3D;5</span><br><span class="line">syncLimit&#x3D;2</span><br><span class="line">dataDir&#x3D;&#x2F;app&#x2F;zookeeper-3.4.11&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;app&#x2F;zookeeper-3.4.11&#x2F;logs</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line">server.43&#x3D;10.1.39.43:2888:3888  </span><br><span class="line">server.47&#x3D;10.1.39.47:2888:3888</span><br><span class="line">server.48&#x3D;10.1.39.48:2888:3888</span><br></pre></td></tr></table></figure>
<h2 id="启动连接"><a href="#启动连接" class="headerlink" title="启动连接"></a>启动连接</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/1590062678958.png" class>

</div>

<p>如果想在前台中运行以便查看服务器进程的输出日志，可以通过以下命令运行：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./zkServer.sh start-foreground</span><br></pre></td></tr></table></figure>
<p>执行此命令，可以看到大量详细信息的输出，以便允许查看服务器发生了什么。  </p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/zkCli.sh -server 127.0.0.1:2181</span><br><span class="line"><span class="comment">#连接一个zk集群</span></span><br><span class="line">bin/zkCli.sh -server 192.168.229.160:2181,192.168.229.161:2181,192.168.229.162:2181</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/1590062736868.png" class>

</div>

<h3 id="可用命令"><a href="#可用命令" class="headerlink" title="可用命令"></a>可用命令</h3><div align="center">

<img src="/2021/02/07/Centos7-2-%E5%AE%89%E8%A3%85zookeeper3-4-11/1590062764474.png" class>

</div>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.2离线安装mysql5.7.20</title>
    <url>/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/</url>
    <content><![CDATA[<h2 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h2><p><a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br>根据系统版本下载</p>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589454272587.png" class>

</div>
<a id="more"></a>

<h2 id="安装新版mysql前，需将系统自带的mariadb-lib卸载"><a href="#安装新版mysql前，需将系统自带的mariadb-lib卸载" class="headerlink" title="安装新版mysql前，需将系统自带的mariadb-lib卸载"></a>安装新版mysql前，需将系统自带的mariadb-lib卸载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop ~]<span class="comment"># rpm -qa|grep mariadb</span></span><br><span class="line">mariadb-libs-5.5.52-1.el7.x86_64</span><br><span class="line">[root@hadoop ~]<span class="comment"># rpm -e --nodeps mariadb-libs-5.5.52-1.el7.x86_64</span></span><br><span class="line">[root@hadoop ~]<span class="comment"># rpm -qa|grep mariadb</span></span><br></pre></td></tr></table></figure>
<h2 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf mysql-5.7.20-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589454370778.png" class>

</div>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="mysql-community-common-5-7-20-1-el7-x86-64-rpm"><a href="#mysql-community-common-5-7-20-1-el7-x86-64-rpm" class="headerlink" title="mysql-community-common-5.7.20-1.el7.x86_64.rpm"></a>mysql-community-common-5.7.20-1.el7.x86_64.rpm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.20-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589454434717.png" class>

</div>

<h3 id="mysql-community-libs-5-7-20-1-el7-x86-64-rpm"><a href="#mysql-community-libs-5-7-20-1-el7-x86-64-rpm" class="headerlink" title="mysql-community-libs-5.7.20-1.el7.x86_64.rpm"></a>mysql-community-libs-5.7.20-1.el7.x86_64.rpm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-libs-5.7.20-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589454721424.png" class>

</div>

<h3 id="mysql-community-client-5-7-20-1-el7-x86-64-rpm"><a href="#mysql-community-client-5-7-20-1-el7-x86-64-rpm" class="headerlink" title="mysql-community-client-5.7.20-1.el7.x86_64.rpm"></a>mysql-community-client-5.7.20-1.el7.x86_64.rpm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-client-5.7.20-1.el7.x86_64.rpm </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589454775475.png" class>

</div>

<h3 id="mysql-community-server-5-7-20-1-el7-x86-64-rpm"><a href="#mysql-community-server-5-7-20-1-el7-x86-64-rpm" class="headerlink" title="mysql-community-server-5.7.20-1.el7.x86_64.rpm"></a>mysql-community-server-5.7.20-1.el7.x86_64.rpm</h3><p>在安装之前需要安装libaio  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop app]<span class="comment"># rpm -qa|grep libaio</span></span><br><span class="line">libaio-0.3.109-13.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>如果不存需要下载离线包：<br><a href="http://mirror.centos.org/centos/6/os/x86_64/Packages/">http://mirror.centos.org/centos/6/os/x86_64/Packages/</a>  </p>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589454830994.png" class>

</div>

<h4 id="安装libaio库"><a href="#安装libaio库" class="headerlink" title="安装libaio库"></a>安装libaio库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh libaio-0.3.107-10.el6.x86_64.rpm（若在有网情况下可执行yum install libaio）</span><br></pre></td></tr></table></figure>
<h4 id="安装server"><a href="#安装server" class="headerlink" title="安装server"></a>安装server</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-server-5.7.20-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>出现如下错误：（最好安装服务版的centos，最小化安装会出现如下错误，处理比较麻烦，需要安装各种依赖包）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error: Failed dependencies:</span><br><span class="line">	/usr/bin/perl is needed by mysql-community-server-5.7.20-1.el7.x86_64</span><br><span class="line">	perl(Getopt::Long) is needed by mysql-community-server-5.7.20-1.el7.x86_64</span><br><span class="line">	perl(strict) is needed by mysql-community-server-5.7.20-1.el7.x86_64</span><br></pre></td></tr></table></figure>
<h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install perl*</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589454969007.png" class>

</div>

<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 指定datadir, 执行后会生成~/.mysql_secret密码文件（5.7以后不在使用）</span><br><span class="line">[root@slave mytmp]<span class="comment"># mysql_install_db --datadir=/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line">// 初始化，执行生会在/var/<span class="built_in">log</span>/mysqld.log生成随机密码</span><br><span class="line">[root@slave mytmp]<span class="comment"># mysqld --initialize</span></span><br></pre></td></tr></table></figure>
<h2 id="更改mysql数据库目录的所属用户及其所属组（没用创建mysql用户）"><a href="#更改mysql数据库目录的所属用户及其所属组（没用创建mysql用户）" class="headerlink" title="更改mysql数据库目录的所属用户及其所属组（没用创建mysql用户）"></a>更改mysql数据库目录的所属用户及其所属组（没用创建mysql用户）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown mysql:mysql /var/lib/mysql -R</span><br></pre></td></tr></table></figure>
<h2 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h2><p><code>systemctl start mysqld.service</code></p>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589455054435.png" class>

</div>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Process: 5924 ExecStart=/usr/sbin/mysqld –daemonize –pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=1/FAILURE)</p>
<h3 id="跟踪日志-var-log-mysqld-log"><a href="#跟踪日志-var-log-mysqld-log" class="headerlink" title="跟踪日志/var/log/mysqld.log"></a>跟踪日志/var/log/mysqld.log</h3><div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589455100018.png" class>

</div>

<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p><code>chmod -R 777 mysql</code>  </p>
<p>在启动查看：  </p>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589455136671.png" class>

</div>

<h2 id="登录到mysql，更改root用户的密码"><a href="#登录到mysql，更改root用户的密码" class="headerlink" title="登录到mysql，更改root用户的密码"></a>登录到mysql，更改root用户的密码</h2><p>命令可以查看初始密码  </p>
<p><code>grep &#39;temporary password&#39; /var/log/mysqld.log</code>  </p>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589455206763.png" class>

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589455212725.png" class>

</div>

<p><code>set password=password(&#39;123456a?&#39;);</code>  </p>
<h2 id="创建用户，及作权限分配"><a href="#创建用户，及作权限分配" class="headerlink" title="创建用户，及作权限分配"></a>创建用户，及作权限分配</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;sunld&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456a?&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;sunld&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589455267259.png" class>

</div>

<h2 id="远程登陆授权"><a href="#远程登陆授权" class="headerlink" title="远程登陆授权"></a>远程登陆授权</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456a?&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589455303080.png" class>

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589455308288.png" class>

</div>

<h2 id="设置mysql开机启动"><a href="#设置mysql开机启动" class="headerlink" title="设置mysql开机启动"></a>设置mysql开机启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 检查是否已经是开机启动</span><br><span class="line">systemctl list-unit-files | grep mysqld</span><br><span class="line">// 开机启动</span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld.service</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Centos7-2%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85mysql5-7-20/1589455358323.png" class>

</div>

<h2 id="默认配置文件路径"><a href="#默认配置文件路径" class="headerlink" title="默认配置文件路径"></a>默认配置文件路径</h2><ol>
<li>配置文件：/etc/my.cnf</li>
<li>日志文件：/var/log/mysqld.log</li>
<li>服务启动脚本：/usr/lib/systemd/system/mysqld.service</li>
<li>socket文件：/var/run/mysqld/mysqld.pid</li>
</ol>
<h2 id="配置默认编码为utf8"><a href="#配置默认编码为utf8" class="headerlink" title="配置默认编码为utf8"></a>配置默认编码为utf8</h2><p>修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server<span class="operator">=</span>utf8</span><br><span class="line">init_connect<span class="operator">=</span><span class="string">&#x27;SET NAMES utf8&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop1.X伪分布式安装</title>
    <url>/2021/02/07/Hadoop1-X%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="安装模式"><a href="#安装模式" class="headerlink" title="安装模式"></a>安装模式</h2><h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><p>安装简单，几乎不用作任何配置，但仅限于调试用途；</p>
<h3 id="伪分布模式"><a href="#伪分布模式" class="headerlink" title="伪分布模式"></a>伪分布模式</h3><p>在单节点上同时启动NameNode、DataNode、JobTracker、TaskTracker、Secondary Namenode等5个进程，模拟分布式运行的各个节点；</p>
<h3 id="完全分布式模式"><a href="#完全分布式模式" class="headerlink" title="完全分布式模式"></a>完全分布式模式</h3><p>正常的Hadoop集群，由多个各司其职的节点构成</p>
<a id="more"></a>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>创建安装用户（sunld），所有的组件和jdk放到目前/app下，并且授权如下：<br>chown –R sunld:sunld /app</p>
<h3 id="设置网络"><a href="#设置网络" class="headerlink" title="设置网络"></a>设置网络</h3><p>IP地址: 192.168.42.8<br>子网掩码： 255.255.255.0<br>DNS： 221.12.1.227 (需要根据所在地设置DNS服务器)<br>Domain: 221.12.33.227  </p>
<p>效果如下：</p>
<div align="center">

<img src="/2021/02/07/Hadoop1-X%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%89%E8%A3%85/1589976157995.png" class>

</div>

<h3 id="设置机器名（重启后生效）"><a href="#设置机器名（重启后生效）" class="headerlink" title="设置机器名（重启后生效）"></a>设置机器名（重启后生效）</h3><div align="center">

<img src="/2021/02/07/Hadoop1-X%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%89%E8%A3%85/1589976217994.png" class>

</div>

<h3 id="设置host映射文件"><a href="#设置host映射文件" class="headerlink" title="设置host映射文件"></a>设置host映射文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop1-X%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%89%E8%A3%85/1589976251086.png" class>

</div>

<p>使用ping命令验证配置是否正确</p>
<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service iptables status</span><br><span class="line">sudo chkconfig iptables off</span><br></pre></td></tr></table></figure>
<h3 id="关闭Selinux"><a href="#关闭Selinux" class="headerlink" title="关闭Selinux"></a>关闭Selinux</h3><ol>
<li>使用getenforce命令查看是否关闭</li>
<li>修改/etc/selinux/config 文件</li>
</ol>
<p>将SELINUX=enforcing改为SELINUX=disabled，执行该命令后重启机器生效</p>
<h3 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h3><p>首先在官网现在安装包，创建安装目录，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir /app</span><br><span class="line">sudo chown -R sunld:sunld /app</span><br><span class="line">mkdir /app/lib</span><br><span class="line"></span><br><span class="line">tar -zxf jdk-7u55-linux-x64.tar.gz</span><br><span class="line">mv jdk1.7.0_55/ /app/lib</span><br><span class="line">ll /app/lib</span><br><span class="line"></span><br><span class="line">配置环境变量：sudo vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/app/lib/jdk1.7.0_55</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h3 id="更新OpenSSL"><a href="#更新OpenSSL" class="headerlink" title="更新OpenSSL"></a>更新OpenSSL</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update openssl</span><br></pre></td></tr></table></figure>
<h3 id="SSH无密码验证配置"><a href="#SSH无密码验证配置" class="headerlink" title="SSH无密码验证配置"></a>SSH无密码验证配置</h3><ol>
<li>使用sudo vi /etc/ssh/sshd_config，打开sshd_config配置文件，开放三个配置<ul>
<li>RSAAuthentication yes</li>
<li>PubkeyAuthentication yes</li>
<li>AuthorizedKeysFile .ssh/authorized_keys</li>
</ul>
</li>
<li>配置后重启服务:sudo service sshd restart</li>
<li>使用shiyanlou用户登录使用如下命令生成私钥和公钥；ssh-keygen -t rsa<div align="center">

</div></li>
</ol>
<img src="/2021/02/07/Hadoop1-X%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%89%E8%A3%85/1589976463414.png" class>



<ol start="4">
<li>进入/home/shiyanlou/.ssh目录把公钥命名为authorized_keys，使用命令如下：cp id_rsa.pub authorized_keys</li>
<li>使用如下设置authorized_keys读写权限:sudo chmod 400 authorized_keys</li>
<li>测试ssh免密码登录是否生效</li>
</ol>
<h2 id="Hadoop变量配置"><a href="#Hadoop变量配置" class="headerlink" title="Hadoop变量配置"></a>Hadoop变量配置</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzf hadoop-1.1.2-bin.tar.gz</span><br><span class="line">rm -rf /app/hadoop-1.1.2</span><br><span class="line">mv hadoop-1.1.2 /app</span><br></pre></td></tr></table></figure>
<h3 id="创建子目录"><a href="#创建子目录" class="headerlink" title="创建子目录"></a>创建子目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /app/hadoop-1.1.2</span><br><span class="line">mkdir tmp</span><br><span class="line">mkdir hdfs</span><br><span class="line">mkdir hdfs/name</span><br><span class="line">mkdir hdfs/data</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>把hdfs/data设置为755，否则DataNode会启动失败<br><code>chmod -R 755 data</code></p>
<h3 id="配置hadoop-env-sh"><a href="#配置hadoop-env-sh" class="headerlink" title="配置hadoop-env.sh"></a>配置hadoop-env.sh</h3><ol>
<li>进入hadoop-1.1.2/conf目录，打开配置文件hadoop-env.sh</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /app/hadoop-1.1.2/conf</span><br><span class="line">vi hadoop-env.sh</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop1-X%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%89%E8%A3%85/1589976604242.png" class>

</div>

<ol start="2">
<li>加入配置内容，设置了hadoop中jdk和hadoop/bin路径</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/java/jdk1.7.0_55</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/app/hadoop-1.1.2/bin</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop1-X%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%89%E8%A3%85/1589976645071.png" class>

</div>

<ol start="3">
<li>编译配置文件hadoop-env.sh，并确认生效</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> hadoop-env.sh</span><br><span class="line">hadoop version</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop1-X%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%89%E8%A3%85/1589976670800.png" class>

</div>

<h3 id="配置core-site-xml"><a href="#配置core-site-xml" class="headerlink" title="配置core-site.xml"></a>配置core-site.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line"> &lt;name&gt;fs.default.name&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;hdfs:&#x2F;&#x2F;hadoop:9000&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line"> &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;&#x2F;app&#x2F;hadoop-1.1.2&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置hdfs-site-xml"><a href="#配置hdfs-site-xml" class="headerlink" title="配置hdfs-site.xml"></a>配置hdfs-site.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line"> &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line"> &lt;name&gt;dfs.name.dir&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;&#x2F;app&#x2F;hadoop-1.1.2&#x2F;hdfs&#x2F;name&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line"> &lt;name&gt;dfs.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;&#x2F;app&#x2F;hadoop-1.1.2&#x2F;hdfs&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置mapred-site-xml"><a href="#配置mapred-site-xml" class="headerlink" title="配置mapred-site.xml"></a>配置mapred-site.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapred.job.tracker&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;hadoop:9001&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置masters和slaves文件"><a href="#配置masters和slaves文件" class="headerlink" title="配置masters和slaves文件"></a>配置masters和slaves文件</h3><ol>
<li>vi masters</li>
<li>vi slaves</li>
<li>输入hadoop（节点名称）</li>
</ol>
<h3 id="格式化namenode"><a href="#格式化namenode" class="headerlink" title="格式化namenode"></a>格式化namenode</h3><p>在hadoop1机器上使用如下命令进行格式化namenode<br>hadoop namenode -format</p>
<h3 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /app/hadoop-1.1.2/bin</span><br><span class="line">./start-all.sh</span><br></pre></td></tr></table></figure>
<h3 id="用jps检验各后台进程是否成功启动"><a href="#用jps检验各后台进程是否成功启动" class="headerlink" title="用jps检验各后台进程是否成功启动"></a>用jps检验各后台进程是否成功启动</h3>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop开发环境安装（Hadoop2.7.4）</title>
    <url>/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/</url>
    <content><![CDATA[<h2 id="虚拟机基本配置"><a href="#虚拟机基本配置" class="headerlink" title="虚拟机基本配置"></a>虚拟机基本配置</h2><h3 id="设置机器名（重启后生效）–使用ubuntu"><a href="#设置机器名（重启后生效）–使用ubuntu" class="headerlink" title="设置机器名（重启后生效）–使用ubuntu"></a>设置机器名（重启后生效）–使用ubuntu</h3><div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589969553959.png" class>

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589969589813.png" class>

</div>
<a id="more"></a>
对于ubuntu修改文件是/etc/hostname

<h3 id="设置host映射文件"><a href="#设置host映射文件" class="headerlink" title="设置host映射文件"></a>设置host映射文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589969667963.png" class>

</div>
使用ping命令验证配置是否正确

<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service iptables status（sudo ufw status）</span><br><span class="line">sudo chkconfig iptables off（sudo ufw <span class="built_in">enable</span>|<span class="built_in">disable</span> ）</span><br></pre></td></tr></table></figure>
<h4 id="Centos7"><a href="#Centos7" class="headerlink" title="Centos7"></a>Centos7</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br><span class="line">firewall-cmd --state <span class="comment">#查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭Selinux（ubuntu不需要）"><a href="#关闭Selinux（ubuntu不需要）" class="headerlink" title="关闭Selinux（ubuntu不需要）"></a>关闭Selinux（ubuntu不需要）</h3><ol>
<li>使用getenforce命令查看是否关闭</li>
<li>修改/etc/selinux/config 文件</li>
</ol>
<p>将SELINUX=enforcing改为SELINUX=disabled，执行该命令后重启机器生效</p>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -e | grep ssh</span><br><span class="line">sudo yum install openssh-server</span><br><span class="line">/etc/init.d/ssh start</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589969827184.png" class>

</div>

<h3 id="无密钥SHH"><a href="#无密钥SHH" class="headerlink" title="无密钥SHH"></a>无密钥SHH</h3><p>在ROOT用户下执行：<code>ssh-keygen -t rsa</code></p>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589969893571.png" class>

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589969908640.png" class>

</div>

<p><code>cat id_rsa.pub &gt; authorized_keys</code></p>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589969941859.png" class>

</div>

<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>下载安装包，并且完成安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u111-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /etc/profile</span></span><br><span class="line"><span class="comment">#JAVA INFO START</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/app/jdk1.8.0_111</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=/app/jdk1.8.0_111/jre</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="comment">#JAVA INFO END</span></span><br></pre></td></tr></table></figure>
<p>保存，退出！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; <span class="built_in">source</span> /etc/profile    <span class="comment">#使之立即生效</span></span><br></pre></td></tr></table></figure>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589970142470.png" class>

</div>

<h3 id="【建议也设置默认启动】"><a href="#【建议也设置默认启动】" class="headerlink" title="【建议也设置默认启动】"></a>【建议也设置默认启动】</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /etc/rc.local</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#JAVA INFO START</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/app/jdk1.8.0_111</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=/app/jdk1.8.0_111/jre</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="comment">#JAVA INFO END</span></span><br></pre></td></tr></table></figure>
<h3 id="设置全局环境变量"><a href="#设置全局环境变量" class="headerlink" title="设置全局环境变量"></a>设置全局环境变量</h3><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.0.23.tar.gz</span><br><span class="line">gedit startup.sh</span><br><span class="line">JAVA_HOME=/app/jdk1.8.0_111</span><br><span class="line">JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span></span><br><span class="line">CLASSPATH=.:<span class="variable">$JRE_HOME</span>/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">TOMCAT_HOME=/app/apache-tomcat-8.5.23</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589970472693.png" class>

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589970480429.png" class>

</div>

<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gedit /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589970544921.png" class>

</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/iptables restart</span><br></pre></td></tr></table></figure>
<h3 id="vsftpd"><a href="#vsftpd" class="headerlink" title="vsftpd"></a>vsftpd</h3><ol>
<li>查看是否安装：rpm –qa|grep vsftpd</li>
<li>安装：yum -y install vsftpd</li>
<li>启动：service vsftpd start</li>
<li>重启：service vsftpd restart</li>
<li>设置相关参数：setsebool -P ftp_home_dir 1</li>
</ol>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589970692117.png" class>

</div>

<h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf mongodb-linux-x86_64-3.0.3.gz</span><br><span class="line">mkdir data</span><br><span class="line">mkdir data/mongodb</span><br><span class="line">touch logs</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#【代表端口号，如果不指定则默认为   27017   】</span><br><span class="line">port&#x3D;27017</span><br><span class="line">#数据库路径】</span><br><span class="line">dbpath&#x3D; &#x2F;usr&#x2F;mongodb&#x2F;mongodb-linux-x86_64-3.0.3&#x2F;data&#x2F;mongodb</span><br><span class="line">#【日志路径】</span><br><span class="line">logpath&#x3D; &#x2F;usr&#x2F;mongodb&#x2F;mongodb-linux-x86_64-3.0.3&#x2F;logs</span><br><span class="line">#【日志文件自动累加，而不是覆盖】</span><br><span class="line">logappend&#x3D;true</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589970793295.png" class>

</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/mongodb/mongodb-linux-x86_64-3.0.3/bin/mongod -f /usr/mongodb/mongodb-linux-x86_64-3.0.3/mongodb.conf</span><br><span class="line">pkill mongod</span><br><span class="line">进入mongo shell ：运行 db.shutdownServer()</span><br><span class="line">/usr/mongodb/mongodb-linux-x86_64-3.0.3/bin/mongo</span><br></pre></td></tr></table></figure>
<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h3 id="下载安装安装包"><a href="#下载安装安装包" class="headerlink" title="下载安装安装包"></a>下载安装安装包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf hadoop-2.7.4.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#hadoop info start</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/app/hadoop-2.7.4</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment">#hadoop info end</span></span><br></pre></td></tr></table></figure>
<p><code>source /etc/profile</code>  </p>
<p>加入rc.local  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /etc/rc.local</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#hadoop info start</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/app/hadoop-2.7.4</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment">#hadoop info end</span></span><br></pre></td></tr></table></figure>
<h3 id="创建文件目录"><a href="#创建文件目录" class="headerlink" title="创建文件目录"></a>创建文件目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/app/hadoop-2.7.4<span class="comment"># mkdir hdfs</span></span><br><span class="line">root@ubuntu:/app/hadoop-2.7.4<span class="comment"># mkdir hdfs/name</span></span><br><span class="line">root@ubuntu:/app/hadoop-2.7.4<span class="comment"># mkdir hdfs/data</span></span><br><span class="line">root@ubuntu:/app/hadoop-2.7.4<span class="comment"># mkdir tmp</span></span><br><span class="line">root@ubuntu:/app/hadoop-2.7.4<span class="comment"># mkdir mapred</span></span><br><span class="line">root@ubuntu:/app/hadoop-2.7.4<span class="comment"># mkdir mapred/local</span></span><br><span class="line">root@ubuntu:/app/hadoop-2.7.4<span class="comment"># mkdir mapred/system</span></span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971047049.png" class>

</div>

<h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>配置文件目录位置：/app/hadoop-2.7.4/etc/hadoop，注意如果在配置文件中使用ip需要使用实际的ip比如192.168.209.132，不要使用127.0.0.1或者localhost</p>
<h4 id="hadoop-env-sh（可以不修改）"><a href="#hadoop-env-sh（可以不修改）" class="headerlink" title="hadoop-env.sh（可以不修改）"></a>hadoop-env.sh（可以不修改）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim hadoop-env.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># The java implementation to use.</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/app/jdk1.8.0_111</span><br></pre></td></tr></table></figure>
<h4 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h4><p>vim core-site.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;hdfs:&#x2F;&#x2F;192.168.209.132:9000&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;app&#x2F;hadoop-2.7.4&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;app&#x2F;hadoop-2.7.4&#x2F;hdfs&#x2F;name&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;app&#x2F;hadoop-2.7.4&#x2F;hdfs&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h4><p>vim hdfs-site.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.permissions&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;app&#x2F;hadoop-2.7.4&#x2F;hdfs&#x2F;name&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;app&#x2F;hadoop-2.7.4&#x2F;hdfs&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h4><p>修改mapred-site.xml(默认没有这个配置文件，可以拷贝改目录下的mapred-site.xml.template    :  cp mapred-site.xml.template mapred-site.xml)内容如下  </p>
<p>cp mapred-site.xml.template mapred-site.xml  </p>
<p>vim mapred-site.xml  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.jobtracker.address&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;192.168.209.132:9001&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;final&gt;true&lt;&#x2F;final&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapred.system.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;app&#x2F;hadoop-2.7.4&#x2F;mapred&#x2F;system&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;final&gt;true&lt;&#x2F;final&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapred.local.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;app&#x2F;hadoop-2.7.4&#x2F;mapred&#x2F;local&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;final&gt;true&lt;&#x2F;final&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- Site specific YARN configuration properties --&gt;</span><br><span class="line">  &lt;!--&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;  --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>首次运行需要进行hdfs格式化：hdfs namenode -format  </p>
<p>/app/hadoop-2.7.4/bin/hdfs namenode -format  </p>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971563872.png" class>

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971601483.png" class>

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971615684.png" class>

</div>

<h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><p>进入sbin文件夹，执行：./start-all.sh<br>/app/hadoop-2.7.4/sbin/start-all.sh  </p>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971690763.png" class>

</div>

<h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p>运行启动后，使用jps命令查看是否将服务启动成功：  </p>
<h5 id="输入命令：jps"><a href="#输入命令：jps" class="headerlink" title="输入命令：jps"></a>输入命令：jps</h5><p>包括NameNode,SecondaryNameNode, ResourceManager, DataNode, NodeManager和jps；</p>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971742904.png" class>

</div>

<h5 id="192-168-209-135-8088-cluster"><a href="#192-168-209-135-8088-cluster" class="headerlink" title="192.168.209.135:8088/cluster"></a>192.168.209.135:8088/cluster</h5><div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971784740.png" class>

</div>

<h5 id="192-168-209-135-50070"><a href="#192-168-209-135-50070" class="headerlink" title="192.168.209.135:50070"></a>192.168.209.135:50070</h5><div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971819683.png" class>

</div>

<h5 id="ps-ef-grep-hadoop"><a href="#ps-ef-grep-hadoop" class="headerlink" title="ps -ef|grep hadoop"></a>ps -ef|grep hadoop</h5><div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971869797.png" class>

</div>

<h5 id="使用测试用例测试"><a href="#使用测试用例测试" class="headerlink" title="使用测试用例测试"></a>使用测试用例测试</h5><h6 id="创建测试目录"><a href="#创建测试目录" class="headerlink" title="创建测试目录"></a>创建测试目录</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/app/hadoop-2.7.4/bin/hadoop fs -mkdir -p /class3/input</span><br><span class="line">/app/hadoop-2.7.4/bin/hadoop fs -ls /class3/</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971947610.png" class>

</div>

<h6 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/app/hadoop-2.7.4/bin/hadoop fs -copyFromLocal /app/hadoop-2.7.4/etc/hadoop/* /class3/input</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589971996895.png" class>

</div>

<p>该异常处理：（hadoop的本身bug,不用处理，使用centos7安装没问题）<br>重新复制文件(可以不使用)  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/app/hadoop-2.7.4/bin/hadoop fs -rm -r -f /class3/</span><br><span class="line">/app/hadoop-2.7.4/bin/hadoop fs -mkdir -p /class3/input</span><br><span class="line">/app/hadoop-2.7.4/bin/hadoop fs -ls /class3/</span><br><span class="line">/app/hadoop-2.7.4/bin/hadoop fs -copyFromLocal /app/hadoop-2.7.4/etc/hadoop/* /class3/input</span><br></pre></td></tr></table></figure>
<p>/app/hadoop-2.7.4/bin/hadoop fs -ls /class3/input  </p>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589972057584.png" class>

</div>

<h6 id="运行wordcount例子"><a href="#运行wordcount例子" class="headerlink" title="运行wordcount例子"></a>运行wordcount例子</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /app/hadoop-2.7.4/</span><br><span class="line">bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.4.jar wordcount /class3/input /class3/output</span><br></pre></td></tr></table></figure>
<p>任务卡住，解决方案：</p>
<div align="center">

<img src="/2021/02/07/Hadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%EF%BC%88Hadoop2-7-4%EF%BC%89/1589972113482.png" class>

</div>

<p>修改yarn-site.xml配置文件，增加如下信息  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;  </span><br><span class="line">    &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;&#x2F;name&gt;  </span><br><span class="line">    &lt;value&gt;2048&lt;&#x2F;value&gt;  </span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;  </span><br><span class="line">    &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;2048&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;2.1&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;  </span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.log-aggregation-enable&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;604800&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!--&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.hostname&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;ubuntu&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;--&gt;</span><br></pre></td></tr></table></figure>
<h6 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/hadoop fs -ls /class3/output/  </span><br><span class="line">bin/hadoop fs -cat /class3/output/part-r-00000 | less</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate系统化学习之对象状态</title>
    <url>/2021/02/04/Hibernate%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><style type="text/css">
.tg  {border-collapse:collapse;border-color:#C44D58;border-spacing:0;}
.tg td{background-color:#F9CDAD;border-color:#C44D58;border-style:solid;border-width:1px;color:#002b36;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#FE4365;border-color:#C44D58;border-style:solid;border-width:1px;color:#fdf6e3;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;状态&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;说明&nbsp;&nbsp;&nbsp;</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;临时状态（Transient）&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;刚创建的对象（new）还没有被Session持久化、缓存中不存在这个对象的数据并且数据库中没有这个对象对应的数据为瞬时状态这个时候是没有OID。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;持久状态（Persistent）&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;对象经过Session持久化操作，缓存中存在这个对象的数据为持久状态并且数据库中存在这个对象对应的数据为持久状态这个时候有OID。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;游离状态（Detached）&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;已经被持久化，但不处于session的缓存中。&nbsp;&nbsp;&nbsp;当Session关闭，缓存中不存在这个对象数据而数据库中有这个对象的数据并且有OID为游离状态。&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<a id="more"></a>

<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><div align="center">

<img src="/2021/02/04/Hibernate%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81/1588843982557.png" class title="对象状态转换">

</div>

<p>当对象在持久化状态时，它一直位于 Session 的缓存中，对它的任何操作在事务提交时都将同步到数据库，因此，对一个已经持久的对象调用 save() 或 update() 方法是没有意义的。</p>
<blockquote>
<p>save()和persist()将会引发SQL的INSERT，delete()会引发SQLDELETE， 而update()或merge()会引发SQLUPDATE。对持久化（persistent）实例的修改在刷新提交的时候会被检测到， 它也会引起SQLUPDATE。saveOrUpdate()或者replicate()会引发SQLINSERT或者UPDATE</p>
</blockquote>
<h3 id="相关方法说明"><a href="#相关方法说明" class="headerlink" title="相关方法说明"></a>相关方法说明</h3><ol>
<li>get、load、find: 方法的使用上较为类似，他们都是将数据库中对应Id的数据映射为Java对象，此时对象变为持久化状态。</li>
<li>save: 保存，此时Java对象已经与数据库记录建立的关系。将对象从临时状态的变为持久化状态或者将游离状态的数据变为持久状态。</li>
<li>saveOrUpdate: 保存或者更新，如果没有与数据库记录所对应的oid，则执行保存，如果有，则执行更新。将对象从临时状态的变为持久化状态或者将游离状态的数据变为持久状态。</li>
<li>delete: 删除对象，将对象从持久化状态或者游离状态变为临时状态。</li>
<li>close: 关闭session, 先将session清空，然后再关闭。将对象从持久状态变为临时状态。</li>
<li>clear: 清空session缓存。将对象从持久状态变为临时状态。</li>
<li>evict: 清除指定的对象。将对象从持久状态变为临时状态.</li>
</ol>
<h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/flqcchblog/p/4619022.html">hibernate的各种保存方式的区别 (save,persist,update,saveOrUpdte,merge,flush,lock)</a></li>
<li><a href="https://blog.csdn.net/pangqiandou/article/details/53386728">Hibernate一级缓存</a></li>
<li><a href="https://blog.csdn.net/looyo/article/details/6309136">hibernate session的flushMode的区别</a></li>
<li><a href="https://blog.csdn.net/lzm1340458776/article/details/32729127">Hibernate的Session_flush与隔离级别</a></li>
<li><a href="https://blog.csdn.net/chuck_kui/article/details/51531089">Hibernate 中的session 的flush、reflush 和clear 方法 ，及数据库的隔离级别</a></li>
<li><a href="https://blog.csdn.net/oChangWen/article/details/52582958">Hibernate深入理解—-03操作Session缓存方法（flush、refresh、clear，事务隔离级别）</a></li>
<li><a href="http://blog.csdn.net/fg2006/article/details/6436517">Hibernate中对象的三种状态及相互转化</a></li>
<li><a href="https://www.cnblogs.com/xiaoluo501395377/p/3380270.html">深入hibernate的三种状态</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Hibernate</category>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>对象状态</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate系统化学习之常用方法</title>
    <url>/2021/02/04/Hibernate%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="session-find-load"><a href="#session-find-load" class="headerlink" title="session.find/load"></a>session.find/load</h2><p>hibernate中session.find/load方法都能通过指定实体类名和id从数据库中读取指定的记录，并且返回与之对映的实体对象。但是它们也有很大的区别 ,find()和load()方法在执行检索时的区别：</p>
<ol>
<li><p>find()在类检索级别时总是执行立即检索而且如果检索不到相关的对象的话会返回null,load()方法则会抛出一个ObjectNotException</p>
</li>
<li><p>load()方法可返回一个实体代理类类型，而find()方法直接返回的是实体类对象。</p>
</li>
<li><p>load()方法可以充分利用内部缓存和二级缓存，而find()方法会忽略二级缓存，若内部缓存没有查询到会到数据库中去查询。</p>
<a id="more"></a>
<h2 id="Session-get-load"><a href="#Session-get-load" class="headerlink" title="Session.get/load"></a>Session.get/load</h2></li>
<li><p>如果未能发现符合条件的记录，get方法返回null，而load方法会抛出一个ObejctNotFoundException。</p>
</li>
<li><p>Load方法可返回实体的代理类类型，而get方法永远直接返回实体类。</p>
</li>
<li><p>Load方法可以充分利用内部缓存和二级缓存中现有数据，而get方法则仅仅在内部缓存中进行数据查找，如没有发现对应数据，将越过二级缓存，直接调用SQL完成数据读取。</p>
</li>
</ol>
<p>Session 的load(), get() , find() 方法都可实现对业务数据的查询，其中load()会因所要查询的对象类的映射文件（比如Customer.hbm.xml文件）中设置的检索策略，而实现立即检索或延迟检索。get()方法和find()方法却不受这种控制，它们总是会执行立即检索。</p>
<p>那么象load()这样的方法，当其被设置为使用延迟检索时，它会返回什么样的实例呢？当使用延迟检索时返回为这一对象的代理类实例，代理类实例也有一个标志性的OID, 但没有被实例化，其所有属性为默认初始值或为空。提到检索，load() 和get()方法都是用指定了OID的方式检索并返回一个与数据库中记录相对应的实例对象。如Customer customer = (Customer)session.get(Customer.class, new Long(1)) 将会返回一个Customer实例对象customer. 而 find()可以实现批量的检索，其返回类型为List的对象集合。例如：<br>List customerList = session.find( “from Customer as c”);</p>
<p>Load(): 另一种读取数据的方法,和get的区别是: 1.异常处理: load有异常处理,get没有,它返回null,2.get从数据库读数据,load可能去读缓冲区。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>Hibernate</category>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
        <tag>常用方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate系统化学习之缓存</title>
    <url>/2021/02/04/Hibernate%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="N-1问题"><a href="#N-1问题" class="headerlink" title="N+1问题"></a>N+1问题</h2><p>所谓N+1问题，使用hibernate查询数据，首先返回数据的id信息，并没有返回所有的对象信息，只有在真正使用的时候，在使用这个id对数据库中查询数据，一次查询多次调用数据库（缓存）的情况，就是所谓的N+1问题。以下方法或者策略会出现N+1问题：</p>
<h3 id="使用iterate（）方法"><a href="#使用iterate（）方法" class="headerlink" title="使用iterate（）方法"></a>使用iterate（）方法</h3><p>存在iterator的原因是，有可能会在一个session中查询两次数据，如果使用list每一次都会把所有的对象查询上来，如果使用iterator仅仅只会查询id，此时所有的对象已经存储在一级缓存(session的缓存)中，可以直接获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the query results as an &lt;tt&gt;Iterator&lt;/tt&gt;. If the query</span></span><br><span class="line"><span class="comment">* contains multiple results per row, the results are returned in</span></span><br><span class="line"><span class="comment">* an instance of &lt;tt&gt;Object[]&lt;/tt&gt;.&lt;br&gt;</span></span><br><span class="line"><span class="comment">* &lt;br&gt;</span></span><br><span class="line"><span class="comment">* Entities returned as results are initialized on demand. The first</span></span><br><span class="line"><span class="comment">* SQL query returns identifiers only.&lt;br&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the result iterator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Iterator&lt;R&gt; <span class="title">iterate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="使用查询缓存策略"><a href="#使用查询缓存策略" class="headerlink" title="使用查询缓存策略"></a>使用查询缓存策略</h3><h2 id="一级缓存，session级别缓存"><a href="#一级缓存，session级别缓存" class="headerlink" title="一级缓存，session级别缓存"></a>一级缓存，session级别缓存</h2><p>首次查询数据，会查询数据库返回数据，并且保存到缓存中；再次查询该数据时，直接从缓存中获取（同一个session）。<br>由于一级缓存是session级别的缓存，只有在同一个session中才能起到再次查询从缓存中获取数据。<br>比如：list()放入缓存，load查询从缓存中获取数据。<br>由于Session对象的生命周期通常对应一个数据库事务或者一个应用事务，因此它的缓存是事务范围的缓存。<br>Session级缓存是必需的，不允许而且事实上也无法卸除。在Session级缓存中，持久化类的每个实例都具有唯一的ID<br><strong>调用session的方法会加入一级缓存：save()、update()、savaeOrUpdate()、get()或load()；调用查询接口的list()、iterate()或filter()方法</strong></p>
<h2 id="二级缓存（sessionFactory级别）"><a href="#二级缓存（sessionFactory级别）" class="headerlink" title="二级缓存（sessionFactory级别）"></a>二级缓存（sessionFactory级别）</h2><h3 id="下载ehcache相关包"><a href="#下载ehcache相关包" class="headerlink" title="下载ehcache相关包"></a>下载ehcache相关包</h3><h3 id="在hibernate-cfg-xml配置文件中配置我们二级缓存的一些属性"><a href="#在hibernate-cfg-xml配置文件中配置我们二级缓存的一些属性" class="headerlink" title="在hibernate.cfg.xml配置文件中配置我们二级缓存的一些属性"></a>在hibernate.cfg.xml配置文件中配置我们二级缓存的一些属性</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.use_second_level_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 二级缓存的提供类 在hibernate4.0版本以后我们都是配置这个属性来指定二级缓存的提供类--&gt;</span></span><br><span class="line">&lt;property name=&quot;hibernate.cache.region.factory_class&quot;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property&gt;</span><br><span class="line"><span class="comment">&lt;!-- 4.0之前版本的配置  &lt;property name=&quot;hibernate.cache.provider_class&quot;&gt;net.sf.ehcache.hibernate.EhCacheProvider&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 二级缓存配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.provider_configuration_file_resource_path&quot;</span>&gt;</span>ehcache.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置ehcache-xml"><a href="#配置ehcache-xml" class="headerlink" title="配置ehcache.xml"></a>配置ehcache.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Sets the path to the directory where cache .data files are created.</span></span><br><span class="line"><span class="comment">If the path is a Java System Property it is replaced by</span></span><br><span class="line"><span class="comment">         its value in the running VM.</span></span><br><span class="line"><span class="comment">The following properties are translated:</span></span><br><span class="line"><span class="comment">         user.home - User&#x27;s home directory</span></span><br><span class="line"><span class="comment">         user.dir - User&#x27;s current working directory</span></span><br><span class="line"><span class="comment">         java.io.tmpdir - Default temp file path --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--指定二级缓存存放在磁盘上的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;user.dir&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--我们可以给每个实体类指定一个对应的缓存，如果没有匹配到该类，则使用这个默认的缓存配置--&gt;</span></span><br><span class="line">    &lt;defaultCache</span><br><span class="line">        maxElementsInMemory=&quot;10000&quot;　　//在内存中存放的最大对象数</span><br><span class="line">        eternal=&quot;false&quot;　　　　　　　　　//是否永久保存缓存，设置成false</span><br><span class="line">        timeToIdleSeconds=&quot;120&quot;</span><br><span class="line">        timeToLiveSeconds=&quot;120&quot;</span><br><span class="line">        overflowToDisk=&quot;true&quot;　　　　　//如果对象数量超过内存中最大的数，是否将其保存到磁盘中，设置成true</span><br><span class="line">        /&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1、timeToLiveSeconds的定义是：以创建时间为基准开始计算的超时时长；</span></span><br><span class="line"><span class="comment">2、timeToIdleSeconds的定义是：在创建时间和最近访问时间中取出离现在最近的时间作为基准计算的超时时长；</span></span><br><span class="line"><span class="comment">3、如果仅设置了timeToLiveSeconds，则该对象的超时时间=创建时间+timeToLiveSeconds，假设为A；</span></span><br><span class="line"><span class="comment">4、如果没设置timeToLiveSeconds，则该对象的超时时间=max(创建时间，最近访问时间)+timeToIdleSeconds，假设为B；</span></span><br><span class="line"><span class="comment">5、如果两者都设置了，则取出A、B最少的值，即min(A,B)，表示只要有一个超时成立即算超时。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--可以给每个实体类指定一个配置文件，通过name属性指定，要使用类的全名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;com.sunld.bean.User&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;600&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;sampleCache2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span> --&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="开启缓存"><a href="#开启缓存" class="headerlink" title="开启缓存"></a>开启缓存</h3><ul>
<li>①如果使用xml配置，我们需要在 *.hbm.xml 中加上一下配置<br><code>&lt;cache usage=&quot;read-only&quot;/&gt; </code><br>②如果使用annotation配置，我们需要在类上加上这样一个注解<br><code>@Cache(usage=CacheConcurrencyStrategy.READ_ONLY)</code></li>
</ul>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>read-only、nonstrict-read-write、read-write、transactional</p>
<h3 id="二级缓存触发的方法"><a href="#二级缓存触发的方法" class="headerlink" title="二级缓存触发的方法"></a>二级缓存触发的方法</h3><p>save、update、saveOrupdate、load、get、list、query、Criteria方法都会填充二级缓存<br>get、load、iterate会从二级缓存中取数据<br>session.save(user)<br>如果user主键使用“native”生成，则不放入二级缓存</p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol>
<li>条件查询的时候，总是发出一条<code>select * from table_name where</code> …. （选择所有字段）这样的SQL语句查询数据库，一次获得所有的数据对象。</li>
<li>把获得的所有数据对象根据ID放入到第二级缓存中。</li>
<li>当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；查不到，再查询数据库，把结果按照ID放入到缓存。</li>
<li>删除、更新、增加数据的时候，同时更新缓存。</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>二级缓存缓存的仅仅是对象，如果查询出来的是对象的一些属性，则不会被加到缓存中去<br>Hibernate的二级缓存策略，是针对于ID查询的缓存策略，对于条件查询则毫无作用。为此，Hibernate提供了针对条件查询的查询缓存（Query Cache）。</p>
<h3 id="解决N-1问题"><a href="#解决N-1问题" class="headerlink" title="解决N+1问题"></a>解决N+1问题</h3><p>当我们如果需要查询出两次对象的时候，可以使用二级缓存来解决N+1的问题<br>先list在iterator</p>
<h2 id="查询缓存（sessionFactory级别）"><a href="#查询缓存（sessionFactory级别）" class="headerlink" title="查询缓存（sessionFactory级别）"></a>查询缓存（sessionFactory级别）</h2><h3 id="开启缓存-1"><a href="#开启缓存-1" class="headerlink" title="开启缓存"></a>开启缓存</h3><p>hibernate.cfg.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启查询缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.use_query_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="查询中需要调用方法"><a href="#查询中需要调用方法" class="headerlink" title="查询中需要调用方法"></a>查询中需要调用方法</h3><p>.setCacheable(true) //开启查询缓存，查询缓存也是SessionFactory级别的缓存<br>如果使用注解方式，需要在类上加入在类上加注解：@Cacheable</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ol>
<li>只有当 HQL 查询语句完全相同时，连参数设置都要相同，此时查询缓存才有效</li>
<li>查询缓存也能引起 N+1 的问题，需要开启二级缓存。</li>
<li>查询普通属性，会先到查询缓存中取，如果没有，则查询数据库；</li>
<li>查询实体，会先到查询缓存中取id，如果有，则根据id到缓存(一级/二级)中取实体，如果缓存中取不到实体，再查询数据库。</li>
</ol>
<h2 id="FlushMode与session-flush"><a href="#FlushMode与session-flush" class="headerlink" title="FlushMode与session.flush()"></a>FlushMode与session.flush()</h2><p>在Hibernate中，使用session来操作数据库，session中的存在缓存（一级缓存），当调用session.save或者session.update()等方法的时候，hibernate并不一定会将修改同步到数据库（要看具体的FlushMode），而是先将这些数据存储在session的缓存中，由hibernate自己决定何时同步刷新到数据中。正是由于hibernate的这种缓存机制，<strong>在同一个session中多次修改一个记录</strong>，最终只会向数据库发出一条update语句。由于session缓存以及脏数据检查机制，能够帮助我们尽可能少地发出SQL语句。</p>
<p>hibernate提供了FlushMode接口，能够让我们干预hibernate将脏数据同步到数据库的时机。Session.flush()会触发hibernate将数据同步到数据库。可以通过session.setFlushMode()来修改刷新模式。FlushMode提供了4种缓存模式：MANUAL、COMMIT、AUTO和ALWAYS。源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enumeration extending javax.persistence flush modes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Carlos Gonz lez-Cadenas</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">FlushModeType</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Corresponds to &#123;<span class="doctag">@link</span> org.hibernate.FlushMode#ALWAYS&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ALWAYS,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Corresponds to  &#123;<span class="doctag">@link</span> org.hibernate.FlushMode#AUTO&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	AUTO,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Corresponds to  &#123;<span class="doctag">@link</span> org.hibernate.FlushMode#COMMIT&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	COMMIT,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Corresponds to  &#123;<span class="doctag">@link</span> org.hibernate.FlushMode#NEVER&#125;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@deprecated</span> use MANUAL, will be removed in a subsequent release</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	NEVER,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Corresponds to  &#123;<span class="doctag">@link</span> org.hibernate.FlushMode#MANUAL&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MANUAL,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Current flush mode of the persistence context at the time the query is executed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PERSISTENCE_CONTEXT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MANUAL"><a href="#MANUAL" class="headerlink" title="MANUAL"></a>MANUAL</h3><p>我们必须在代码中**手动调用session.flush()**，hibernate才会将脏数据同步到数据库。如果我们忘记了手动刷新，那么就算是通过session.getTransaction().commit()提交了事务，也不能将修改同步到数据库。</p>
<h3 id="COMMIT"><a href="#COMMIT" class="headerlink" title="COMMIT"></a>COMMIT</h3><p>当数据库事务提交的时候会刷新缓存，当然手动调用flush()肯定也是可以的，不过没有必要罢了。</p>
<h3 id="AUTO（默认）"><a href="#AUTO（默认）" class="headerlink" title="AUTO（默认）"></a>AUTO（默认）</h3><p>事务提交或者手动刷新，都能将脏数据同步到数据库。除此之外，某些查询出现的时候也会导致缓存刷新。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>you don’t control when Hibernate will decide to execute UPDATE/INSERT/DELETE.</li>
<li>potential performance issues because every object modification may lead to dirty checking + DML statement execution.</li>
<li>you are not taking advantage of batching and other optimizations that Hibernate can perform when it is not trying to avoid ‘stale’ state</li>
</ol>
<h3 id="ALWAYS"><a href="#ALWAYS" class="headerlink" title="ALWAYS"></a>ALWAYS</h3><p>只要有查询出现，或者事务提交，或者手动刷新，都会导致缓存刷新。这个策略性能比较差，实际中不会使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>默认hibernate不会开启查询缓存，这是因为查询缓存只有在hql/hql语句语义完全一致的时候，才能命中。而实际查询场景下，查询条件、分页、排序等构成的复杂查询sql语句很难完全一致。可能是hibernate觉得命中率低，所以默认关闭了查询缓存。我们可以根据实际使用情况，决定是否开启查询缓存，唯一的原则就是命中率要尽可能的高。如果针对A表的查询，查询sql语句基本都是完全一致的情况，就可以针对A使用查询缓存；如果B表的查询条件经常变化，很难命中，那么就不要对B表使用查询缓存。这可能就是hibernate使用查询缓存的时候，既要在hibernate.cfg.xml中进行配置，也需要query.setCacheable(true)的原因。查询缓存只对list有用，对iterate方式无用。iterate不会读也不会写查询缓存，list会读也会写查询缓存。查询缓存中的key是sql语句（这些sql语句会被hibernate解析，保证语义相同的sql，能够命中查询缓存），缓存的value是记录的主键值。</p>
<p>通过开启查询缓存和二级缓存，相同的sql查询可以直接使用查询缓存中的id和二级缓存中的实体对象，可以有效的降低反复的数据库查询，可以提高查询效率。也就是说：同一时候开启查询缓存和二级缓存是有意义的。也是实际使用hibernate的最佳配置。进一步的。我们也能够看出list和iterate方法的差别。list()会将实体对象的id放入查询缓存，将实体对象本身放入二级缓存。iterate不会将实体对象的id放入查询缓存。可是会将实体对象本身存入二级缓存。假设第二次查询可以命中的情况下：list全然不须要查询数据库，可以先从查询缓存中获取到id。再从二级缓存中获取实体对象。iterate一定会发出一条查id的sql，然后去二级缓存中获取实体对象。</p>
<h2 id="缓存策略提供商"><a href="#缓存策略提供商" class="headerlink" title="缓存策略提供商"></a>缓存策略提供商</h2><p>org.hibernate.cache.HashtableCacheProvider(内存)<br>org.hibernate.cache.EhCacheProvider(内存，硬盘)<br>org.hibernate.cache.OSCacheProvider(内存，硬盘)<br>org.hibernate.cache.SwarmCacheProvider(能用于集群环境)<br>org.hibernate.cache.TreeCacheProvider(能用于集群环境)<br>org.hibernate.cache.jbc.JBossCacheRegionFactory(能用于集群环境)</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Hibernate</category>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>InfluxDB深入学习之自身监控</title>
    <url>/2021/03/03/InfluxDB%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E8%BA%AB%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h2 id="常用监控脚本"><a href="#常用监控脚本" class="headerlink" title="常用监控脚本"></a>常用监控脚本</h2><h3 id="series"><a href="#series" class="headerlink" title="series"></a>series</h3><p>Series会被索引且存在内存中，如果量太大会对资源造成过多损耗，且查询效率也得不到保障。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">influx -database <span class="string">&#x27;telegraf&#x27;</span> -execute <span class="string">&#x27;show series&#x27;</span> -format <span class="string">&#x27;csv&#x27;</span>|wc -l</span><br></pre></td></tr></table></figure>
<p>或者使用如下sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> &quot;database&quot; <span class="keyword">WHERE</span> <span class="type">time</span> <span class="operator">&gt;</span> now() <span class="operator">-</span> <span class="number">5</span>m <span class="keyword">and</span> &quot;database&quot;<span class="operator">=</span><span class="string">&#x27;telegraf&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">time</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<h3 id="tag-values"><a href="#tag-values" class="headerlink" title="tag values"></a>tag values</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">influx -database <span class="string">&#x27;telegraf&#x27;</span> -execute <span class="string">&#x27;SHOW TAG VALUES FROM cpu WITH KEY = cpu&#x27;</span> -format <span class="string">&#x27;csv&#x27;</span>|wc -l</span><br></pre></td></tr></table></figure>
<h3 id="每秒写数据量"><a href="#每秒写数据量" class="headerlink" title="每秒写数据量"></a>每秒写数据量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">influx -execute <span class="string">&#x27;select derivative(pointReq, 1s) from &quot;write&quot; where time &gt; now() - 5m&#x27;</span> -database <span class="string">&#x27;_internal&#x27;</span> -precision <span class="string">&#x27;rfc3339&#x27;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cpu <span class="keyword">where</span> <span class="type">time</span> <span class="operator">&gt;</span> now() <span class="operator">-</span> <span class="number">1</span>m</span><br><span class="line">QUERY PLAN</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">EXPRESSION: <span class="operator">&lt;</span>nil<span class="operator">&gt;</span></span><br><span class="line">AUXILIARY FIELDS: cpu::tag, host::tag, usage_active::<span class="type">float</span>, usage_guest::<span class="type">float</span>, usage_guest_nice::<span class="type">float</span>, usage_idle::<span class="type">float</span>, usage_iowait::<span class="type">float</span>, usage_irq::<span class="type">float</span>, usage_nice::<span class="type">float</span>, usage_softirq::<span class="type">float</span>, usage_steal::<span class="type">float</span>, usage_system::<span class="type">float</span>, usage_user::<span class="type">float</span></span><br><span class="line">NUMBER <span class="keyword">OF</span> SHARDS: <span class="number">1</span></span><br><span class="line">NUMBER <span class="keyword">OF</span> SERIES: <span class="number">57</span></span><br><span class="line">CACHED <span class="keyword">VALUES</span>: <span class="number">3135</span></span><br><span class="line">NUMBER <span class="keyword">OF</span> FILES: <span class="number">0</span></span><br><span class="line">NUMBER <span class="keyword">OF</span> BLOCKS: <span class="number">0</span></span><br><span class="line">SIZE <span class="keyword">OF</span> BLOCKS: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="explain-analyze"><a href="#explain-analyze" class="headerlink" title="explain analyze"></a>explain analyze</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain analyze <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cpu <span class="keyword">where</span> <span class="type">time</span> <span class="operator">&gt;</span> now() <span class="operator">-</span> <span class="number">30</span>d</span><br><span class="line">EXPLAIN ANALYZE</span><br><span class="line"><span class="comment">---------------</span></span><br><span class="line">.</span><br><span class="line">└── <span class="keyword">select</span></span><br><span class="line">    ├── execution_time: <span class="number">230.982833</span>ms</span><br><span class="line">    ├── planning_time: <span class="number">8.062578</span>ms</span><br><span class="line">    ├── total_time: <span class="number">239.045411</span>ms</span><br><span class="line">    └── build_cursor</span><br><span class="line">        ├── labels</span><br><span class="line">        │   └── statement: <span class="keyword">SELECT</span> cpu::tag, host::tag, usage_active::<span class="type">float</span>, usage_guest::<span class="type">float</span>, usage_guest_nice::<span class="type">float</span>, usage_idle::<span class="type">float</span>, usage_iowait::<span class="type">float</span>, usage_irq::<span class="type">float</span>, usage_nice::<span class="type">float</span>, usage_softirq::<span class="type">float</span>, usage_steal::<span class="type">float</span>, usage_system::<span class="type">float</span>, usage_user::<span class="type">float</span> <span class="keyword">FROM</span> telegraf.autogen.cpu</span><br><span class="line">        └── iterator_scanner</span><br><span class="line">            ├── labels</span><br><span class="line">            │   └── auxiliary_fields: cpu::tag, host::tag, usage_active::<span class="type">float</span>, usage_guest::<span class="type">float</span>, usage_guest_nice::<span class="type">float</span>, usage_idle::<span class="type">float</span>, usage_iowait::<span class="type">float</span>, usage_irq::<span class="type">float</span>, usage_nice::<span class="type">float</span>, usage_softirq::<span class="type">float</span>, usage_steal::<span class="type">float</span>, usage_system::<span class="type">float</span>, usage_user::<span class="type">float</span></span><br><span class="line">            └── create_iterator</span><br><span class="line">                ├── labels</span><br><span class="line">                │   ├── measurement: cpu</span><br><span class="line">                │   └── shard_id: <span class="number">2</span></span><br><span class="line">                ├── cursors_ref: <span class="number">0</span></span><br><span class="line">                ├── cursors_aux: <span class="number">627</span></span><br><span class="line">                ├── cursors_cond: <span class="number">0</span></span><br><span class="line">                ├── float_blocks_decoded: <span class="number">0</span></span><br><span class="line">                ├── float_blocks_size_bytes: <span class="number">0</span></span><br><span class="line">                ├── integer_blocks_decoded: <span class="number">0</span></span><br><span class="line">                ├── integer_blocks_size_bytes: <span class="number">0</span></span><br><span class="line">                ├── unsigned_blocks_decoded: <span class="number">0</span></span><br><span class="line">                ├── unsigned_blocks_size_bytes: <span class="number">0</span></span><br><span class="line">                ├── string_blocks_decoded: <span class="number">0</span></span><br><span class="line">                ├── string_blocks_size_bytes: <span class="number">0</span></span><br><span class="line">                ├── boolean_blocks_decoded: <span class="number">0</span></span><br><span class="line">                ├── boolean_blocks_size_bytes: <span class="number">0</span></span><br><span class="line">                └── planning_time: <span class="number">7.428681</span>ms</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 由于EXPLAIN ANALYZE忽略查询结果的输出，所以不包括转换为JSON或CSV的成本</p>
</blockquote>
<h4 id="execution-time（执行查询耗时）"><a href="#execution-time（执行查询耗时）" class="headerlink" title="execution_time（执行查询耗时）"></a>execution_time（执行查询耗时）</h4><ol>
<li>reading the time series data</li>
<li>performing operations as data flows through iterators</li>
<li>draining processed data from iterators</li>
<li>不包括：转换为JSON或CSV的耗时</li>
</ol>
<h4 id="planning-time（计划查询耗时）"><a href="#planning-time（计划查询耗时）" class="headerlink" title="planning_time（计划查询耗时）"></a>planning_time（计划查询耗时）</h4><p>资源消耗和时间消耗与查询的复杂性相关；比如，series keys会影响查询速度和内存消耗。首先确认时间范围和shards，然后each shard and each measurement, InfluxDB performs the following steps:</p>
<ol>
<li>Select matching series keys from the index, filtered by tag predicates in the WHERE clause.</li>
<li>Group filtered series keys into tag sets based on the GROUP BY dimensions.</li>
<li>Enumerate each tag set and create a cursor and iterator for each series key.</li>
<li>Merge iterators and return the merged result to the query executor.</li>
</ol>
<h4 id="iterator-type"><a href="#iterator-type" class="headerlink" title="iterator type"></a>iterator type</h4><ol>
<li><strong>create_iterator：</strong> 本地数据库，──a complex composition of nested iterators combined and merged to produce the final query output.</li>
<li><strong>remote_iterator：</strong>(InfluxDB Enterprise only)  在远程完成</li>
</ol>
<h4 id="cursor-type"><a href="#cursor-type" class="headerlink" title="cursor type"></a>cursor type</h4><p>虽然每种游标类型有相同的数据结构和CPU、IO成本，但每种游标的构造原因不同，并在最终的结果中分开。</p>
<ol>
<li><strong>cursor_ref</strong>: 聚合函数的投影游标，比如<code>last()</code> or <code>mean()</code>.</li>
<li><strong>cursor_aux</strong>: 用于简单表达式计算的辅助游标</li>
<li><strong>cursor_cond</strong>: 执行where中的fields创建的游标</li>
</ol>
<h4 id="block-types"><a href="#block-types" class="headerlink" title="block types"></a>block types</h4><p>EXPLAIN ANALYZE separates storage block types, and reports the total number of blocks decoded and their size (in bytes) on disk. The following block types are supported:</p>
<ol>
<li>float | 64-bit IEEE-754 floating-point number</li>
<li>integer | 64-bit signed integer | | unsigned | 64-bit unsigned integer</li>
<li>boolean | 1-bit, LSB encoded</li>
<li>string | UTF-8 string</li>
</ol>
<h3 id="show-retention-policies"><a href="#show-retention-policies" class="headerlink" title="show retention policies"></a>show retention policies</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="keyword">show</span> retention policies</span><br><span class="line">name    duration shardGroupDuration replicaN <span class="keyword">default</span></span><br><span class="line"><span class="comment">----    -------- ------------------ -------- -------</span></span><br><span class="line">autogen <span class="number">0</span>s       <span class="number">168</span>h0m0s           <span class="number">1</span>        <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="show-shards"><a href="#show-shards" class="headerlink" title="show shards"></a>show shards</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">name: telegraf</span><br><span class="line">id database retention_policy shard_group start_time           end_time             expiry_time          owners</span><br><span class="line"><span class="comment">-- -------- ---------------- ----------- ----------           --------             -----------          ------</span></span><br><span class="line"><span class="number">2</span>  telegraf autogen          <span class="number">2</span>           <span class="number">2021</span><span class="number">-03</span><span class="number">-08</span>T00:<span class="number">00</span>:<span class="number">00</span>Z <span class="number">2021</span><span class="number">-03</span><span class="number">-15</span>T00:<span class="number">00</span>:<span class="number">00</span>Z <span class="number">2021</span><span class="number">-03</span><span class="number">-15</span>T00:<span class="number">00</span>:<span class="number">00</span>Z </span><br><span class="line"></span><br><span class="line">name: _internal</span><br><span class="line">id database  retention_policy shard_group start_time           end_time             expiry_time          owners</span><br><span class="line"><span class="comment">-- --------  ---------------- ----------- ----------           --------             -----------          ------</span></span><br><span class="line"><span class="number">1</span>  _internal monitor          <span class="number">1</span>           <span class="number">2021</span><span class="number">-03</span><span class="number">-10</span>T00:<span class="number">00</span>:<span class="number">00</span>Z <span class="number">2021</span><span class="number">-03</span><span class="number">-11</span>T00:<span class="number">00</span>:<span class="number">00</span>Z <span class="number">2021</span><span class="number">-03</span><span class="number">-18</span>T00:<span class="number">00</span>:<span class="number">00</span>Z</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.influxdata.com/influxdb/v1.7/query_language/spec/#explain">explain</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>InfluxDB</category>
      </categories>
      <tags>
        <tag>InfluxDB</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK安装</title>
    <url>/2021/02/07/JDK%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Windows版本"><a href="#Windows版本" class="headerlink" title="Windows版本"></a>Windows版本</h2><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><ol>
<li>操作系统版本：Window10 X64，其他操作系统类似</li>
<li>JDK版本：jdk1.8.0_192，安装后目录：<code>C:\Program Files\Java\jdk1.8.0_192</code><a id="more"></a>

</li>
</ol>
<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ol>
<li><p>打开环境变量配置页面</p>
<div align="center">

</div></li>
</ol>
<img src="/2021/02/07/JDK%E5%AE%89%E8%A3%85/1588070689018.png" class>


2. 在环境变量中新建`JAVA_HOME`,输入实际地址`C:\Program Files\Java\jdk1.8.0_192`
<div align="center">

<img src="/2021/02/07/JDK%E5%AE%89%E8%A3%85/1588070882938.png" class>

</div>
3. 修改Path：找到Path点击编辑打开编辑页面，在编辑页面中新增JDK的相关配置`%JAVA_HOME%\bin`
<div align="center">

<img src="/2021/02/07/JDK%E5%AE%89%E8%A3%85/1588071036233.png" class>

</div>
4. 增加classpath，输入为`.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar`
<div align="center">

<img src="/2021/02/07/JDK%E5%AE%89%E8%A3%85/1588071135219.png" class>

</div>
5. 配置完成之后保存，并且关闭环境变量配置的相关窗口

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>重新打开cmd窗口输入<code>java</code>和<code>java</code>显示出对应的信息，则表示配置成功。</p>
<h2 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本"></a>Linux版本</h2>]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Javap详解</title>
    <url>/2021/02/04/Javap%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>javap 命令用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息,输出堆栈大小、各方法的 locals 及 args 数。</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -<span class="keyword">public</span>                  仅显示公共类和成员</span><br><span class="line">  -<span class="keyword">protected</span>               显示受保护的/公共类和成员</span><br><span class="line">  -<span class="keyword">package</span>                 显示程序包/受保护的/公共类和成员 (默认)</span><br><span class="line">  -p  -<span class="keyword">private</span>             显示所有类和成员</span><br><span class="line">  -c                       输出类中各方法的未解析的代码，即构成 Java 字节码的指令。</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置,如果设置了该选项，则它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置,缺省情况下，自举类是实现核心 Java 平台的类，位于 jrelibt.jar 和 jrelibi18n.jar 中。</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPassByValue</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> temp1 = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">this</span>.passInt(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passInt</span><span class="params">(<span class="keyword">int</span> abc)</span> </span>&#123; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String temp = <span class="string">&quot;abcddd&quot;</span>;</span><br><span class="line">		PassByValue val = <span class="keyword">new</span> PassByValue();</span><br><span class="line">		<span class="keyword">this</span>.passObject(val, temp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passObject</span><span class="params">(PassByValue passByValue, String value)</span> </span>&#123; </span><br><span class="line">		passByValue = <span class="keyword">null</span>;</span><br><span class="line">		value = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValue</span></span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="javap分析"><a href="#javap分析" class="headerlink" title="javap分析"></a>javap分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.TestPassByValue包含com.sunld.TestPassByValue</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/TestPassByValue.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">4</span>-<span class="number">29</span>; size <span class="number">939</span> bytes</span><br><span class="line">  MD5 checksum ae6cce5733ce01797de9d8ae30359bdd</span><br><span class="line">  Compiled from <span class="string">&quot;TestPassByValue.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">TestPassByValue</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/TestPassByValue</span><br><span class="line">   #2 = Utf8               com/sunld/TestPassByValue</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               temp1</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Methodref          #3.#11         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #11 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #12 = Fieldref           #1.#13         // com/sunld/TestPassByValue.temp1:I</span><br><span class="line">  #13 = NameAndType        #5:#6          // temp1:I</span><br><span class="line">  #14 = Utf8               LineNumberTable</span><br><span class="line">  #15 = Utf8               LocalVariableTable</span><br><span class="line">  #16 = Utf8               this</span><br><span class="line">  #17 = Utf8               Lcom/sunld/TestPassByValue;</span><br><span class="line">  #18 = Utf8               doPassInt</span><br><span class="line">  #19 = Methodref          #1.#20         // com/sunld/TestPassByValue.passInt:(I)V</span><br><span class="line">  #20 = NameAndType        #21:#22        // passInt:(I)V</span><br><span class="line">  #21 = Utf8               passInt</span><br><span class="line">  #22 = Utf8               (I)V</span><br><span class="line">  #23 = Utf8               temp</span><br><span class="line">  #24 = Utf8               abc</span><br><span class="line">  #25 = Utf8               doPassObject</span><br><span class="line">  #26 = String             #27            // abcddd</span><br><span class="line">  #27 = Utf8               abcddd</span><br><span class="line">  #28 = Class              #29            // com/sunld/PassByValue</span><br><span class="line">  #29 = Utf8               com/sunld/PassByValue</span><br><span class="line">  #30 = Methodref          #28.#11        // com/sunld/PassByValue.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #31 = Methodref          #1.#32         // com/sunld/TestPassByValue.passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #32 = NameAndType        #33:#34        // passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #33 = Utf8               passObject</span><br><span class="line">  #34 = Utf8               (Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #35 = Utf8               Ljava/lang/String;</span><br><span class="line">  #36 = Utf8               val</span><br><span class="line">  #37 = Utf8               Lcom/sunld/PassByValue;</span><br><span class="line">  #38 = String             #39            // value</span><br><span class="line">  #39 = Utf8               value</span><br><span class="line">  #40 = Utf8               passByValue</span><br><span class="line">  #41 = Utf8               SourceFile</span><br><span class="line">  #42 = Utf8               TestPassByValue.java</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//默认的构造方法，在构造方法执行时主要完成一些初始化操作，包括一些成员变量的初始化赋值等操作</span></span><br><span class="line">  <span class="keyword">public</span> com.sunld.TestPassByValue();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">//*load_*：将本地变量表中索引为*的局部变量加载到操作栈</span></span><br><span class="line">         <span class="comment">//从本地变量表中加载索引为0的变量的值到操作栈，也即this的引用，压入栈</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="comment">//invokespecial：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）</span></span><br><span class="line">         <span class="comment">//出栈，调用java/lang/Object.&quot;&lt;init&gt;&quot;:()V 初始化对象，就是this指定的对象的init()方法完成初始化</span></span><br><span class="line">         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="comment">// 4到7表示，完成this.temp1 = 10的赋值。这里this引用入栈</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="comment">//将常量10加入到操作数栈</span></span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="comment">//出栈前面压入的两个值（this引用，常量值10）， 将10取出，并赋值给temp1</span></span><br><span class="line">         7: putfield      #12                 // Field temp1:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      <span class="comment">//指令与代码行数的偏移对应关系，每一行第一个数字对应代码行数，第二个数字对应前面code中指令前面的数字</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">3</span>: <span class="number">10</span></span><br><span class="line">      <span class="comment">//局部变量表，start+length表示这个变量在字节码中的生命周期起始和结束的偏移位置（this生命周期从头0到结尾10）</span></span><br><span class="line">      <span class="comment">//slot就是这个变量在局部变量表中的槽位（槽位可复用），name就是变量名称，Signatur局部变量类型描述</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassInt</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// 常量100入栈</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="comment">// 将一个数值从操作数栈存储到局部变量表,存储100给temp</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="comment">// 加载this入栈</span></span><br><span class="line">         <span class="number">3</span>: aload_0</span><br><span class="line">         <span class="comment">// temp入栈</span></span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         5: invokevirtual #19                 // Method passInt:(I)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">3</span>       <span class="number">6</span>     <span class="number">1</span>  temp   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passInt</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">1</span>   abc   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassObject</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// 从常量池取出abcddd入栈</span></span><br><span class="line">         0: ldc           #26                 // String abcddd</span><br><span class="line">         <span class="comment">// 出栈赋值给temp</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="comment">// 创建PassByValue对象，将引用压入栈</span></span><br><span class="line">         3: new           #28                 // class com/sunld/PassByValue</span><br><span class="line">         <span class="comment">// 将操作数栈顶的数据复制一份，并压入栈，此时栈中有两个引用值（目前有两个PassByValue的引用）</span></span><br><span class="line">         <span class="number">6</span>: dup</span><br><span class="line">         7: invokespecial #30                 // Method com/sunld/PassByValue.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="comment">// 出栈栈顶数据（对象PassByValue）复制给val</span></span><br><span class="line">        <span class="number">10</span>: astore_2</span><br><span class="line">        <span class="comment">// 入栈this</span></span><br><span class="line">        <span class="number">11</span>: aload_0</span><br><span class="line">        <span class="comment">// 入栈val</span></span><br><span class="line">        <span class="number">12</span>: aload_2</span><br><span class="line">        <span class="comment">// 入栈temp</span></span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        14: invokevirtual #31                 // Method passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">        <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">18</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">3</span>      <span class="number">15</span>     <span class="number">1</span>  temp   Ljava/lang/String;</span><br><span class="line">           <span class="number">11</span>       <span class="number">7</span>     <span class="number">2</span>   val   Lcom/sunld/PassByValue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passObject</span><span class="params">(com.sunld.PassByValue, java.lang.String)</span></span>;</span><br><span class="line">    descriptor: (Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: aconst_null</span><br><span class="line">         <span class="number">1</span>: astore_1</span><br><span class="line">         2: ldc           #38                 // String value</span><br><span class="line">         <span class="number">4</span>: astore_2</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span> passByValue   Lcom/sunld/PassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">2</span> value   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestPassByValue.java&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.jianshu.com/p/6a8997560b05">通过javap命令分析java汇编指令</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>Javap</tag>
        <tag>Class分析</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常见问题之两套JRE</title>
    <url>/2021/02/05/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B9%8B%E4%B8%A4%E5%A5%97JRE/</url>
    <content><![CDATA[<p>JDK在安装过程中如果勾选安装JRE最终会在安装目录中有两套JRE。简单来说一套用于Java本身的运行（比如java本身的javac、还有监控套件javap等），一套用于程序的运行。两套JRE的路径默认为：</p>
<ol>
<li>C:\Program Files\Java\jdk1.8.0_192\jre</li>
<li>C:\Program Files\Java\jre1.8.0_192<a id="more"></a>

</li>
</ol>
<h2 id="JDK、JRE、JVM之间的关系"><a href="#JDK、JRE、JVM之间的关系" class="headerlink" title="JDK、JRE、JVM之间的关系"></a>JDK、JRE、JVM之间的关系</h2><p>JDK本身运行环境中的jre比jre目录下多了Server端的Java虚拟机。  </p>
<p>JRE：Java编译后的可运行环境。<br>JVM：Java虚拟机</p>
<h3 id="使用两套JDK的原因"><a href="#使用两套JDK的原因" class="headerlink" title="使用两套JDK的原因"></a>使用两套JDK的原因</h3><p>JDK里面有很多用Java所编写的开发工具（如javac.exe、jar.exe等），而且都放置在 &lt;JDK安装目录&gt;\lib\tools.jar 里。<code>javac.exe与输入 java -cp c:\jdk\lib\tools.jar com.sun.tools.javac.Main</code>是一样的，会得到相同的结果。</p>
<h3 id="如何选择使用那套JRE"><a href="#如何选择使用那套JRE" class="headerlink" title="如何选择使用那套JRE"></a>如何选择使用那套JRE</h3><p>由<code>java.exe</code>决定，执行顺序如下：</p>
<ol>
<li>自己的目录下有没有JRE；</li>
<li>父目录有没有JRE；</li>
<li>查询注册表：<br>[HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment]</li>
</ol>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p><strong>JRE目录下的Bin目录有两个目录：server与client。这就是真正的jvm.dll所在。</strong><br>jvm.dll 无法单独工作，当jvm.dll启动后，会使用explicit的方法（就是使用Win32 API之中的LoadLibrary()与GetProcAddress()来载入辅助用的动态链接库），而这些辅助用的动态链接库（.dll）都必须位于jvm.dll所在目录的父目录之中。因此想使用哪个JVM，只需要设置PATH，指向JRE所在目录底下的jvm.dll。</p>
<h2 id="名称解释"><a href="#名称解释" class="headerlink" title="名称解释"></a>名称解释</h2><ol>
<li><strong>JAVA IDE</strong>:JAVA集成开发环境，如JBuilder Eclipse NetBeans,JEdit,TaxPad等等。</li>
<li><strong>JDK Java开发包</strong>:java development kit ，它是使用JAVA进行开发的基础，包含：JVM（JAVA虚拟机）,JAVA 类库，JAVA运行环境。简单的说就是个开发平台：包含开发平台，和JAVA运行平台（即JRE或J2RE是Java2 Runtime Environment，即Java运行环境，有时简称JRE。如果你只需要运行Java程序或Applet，下载并安装它即可。）</li>
<li><strong>SDK（Software Development Kit）</strong>一般指软件开发包，可以包括函数库、编译程序等。</li>
<li><strong>JRE（Java Runtime Enviroment）</strong>是指Java的运行环境，是面向Java程序的使用者，而不是开发者。其内部含有JVM(JAVA虚拟机）</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="jdk下bin目录里的java-exe与外部jre中的java-exe的秘密"><a href="#jdk下bin目录里的java-exe与外部jre中的java-exe的秘密" class="headerlink" title="jdk下bin目录里的java.exe与外部jre中的java.exe的秘密"></a>jdk下bin目录里的java.exe与外部jre中的java.exe的秘密</h3><p>jdk里的java.exe和jre中的java.exe其实是一样的，但我们在运行的时候用的却是优先使用外部jre中的java.exe（即使我们安装了JDK且也配置了环境变量）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>安装JDK时一定会在其子目录下面安装一个JRE，同时在安装的过程也会询问你是否要安装一个外部的JRE。</li>
<li>如果我们选择安装则就同时拥有了两个jre。这两个JRE其实本质上是没有任何分别的。最主要的区别在于：JDK目录里面的JRE主要是设计用来运行JDK自带的那些工具的（Bin目录下）。而外部的JRE在安装的时候会自动注册到操作系统的path（但在我的电脑\属性\高级系统设置\环境变量\系统变量中的 path中并没有包含该命令的路径值）里面一般是：System32文件夹下（该文件夹下包含：java.exe javaw.exe  javaws.exe 三个文件）面。</li>
<li>因此我们只要安装了外部的JRE（即使JDK没有安装，环境变量没有配置）则运行Java程序时都是用的外部JRE的java.exe程序来运行的（即使安装了JDK且配置了环境变量）（系统的默认path具有优先）。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>JRE</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之CAS</title>
    <url>/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS/</url>
    <content><![CDATA[<h2 id="无锁的优点（效率高的原因）"><a href="#无锁的优点（效率高的原因）" class="headerlink" title="无锁的优点（效率高的原因）"></a>无锁的优点（效率高的原因）</h2><ol>
<li>不会出现上下文切换</li>
<li>需要额外CPU的支持</li>
</ol>
<h2 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h2><p><strong>结合CAS+volatile可以实现无锁并发。</strong></p>
<ol>
<li>场景：线程数少、多核 CPU 的场景下</li>
<li>CAS基于乐观锁实现思路，synchronized基于悲观锁的思路</li>
<li>CAS 体现的是无锁并发、无阻塞并发（竞争不激烈的前提下）</li>
<li>概念：Compare And Swap/Set，3 个参数 CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。 <a id="more"></a>

</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="原子类操作"><a href="#原子类操作" class="headerlink" title="原子类操作"></a>原子类操作</h3><ol>
<li>引入时间：JDK1.5后</li>
<li>包路径：java.util.concurrent.atomic</li>
<li>实现原理（锁自旋）：在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，<strong>具有排他性</strong>，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。</li>
</ol>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS/1589109472540.png" class>

</div>


<h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>在JDK1.8中使用Unsafe类进行数据处理的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Unsafe.compareAndSwapInt处理数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用unsafe设置数据value的偏移地址</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证内存可见性和禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在转化的时候，先通过反射（getDeclaredField）获取value成员变量对应的Field对象，再通过objectFieldOffset函数转化成valueOffset。此处的valueOffset就代表了value变量本身，后面执行CAS操作的时候，不是直接操作value，而是操作valueOffset。</p>
<h4 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h4><p>与AtomicInteger的实现方式类似。</p>
<h4 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h4><ol>
<li>背景：处理compareAndSet(true, false)问题</li>
<li>实现方式：基于unsafe.compareAndSwapInt</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">  * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment">  * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AtomicStampedReference和AtomicMarkableReference"><a href="#AtomicStampedReference和AtomicMarkableReference" class="headerlink" title="AtomicStampedReference和AtomicMarkableReference"></a>AtomicStampedReference和AtomicMarkableReference</h4><ol>
<li>处理ABA问题</li>
<li>通过增加版本的概念处理</li>
<li>AtomicStampedReference版本是int类型</li>
<li>AtomicMarkableReference版本是boolean类型，还可能会出现ABA问题</li>
<li>原理：通过“值”和“版本号”比对确认是否可以更新，可解决Integer型或者Long型的ABA问题</li>
</ol>
<h5 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="comment">// 维护的版本</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AtomicStampedReference&#125; with the given</span></span><br><span class="line"><span class="comment">     * initial values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialRef the initial reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialStamp the initial stamp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;</span><br><span class="line">        pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value of both the reference and stamp</span></span><br><span class="line"><span class="comment">     * to the given update values if the</span></span><br><span class="line"><span class="comment">     * current reference is &#123;<span class="doctag">@code</span> ==&#125; to the expected reference</span></span><br><span class="line"><span class="comment">     * and the current stamp is equal to the expected stamp.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expectedReference the expected value of the reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newReference the new value for the reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expectedStamp the expected value of the stamp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newStamp the new value for the stamp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicMarkableReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="comment">// 维护的版本</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> mark;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.mark = mark;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, mark);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AtomicMarkableReference&#125; with the given</span></span><br><span class="line"><span class="comment">     * initial values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialRef the initial reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialMark the initial mark</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicMarkableReference</span><span class="params">(V initialRef, <span class="keyword">boolean</span> initialMark)</span> </span>&#123;</span><br><span class="line">        pair = Pair.of(initialRef, initialMark);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value of both the reference and mark</span></span><br><span class="line"><span class="comment">     * to the given update values if the</span></span><br><span class="line"><span class="comment">     * current reference is &#123;<span class="doctag">@code</span> ==&#125; to the expected reference</span></span><br><span class="line"><span class="comment">     * and the current mark is equal to the expected mark.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expectedReference the expected value of the reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newReference the new value for the reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expectedMark the expected value of the mark</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newMark the new value for the mark</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V       expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V       newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> expectedMark,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> newMark)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedMark == current.mark &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newMark == current.mark) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newMark)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="AtomicXXXFieldUpdater"><a href="#AtomicXXXFieldUpdater" class="headerlink" title="AtomicXXXFieldUpdater"></a>AtomicXXXFieldUpdater</h4><ol>
<li>处理类似类中的属性原始操作</li>
<li>条件：成员变量必须是volatile的int类型（不能是Integer包装类）</li>
</ol>
<h4 id="Striped64与LongAdder"><a href="#Striped64与LongAdder" class="headerlink" title="Striped64与LongAdder"></a>Striped64与LongAdder</h4><p>在jdk1.8中针对long和double(具体实现基于long)分别增加了XXXAdder、XXXAccumulator来处理原则操作。具体类图如下：</p>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS/1591450381138.png" class title="类图">

</div>

<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>与ConcurrentHashMap类似。</p>
<ol>
<li>拆分：提高并发，把一个long拆分成多个long</li>
<li>最终一致性：最终对数据进行汇总处理</li>
</ol>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCAS/1591450602899.png" class>

</div>

<h5 id="Striped64"><a href="#Striped64" class="headerlink" title="Striped64"></a>Striped64</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">import</span> java.util.function.LongBinaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.DoubleBinaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">        Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">                valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Number of CPUS, to place bound on table size */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table of cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base value, used mainly when there is no contention, but also as</span></span><br><span class="line"><span class="comment">     * a fallback during table initialization races. Updated via CAS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spinlock (locked via CAS) used when resizing and/or creating Cells.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; sk = Striped64.class;</span><br><span class="line">            BASE = UNSAFE.objectFieldOffset</span><br><span class="line">                (sk.getDeclaredField(<span class="string">&quot;base&quot;</span>));</span><br><span class="line">            CELLSBUSY = UNSAFE.objectFieldOffset</span><br><span class="line">                (sk.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomProbe&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Adds the given value.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> x the value to add</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="聚合数据"><a href="#聚合数据" class="headerlink" title="聚合数据"></a>聚合数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the current sum.  The returned value is &lt;em&gt;NOT&lt;/em&gt; an</span></span><br><span class="line"><span class="comment">  * atomic snapshot; invocation in the absence of concurrent</span></span><br><span class="line"><span class="comment">  * updates returns an accurate result, but concurrent updates that</span></span><br><span class="line"><span class="comment">  * occur while the sum is being calculated might not be</span></span><br><span class="line"><span class="comment">  * incorporated.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the sum</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><ol>
<li>多个线程操作同一个数据时，数据被修改为A-B-A</li>
<li>解决方式：使用版本号解决 </li>
</ol>
<h3 id="消除缓存行的伪共享"><a href="#消除缓存行的伪共享" class="headerlink" title="消除缓存行的伪共享"></a>消除缓存行的伪共享</h3><ol>
<li>cpu中的一级缓存、二级缓存、三级缓存</li>
<li>禁用 <ul>
<li>jdk1.7前会将需要独占缓存行的变量前后添加一组long类型的变量，依靠这些无意义的数组的填充做到一个变量自己独占一个缓存行； </li>
<li>在jdk1.7因为jvm会将这些没有用到的变量优化掉，所以采用继承一个声明了好多long变量的类的方式来实现； </li>
<li>在jdk1.8中通过添加sun.misc.Contended注解来解决这个问题，若要使该注解有效必须在jvm中添加以下参数： -XX:-RestrictContended</li>
<li>sun.misc.Contended注解会在变量前面添加128字节的padding将当前变量与其他变量进行隔离； </li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>CAS</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之LockSupport</title>
    <url>/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLockSupport/</url>
    <content><![CDATA[<h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLockSupport/1590712088254.png" class title="LocalSupport类图">

</div>

<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LockSupport</tag>
        <tag>线程控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之ReentrantReadWriteLock</title>
    <url>/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BReentrantReadWriteLock/</url>
    <content><![CDATA[<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BReentrantReadWriteLock/1591534830113.png" class title="类图">

</div>
<a id="more"></a>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">* the given fairness policy.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过ReentrantReadWriteLock的构造函数可知：</p>
<ol>
<li>支持公平/非公平模式</li>
<li>读写锁使用同一把锁（两个视图），及sync = lock.sync;</li>
</ol>
<h3 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h3><p>读写锁也是用state变量来表示锁状态的。只是state变量在这里的含义和互斥锁完全不同。在内部类Sync中，对state变量进行了重新定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Synchronization implementation for ReentrantReadWriteLock.</span></span><br><span class="line"><span class="comment">* Subclassed into fair and nonfair versions.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Read vs write count extraction constants and functions.</span></span><br><span class="line"><span class="comment">    * Lock state is logically divided into two unsigned shorts:</span></span><br><span class="line"><span class="comment">    * 锁状态被拆分成两种无符号状态，高位16和低16</span></span><br><span class="line"><span class="comment">    * The lower one representing the exclusive (writer) lock hold count,</span></span><br><span class="line"><span class="comment">    * and the upper the shared (reader) hold count.</span></span><br><span class="line"><span class="comment">    * 高位16：记录读锁，可以表示n个线程获取锁或一个线程重入n次</span></span><br><span class="line"><span class="comment">    * 低位16：记录写锁，一个线程重入n次（写锁互斥，所以只能一个线程独占）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">    <span class="comment">// 读锁重入次数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">    <span class="comment">// 写锁重入次数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之ScheduledThreadPoolExecutor</title>
    <url>/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BScheduledThreadPoolExecutor/</url>
    <content><![CDATA[<h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWith-FixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了RunnableScheduledFuture接口的ScheduledFutureTask。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay,</span><br><span class="line">                                   TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(delay, unit)));</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main execution method for delayed or periodic tasks.  If pool</span></span><br><span class="line"><span class="comment"> * is shut down, rejects the task. Otherwise adds task to queue</span></span><br><span class="line"><span class="comment"> * and starts a thread, if necessary, to run it.  (We cannot</span></span><br><span class="line"><span class="comment"> * prestart the thread to run the task because the task (probably)</span></span><br><span class="line"><span class="comment"> * shouldn&#x27;t be run yet.)  If the pool is shut down while the task</span></span><br><span class="line"><span class="comment"> * is being added, cancel and remove it if required by state and</span></span><br><span class="line"><span class="comment"> * run-after-shutdown parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</p>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BScheduledThreadPoolExecutor/1589104571948.png" class>

</div>

<p>ScheduledThreadPoolExecutor为了实现周期性的执行任务，对ThreadPoolExecutor做了如下的修改。<br>❑ 使用DelayQueue作为任务队列。<br>❑ 获取任务的方式不同（后文会说明）。<br>❑ 执行周期任务后，增加了额外的处理。</p>
<h3 id="任务执行过程"><a href="#任务执行过程" class="headerlink" title="任务执行过程"></a>任务执行过程</h3><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BScheduledThreadPoolExecutor/1589104596328.png" class>

</div>

<p>1）线程1从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue. take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。</p>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BScheduledThreadPoolExecutor/1589104627768.png" class>

</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head of this queue, waiting if necessary</span></span><br><span class="line"><span class="comment"> * until an element with an expired delay is available on this queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 1 获取lock锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            	<span class="comment">// 2.1：如果PriorityQueue为空，则当前Condition available等待</span></span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                	<span class="comment">// 2.3.1 返回PriorityQueue中的头元素</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	<span class="comment">// 2.2</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">        	<span class="comment">//2.3.2 唤醒Condition available等待的线程</span></span><br><span class="line">            available.signal();</span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）线程1执行这个ScheduledFutureTask。<br>3）线程1修改ScheduledFutureTask的time变量为下次将要被执行的时间。<br>4）线程1把这个修改time之后的ScheduledFutureTask放回DelayQueue中（Delay-Queue.add()）。</p>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BScheduledThreadPoolExecutor/1589104656087.png" class>

</div>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element into this delay queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e); <span class="comment">//2.1</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 2.2如果在上面2.1中添加的任务是PriorityQueue的头元素，唤醒在Condition中等待的所有线程。</span></span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorService1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">		scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;延迟三秒&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">		scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;延迟 1 秒后每三秒执行一次&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>Java线程池</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ScheduledThreadPoolExecutor</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之StampedLock</title>
    <url>/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BStampedLock/</url>
    <content><![CDATA[<p>读写锁的改进。</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>并发度</th>
</tr>
</thead>
<tbody><tr>
<td>ReentrantLock</td>
<td>读读互斥、读写互斥、写写互斥</td>
</tr>
<tr>
<td>ReentrantReadWriteLock</td>
<td>读读不互斥、读写互斥、写写互斥</td>
</tr>
<tr>
<td>StampedLock</td>
<td>读读不互斥、读写不互斥、写写互斥</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h2 id="乐观读的原理"><a href="#乐观读的原理" class="headerlink" title="乐观读的原理"></a>乐观读的原理</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>StampedLock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之Synchronized</title>
    <url>/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized/</url>
    <content><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>任意非NULL对象当作锁</li>
<li>独占式悲观锁</li>
<li>可重入锁<a id="more"></a>

</li>
</ol>
<h2 id="Synchronized-语义"><a href="#Synchronized-语义" class="headerlink" title="Synchronized 语义"></a>Synchronized 语义</h2><ol>
<li>同步语法，在JDK1.6之后增加了锁的优化，包括偏向锁、轻量锁、自旋</li>
<li>代码块语义：编译之后在进入同步代码之前写入<code>monitorenter</code>字节码指令，执行完成写入<code>monitorexit</code>指令（异常退出的时候也会写入该指令） </li>
<li>方法同步语义：<code>ACC_SYNCHRONIZED</code></li>
<li>锁对象：使用reference类型指明加锁和加锁的对象（自定义对象、this、当前class）</li>
<li>锁计数：通过锁的<strong>计数器</strong>来判断是否释放锁，在执行monitorenter指令时，首先要去尝试获取对象的锁，获取锁或当前拥有锁则计数器+1；执行monitorexit指令时会将锁计数器的值减一；一旦计数器的值为零，锁随即就被释放了</li>
<li>如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止</li>
<li>支持可重入，防止死锁</li>
<li>独占锁，不能强制已经获取锁的线程释放锁；不能强制正在等待锁的线程中断等待或超时退出</li>
<li>作用粒度：对象，用来实现临界资源的同步互斥访问</li>
</ol>
<h2 id="Synchronized-作用范围"><a href="#Synchronized-作用范围" class="headerlink" title="Synchronized 作用范围"></a>Synchronized 作用范围</h2><ol>
<li>普通同步方法：使用当前实例锁定</li>
<li>静态同步方法：锁是当前类的Class实例，Class数据存在永久代中，是该类的一个全局锁</li>
<li>同步代码块：使用代码块中定义的对象（this、自定义对象、class对象）</li>
</ol>
<h2 id="Synchronized-核心组件"><a href="#Synchronized-核心组件" class="headerlink" title="Synchronized 核心组件"></a>Synchronized 核心组件</h2><ol>
<li>Wait Set：调用 wait 方法被阻塞的线程被放置在这里； </li>
<li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中； </li>
<li>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中； </li>
<li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为 OnDeck； </li>
<li>Owner：当前已经获取到所资源的线程被称为 Owner； </li>
<li>!Owner：当前释放锁的线程。 </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;  <span class="comment">// markOop对象头</span></span><br><span class="line">    _count        = <span class="number">0</span>;     <span class="comment">// 重入次数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,     <span class="comment">// 等待线程数</span></span><br><span class="line">    _recursions   = <span class="number">0</span>;     <span class="comment">// 重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;  <span class="comment">// 指向获得ObjectMonitor对象的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;  <span class="comment">// 处于wait状态的线程，会被加入到waitset中</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ; <span class="comment">// JVM为每个尝试进入synchronized代码段的线程创建一个ObjectWaiter并添加到该队列</span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 处于等待block状态的线程，由ObjectWaiter组成的双向链表</span></span><br><span class="line">                           <span class="comment">// JVM会从该链表中获取一个ObjectWaiter并唤醒对应的JavaThread</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>; <span class="comment">// 监视器前一个拥有者的线程ID</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Synchronized-实现原理"><a href="#Synchronized-实现原理" class="headerlink" title="Synchronized 实现原理"></a>Synchronized 实现原理</h2><p>重量锁的实现依赖于对象中的警示器monitor，本质依赖于操作系统中的Mutex Lock；</p>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized/synchronized%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B.png" class title="synchronized锁的使用过程">

</div>

<ol>
<li>线程首先会进入ContentionList队列，JVM复制部分线程到EntryList，JVM从EntryList的尾部获取后选择线程（OnDeck）<ul>
<li>为了解决并发进程引入EntryList队列（候选者竞争队列） </li>
<li>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的(Linux 内核下采用 pthread_mutex_lock 内核函数实现的);</li>
</ul>
</li>
<li>当进入OnDeck中的线程获取锁之后：<ul>
<li>修改_owner为当前线程</li>
<li>修改markword（地址+状态10）</li>
<li>阻塞后续线程到ContentionList</li>
</ul>
</li>
<li>Owner释放锁或则阻塞：<ul>
<li>释放锁： 执行1（需要重新竞争锁、提高吞吐量，称为“竞争切换”）</li>
<li>阻塞（wait）：转移到WaitSet，并且释放锁，只有notify 或者 notifyAll 唤醒，会重新进去EntryList中 </li>
</ul>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/30 19:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(TestSynchronized.class)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="javap分析"><a href="#javap分析" class="headerlink" title="javap分析"></a>javap分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;C:\Program Files\Java\jdk1.8.0_152\bin\javap.exe&quot;</span> -v -c com.sunld.thread.lock.TestSynchronized</span><br><span class="line">Classfile /D:/workspace/learning/target/classes/com/sunld/thread/lock/TestSynchronized.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">5</span>-<span class="number">30</span>; size <span class="number">834</span> bytes</span><br><span class="line">  MD5 checksum 9806782e622d7e5e193f3d1b5b8cf61e</span><br><span class="line">  Compiled from <span class="string">&quot;TestSynchronized.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">thread</span>.<span class="title">lock</span>.<span class="title">TestSynchronized</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #3.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #26            // com/sunld/thread/lock/TestSynchronized</span><br><span class="line">   #3 = Class              #27            // java/lang/Object</span><br><span class="line">   #4 = Utf8               &lt;init&gt;</span><br><span class="line">   #5 = Utf8               ()V</span><br><span class="line">   #6 = Utf8               Code</span><br><span class="line">   #7 = Utf8               LineNumberTable</span><br><span class="line">   #8 = Utf8               LocalVariableTable</span><br><span class="line">   #9 = Utf8               this</span><br><span class="line">  #10 = Utf8               Lcom/sunld/thread/lock/TestSynchronized;</span><br><span class="line">  #11 = Utf8               test1</span><br><span class="line">  #12 = Utf8               test2</span><br><span class="line">  #13 = Utf8               test3</span><br><span class="line">  #14 = Utf8               StackMapTable</span><br><span class="line">  #15 = Class              #26            // com/sunld/thread/lock/TestSynchronized</span><br><span class="line">  #16 = Class              #27            // java/lang/Object</span><br><span class="line">  #17 = Class              #28            // java/lang/Throwable</span><br><span class="line">  #18 = Utf8               test4</span><br><span class="line">  #19 = Utf8               main</span><br><span class="line">  #20 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               args</span><br><span class="line">  #22 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #23 = Utf8               SourceFile</span><br><span class="line">  #24 = Utf8               TestSynchronized.java</span><br><span class="line">  #25 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #26 = Utf8               com/sunld/thread/lock/TestSynchronized</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/Throwable</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.sunld.thread.lock.TestSynchronized();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/thread/lock/TestSynchronized;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/thread/lock/TestSynchronized;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter</span><br><span class="line">         <span class="number">4</span>: aload_1</span><br><span class="line">         <span class="number">5</span>: monitorexit</span><br><span class="line">         <span class="number">6</span>: goto          <span class="number">14</span></span><br><span class="line">         <span class="number">9</span>: astore_2</span><br><span class="line">        <span class="number">10</span>: aload_1</span><br><span class="line">        <span class="number">11</span>: monitorexit</span><br><span class="line">        <span class="number">12</span>: aload_2</span><br><span class="line">        <span class="number">13</span>: athrow</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">4</span>     <span class="number">6</span>     <span class="number">9</span>   any</span><br><span class="line">             <span class="number">9</span>    <span class="number">12</span>     <span class="number">9</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">14</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">15</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/thread/lock/TestSynchronized;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">9</span></span><br><span class="line">          locals = [ class com/sunld/thread/lock/TestSynchronized, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: ldc           #2                  // class com/sunld/thread/lock/TestSynchronized</span><br><span class="line">         <span class="number">2</span>: dup</span><br><span class="line">         <span class="number">3</span>: astore_0</span><br><span class="line">         <span class="number">4</span>: monitorenter</span><br><span class="line">         <span class="number">5</span>: aload_0</span><br><span class="line">         <span class="number">6</span>: monitorexit</span><br><span class="line">         <span class="number">7</span>: goto          <span class="number">15</span></span><br><span class="line">        <span class="number">10</span>: astore_1</span><br><span class="line">        <span class="number">11</span>: aload_0</span><br><span class="line">        <span class="number">12</span>: monitorexit</span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="number">14</span>: athrow</span><br><span class="line">        <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">5</span>     <span class="number">7</span>    <span class="number">10</span>   any</span><br><span class="line">            <span class="number">10</span>    <span class="number">13</span>    <span class="number">10</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">26</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">29</span>: <span class="number">15</span></span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">10</span></span><br><span class="line">          locals = [ class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">33</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestSynchronized.java&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/zqz_zqz/article/details/70233767">java 中的锁 – 偏向锁、轻量级锁、自旋锁、重量级锁</a></li>
<li><a href="book/java-thread-lock.md">Java中的锁</a></li>
<li><a href="https://www.toutiao.com/i6918719190144647687">一个synchronized跟面试官扯了半个小时</a></li>
<li><a href="https://www.cnblogs.com/wuzhenzhao/p/10250801.html">synchronized原理</a></li>
<li><a href="https://www.jianshu.com/p/e62fa839aa41">啃碎并发（七）：深入分析Synchronized原理</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之守护线程</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>java中线程的分类：用户线程 (User Thread)、守护线程 (Daemon Thread)。  </p>
<ol>
<li><p><strong>守护线程</strong>：在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。  </p>
</li>
<li><p><strong>区别</strong>：用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p>
</li>
</ol>
<h2 id="Java中的定义"><a href="#Java中的定义" class="headerlink" title="Java中的定义"></a>Java中的定义</h2><p>通过Thread中的setDaemon方法完成设置。通过源码分析得知：<strong>当线程只剩下守护线程的时候，JVM就会退出.但是如果还有其他的任意一个用户线程还在，JVM就不会退出</strong></p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Marks this thread as either a &#123;<span class="doctag">@linkplain</span> #isDaemon daemon&#125; thread</span></span><br><span class="line"><span class="comment">* or a user thread. The Java Virtual Machine exits when the only</span></span><br><span class="line"><span class="comment">* threads running are all daemon threads.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; This method must be invoked before the thread is started.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  on</span></span><br><span class="line"><span class="comment">*         if &#123;<span class="doctag">@code</span> true&#125;, marks this thread as a daemon thread</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  IllegalThreadStateException</span></span><br><span class="line"><span class="comment">*          if this thread is &#123;<span class="doctag">@linkplain</span> #isAlive alive&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">*          if &#123;<span class="doctag">@link</span> #checkAccess&#125; determines that the current</span></span><br><span class="line"><span class="comment">*          thread cannot modify this thread</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    daemon = on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: MyDaemon.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.sunld</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description:&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunld</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0.0 </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;CreateDate:2017年10月9日 下午4:09:31&lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDaemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread daemonThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyDaemon());</span><br><span class="line">		<span class="comment">// 设置为守护进程</span></span><br><span class="line">        daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        daemonThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;isDaemon = &quot;</span> + daemonThread.isDaemon());</span><br><span class="line">        <span class="comment">//sleep完成之后,main线程结束，JVM退出!</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//AddShutdownHook方法增加JVM停止时要做处理事件：</span></span><br><span class="line">        <span class="comment">//当JVM退出时，打印JVM Exit语句.</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        	<span class="meta">@Override</span></span><br><span class="line">        	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        		System.out.println(<span class="string">&quot;JVM Exit!&quot;</span>);</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">			System.out.println(i+<span class="string">&quot;=====MyDaemon=======&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。</li>
<li>在Daemon线程中产生的新线程也是Daemon的。</li>
<li>守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</li>
<li>Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行,所以不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑</li>
</ol>
<h2 id="JAVA-后台线程总结"><a href="#JAVA-后台线程总结" class="headerlink" title="JAVA 后台线程总结"></a>JAVA 后台线程总结</h2><ol>
<li>   定义：“服务线程”，一种后台线程，它有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。 </li>
<li>   优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。 </li>
<li>   设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。 </li>
<li>   在 Daemon 线程中产生的新线程也是 Daemon 的。 </li>
<li>   线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。 </li>
<li>   example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread, 程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 </li>
<li>   生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。 </li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
<li><a href="https://www.cnblogs.com/wxd0108/p/5479442.html">Java中的多线程你只要看这一篇就够了</a></li>
<li><a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin">线程</a></li>
<li><a href="https://www.cnblogs.com/lwbqqyumidi/p/3804883.html">Java总结篇系列：Java多线程（一）</a></li>
<li>《java并发编程实战》</li>
<li><a href="https://blog.csdn.net/hanhaiyinheguxing/article/details/51366541">多线程01：《疯狂Java讲义》学习笔记——线程概述</a></li>
<li><a href="https://blog.csdn.net/hla199106/article/details/47840505">java并发编程—如何创建线程以及Thread类的使用</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920357.html">Java并发编程：Thread类的使用</a></li>
<li><a href="https://www.cnblogs.com/loveer/p/11518402.html">Java中断机制</a></li>
<li><a href="https://www.cnblogs.com/hapjin/p/5450779.html">JAVA多线程之中断机制(如何处理中断？)</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>守护线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之应用-设备升级</title>
    <url>/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%BA%94%E7%94%A8-%E8%AE%BE%E5%A4%87%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>功能需求：设备策略升级  </p>
<p>详细描述：用户可以不定期的创建1条策略来升级选择的多个设备从a版本到b版本  </p>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%BA%94%E7%94%A8-%E8%AE%BE%E5%A4%87%E5%8D%87%E7%BA%A7/1588229421629.png" class>

</div>
<a id="more"></a>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%BA%94%E7%94%A8-%E8%AE%BE%E5%A4%87%E5%8D%87%E7%BA%A7/1588229450427.png" class>

</div>

<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h3 id="创建个无界带自动回收机制的线程池"><a href="#创建个无界带自动回收机制的线程池" class="headerlink" title="创建个无界带自动回收机制的线程池"></a>创建个无界带自动回收机制的线程池</h3><p><code>ExecutorService threadPool = Executors.newCachedThreadPool();</code></p>
<h3 id="创建策略"><a href="#创建策略" class="headerlink" title="创建策略"></a>创建策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把每条策略要升级设备放入队列中</span></span><br><span class="line">LinkedBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=startNum;j&lt;endNum;j++)&#123;</span><br><span class="line">    queue.offer(dev[j]);</span><br><span class="line">&#125;</span><br><span class="line">StratageConsumer consumer=<span class="keyword">new</span> StratageConsumer(queue);</span><br></pre></td></tr></table></figure>
<h3 id="每次创建策略后加入线程池"><a href="#每次创建策略后加入线程池" class="headerlink" title="每次创建策略后加入线程池"></a>每次创建策略后加入线程池</h3><p><code>threadPool.execute(consumer);</code></p>
<h3 id="启动策略"><a href="#启动策略" class="headerlink" title="启动策略"></a>启动策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Integer data=<span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">while</span>(Thread.currentThread().isInterrupted()==<span class="keyword">false</span> &amp;&amp; isRunning) &#123;  </span><br><span class="line">        <span class="comment">//System.out.println(&quot;运行线程数&quot;+Thread.getAllStackTraces().size());  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//因为BlockingQueue是线程安全的，所以不用考虑同步问题  </span></span><br><span class="line">            data = queue.take();  </span><br><span class="line">            <span class="comment">//升级处理  </span></span><br><span class="line">            <span class="keyword">if</span>(data!=<span class="keyword">null</span>) &#123;  </span><br><span class="line">                iCrawcomplete.update(data);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(queue.isEmpty())&#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    Thread.sleep(<span class="number">360</span>*<span class="number">1000</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  &#125;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                isRunning = <span class="keyword">false</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            Thread.sleep(<span class="number">60</span>*<span class="number">1000</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            logger.info(<span class="string">&quot;抓取&quot;</span>+url+data+<span class="string">&quot;出现异常&quot;</span>+e.getStackTrace());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>Java线程池</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之知识图谱</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/1588238047655.png" class title="并发编程知识图谱">

</div>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之线程中断</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h2 id="正常结束-执行完成"><a href="#正常结束-执行完成" class="headerlink" title="正常结束(执行完成)"></a>正常结束(执行完成)</h2><h2 id="使用退出标志退出线程"><a href="#使用退出标志退出线程" class="headerlink" title="使用退出标志退出线程"></a>使用退出标志退出线程</h2><p>一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是<strong>伺服线程</strong>。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false 来控制while 循环是否退出，代码示例：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!exit)&#123;</span><br><span class="line">			<span class="comment">//do something</span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个退出标志 exit，当 exit 为 true 时，while 循环退出，exit 的默认值为 false.在定义 exit 时，<strong>使用了一个 Java 关键字 volatile，这个关键字的目的是使 exit 同步</strong>，也就是说在同一时刻只能由一个线程来修改 exit 的值。</p>
<h2 id="interrupt方法结束线程"><a href="#interrupt方法结束线程" class="headerlink" title="interrupt方法结束线程"></a>interrupt方法结束线程</h2><h3 id="Thread中断方法说明"><a href="#Thread中断方法说明" class="headerlink" title="Thread中断方法说明"></a>Thread中断方法说明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 测试当前线程是否被中断</span></span><br><span class="line"><span class="comment">* 2. 执行该方法之后会清除当前线程的中断状态。</span></span><br><span class="line"><span class="comment">* 3. 如果中断一个已经不活跃的线程，则返回false</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span></span><br><span class="line"><span class="comment">*          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #isInterrupted()</span></span><br><span class="line"><span class="comment">* <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 测试线程是否被中断，该方法不会清除中断状态</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 2. 如果中断一个已经不活跃的线程，则返回false</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span></span><br><span class="line"><span class="comment">*          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>     #interrupted()</span></span><br><span class="line"><span class="comment">* <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment">* is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment">* passed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Interrupts this thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; Unless the current thread is interrupting itself, which is</span></span><br><span class="line"><span class="comment">* always permitted, the &#123;<span class="doctag">@link</span> #checkAccess() checkAccess&#125; method</span></span><br><span class="line"><span class="comment">* of this thread is invoked, which may cause a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* SecurityException&#125; to be thrown.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; If this thread is blocked in an invocation of the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* Object#wait() wait()&#125;, &#123;<span class="doctag">@link</span> Object#wait(long) wait(long)&#125;, or &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* Object#wait(long, int) wait(long, int)&#125; methods of the &#123;<span class="doctag">@link</span> Object&#125;</span></span><br><span class="line"><span class="comment">* class, or of the &#123;<span class="doctag">@link</span> #join()&#125;, &#123;<span class="doctag">@link</span> #join(long)&#125;, &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #join(long, int)&#125;, &#123;<span class="doctag">@link</span> #sleep(long)&#125;, or &#123;<span class="doctag">@link</span> #sleep(long, int)&#125;,</span></span><br><span class="line"><span class="comment">* methods of this class, then its interrupt status will be cleared and it</span></span><br><span class="line"><span class="comment">* will receive an &#123;<span class="doctag">@link</span> InterruptedException&#125;.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span></span><br><span class="line"><span class="comment">* then the channel will be closed, the thread&#x27;s interrupt</span></span><br><span class="line"><span class="comment">* status will be set, and the thread will receive a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* java.nio.channels.ClosedByInterruptException&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; If this thread is blocked in a &#123;<span class="doctag">@link</span> java.nio.channels.Selector&#125;</span></span><br><span class="line"><span class="comment">* then the thread&#x27;s interrupt status will be set and it will return</span></span><br><span class="line"><span class="comment">* immediately from the selection operation, possibly with a non-zero</span></span><br><span class="line"><span class="comment">* value, just as if the selector&#x27;s &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt</span></span><br><span class="line"><span class="comment">* status will be set. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">*          if the current thread cannot modify this thread</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类库中的中断"><a href="#类库中的中断" class="headerlink" title="类库中的中断"></a>类库中的中断</h3><ol>
<li>FutureTask中的cancel方法，如果传入的参数为true，它将会在正在运行异步任务的线程上调用interrupt方法，如果正在执行的异步任务中的代码没有对中断做出响应，那么cancel方法中的参数将不会起到什么效果；</li>
<li>ThreadPoolExecutor中的shutdownNow方法会遍历线程池中的工作线程并调用线程的interrupt方法来中断线程，如果工作线程中正在执行的任务没有对中断做出响应，任务将一直执行直到正常结束。</li>
</ol>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><ol>
<li>interrupt()方法仅仅是在当前线程中打了一个停止的标识将中断标志修改为true，并没有真正的停止线程：如果在此基础上进入堵塞状态（sleep(),wait(),join()）,马上就会抛出一个InterruptedException，且中断标志被清除，重新设置为false，线程退出。</li>
<li>如果遇到的是可中断的阻塞方法抛出InterruptedException：可以继续向上层抛出该异常。若有时候不太方便在方法上抛出InterruptedException，比如要实现的某个接口中的方法签名上没有throws InterruptedException，这时就可以捕获可中断方法的InterruptedException并且恢复异常（重新设置中断）。</li>
<li>阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。</li>
<li>线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</li>
</ol>
<h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><p>有些程序可能一检测到中断就立马将线程终止，有些可能是退出当前执行的任务，继续执行下一个任务……作为一种协作机制，这要与中断方协商好，当调用interrupt会发生些什么都是事先知道的，如做一些事务回滚操作，一些清理工作，一些补偿操作等。若不确定调用某个线程的interrupt后该线程会做出什么样的响应，那就不应当中断该线程。</p>
<p><strong>程序应该对线程中断作出恰当的响应。只有正确响应中断才能更好的结束线程。</strong></p>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/1587984426042.png" class title="中断响应">

</div>

<h3 id="中断示例"><a href="#中断示例" class="headerlink" title="中断示例"></a>中断示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/6/6 20:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123; <span class="comment">// 非阻塞过程中通过判断中断标志来退出</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);<span class="comment">// 阻塞过程捕获中断异常来退出</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 捕获到异常之后，执行 break 跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="stop-方法终止线程（线程不安全）"><a href="#stop-方法终止线程（线程不安全）" class="headerlink" title="stop 方法终止线程（线程不安全）"></a>stop 方法终止线程（线程不安全）</h2><ol>
<li>stop、destroy方法已经被Java废弃</li>
<li>原理：强制杀死线程</li>
<li>不安全原因：thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。导致数据不一致等不可控情况</li>
</ol>
<h2 id="中断的使用场景"><a href="#中断的使用场景" class="headerlink" title="中断的使用场景"></a>中断的使用场景</h2><ol>
<li>点击某个桌面应用中的取消按钮时；</li>
<li>某个操作超过了一定的执行时间限制需要中止时；</li>
<li>多个线程做相同的事情，只要一个线程成功其它线程都可以取消时；</li>
<li>一组线程中的一个或多个出现错误导致整组都无法继续时；</li>
<li>当一个应用或服务需要停止时。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
<li><a href="https://www.cnblogs.com/wxd0108/p/5479442.html">Java中的多线程你只要看这一篇就够了</a></li>
<li><a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin">线程</a></li>
<li><a href="https://www.cnblogs.com/lwbqqyumidi/p/3804883.html">Java总结篇系列：Java多线程（一）</a></li>
<li>《java并发编程实战》</li>
<li><a href="https://blog.csdn.net/hanhaiyinheguxing/article/details/51366541">多线程01：《疯狂Java讲义》学习笔记——线程概述</a></li>
<li><a href="https://blog.csdn.net/hla199106/article/details/47840505">java并发编程—如何创建线程以及Thread类的使用</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920357.html">Java并发编程：Thread类的使用</a></li>
<li><a href="https://www.cnblogs.com/loveer/p/11518402.html">Java中断机制</a></li>
<li><a href="https://www.cnblogs.com/hapjin/p/5450779.html">JAVA多线程之中断机制(如何处理中断？)</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程中断</tag>
        <tag>Interrupt</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之线程优先级</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。优先级高的线程分配时间片的数量要多于优先级低的线程。</p>
<a id="more"></a>

<h2 id="Java中的设置方式setPriority-int"><a href="#Java中的设置方式setPriority-int" class="headerlink" title="Java中的设置方式setPriority(int)"></a>Java中的设置方式setPriority(int)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 属性定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>            priority;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Changes the priority of this thread.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called</span></span><br><span class="line"><span class="comment">* with no arguments. This may result in throwing a</span></span><br><span class="line"><span class="comment">* &lt;code&gt;SecurityException&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* Otherwise, the priority of this thread is set to the smaller of</span></span><br><span class="line"><span class="comment">* the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted</span></span><br><span class="line"><span class="comment">* priority of the thread&#x27;s thread group.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> newPriority priority to set this thread to</span></span><br><span class="line"><span class="comment">* <span class="doctag">@exception</span>  IllegalArgumentException  If the priority is not in the</span></span><br><span class="line"><span class="comment">*               range &lt;code&gt;MIN_PRIORITY&lt;/code&gt; to</span></span><br><span class="line"><span class="comment">*               &lt;code&gt;MAX_PRIORITY&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@exception</span>  SecurityException  if the current thread cannot modify</span></span><br><span class="line"><span class="comment">*               this thread.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>        #getPriority</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>        #checkAccess()</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>        #getThreadGroup()</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>        #MAX_PRIORITY</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>        #MIN_PRIORITY</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>        ThreadGroup#getMaxPriority()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例（java并发编程艺术）"><a href="#示例（java并发编程艺术）" class="headerlink" title="示例（java并发编程艺术）"></a>示例（java并发编程艺术）</h2><p>设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: Priority.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.sunld</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description:&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunld</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0.0 </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;CreateDate:2017年10月9日 下午2:26:33&lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priority</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notStart = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notEnd = <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		List&lt;Job&gt; jobs = <span class="keyword">new</span> ArrayList&lt;Job&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> priority = i &lt; <span class="number">5</span> ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;</span><br><span class="line">			Job job = <span class="keyword">new</span> Job(priority);</span><br><span class="line">			jobs.add(job);</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread(job, <span class="string">&quot;Thread:&quot;</span> + i);</span><br><span class="line">			thread.setPriority(priority);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">		notStart = <span class="keyword">false</span>;</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">		notEnd = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (Job job : jobs) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Job Priority : &quot;</span> + job.priority + <span class="string">&quot;,&quot;</span></span><br><span class="line">					+ <span class="string">&quot;Count : &quot;</span> + job.jobCount);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">long</span> jobCount;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.priority = priority;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(notStart) &#123;</span><br><span class="line">				Thread.yield();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(notEnd) &#123;</span><br><span class="line">				Thread.yield();</span><br><span class="line">				jobCount++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Job Priority : <span class="number">1</span>,Count : <span class="number">1034791</span></span><br><span class="line">Job Priority : <span class="number">1</span>,Count : <span class="number">1034727</span></span><br><span class="line">Job Priority : <span class="number">1</span>,Count : <span class="number">1033945</span></span><br><span class="line">Job Priority : <span class="number">1</span>,Count : <span class="number">1034445</span></span><br><span class="line">Job Priority : <span class="number">1</span>,Count : <span class="number">1034565</span></span><br><span class="line">Job Priority : <span class="number">10</span>,Count : <span class="number">4388204</span></span><br><span class="line">Job Priority : <span class="number">10</span>,Count : <span class="number">4374055</span></span><br><span class="line">Job Priority : <span class="number">10</span>,Count : <span class="number">4375073</span></span><br><span class="line">Job Priority : <span class="number">10</span>,Count : <span class="number">4350174</span></span><br><span class="line">Job Priority : <span class="number">10</span>,Count : <span class="number">4393224</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：</p>
<blockquote>
<p>测试环境是win10+JDK1.8，级别越高执行的次数越多。但是<strong>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定。</strong></p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程优先级</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之线程池概述</title>
    <url>/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>使用线程池可以有以下优点：  </p>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。<a id="more"></a>

</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：<strong>线程复用；控制最大并发数；管理线程</strong>。</p>
<h3 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h3><p>每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写 Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。</p>
<h2 id="线程池使用注意事项"><a href="#线程池使用注意事项" class="headerlink" title="线程池使用注意事项"></a>线程池使用注意事项</h2><h3 id="配置合理线程池的参考项"><a href="#配置合理线程池的参考项" class="headerlink" title="配置合理线程池的参考项"></a>配置合理线程池的参考项</h3><ol>
<li>❑ 任务的性质：CPU密集型任务、IO密集型任务和混合型任务。<ol>
<li>CPU密集型任务：配置可能小的线程，如配置Ncpu+1个线程的线程池。</li>
<li>IO密集型任务：配置尽可能多的线程，如2*Ncpu。</li>
</ol>
</li>
<li>❑ 任务的优先级：高、中和低。<ol>
<li>使用优先级队列：<code>PriorityBlockingQueue</code></li>
</ol>
</li>
<li>❑ 任务的执行时间：长、中和短。<ol>
<li>使用不同规模的线程池处理</li>
<li>或者使用优先级队列</li>
</ol>
</li>
<li>❑ 任务的依赖性：是否依赖其他系统资源，如数据库连接。<ol>
<li>线程数配置尽量大，充分利用CPU</li>
</ol>
</li>
</ol>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><ol>
<li>避免是有无限队列</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
<li>《Java并发编程》</li>
<li>《Java多线程编程核心技术》</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>Java线程池</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之线程状态</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="操作系统中的状态"><a href="#操作系统中的状态" class="headerlink" title="操作系统中的状态"></a>操作系统中的状态</h2><div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1590649906474.png" class title="操作系统中的状态">

</div>

<ol>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】<ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态<a id="more"></a>

</li>
</ol>
<h2 id="Java中的线程状态"><a href="#Java中的线程状态" class="headerlink" title="Java中的线程状态"></a>Java中的线程状态</h2><h3 id="源码定义"><a href="#源码定义" class="headerlink" title="源码定义"></a>源码定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A thread state.  A thread can be in one of the following states:</span></span><br><span class="line"><span class="comment">* &lt;ul&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #NEW&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread that has not yet started is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #RUNNABLE&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread executing in the Java virtual machine is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #BLOCKED&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread that is blocked waiting for a monitor lock</span></span><br><span class="line"><span class="comment">*     is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #WAITING&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread that is waiting indefinitely for another thread to</span></span><br><span class="line"><span class="comment">*     perform a particular action is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #TIMED_WAITING&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread that is waiting for another thread to perform an action</span></span><br><span class="line"><span class="comment">*     for up to a specified waiting time is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #TERMINATED&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">*     A thread that has exited is in this state.</span></span><br><span class="line"><span class="comment">*     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* A thread can be in only one state at a given point in time.</span></span><br><span class="line"><span class="comment">* These states are virtual machine states which do not reflect</span></span><br><span class="line"><span class="comment">* any operating system thread states.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span>   1.5</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #getState</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">    * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">    * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">    * such as processor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">    * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">    * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">    * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">    * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">    * following methods:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">    * perform a particular action.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">    * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">    * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">    * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">    * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">    * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">    * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">    * The thread has completed execution.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1587977737466.png" class title="状态转换">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1587983275233.png" class title="状态转换">


</div>

<ol>
<li>NEW –&gt; RUNNABLE<ul>
<li>当调用 t.start() 方法时，由 NEW –&gt; RUNNABLE</li>
</ul>
</li>
<li>RUNNABLE &lt;–&gt; WAITING<ul>
<li>wait方式（需要synchronized(obj)获取锁）<ul>
<li>释放（obj.notify() ， obj.notifyAll() ， t.interrupt()）<ul>
<li> 竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li>
<li> 竞争锁失败，t 线程从 WAITING –&gt; BLOCKED  </li>
</ul>
</li>
</ul>
</li>
<li>join方式（当前线程在t 线程对象的监视器上等待）<ul>
<li> 释放：运行结束或调用当前线程的interrupt方法：WAITING –&gt; RUNNABLE</li>
</ul>
</li>
<li>LockSupport.park方式<ul>
<li> 调用unpark(目标线程)或interrupt方法：WAITING –&gt; RUNNABLE</li>
</ul>
</li>
</ul>
</li>
<li>RUNNABLE &lt;–&gt; TIMED_WAITING<ul>
<li>wait(时间)方式（需要synchronized(obj)获取锁）<ul>
<li>释放（obj.notify() ， obj.notifyAll() ， t.interrupt()、或超时）<ul>
<li> 竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li>
<li> 竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED  </li>
</ul>
</li>
</ul>
</li>
<li>join(时间)方式（当前线程在t 线程对象的监视器上等待）<ul>
<li> 释放：运行结束或调用当前线程的interrupt方法、或超时：TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
</li>
<li>LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis)方式<ul>
<li> 调用unpark(目标线程)或interrupt方法、或超时：TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
</li>
<li>sleep（时间）<ul>
<li> 当前线程超时： TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
</li>
</ul>
</li>
<li>RUNNABLE &lt;–&gt; BLOCKED<ul>
<li> t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li>
<li> 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li>
</ul>
</li>
<li>RUNNABLE &lt;–&gt; TERMINATED<ul>
<li> 当前线程所有代码运行完毕，进入 TERMINATED</li>
</ul>
</li>
</ol>
<h3 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h3><h4 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h4><ol>
<li>创建并启动线程后，不会立即进入就绪状态（<strong>需要经过经过新建(New)、就绪（Runnable）、运行（Running）、阻塞 (Blocked)和死亡(Dead)5 种状态。</strong>），而且线程的运行需要一些条件（比如内存资源，程序计数器、Java栈、本地方法栈都是线程私有的，所以需要为线程分配一定的内存空间），只有线程运行需要的所有条件满足了，才进入就绪状态。</li>
<li>当线程进入就绪状态后，不代表立刻就能获取CPU执行时间，也许此时CPU正在执行其他的事情，因此它要等待。当得到CPU执行时间之后，线程便真正进入运行状态。</li>
<li>线程在运行状态过程中，可能有多个原因导致当前线程不继续运行下去，比如用户主动让线程睡眠（睡眠一定的时间之后再重新执行）、用户主动让线程等待，或者被同步块给阻塞，此时就对应着多个状态：time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、blocked（阻塞）。</li>
<li>当由于突然中断或者子任务执行完毕，线程就会被消亡。</li>
</ol>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-sjuo{background-color:#C2FFD6;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0lax">状态名称</th>
    <th class="tg-0lax">说明</th>
  </tr>
  <tr>
    <td class="tg-sjuo">NEW</td>
    <td class="tg-sjuo">
        初始状态，线程在被构建时的状态，如果Thread t = new MyThread();还没有调用start方法<br>
        此时仅由 JVM 为其分配内存，并初始化其成员变量的值<br>
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">RUNNABLE</td>
    <td class="tg-0lax">
        运行状态，java线程将操作系统中的就绪状态和运行状态笼统地称为“运行中”。<br>
        <font color="red">ready</font>：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；此时Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行<br>
        <font color="red">running</font>：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态（开始执行run方法）。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；<br>
    </td>
  </tr>
  <tr>
    <td class="tg-sjuo">BLOCKED</td>
    <td class="tg-sjuo">
        阻塞状态，表示线程阻塞于锁，释放出cpu使用权，让出了cpu timeslice，暂时停止运行<br>
        此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。<br>
        根据阻塞产生的原因不同，阻塞状态又可以分为三种：<br>
        1.等待阻塞（o.wait->等待对列）：运行状态中的线程执行wait()方法，JVM 会把该线程放入等待队列(waitting queue) 中，使本线程进入到等待阻塞状态；<br>
        2.同步阻塞(lock->锁池) ：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用（获取synchronized同步锁失败），则 JVM 会把该线程放入锁池(lock pool)中，进入同步阻塞状态；<br>
        3.其他阻塞(sleep/join)： 运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时， JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行(runnable)状态。<br>
    </td>
  </tr>
  
  <tr>
    <td class="tg-0lax">WAITING</td>
    <td class="tg-0lax">等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定的动作（通知或中断）</td>
  </tr>
  <tr>
    <td class="tg-sjuo">TIMED_WAITING</td>
    <td class="tg-sjuo">超时等待状态，改状态不同于waiting，它是可以在指定时间内自动返回的</td>
  </tr>
  <tr>
    <td class="tg-0lax">TERMINATED</td>
    <td class="tg-0lax">线程执行完了或者因异常退出了run()方法，该线程结束生命周期</td>
  </tr>
</table>

<h4 id="Java多线程的就绪、运行和死亡状态（DEAD）"><a href="#Java多线程的就绪、运行和死亡状态（DEAD）" class="headerlink" title="Java多线程的就绪、运行和死亡状态（DEAD）"></a>Java多线程的就绪、运行和死亡状态（DEAD）</h4><ol>
<li>就绪状态转换为运行状态：当此线程得到处理器资源；</li>
<li>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</li>
<li>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。<ol>
<li>正常结束 ：run()或 call()方法执行完成，线程正常结束。</li>
<li>异常结束：线程抛出一个未捕获的 Exception 或 Error。</li>
<li>调用stop：直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用</li>
</ol>
</li>
</ol>
<blockquote>
<p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。<br>由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕（<strong>不在执行run方法</strong>）。</p>
</blockquote>
<h2 id="状态分析-jvisualvm"><a href="#状态分析-jvisualvm" class="headerlink" title="状态分析-jvisualvm"></a>状态分析-jvisualvm</h2><h3 id="参考代码（java并发编程艺术）"><a href="#参考代码（java并发编程艺术）" class="headerlink" title="参考代码（java并发编程艺术）"></a>参考代码（java并发编程艺术）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: TestThreadState.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.sunld</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description:&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunld</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0.0 </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;CreateDate:2017年9月28日 下午5:14:27&lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadState</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting (), <span class="string">&quot;TimeWaitingThread&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">&quot;WaitingThread&quot;</span>).start();</span><br><span class="line">		<span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">&quot;BlockedThread-1&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">&quot;BlockedThread-2&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该线程不断地进行睡眠</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该线程在Waiting.class实例上等待</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (Waiting.class) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Waiting.class.wait();</span><br><span class="line">					&#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该线程在Blocked.class实例上加锁后，不会释放该锁</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Blocked.class) &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dump信息"><a href="#dump信息" class="headerlink" title="dump信息"></a>dump信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span>-09-<span class="number">28</span> <span class="number">17</span>:<span class="number">26</span>:<span class="number">47</span></span><br><span class="line"><span class="function">Full thread dump Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(<span class="number">25.112</span>-b15 mixed mode)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">//BlockedThread-2线程获取到了Blocked.class的锁</span></span></span><br><span class="line"><span class="function">&quot;BlockedThread-2&quot; #13 prio</span>=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x000000001f268000</span> nid=<span class="number">0x3754</span> waiting on condition [<span class="number">0x000000002009f000</span>]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line"><span class="comment">//BlockedThread-1线程阻塞在获取Blocked.class示例的锁上</span></span><br><span class="line">&quot;BlockedThread-1&quot; #12 prio=5 os_prio=0 tid=0x000000001f266800 nid=0x89c waiting for monitor entry [0x000000001ff9f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"><span class="comment">//WaitingThread线程在Waiting实例上等待</span></span><br><span class="line">&quot;WaitingThread&quot; #11 prio=5 os_prio=0 tid=0x000000001f260800 nid=0x4d08 in Object.wait() [0x000000001fe9f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line"><span class="comment">//TimeWaitingThread线程处于超时等待</span></span><br><span class="line">&quot;TimeWaitingThread&quot; #10 prio=5 os_prio=0 tid=0x000000001f25f000 nid=0x42ac waiting on condition [0x000000001fd9e000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
<li><a href="https://www.cnblogs.com/wxd0108/p/5479442.html">Java中的多线程你只要看这一篇就够了</a></li>
<li><a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin">线程</a></li>
<li><a href="https://www.cnblogs.com/lwbqqyumidi/p/3804883.html">Java总结篇系列：Java多线程（一）</a></li>
<li>《java并发编程实战》</li>
<li><a href="https://blog.csdn.net/hanhaiyinheguxing/article/details/51366541">多线程01：《疯狂Java讲义》学习笔记——线程概述</a></li>
<li><a href="https://blog.csdn.net/hla199106/article/details/47840505">java并发编程—如何创建线程以及Thread类的使用</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920357.html">Java并发编程：Thread类的使用</a></li>
<li><a href="https://www.cnblogs.com/loveer/p/11518402.html">Java中断机制</a></li>
<li><a href="https://www.cnblogs.com/hapjin/p/5450779.html">JAVA多线程之中断机制(如何处理中断？)</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程状态</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之线程的概念</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ol>
<li>用来加载指令、管理内存、管理IO、磁盘读写</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为程序的一个实例比如java.exe</li>
</ol>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ol>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li>
<li>在一个进程里可以创建多个线程，一个标准的线程包括<strong>线程ID，当前指令指针(PC），寄存器集合和堆栈组成</strong>，堆中的内容可共享。处理器在这些线程上高速切换（涉及到上下文切换），让使用者感觉到这些线程在同时执行。<strong>如果没有明确的协同机制</strong>，线程将彼此独立执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。  </li>
<li>线程是进程的一个实体（一个进程包含多个进程），是被系统独立调度和分配的最小单元，，也叫轻量级线程（Light Weight Process），并且线程拥有独立的资源包括：栈、线程ID、寄存器和指令指针，其他堆中的资源在内存中共享。共享资源在并发编程中需要增加同步机制防止资源数据处理不对。  </li>
<li>一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有<strong>就绪、阻塞和运行</strong>三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。  </li>
<li>线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。<a id="more"></a>

</li>
</ol>
<h5 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h5><p>在java中，一个应用程序对应者一个jvm实例（jvm进程），一般来说名字默认为java.exe或者javaw.exe。java采用的是<strong>单线程编程模型</strong>，即在我们自己的程序中如果没有主动创建线程，则只会创建一个主线程。但是需要注意，虽然只是一个线程执行任务，不代表jvm中只有一个线程，jvm在创建实例的过程中，同时会创建很多线程，具体参考如下说明：  </p>
<p>一个Java程序的入口是main方法，通过调用main方法开始执行，然后按照代码逻辑执行，看似没有其他线程参与，其实java程序天生就是多线程程序，执行一个main方法其实就是一个名为mian的线程和其他线程分别执行，参考代码如下（来源于java并发编程艺术）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description:&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0.0</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;CreateDate:2017年9月28日 下午3:54:19&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMXBeanTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Java线程管理MXBean</span></span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="comment">// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 遍历线程信息，仅打印线程ID和线程名称信息</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="string">&quot;] &quot;</span> +</span><br><span class="line">                    threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>] Monitor Ctrl-Break</span><br><span class="line">[<span class="number">5</span>] Attach Listener<span class="comment">//附加监听</span></span><br><span class="line">[<span class="number">4</span>] Signal Dispatcher<span class="comment">//分发处理发送给JVM信号的线程</span></span><br><span class="line">[<span class="number">3</span>] Finalizer<span class="comment">//调用对象finalize方法的线程</span></span><br><span class="line">[<span class="number">2</span>] Reference Handler清除Reference的线程</span><br><span class="line">[<span class="number">1</span>] main 线程，用户程序入口</span><br></pre></td></tr></table></figure>
<h4 id="进程与线程的对比"><a href="#进程与线程的对比" class="headerlink" title="进程与线程的对比"></a>进程与线程的对比</h4><ol>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li>
<li>进程间通信较为复杂<ul>
<li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ol>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ol>
<li><strong>并发（concurrent）：</strong> 同一时间应对（dealing with）多件事情的能力</li>
<li><strong>并行（parallel）：</strong> 同一时间动手做（doing）多件事情的能力，会出现资源竞争的问题</li>
<li><strong>单核</strong>： 微观串行，宏观并行，一般会将这种<strong>线程轮流使用</strong>CPU的做法称为并发</li>
<li><strong>多核</strong>：多核下，每个核都可以调度运行线程，这时候线程可以是并行的</li>
</ol>
<h2 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h2><h3 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h3><p>如果使用得当，线程可以有效地的降低程序的开发和维护成本，同时提升复杂应用程序的性能。线程能够将大部分的异步工作流转成串行工作流，因此能更好的模拟人类的工作方式和交互方式。此外，线程可以降低代码的复杂度，是代码更容易编写、阅读和维护。  </p>
<p>在GUI应用中，线程可以提高用户界面的响应灵敏度，而在服务器应用程序中，可以提升资源利用率以及系统吞吐率。线程还可以简化jvm的实现，垃圾收集器通常在一个或多个专门的线程中运行。</p>
<h4 id="发挥多处理器的强大能力"><a href="#发挥多处理器的强大能力" class="headerlink" title="发挥多处理器的强大能力"></a>发挥多处理器的强大能力</h4><p>随着技术的发展，在单核处理器上通过提高时钟频率来提升性能以变的越来越困难，目前大多数机器都是在单个芯片上放置多个处理器核。但是由于基本的调度单位是线程，因此如果使用单个线程会造成很多cpu资源的浪费。多线程程序可以同时在多个处理器上执行，并且可以通过提高处理器资源的利用率来提升吞吐率。比如IO读写。</p>
<h4 id="建模的简单性"><a href="#建模的简单性" class="headerlink" title="建模的简单性"></a>建模的简单性</h4><p>通过使用线程，可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互。  </p>
<p>可以使用框架实现以上功能，例如：servlet和RMI；框架负责解决一些细节问题，例如请求管理、线程创建、负载均衡，并在正确的时刻将请求分发给正确的应用程序组件。  </p>
<p>Java为多线程编程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁地考虑如何将其多线程化。一旦开发人员建立好了模型，稍做修改总是能够方便地映射到Java提供的多线程编程模型上。</p>
<h4 id="异步事件的简化处理"><a href="#异步事件的简化处理" class="headerlink" title="异步事件的简化处理"></a>异步事件的简化处理</h4><p>服务器应用程序在接受来自多个远程客户端的套接字链接请求时，如果为每个链接都分配其各自的线程并且使用同步IO，那么就会降低这类程序的开发难度。</p>
<h4 id="响应更灵敏的用户界面"><a href="#响应更灵敏的用户界面" class="headerlink" title="响应更灵敏的用户界面"></a>响应更灵敏的用户界面</h4><p>使用多线程技术，即将数据一致性不强的操作派发给其他线程处理（也可以使用消息队列），如生成订单快照、发送邮件等。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。</p>
<h3 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h3><h4 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h4><p>线程安全性非常复杂，在没有充足同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果。比如常见的序列中计算（a++），多个线程同时调用会出现重复值的情况。  </p>
<p>由于多个线程要共享相同的内存地址空间，并且是并发执行，因此他们会访问或则修改其他线程正在使用的变量。这样就会产生竞态条件（资源竞争），导致并发安全性问题的发生。java本身提供了各种同步机制来协同这种访问。比如加锁以及内存可见性等。</p>
<h4 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h4><p>安全性的含义是“永远不发生糟糕的事情”，而活跃性则是“某个正确的事情最终会发生”。</p>
<h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
<li><a href="https://www.cnblogs.com/wxd0108/p/5479442.html">Java中的多线程你只要看这一篇就够了</a></li>
<li><a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin">线程</a></li>
<li><a href="https://www.cnblogs.com/lwbqqyumidi/p/3804883.html">Java总结篇系列：Java多线程（一）</a></li>
<li>《java并发编程实战》</li>
<li><a href="https://blog.csdn.net/hanhaiyinheguxing/article/details/51366541">多线程01：《疯狂Java讲义》学习笔记——线程概述</a></li>
<li><a href="https://blog.csdn.net/hla199106/article/details/47840505">java并发编程—如何创建线程以及Thread类的使用</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920357.html">Java并发编程：Thread类的使用</a></li>
<li><a href="https://www.cnblogs.com/loveer/p/11518402.html">Java中断机制</a></li>
<li><a href="https://www.cnblogs.com/hapjin/p/5450779.html">JAVA多线程之中断机制(如何处理中断？)</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之调度方式</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><p>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</p>
<h2 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h2><p>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</p>
<a id="more"></a>

<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/1588842599605.png" class>

</div>

<h2 id="JVM-的线程调度实现（抢占式调度）"><a href="#JVM-的线程调度实现（抢占式调度）" class="headerlink" title="JVM 的线程调度实现（抢占式调度）"></a>JVM 的线程调度实现（抢占式调度）</h2><p>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</p>
<h2 id="线程让出-cpu-的情况"><a href="#线程让出-cpu-的情况" class="headerlink" title="线程让出 cpu 的情况"></a>线程让出 cpu 的情况</h2><ol>
<li>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。</li>
<li>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。</li>
<li>当前运行线程结束，即运行完 run()方法里面的任务。</li>
</ol>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h3><h4 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h4><p>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。</p>
<h4 id="短作业-进程-优先调度算法"><a href="#短作业-进程-优先调度算法" class="headerlink" title="短作业(进程)优先调度算法"></a>短作业(进程)优先调度算法</h4><p>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</p>
<h3 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h3><p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。<br>当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</p>
<h4 id="非抢占式优先权算法"><a href="#非抢占式优先权算法" class="headerlink" title="非抢占式优先权算法"></a>非抢占式优先权算法</h4><p>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p>
<h4 id="抢占式优先权调度算法"><a href="#抢占式优先权调度算法" class="headerlink" title="抢占式优先权调度算法"></a>抢占式优先权调度算法</h4><p>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程) 的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p>
<h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/1588843436863.png" class>

</div>

<ol>
<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。</li>
<li>当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。</li>
<li>对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销</li>
</ol>
<h3 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h3><h4 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h4><p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。</p>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><ol>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。 在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程调度</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之面临的问题</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="上线文切换"><a href="#上线文切换" class="headerlink" title="上线文切换"></a>上线文切换</h2><p>巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做<strong>上下文切换</strong>。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。</p>
<a id="more"></a>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/1587898800503.png" class title="上线文切换">

</div>

<h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p><strong>Java Virtual Machine Stacks （Java 虚拟机栈）</strong></p>
<ol>
<li>每个线程启动后，虚拟机就会为其分配一块栈内存。</li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ol>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>（有时候也称做任务）是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。</p>
<h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>是指某一时间点 CPU 寄存器和程序计数器的内容。</p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</p>
<h4 id="PCB-“切换桢”"><a href="#PCB-“切换桢”" class="headerlink" title="PCB-“切换桢”"></a>PCB-“切换桢”</h4><p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。</p>
<h3 id="上下文切换的活动"><a href="#上下文切换的活动" class="headerlink" title="上下文切换的活动"></a>上下文切换的活动</h3><h4 id="切换的原因"><a href="#切换的原因" class="headerlink" title="切换的原因"></a>切换的原因</h4><ol>
<li>当前线程的时间片耗尽</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要执行</li>
<li>线程自己调用 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ol>
<h4 id="切换过程的动作"><a href="#切换过程的动作" class="headerlink" title="切换过程的动作"></a>切换过程的动作</h4><ol>
<li>由操作系统保存当前线程的状态，并恢复另一个线程的状态（通过程序计数器完成）<ul>
<li>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。</li>
<li>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。</li>
<li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。</li>
</ul>
</li>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会影响性能</li>
</ol>
<h3 id="引起线程上下文切换的原因"><a href="#引起线程上下文切换的原因" class="headerlink" title="引起线程上下文切换的原因"></a>引起线程上下文切换的原因</h3><ol>
<li>当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务；</li>
<li>当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；</li>
<li>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；</li>
<li>用户代码挂起当前任务，让出 CPU 时间；</li>
<li>硬件中断；</li>
</ol>
<h3 id="上线文切换次数监测"><a href="#上线文切换次数监测" class="headerlink" title="上线文切换次数监测"></a>上线文切换次数监测</h3><ol>
<li>使用<code>Lmbench</code>可以测量上线文切换的时长</li>
<li>使用<code>vmstat</code>可以查看上下文切换的次数</li>
</ol>
<h3 id="减少上下文切换的方式"><a href="#减少上下文切换的方式" class="headerlink" title="减少上下文切换的方式"></a>减少上下文切换的方式</h3><ol>
<li>❑ 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li>
<li>❑ CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。</li>
<li>❑ 使用最少线程。合理使用线程池。</li>
<li>❑ 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ol>
<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>多线程互相需要对方的锁，而且都不释放就会出现死锁。</p>
<h3 id="避免死锁的方式"><a href="#避免死锁的方式" class="headerlink" title="避免死锁的方式"></a>避免死锁的方式</h3><ol>
<li>❑ 避免一个线程同时获取多个锁。</li>
<li>❑ 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>❑ 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</li>
<li>❑ 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
<li>❑ 避免死锁要注意加锁顺序</li>
<li>❑ 如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查</li>
</ol>
<h3 id="死锁定位"><a href="#死锁定位" class="headerlink" title="死锁定位"></a>死锁定位</h3><ol>
<li>可用工具jconsole工具，或者jps获取线程id在使用jstack定位</li>
</ol>
<h2 id="活锁问题"><a href="#活锁问题" class="headerlink" title="活锁问题"></a>活锁问题</h2><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/29 14:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span>  <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;<span class="comment">// 期望0时退出</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(<span class="string">&quot;11 count: &quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;22 count: &quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="饥饿问题"><a href="#饥饿问题" class="headerlink" title="饥饿问题"></a>饥饿问题</h2><div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/1590736135292.png" class title="饥饿问题">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/1590736163727.png" class title="顺序加锁解决方案">

</div>

<h2 id="资源限制问题"><a href="#资源限制问题" class="headerlink" title="资源限制问题"></a>资源限制问题</h2><ol>
<li>资源限制：在并发编程过程中，程序的执行速度受限于物理硬件资源或软件资源，比如：节点网络、磁盘读写、CPU处理速度、数据库连接</li>
<li>由于资源组不足，在多线程并发过程中会降低程序的运行效率，可能比串行还慢（由于上线文切换）</li>
<li>解决方案：合理使用线程池、复用socket连接、多路复用</li>
</ol>
<h2 id="变量线程安全分析"><a href="#变量线程安全分析" class="headerlink" title="变量线程安全分析"></a>变量线程安全分析</h2><h3 id="成员变量、类变量"><a href="#成员变量、类变量" class="headerlink" title="成员变量、类变量"></a>成员变量、类变量</h3><ol>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ol>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ol>
<li>局部变量是线程安全的</li>
<li>但局部变量引用的对象则未必<ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ol>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/28 19:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSafe1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSafe1</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">2</span>: istore_0</span><br><span class="line">       <span class="number">3</span>: iinc          <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">       6: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       <span class="number">9</span>: iload_0</span><br><span class="line">      10: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">13</span>: <span class="number">3</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">6</span></span><br><span class="line">      line <span class="number">15</span>: <span class="number">13</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">3</span>      <span class="number">11</span>     <span class="number">0</span>     i   I</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/1590666789177.png" class>

</div>

<h4 id="引用类型–成员变量"><a href="#引用类型–成员变量" class="headerlink" title="引用类型–成员变量"></a>引用类型–成员变量</h4><div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/1590667021020.png" class>

</div>

<h4 id="引用类型–局部变量"><a href="#引用类型–局部变量" class="headerlink" title="引用类型–局部变量"></a>引用类型–局部变量</h4><div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/1590667066179.png" class>

</div>

<h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ol>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>java.util.concurrent 包下的类</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>上线文切换</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之Type</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BType/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里的Type指java.lang.reflect.Type, 是Java中所有类型的公共高级接口, 代表了Java中的所有类型. Type体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现Type接口.  </p>
<p>Type 表示的全部类型而每个Class对象表示一个具体类型的实例，如String.class仅代表String类型。由此看来Type与 Class 表示类型几乎是相同的（Class实现接口Type），只不过 Type表示的范围比Class要广得多而已。当然Type还有其他子类。</p>
<ol>
<li>参数化类型（ParameterizedType）：有原始类型和具体的类型参数，泛型List<String>、Map；</String></li>
<li>数组类型（GenericArrayType）：不是数组String[] 、byte[]，而是带有泛型的数组，即T[] ；</li>
<li>通配符类型（WildcardType）： 指的是&lt;?&gt;, &lt;? extends T&gt;等等</li>
<li>原始类型（Class）： 不仅仅包含我们平常所指的类，还包括枚举、数组、注解等；</li>
<li>基本类型（Class）, 也就是我们所说的java的基本类型，即int,float,double等</li>
<li>类型变量(TypeVariable)：表示类型参数，可以有上界，比如：T extends Number<a id="more"></a>
<h2 id="JDK定义"><a href="#JDK定义" class="headerlink" title="JDK定义"></a>JDK定义</h2></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Type is the common superinterface for all types in the Java</span></span><br><span class="line"><span class="comment"> * programming language. These include raw types, parameterized types,</span></span><br><span class="line"><span class="comment"> * array types, type variables and primitive types.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string describing this type, including information</span></span><br><span class="line"><span class="comment">     * about any type parameters.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span> The default implementation calls &#123;<span class="doctag">@code</span> toString&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string describing this type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BType/1588062825641.png" class title="Type类结构">

</div>

<h3 id="ParameterizedType"><a href="#ParameterizedType" class="headerlink" title="ParameterizedType"></a>ParameterizedType</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParameterizedType represents a parameterized type such as</span></span><br><span class="line"><span class="comment"> * Collection&amp;lt;String&amp;gt;.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 表示一种参数化类型，比如：Collection&lt;String&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A parameterized type is created the first time it is needed by a</span></span><br><span class="line"><span class="comment"> * reflective method, as specified in this package. When a</span></span><br><span class="line"><span class="comment"> * parameterized type p is created, the generic type declaration that</span></span><br><span class="line"><span class="comment"> * p instantiates is resolved, and all type arguments of p are created</span></span><br><span class="line"><span class="comment"> * recursively. See &#123;<span class="doctag">@link</span> java.lang.reflect.TypeVariable</span></span><br><span class="line"><span class="comment"> * TypeVariable&#125; for details on the creation process for type</span></span><br><span class="line"><span class="comment"> * variables. Repeated creation of a parameterized type has no effect.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 参数化类型在反射方法第一次使用的时候被创建。</span></span><br><span class="line"><span class="comment"> * 3. 当参数化类型p被创建之后，被p实例化的泛型会被解析，并且递归创建p的所有参数化类型</span></span><br><span class="line"><span class="comment"> * 4. 重复创建一个参数化类型不会有影响</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Instances of classes that implement this interface must implement</span></span><br><span class="line"><span class="comment"> * an equals() method that equates any two instances that share the</span></span><br><span class="line"><span class="comment"> * same generic type declaration and have equal type parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of &#123;<span class="doctag">@code</span> Type&#125; objects representing the actual type</span></span><br><span class="line"><span class="comment">     * arguments to this type.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that in some cases, the returned array be empty. This can occur</span></span><br><span class="line"><span class="comment">     * if this type represents a non-parameterized type nested within</span></span><br><span class="line"><span class="comment">     * a parameterized type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of &#123;<span class="doctag">@code</span> Type&#125; objects representing the actual type</span></span><br><span class="line"><span class="comment">     *     arguments to this type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TypeNotPresentException if any of the</span></span><br><span class="line"><span class="comment">     *     actual type arguments refers to a non-existent type declaration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MalformedParameterizedTypeException if any of the</span></span><br><span class="line"><span class="comment">     *     actual type parameters refer to a parameterized type that cannot</span></span><br><span class="line"><span class="comment">     *     be instantiated for any reason</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@code</span> Type&#125; object representing the class or interface</span></span><br><span class="line"><span class="comment">     * that declared this type.</span></span><br><span class="line"><span class="comment">     * 1. 返回当前class或interface声明的类型, 如List&lt;?&gt;返回List</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the &#123;<span class="doctag">@code</span> Type&#125; object representing the class or interface</span></span><br><span class="line"><span class="comment">     *     that declared this type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@code</span> Type&#125; object representing the type that this type</span></span><br><span class="line"><span class="comment">     * is a member of.  For example, if this type is &#123;<span class="doctag">@code</span> O&lt;T&gt;.I&lt;S&gt;&#125;,</span></span><br><span class="line"><span class="comment">     * return a representation of &#123;<span class="doctag">@code</span> O&lt;T&gt;&#125;.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 返回所属类型. 如,当前类型为O&lt;T&gt;.I&lt;S&gt;, 则返回O&lt;T&gt;. 顶级类型将返回null </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If this type is a top-level type, &#123;<span class="doctag">@code</span> null&#125; is returned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Type&#125; object representing the type that</span></span><br><span class="line"><span class="comment">     *     this type is a member of. If this type is a top-level type,</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> null&#125; is returned</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TypeNotPresentException if the owner type</span></span><br><span class="line"><span class="comment">     *     refers to a non-existent type declaration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MalformedParameterizedTypeException if the owner type</span></span><br><span class="line"><span class="comment">     *     refers to a parameterized type that cannot be instantiated</span></span><br><span class="line"><span class="comment">     *     for any reason</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/JustBeauty/article/details/81116144">ParameterizedType详解</a></li>
<li><a href="https://www.jianshu.com/p/cfa74c980b25">Java中与泛型相关的接口 之 ParameterizedType</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Type</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之传递方式</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在Java中的方法调用使用的都是<strong>值传递</strong>，Java 中的所有自变量或参数传递都是通过传递句柄进行的。也就是说，当我们传递“一个对象”时，<strong>实际传递的只是指向位于方法外部的那个对象的“一个句柄”</strong>。所以一旦要对那个句柄进行任何修改，便相当于修改外部对象。此外：</p>
<ol>
<li>■参数传递过程中会自动产生别名问题</li>
<li>■不存在本地对象，只有本地句柄</li>
<li>■句柄有自己的作用域，而对象没有</li>
<li>■对象的“存在时间”在 Java 里不是个问题</li>
<li>■没有语言上的支持（如常量）可防止对象被修改（以避免别名的副作用）<a id="more"></a>
<h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2></li>
</ol>
<blockquote>
<p>形式参数：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。<br>实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。</p>
</blockquote>
<h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><blockquote>
<p>值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中(<strong>副本的概念</strong>)，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
</blockquote>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-sjuo{background-color:#C2FFD6;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0lax"></th>
    <th class="tg-0lax">值传递</th>
    <th class="tg-0lax">引用传递</th>
  </tr>
  <tr>
    <td class="tg-0lax">根本区别</td>
    <td class="tg-sjuo">会创建副本，或者是直接句柄处理</td>
    <td class="tg-0lax">不创建副本</td>
  </tr>
  <tr>
    <td class="tg-0lax">结论</td>
    <td class="tg-sjuo">方法中无法改变原始对象</td>
    <td class="tg-0lax">方法中可以改变原始对象</td>
  </tr>
</table>

<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>参考《<a href="https://www.sunliaodong.cn/2021/02/04/Javap%E8%AF%A6%E8%A7%A3/">javap详解</a>》</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.toutiao.com/i6813552507239793164/">Java 到底是值传递还是引用传递？</a></li>
<li><a href="https://www.sohu.com/a/158425070_505800">Java 函数调用是传值还是传引用？从字节码角度来看看 ！</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>传递方式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之克隆</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%8B%E9%9A%86/</url>
    <content><![CDATA[<p>所谓克隆就是对原有对象复用的复用，<strong>Java语言中克隆针对的是类的实例（对象）</strong>，在Java中一共有三种方式实现。</p>
<ol>
<li>直接赋值</li>
<li>浅拷贝</li>
<li>深拷贝<a id="more"></a>
<h2 id="java-lang-Cloneable"><a href="#java-lang-Cloneable" class="headerlink" title="java.lang.Cloneable"></a>java.lang.Cloneable</h2></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></span><br><span class="line"><span class="comment"> * indicate to the &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; method that it</span></span><br><span class="line"><span class="comment"> * is legal for that method to make a</span></span><br><span class="line"><span class="comment"> * field-for-field copy of instances of that class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Invoking Object&#x27;s clone method on an instance that does not implement the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, classes that implement this interface should override</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Object.clone&lt;/tt&gt; (which is protected) with a public method.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></span><br><span class="line"><span class="comment"> * method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &lt;tt&gt;clone&lt;/tt&gt; method.</span></span><br><span class="line"><span class="comment"> * Therefore, it is not possible to clone an object merely by virtue of the</span></span><br><span class="line"><span class="comment"> * fact that it implements this interface.  Even if the clone method is invoked</span></span><br><span class="line"><span class="comment"> * reflectively, there is no guarantee that it will succeed.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实现该接口类，可以通过java.lang.Object.clone()方法完成对象中属性的赋值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码分析可知：  </p>
<ol>
<li>必须实现Cloneable接口，否则抛出CloneNotSupportedException异常</li>
<li>实现Cloneable的类应该重写clone()，重写时该方法的修饰符为public。</li>
</ol>
<h2 id="java-lang-Object-clone"><a href="#java-lang-Object-clone" class="headerlink" title="java.lang.Object.clone()"></a>java.lang.Object.clone()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates and returns a copy of this object.  The precise meaning</span></span><br><span class="line"><span class="comment">* of &quot;copy&quot; may depend on the class of the object. The general</span></span><br><span class="line"><span class="comment">* intent is that, for any object &#123;<span class="doctag">@code</span> x&#125;, the expression:</span></span><br><span class="line"><span class="comment">* &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">* &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">* will be true, and that the expression:</span></span><br><span class="line"><span class="comment">* &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">* &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">* will be &#123;<span class="doctag">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment">* While it is typically the case that:</span></span><br><span class="line"><span class="comment">* &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">* &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">* will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment">* of this object (which is being cloned).  To achieve this independence,</span></span><br><span class="line"><span class="comment">* it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment">* by &#123;<span class="doctag">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class="line"><span class="comment">* copying any mutable objects that comprise the internal &quot;deep structure&quot;</span></span><br><span class="line"><span class="comment">* of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment">* objects with references to the copies.  If a class contains only</span></span><br><span class="line"><span class="comment">* primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment">* the case that no fields in the object returned by &#123;<span class="doctag">@code</span> super.clone&#125;</span></span><br><span class="line"><span class="comment">* need to be modified.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* The method &#123;<span class="doctag">@code</span> clone&#125; for class &#123;<span class="doctag">@code</span> Object&#125; performs a</span></span><br><span class="line"><span class="comment">* specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment">* not implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> CloneNotSupportedException&#125; is thrown. Note that all arrays</span></span><br><span class="line"><span class="comment">* are considered to implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125; and that</span></span><br><span class="line"><span class="comment">* the return type of the &#123;<span class="doctag">@code</span> clone&#125; method of an array type &#123;<span class="doctag">@code</span> T[]&#125;</span></span><br><span class="line"><span class="comment">* is &#123;<span class="doctag">@code</span> T[]&#125; where T is any reference or primitive type.</span></span><br><span class="line"><span class="comment">* Otherwise, this method creates a new instance of the class of this</span></span><br><span class="line"><span class="comment">* object and initializes all its fields with exactly the contents of</span></span><br><span class="line"><span class="comment">* the corresponding fields of this object, as if by assignment; the</span></span><br><span class="line"><span class="comment">* contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment">* performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* The class &#123;<span class="doctag">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> Cloneable&#125;, so calling the &#123;<span class="doctag">@code</span> clone&#125; method on an object</span></span><br><span class="line"><span class="comment">* whose class is &#123;<span class="doctag">@code</span> Object&#125; will result in throwing an</span></span><br><span class="line"><span class="comment">* exception at run time.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>     a clone of this instance.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  CloneNotSupportedException  if the object&#x27;s class does not</span></span><br><span class="line"><span class="comment">*               support the &#123;<span class="doctag">@code</span> Cloneable&#125; interface. Subclasses</span></span><br><span class="line"><span class="comment">*               that override the &#123;<span class="doctag">@code</span> clone&#125; method can also</span></span><br><span class="line"><span class="comment">*               throw this exception to indicate that an instance cannot</span></span><br><span class="line"><span class="comment">*               be cloned.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> java.lang.Cloneable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="测试代码准备"><a href="#测试代码准备" class="headerlink" title="测试代码准备"></a>测试代码准备</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.clone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		CloneObject co1 = <span class="keyword">new</span> CloneObject();</span><br><span class="line">		co1.setName(<span class="string">&quot;name1&quot;</span>);</span><br><span class="line">		co1.setAge(<span class="number">10</span>);</span><br><span class="line">		CloneObject2 c021 = <span class="keyword">new</span> CloneObject2();</span><br><span class="line">		c021.setName2(<span class="string">&quot;name21&quot;</span>);</span><br><span class="line">		co1.setCloneObject2(c021);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObject</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> CloneObject2 cloneObject2;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject2 <span class="title">getCloneObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCloneObject2</span><span class="params">(CloneObject2 cloneObject2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneObject2 = cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObject2</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name2;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName2</span><span class="params">(String name2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name2 = name2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1.直接赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CloneObject co2 = co1;</span><br><span class="line">System.out.println(co2.getName());</span><br><span class="line">System.out.println(co1.getName());</span><br></pre></td></tr></table></figure>
<p>对象co2和co1在堆内存中的地址一致，所以<strong>两个对象之间会互相影响</strong>。</p>
<h3 id="浅复制（复制引用但不复制引用的对象）"><a href="#浅复制（复制引用但不复制引用的对象）" class="headerlink" title="浅复制（复制引用但不复制引用的对象）"></a>浅复制（复制引用但不复制引用的对象）</h3><p>需要通过实现接口<code>java.lang.Cloneable</code>，并且重新<code>java.lang.Object.clone()</code>的方法进行实现。实现原理：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。<strong>因此，原始对象及其副本引用同一个对象。（对象中的对象）</strong></p>
<p>参考代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObject</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> CloneObject2 cloneObject2;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject2 <span class="title">getCloneObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCloneObject2</span><span class="params">(CloneObject2 cloneObject2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneObject2 = cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * (1) 实现 Cloneable 接口</span></span><br><span class="line"><span class="comment">	 * (2) 覆盖 clone()</span></span><br><span class="line"><span class="comment">	 * (3) 在自己的 clone()中调用 super.clone()</span></span><br><span class="line"><span class="comment">	 * (4) 在自己的 clone()中捕获违例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (CloneObject) <span class="keyword">super</span>.clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 2.浅复制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CloneObject co2 = co1.clone();</span><br><span class="line">co2.setName(<span class="string">&quot;cloneName&quot;</span>);</span><br><span class="line">co2.getCloneObject2().setName2(<span class="string">&quot;cloneName2222&quot;</span>);</span><br><span class="line">System.out.println(co2.getName());</span><br><span class="line">System.out.println(co1.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(co1.getCloneObject2().getName2());</span><br><span class="line">System.out.println(co2.getCloneObject2().getName2());</span><br></pre></td></tr></table></figure>
<h3 id="深复制（复制对象和其应用对象）"><a href="#深复制（复制对象和其应用对象）" class="headerlink" title="深复制（复制对象和其应用对象）"></a>深复制（复制对象和其应用对象）</h3><p>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObject</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> CloneObject2 cloneObject2;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject2 <span class="title">getCloneObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCloneObject2</span><span class="params">(CloneObject2 cloneObject2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneObject2 = cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * (1) 实现 Cloneable 接口</span></span><br><span class="line"><span class="comment">	 * (2) 覆盖 clone()</span></span><br><span class="line"><span class="comment">	 * (3) 在自己的 clone()中调用 super.clone()</span></span><br><span class="line"><span class="comment">	 * (4) 在自己的 clone()中捕获违例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			CloneObject cloneObject = (CloneObject) <span class="keyword">super</span>.clone();</span><br><span class="line">			cloneObject.cloneObject2 = <span class="keyword">this</span>.cloneObject2.clone();</span><br><span class="line">			<span class="keyword">return</span> cloneObject;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObject2</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name2;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName2</span><span class="params">(String name2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name2 = name2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject2 <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (CloneObject2) <span class="keyword">super</span>.clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化（深-clone-一中实现）"><a href="#序列化（深-clone-一中实现）" class="headerlink" title="序列化（深 clone 一中实现）"></a>序列化（深 clone 一中实现）</h3><p>在Java 语言里深复制一个对象，常常可以先使对象实现 <code>Serializable 接口</code>(必须)，然后把对象（实际上只是对象的一个拷贝）写到一个流里（<strong>可以实现对象持久化到内存或磁盘中，提高对象的生命周期</strong>），再从流里读出来，便可以重建对象。特点：</p>
<ol>
<li>序列化对象以字节数组保持-静态成员不保存，保存到是对象的“状态”</li>
<li>序列化用户远程对象传输，比如：RMI(远程方法调用)</li>
<li>实现接口<code>java.io.Serializable</code></li>
<li>序列化和反序列化：<code>ObjectOutputStream</code> 和<code>ObjectInputStream</code></li>
<li><code>writeObject</code> 和 <code>readObject</code> 自定义序列化策略，可以实现序列化信息和反序列化的控制</li>
<li>序列化 ID（<code>private static final long serialVersionUID</code>） ：需要保证序列化和反序列化类的ID一致性</li>
<li>Transient  关键字阻止该变量被序列化到文件中<ul>
<li>阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</li>
<li>writeExternal() 使用该方法也可以实现序列信息的控制</li>
</ul>
</li>
</ol>
<h4 id="实现deepclone"><a href="#实现deepclone" class="headerlink" title="实现deepclone"></a>实现deepclone</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.clone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerCloneTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SerCloneObject co1 = <span class="keyword">new</span> SerCloneObject();</span><br><span class="line">		co1.setName(<span class="string">&quot;name1&quot;</span>);</span><br><span class="line">		co1.setAge(<span class="number">10</span>);</span><br><span class="line">		SerCloneObject2 c021 = <span class="keyword">new</span> SerCloneObject2();</span><br><span class="line">		c021.setName2(<span class="string">&quot;name21&quot;</span>);</span><br><span class="line">		co1.setCloneObject2(c021);</span><br><span class="line">		</span><br><span class="line">		SerCloneObject co2 = co1.deepClone();</span><br><span class="line">		co2.setName(<span class="string">&quot;cloneName&quot;</span>);</span><br><span class="line">		co2.getCloneObject2().setName2(<span class="string">&quot;cloneName2222&quot;</span>);</span><br><span class="line">		System.out.println(co2.getName());</span><br><span class="line">		System.out.println(co1.getName());</span><br><span class="line">		</span><br><span class="line">		System.out.println(co1.getCloneObject2().getName2());</span><br><span class="line">		System.out.println(co2.getCloneObject2().getName2());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerCloneObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> SerCloneObject2 cloneObject2;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> SerCloneObject2 <span class="title">getCloneObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCloneObject2</span><span class="params">(SerCloneObject2 cloneObject2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneObject2 = cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> SerCloneObject <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//将该对象序列化成流,因为写在流里的是对象的一个拷贝，</span></span><br><span class="line">		<span class="comment">//而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝  </span></span><br><span class="line">		ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line">		ObjectOutputStream oos;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">			oos.writeObject(<span class="keyword">this</span>);  </span><br><span class="line">			<span class="comment">//将流序列化成对象  </span></span><br><span class="line">			ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());  </span><br><span class="line">			ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);  </span><br><span class="line">			<span class="keyword">return</span> (SerCloneObject) ois.readObject();  </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerCloneObject2</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> String name2;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName2</span><span class="params">(String name2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name2 = name2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射（深复制一种）"><a href="#反射（深复制一种）" class="headerlink" title="反射（深复制一种）"></a>反射（深复制一种）</h3><h4 id="org-springframework-beans-BeanUtils"><a href="#org-springframework-beans-BeanUtils" class="headerlink" title="org.springframework.beans.BeanUtils"></a>org.springframework.beans.BeanUtils</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy the property values of the given source bean into the given target bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: The source and target classes do not have to match or even be derived</span></span><br><span class="line"><span class="comment"> * from each other, as long as the properties match. Any bean properties that the</span></span><br><span class="line"><span class="comment"> * source bean exposes but the target bean does not will silently be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the source bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target the target bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> editable the class (or interface) to restrict property setting to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ignoreProperties array of property names to ignore</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the copying failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanWrapper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target, <span class="meta">@Nullable</span> Class&lt;?&gt; editable,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> String... ignoreProperties)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(source, <span class="string">&quot;Source must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(target, <span class="string">&quot;Target must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取目标对象的class</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt; actualEditable = target.getClass();</span><br><span class="line">	<span class="keyword">if</span> (editable != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!editable.isInstance(target)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Target class [&quot;</span> + target.getClass().getName() +</span><br><span class="line">					<span class="string">&quot;] not assignable to Editable class [&quot;</span> + editable.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		actualEditable = editable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取目标对象的属性信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理忽略属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;String&gt; ignoreList = (ignoreProperties != <span class="keyword">null</span> ? Arrays.asList(ignoreProperties) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (PropertyDescriptor targetPd : targetPds) &#123;</span><br><span class="line">		Method writeMethod = targetPd.getWriteMethod();</span><br><span class="line">		<span class="keyword">if</span> (writeMethod != <span class="keyword">null</span> &amp;&amp; (ignoreList == <span class="keyword">null</span> || !ignoreList.contains(targetPd.getName()))) &#123;</span><br><span class="line">			PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</span><br><span class="line">			<span class="keyword">if</span> (sourcePd != <span class="keyword">null</span>) &#123;</span><br><span class="line">				Method readMethod = sourcePd.getReadMethod();</span><br><span class="line">				<span class="keyword">if</span> (readMethod != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						ClassUtils.isAssignable(writeMethod.getParameterTypes()[<span class="number">0</span>], readMethod.getReturnType())) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">							readMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						Object value = readMethod.invoke(source);</span><br><span class="line">						<span class="keyword">if</span> (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">							writeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						writeMethod.invoke(target, value);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(</span><br><span class="line">								<span class="string">&quot;Could not copy property &#x27;&quot;</span> + targetPd.getName() + <span class="string">&quot;&#x27; from source to target&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/Qian123/p/5710533.html">Java提高篇——对象克隆（复制）</a></li>
<li><a href="https://lingcoder.github.io/OnJava8/#/book/Appendix-Object-Serialization">编程思想</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>clone</tag>
        <tag>克隆</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之内部类</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>定义：外部类内部定义的类，类名不需要与文件名不同</li>
<li>static修饰（静态内部类）</li>
<li>作用域（public、default、protected、private）</li>
<li>作用范围：编译期概念，一但编译成功就是有不同的class文件（outer.class和outer$inner.class），所以内部类的成员变量/方法名可以和外部类的相同。</li>
<li>分类：静态内部类，成员内部类，局部内部类，匿名内部类四种。</li>
</ol>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>Ø 在一个方法内部使用<br>Ø 在方法的一个作用域中使用<br>Ø 一个匿名类，用于实现一个接口<br>Ø 一个匿名类，用于扩展拥有非默认构造器的类<br>Ø 一个匿名类，用于执行字段初始化<br>Ø 一个匿名类，通过实例初始化进行构建（匿名内部类不能拥有构造器)  </p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>一个内部类的对象能够访问创建它的对象的实现，包括私有数据。即内部类实例对包含它的哪个类的实例来说，是特权的。</li>
<li>对于同一个包中的其他类来说,内部类能够隐藏起来,换句话说，内部类不管方法的可见性如何，那怕是public，除了包容类，其他类都无法使用它。</li>
<li>匿名内部类可以很方便的定义回调。</li>
<li>使用内部类可以非常方便的编写事件驱动程序。</li>
</ol>
<h2 id="静态内部类-嵌套内部类"><a href="#静态内部类-嵌套内部类" class="headerlink" title="静态内部类/嵌套内部类"></a>静态内部类/嵌套内部类</h2><ol>
<li>被static修饰的内部类</li>
<li>不需要维护与外部类的对象的关系（可以直接引用，比如：outer.inner），一般不会出现内存泄漏的问题</li>
<li>嵌套类和普通的内部类还有一个区别：普通内部类不能有static数据和static属性，也不能包含嵌套类，但嵌套类可以。</li>
<li>作用域修饰符：不能声明为private，一般声明为public，方便调用。</li>
<li>静态内部类可以访问外部类所有的静态变量和方法，包括private</li>
<li>静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</li>
<li>其它类使用静态内部类需要使用“外部类.静态内部类”方式</li>
<li>Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象， HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">11</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.err.println(a);</span><br><span class="line"><span class="comment">//			System.err.println(b); // 编译出错</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printInner1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.err.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StaticInnerClass.Inner.printInner();</span><br><span class="line">		StaticInnerClass.Inner inner = <span class="keyword">new</span> StaticInnerClass.Inner();</span><br><span class="line">		inner.printInner1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员内部类：定义在类内部的非静态类，就是成员内部类"><a href="#成员内部类：定义在类内部的非静态类，就是成员内部类" class="headerlink" title="成员内部类：定义在类内部的非静态类，就是成员内部类"></a>成员内部类：定义在类内部的非静态类，就是成员内部类</h2><ol>
<li>成员内部类，就是作为外部类的成员，可以直接使用外部类的所有成员和方法，即使是private的。</li>
<li>同时外部类要访问内部类的所有成员变量/方法，则需要通过内部类的对象来获取。<br>要注意的是，成员内部类不能含有static的方法和变量（final 修饰的除外）。<strong>因为成员内部类需要先创建了外部类，才能创建它自己的</strong>，成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</li>
<li>在成员内部类要引用外部类对象时，使用outer.this来表示外部类对象；</li>
<li>而需要创建内部类对象，可以使用outer.inner  obj = outerobj.new inner();</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">		Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">		inner.print(<span class="string">&quot;Outer.new&quot;</span>);</span><br><span class="line">		inner = outer.getInner();</span><br><span class="line">		inner.print(<span class="string">&quot;Outer.get&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 个人推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类：内部类定义在方法和作用域内"><a href="#局部内部类：内部类定义在方法和作用域内" class="headerlink" title="局部内部类：内部类定义在方法和作用域内"></a>局部内部类：内部类定义在方法和作用域内</h2><p>定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutScope</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类（要继承一个父类或者实现一个接口、直接使用-new-来生成一个对象的引用）"><a href="#匿名内部类（要继承一个父类或者实现一个接口、直接使用-new-来生成一个对象的引用）" class="headerlink" title="匿名内部类（要继承一个父类或者实现一个接口、直接使用 new 来生成一个对象的引用）"></a>匿名内部类（要继承一个父类或者实现一个接口、直接使用 new 来生成一个对象的引用）</h2><p>匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。<br>有时候我为了免去给内部类命名，便倾向于使用匿名内部类，因为它没有名字。例如：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/screenshot_1587209816208.png" class title="反射知识点">

</div>

<p>匿名内部类是不能加访问修饰符的。<strong>要注意的是，new匿名类，这个类是要先定义的</strong>，看下面例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousOuter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnonymousOuter outer = <span class="keyword">new</span> AnonymousOuter();</span><br><span class="line">		Inner inner = outer.getInner(<span class="string">&quot;Inner&quot;</span>, <span class="string">&quot;gz&quot;</span>);</span><br><span class="line">		System.out.println(inner.getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, String city)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner() &#123;</span><br><span class="line">			<span class="keyword">private</span> String nameStr = name;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> nameStr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注释后，编译时提示类Inner找不到 </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="在使用匿名内部类时，要记住以下几个原则"><a href="#在使用匿名内部类时，要记住以下几个原则" class="headerlink" title="在使用匿名内部类时，要记住以下几个原则"></a>在使用匿名内部类时，要记住以下几个原则</h3><p>Ø 匿名内部类不能有构造方法。<br>Ø 匿名内部类不能定义任何静态成员、方法和类。<br>Ø 匿名内部类不能是public,protected,private,static<br>Ø 只能创建匿名内部类的一个实例。<br>Ø 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。<br>Ø 因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。<br>Ø 当所在的方法的形参需要被内部类里面使用时，该形参必须为final</p>
<h3 id="使用final修饰入参的原因"><a href="#使用final修饰入参的原因" class="headerlink" title="使用final修饰入参的原因"></a>使用final修饰入参的原因</h3><p>“这是一个编译器设计的问题，如果你了解java的编译原理的话很容易理解。<br>首先，内部类被编译的时候会生成一个单独的内部类的.class文件，这个文件并不与外部类在同一class文件中。<br>当外部类传的参数被内部类调用时，从java程序的角度来看是直接的调用例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">(<span class="keyword">final</span> String a,<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123; </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dosome</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;System.out.println(a+b)&#125;&#125;;</span><br><span class="line">  Dosome some=<span class="keyword">new</span> Dosome(); </span><br><span class="line">  some.dosome(); </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>从代码来看好像是那个内部类直接调用的a参数和b参数，但是实际上不是，在java编译器编译以后实际的操作代码是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$<span class="title">Dosome</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dosome</span><span class="params">(<span class="keyword">final</span> String a,<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.Dosome$a=a;</span><br><span class="line">  <span class="keyword">this</span>.Dosome$b=b;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.Dosome$a+<span class="keyword">this</span>.Dosome$b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码看来，内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数。 </p>
<p>这样理解就很容易得出为什么要用final了，因为两者从外表看起来是同一个东西，实际上却不是这样，如果内部类改掉了这些参数的值也不可能影响到原参数，然而这样却失去了参数的一致性，因为从编程人员的角度来看他们是同一个东西，如果编程人员在程序设计的时候在内部类中改掉参数的值，但是外部调用的时候又发现值其实没有被改掉，这就让人非常的难以理解和接受，为了避免这种尴尬的问题存在，所以编译器设计人员把内部类能够使用的参数设定为必须是final来规避这种莫名其妙错误的存在。”</p>
<blockquote>
<p>(简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变)</p>
</blockquote>
<h3 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer1</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Outer1 outer = <span class="keyword">new</span> Outer1(); </span><br><span class="line">		Inner1 inner = outer.getInner(<span class="string">&quot;Inner&quot;</span>, <span class="string">&quot;gz&quot;</span>); </span><br><span class="line">		System.out.println(inner.getName()); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner1 <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, String city)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner1(name, city) &#123; </span><br><span class="line">			<span class="keyword">private</span> String nameStr = name; </span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">return</span> nameStr; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span> </span>&#123; </span><br><span class="line">	Inner1(String name, String city) &#123; </span><br><span class="line">		System.out.println(city); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>注意这里的形参city，由于它没有被匿名内部类直接使用，而是被抽象类Inner的构造函数所使用，所以不必定义为final。<br>而匿名内部类通过实例初始化，可以达到类似构造器的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer2</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Outer2 outer = <span class="keyword">new</span> Outer2(); </span><br><span class="line">		Inner2 inner = outer.getInner(<span class="string">&quot;Inner&quot;</span>, <span class="string">&quot;gz&quot;</span>); </span><br><span class="line">		System.out.println(inner.getName()); </span><br><span class="line">		System.out.println(inner.getProvince()); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner2 <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> String city)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner2() &#123;</span><br><span class="line">			<span class="keyword">private</span> String nameStr = name; </span><br><span class="line">			<span class="keyword">private</span> String province; </span><br><span class="line">			<span class="comment">// 实例初始化 </span></span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">if</span> (city.equals(<span class="string">&quot;gz&quot;</span>)) &#123; </span><br><span class="line">					province = <span class="string">&quot;gd&quot;</span>; </span><br><span class="line">				&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">					province = <span class="string">&quot;&quot;</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">return</span> nameStr; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">return</span> province; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner2</span> </span>&#123; </span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="function">String <span class="title">getProvince</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="内部类继承"><a href="#内部类继承" class="headerlink" title="内部类继承"></a>内部类继承</h2><p>内部类的继承，是指内部类被继承，普通类 extents 内部类。而这时候代码上要有点特别处理，具体看以下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123; </span><br><span class="line">	<span class="comment">// InheritInner() 是不能通过编译的，一定要加上形参 </span></span><br><span class="line">	InheritInner(WithInner wi) &#123; </span><br><span class="line">		wi.<span class="keyword">super</span>(); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		WithInner wi = <span class="keyword">new</span> WithInner(); </span><br><span class="line">		InheritInner obj = <span class="keyword">new</span> InheritInner(wi); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123; </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以看到子类的构造函数里面要使用<strong>父类的外部类对象.super()</strong>;而这个对象需要从外面创建并传给形参.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之泛型</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>泛型在JDK1.5引入，其本质是一种<strong>参数化类型（Parameterized Type），在使用时传入实际类型即可</strong>，即可以将操作的数据类型指定为方法签名中的一种特殊参数,可以作用在类、接口、方法中。泛型是编译期的一种概念，主要是用于编译期类型安全检查（编译之后泛型会被擦除）。</p>
<h3 id="常用泛型类型常量"><a href="#常用泛型类型常量" class="headerlink" title="常用泛型类型常量"></a>常用泛型类型常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E：元素（Element），多用于java集合框架</span><br><span class="line">K：关键字（Key）</span><br><span class="line">N：数字（Number）</span><br><span class="line">T：类型（Type）</span><br><span class="line">V：值（Value）</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="泛型反例"><a href="#泛型反例" class="headerlink" title="泛型反例"></a>泛型反例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		list.add(<span class="number">100</span>);</span><br><span class="line">		list.add(<span class="number">10.09</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">			System.out.println((String)list.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译期通过，并且运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">	at com.sunld.Test1.main(Test1.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>
<p><strong>如何在编译期完成校验？</strong></p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>与泛型类的定义类似，参考代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方式1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类的声明与非泛型类的类似，在类的名称后面增加类型参数。语法如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">className</span>&lt;泛型标识 <span class="keyword">extends</span>|<span class="title">super</span> 上限|下限, ...&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> genericType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。如果上限或下限有多个限制，可以使用<code>&amp;</code>处理。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。简单示例：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>一种可以接受不同参数类型的方法，并且可以根据入参进行参数返回，尤其是反射处理数据转换比较常用。</p>
<blockquote>
<p>注意：方法上是否定义泛型和类上是否定义没有必然的联系</p>
</blockquote>
<p>语法参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 第一个T表示泛型声明，只有声明之后才能使用</span></span><br><span class="line"><span class="comment">* 2. 第二个T表示返回值</span></span><br><span class="line"><span class="comment">* 3.第三个T限制入参的返回需要与第一个T一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">executeGenericMethod</span><span class="params">(Class&lt;T&gt; cls)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cls.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>泛型是编译期的概念，在编译之后的字节码中不包含泛型的信息（为了解决该问题，java在字节码中引入Signature、LocalVariableTypeTable）。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为<strong>类型擦除</strong>。比如：<code>List&lt;Object&gt;</code>和 <code>List&lt;String&gt;</code>等类型，在编译之后都会变成 <code>List</code>。JVM 看到的只是 List，而由泛型附加的类型信息对JVM来说是不可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericType2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> temp1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> temp2 =<span class="number">20</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> temp3=<span class="number">30</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment">//	public T getT() &#123;</span></span><br><span class="line"><span class="comment">//		return t;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public void setT(T t) &#123;</span></span><br><span class="line"><span class="comment">//		this.t = t;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public List&lt;String&gt; getList() &#123;</span></span><br><span class="line"><span class="comment">//		return list;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public void setList(List&lt;String&gt; list) &#123;</span></span><br><span class="line"><span class="comment">//		this.list = list;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">		map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;valueaa&quot;</span>);</span><br><span class="line">		String value = map.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//		TestGenericType2&lt;Integer&gt;[] array = new TestGenericType2&lt;Integer&gt;[10];</span></span><br><span class="line"><span class="comment">//		TestGenericType2&lt;Integer&gt;[] array1 = new TestGenericType2[10];</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后的结果：  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.TestGenericType2包含com.sunld.TestGenericType2</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/TestGenericType2.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">5</span>-<span class="number">14</span>; size <span class="number">1287</span> bytes</span><br><span class="line">  MD5 checksum 7ad53533c7723c97d0ec9bb863b415ca</span><br><span class="line">  Compiled from <span class="string">&quot;TestGenericType2.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">TestGenericType2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span>&gt; <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/TestGenericType2</span><br><span class="line">   #2 = Utf8               com/sunld/TestGenericType2</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               t</span><br><span class="line">   #6 = Utf8               Ljava/lang/Object;</span><br><span class="line">   #7 = Utf8               Signature</span><br><span class="line">   #8 = Utf8               TT;</span><br><span class="line">   #9 = Utf8               list</span><br><span class="line">  #10 = Utf8               Ljava/util/List;</span><br><span class="line">  #11 = Utf8               Ljava/util/List&lt;Ljava/lang/String;&gt;;</span><br><span class="line">  #12 = Utf8               temp1</span><br><span class="line">  #13 = Utf8               I</span><br><span class="line">  #14 = Utf8               temp2</span><br><span class="line">  #15 = Utf8               ConstantValue</span><br><span class="line">  #16 = Integer            20</span><br><span class="line">  #17 = Utf8               temp3</span><br><span class="line">  #18 = Integer            30</span><br><span class="line">  #19 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #20 = Utf8               ()V</span><br><span class="line">  #21 = Utf8               Code</span><br><span class="line">  #22 = Fieldref           #1.#23         // com/sunld/TestGenericType2.temp1:I</span><br><span class="line">  #23 = NameAndType        #12:#13        // temp1:I</span><br><span class="line">  #24 = Utf8               LineNumberTable</span><br><span class="line">  #25 = Utf8               LocalVariableTable</span><br><span class="line">  #26 = Utf8               &lt;init&gt;</span><br><span class="line">  #27 = Methodref          #3.#28         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #28 = NameAndType        #26:#20        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #29 = Fieldref           #1.#30         // com/sunld/TestGenericType2.temp2:I</span><br><span class="line">  #30 = NameAndType        #14:#13        // temp2:I</span><br><span class="line">  #31 = Utf8               this</span><br><span class="line">  #32 = Utf8               Lcom/sunld/TestGenericType2;</span><br><span class="line">  #33 = Utf8               LocalVariableTypeTable</span><br><span class="line">  #34 = Utf8               Lcom/sunld/TestGenericType2&lt;TT;&gt;;</span><br><span class="line">  #35 = Utf8               main</span><br><span class="line">  #36 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #37 = Class              #38            // java/util/HashMap</span><br><span class="line">  #38 = Utf8               java/util/HashMap</span><br><span class="line">  #39 = Methodref          #37.#28        // java/util/HashMap.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #40 = String             #41            // a</span><br><span class="line">  #41 = Utf8               a</span><br><span class="line">  #42 = String             #43            // valueaa</span><br><span class="line">  #43 = Utf8               valueaa</span><br><span class="line">  #44 = InterfaceMethodref #45.#47        // java/util/Map.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #45 = Class              #46            // java/util/Map</span><br><span class="line">  #46 = Utf8               java/util/Map</span><br><span class="line">  #47 = NameAndType        #48:#49        // put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #48 = Utf8               put</span><br><span class="line">  #49 = Utf8               (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #50 = InterfaceMethodref #45.#51        // java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #51 = NameAndType        #52:#53        // get:(Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #52 = Utf8               get</span><br><span class="line">  #53 = Utf8               (Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #54 = Class              #55            // java/lang/String</span><br><span class="line">  #55 = Utf8               java/lang/String</span><br><span class="line">  #56 = Utf8               args</span><br><span class="line">  #57 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #58 = Utf8               map</span><br><span class="line">  #59 = Utf8               Ljava/util/Map;</span><br><span class="line">  #60 = Utf8               value</span><br><span class="line">  #61 = Utf8               Ljava/lang/String;</span><br><span class="line">  #62 = Utf8               Ljava/util/Map&lt;Ljava/lang/String;Ljava/lang/String;&gt;;</span><br><span class="line">  #63 = Utf8               SourceFile</span><br><span class="line">  #64 = Utf8               TestGenericType2.java</span><br><span class="line">  #65 = Utf8               &lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         2: putstatic     #22                 // Field temp1:I</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.sunld.TestGenericType2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #27                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">         7: putfield      #29                 // Field temp2:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">10</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestGenericType2;</span><br><span class="line">      LocalVariableTypeTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestGenericType2&lt;TT;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #37                 // class java/util/HashMap</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #39                 // Method java/util/HashMap.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         9: ldc           #40                 // String a</span><br><span class="line">        11: ldc           #42                 // String valueaa</span><br><span class="line">        13: invokeinterface #44,  3           // InterfaceMethod java/util/Map.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">        <span class="number">18</span>: pop</span><br><span class="line">        <span class="number">19</span>: aload_1</span><br><span class="line">        20: ldc           #40                 // String a</span><br><span class="line">        22: invokeinterface #50,  2           // InterfaceMethod java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">        27: checkcast     #54                 // class java/lang/String</span><br><span class="line">        <span class="number">30</span>: astore_2</span><br><span class="line">        <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">45</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">46</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">47</span>: <span class="number">19</span></span><br><span class="line">        line <span class="number">50</span>: <span class="number">31</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">32</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>   map   Ljava/util/Map;</span><br><span class="line">           <span class="number">31</span>       <span class="number">1</span>     <span class="number">2</span> value   Ljava/lang/String;</span><br><span class="line">      LocalVariableTypeTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>   map   Ljava/util/Map&lt;Ljava/lang/String;Ljava/lang/String;&gt;;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestGenericType2.java&quot;</span></span><br><span class="line">Signature: #65                          // &lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</span><br></pre></td></tr></table></figure>
<p>从Signature属性的得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们在编码时能通过反射手段取得参数化类型的根本依据。</p>
<h3 id="擦除过程"><a href="#擦除过程" class="headerlink" title="擦除过程"></a>擦除过程</h3><p>首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</p>
<h3 id="泛型擦除的问题"><a href="#泛型擦除的问题" class="headerlink" title="泛型擦除的问题"></a>泛型擦除的问题</h3><ol>
<li>用泛型不可以区分方法签名</li>
<li>泛型类的静态变量是共享</li>
</ol>
<h2 id="泛型边界"><a href="#泛型边界" class="headerlink" title="泛型边界"></a>泛型边界</h2><ol>
<li><? extends T>表示该通配符所代表的类型是 T 类型的子类。</li>
<li><? super T>表示该通配符所代表的类型是 T 类型的父类。

</li>
</ol>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符?</h3><p>在java中如果使用泛型，例如<code>List&lt;Interger&gt;和List&lt;Number&gt;</code>其实是两种类型(<strong>类型之间转换会出现转换异常</strong>)，之间没有任务关系，如果想要接收不同类型的参数，则需要引入通配符的概念，<code>List&lt;?&gt;</code>（？表示所有泛型中的父类）<strong>泛型内是不存在父子关系，但是利用通配符可以产生类似的效果</strong>。</p>
<h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><p>假设给定的泛型类型为G,两个具体的泛型参数X、Y，当中Y是X的子类</p>
<ol>
<li>G&lt;? extends Y&gt; 是 G&lt;? extends X&gt;的子类型</li>
<li>G<X> 是 G&lt;? extends X&gt;的子类型</X></li>
<li>G&lt;?&gt; 与 G&lt;? extends Object&gt;等同</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>适用于多种数据类型执行相同的代码（代码复用）</li>
<li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li>
</ol>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol>
<li>不能实例化泛型类：<code>T t = new T();</code></li>
<li>静态变量不能引用泛型变量：<code>private static T t1;</code>；非静态变量可以引用：<code>private T t1;</code></li>
<li>未声明泛型的方法不能引用泛型变量：<code>public static T getT1()&#123;return t1;&#125;</code>；声明之后可以：<code>public static &lt;T&gt; T executeGenericMethod(Class&lt;T&gt; cls)&#123;return null;&#125;</code></li>
<li>基本类型无法作为泛型类型：<code>List&lt;int&gt; list = new ArrayList&lt;&gt;();</code></li>
<li>无法使用instanceof关键字或==判断泛型类的类型：<code>list instanceof List&lt;String&gt;</code> 或者<code>list == List&lt;String&gt;</code></li>
<li>泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的，即类型擦除之后的class信息相同</li>
<li>泛型数组可以声明但无法实例化：<code>Test1&lt;Integer&gt;[] array = new Test1&lt;Integer&gt;[10];</code>，去掉泛型即可<code>Test1&lt;Integer&gt;[] array = new Test1[10];</code></li>
<li>泛型类不能继承Exception或者Throwable</li>
<li>不能捕获泛型类型限定的异常但可以将泛型限定的异常抛出</li>
</ol>
<h3 id="泛型继承规则"><a href="#泛型继承规则" class="headerlink" title="泛型继承规则"></a>泛型继承规则</h3><ol>
<li>对于泛型参数是继承关系的泛型类之间是没有继承关系的：<code>List&lt;Integer&gt;与List&lt;Number&gt;</code></li>
<li>泛型类可以继承其它泛型类，例如: <code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</code></li>
<li>泛型类的继承关系在使用中同样会受到泛型类型的影响</li>
</ol>
<h2 id="泛型与反射"><a href="#泛型与反射" class="headerlink" title="泛型与反射"></a>泛型与反射</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericType1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestGenericType1&lt;Integer&gt; a = <span class="keyword">new</span> TestGenericType1&lt;Integer&gt;() &#123;&#125;;</span><br><span class="line">		Type superclass = a.getClass().getGenericSuperclass();</span><br><span class="line">		System.out.println(superclass);</span><br><span class="line">	    <span class="comment">//getActualTypeArguments 返回确切的泛型参数</span></span><br><span class="line">		Type type = ((ParameterizedType)superclass).getActualTypeArguments()[<span class="number">0</span>]; </span><br><span class="line">	    System.out.println(type);<span class="comment">//class java.lang.Integer</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/ldh-better/p/7127308.html#_label0">Java 泛型在实际开发中的应用</a></li>
<li><a href="https://www.jianshu.com/p/986f732ed2f1">Java泛型详解</a></li>
<li><a href="https://www.cnblogs.com/lwbqqyumidi/p/3837629.html">Java总结篇系列：Java泛型</a></li>
<li><a href="https://www.cnblogs.com/coprince/p/8603492.html">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之注解</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>在jdk1.5中引入了注解的概念，注解是Java提供的一种对类信息（包括：类、属性与方法）进行扩展的一种行为。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation 对象，然后通过该 Annotation 对象来获取注解中的元数据信息。通过使用注解，可以将元数据保存在 Java 源代码中。并拥有如下优势：</p>
<ol>
<li>简单易读的代码，</li>
<li>编译器类型检查，</li>
<li>使用 annotation API 为自己的注解构造处理工具。</li>
</ol>
<a id="more"></a>
<p>JDK中目前引入的注解：</p>
<ul>
<li><strong>@Override</strong>：表示当前的方法定义将覆盖基类的方法。如果你不小心拼写错误，或者方法签名被错误拼写的时候，编译器就会发出错误提示。</li>
<li><strong>@Deprecated</strong>：如果使用该注解的元素被调用，编译器就会发出警告信息。</li>
<li><strong>@SuppressWarnings</strong>：关闭不当的编译器警告信息。</li>
<li><strong>@SafeVarargs</strong>：在 Java 7 中加入用于禁止对具有泛型varargs参数的方法或构造函数的调用方发出警告。</li>
<li><strong>@FunctionalInterface</strong>：Java 8 中加入用于表示类型声明为函数式接口</li>
</ul>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/1588840779124.png" class title="Java注解思维导图">

</div>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>jdk中目前定义了5中标准的meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>@Target</td>
<td>表示注解可以用于哪些地方。可能的 <strong>ElementType</strong> 参数包括：<br><strong>CONSTRUCTOR</strong>：构造器的声明<br><strong>FIELD</strong>：字段声明（包括 enum 实例）<br><strong>LOCAL_VARIABLE</strong>：局部变量声明<br><strong>METHOD</strong>：方法声明<br><strong>PACKAGE</strong>：包声明<br><strong>PARAMETER</strong>：参数声明<br><strong>TYPE</strong>：类、接口（包括注解类型）或者 enum 声明</td>
</tr>
<tr>
<td>@Retention</td>
<td>表示注解信息保存的时长。可选的 <strong>RetentionPolicy</strong> 参数包括：<br><strong>SOURCE</strong>：注解将被编译器丢弃<br><strong>CLASS</strong>：注解在 class 文件中可用，但是会被 VM 丢弃。<br><strong>RUNTIME</strong>：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</td>
</tr>
<tr>
<td>@Documented</td>
<td>将此注解保存在 Javadoc 中</td>
</tr>
<tr>
<td>@Inherited</td>
<td>允许子类继承父类的注解</td>
</tr>
<tr>
<td>@Repeatable</td>
<td>允许一个注解可以被使用一次或者多次（Java 8）。</td>
</tr>
</tbody></table>
<h3 id="Target修饰的对象范围"><a href="#Target修饰的对象范围" class="headerlink" title="@Target修饰的对象范围"></a>@Target修饰的对象范围</h3><p><strong>@Target</strong>说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的作用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Retention定义被保留的时间长短"><a href="#Retention定义被保留的时间长短" class="headerlink" title="@Retention定义被保留的时间长短"></a>@Retention定义被保留的时间长短</h3><p><strong>@Retention</strong> 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：</p>
<ol>
<li>SOURCE:在源文件中有效（即源文件保留）</li>
<li>CLASS:在 class 文件中有效（即 class 保留）</li>
<li>RUNTIME:在运行时有效（即运行时保留）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体作用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Documented描述-javadoc"><a href="#Documented描述-javadoc" class="headerlink" title="@Documented描述-javadoc"></a>@Documented描述-javadoc</h3><p><strong>@Documented</strong> 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inherited阐述了某个被标注的类型是被继承的"><a href="#Inherited阐述了某个被标注的类型是被继承的" class="headerlink" title="@Inherited阐述了某个被标注的类型是被继承的"></a>@Inherited阐述了某个被标注的类型是被继承的</h3><p><strong>@Inherited</strong> 元注解是一个标记注解，**@Inherited** 阐述了某个被标注的类型是被继承的。如果一个使用了**@Inherited** 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该 class 的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span></span><br><span class="line"><span class="comment">     * repeatable annotation type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the containing annotation type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过注解实现一种日志记录的方式。</p>
<h3 id="LogAnnotation定义"><a href="#LogAnnotation定义" class="headerlink" title="LogAnnotation定义"></a>LogAnnotation定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation &#123;</span><br><span class="line">	<span class="comment">/** 日志类型 **/</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">	<span class="comment">/** 日志内容 **/</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">content</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@LogAnnotation(content = &quot;用户登录日志信息&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解元数据解析"><a href="#注解元数据解析" class="headerlink" title="注解元数据解析"></a>注解元数据解析</h3><p>getDeclaredMethods() 和 getAnnotation()，它们都属于 AnnotatedElement 接口（Class，Method 与 Field 类都实现了该接口）。getAnnotation() 方法返回指定类型的注解对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationUtil</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getLogInfo</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">		<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">			<span class="keyword">if</span> (method.isAnnotationPresent(LogAnnotation.class)) &#123;</span><br><span class="line">				LogAnnotation annotation = method.getAnnotation(LogAnnotation.class);</span><br><span class="line">				<span class="comment">// 注解信息的处理地方</span></span><br><span class="line">				System.out.println(annotation.content() + <span class="string">&quot; 类型：&quot;</span> + annotation.type());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		AnnotationUtil.getLogInfo(Login.class); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="默认值问题"><a href="#默认值问题" class="headerlink" title="默认值问题"></a>默认值问题</h3><ol>
<li>元素不能有不确定的值：要么使用默认值要么使用代码中定义的值</li>
<li>非基本类型的原始不能定义null，可以使用自定义约束来进行实现</li>
</ol>
<h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>单元测试</li>
<li>数据库相关的ORM操作</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://lingcoder.github.io/OnJava8/#/book/23-Annotations?id=%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95">编程思想</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Jdk1.6+mysql5.6+tomcat1.6安装</title>
    <url>/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Jdk"><a href="#Jdk" class="headerlink" title="Jdk"></a>Jdk</h2><h3 id="查看java的相关信息-yum-y-list-java"><a href="#查看java的相关信息-yum-y-list-java" class="headerlink" title="查看java的相关信息 yum -y list java*"></a>查看java的相关信息 yum -y list java*</h3><div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063041227.png" class title="查看java的相关信息 yum -y list java*">

</div>

<a id="more"></a>

<h3 id="使用root用户安装-yum-y-install-java-1-6-0-openjdk"><a href="#使用root用户安装-yum-y-install-java-1-6-0-openjdk" class="headerlink" title="使用root用户安装 yum -y install java-1.6.0-openjdk*"></a>使用root用户安装 yum -y install java-1.6.0-openjdk*</h3><div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063063934.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063070921.png" class>

</div>

<h3 id="查看安装情况-java-version"><a href="#查看安装情况-java-version" class="headerlink" title="查看安装情况 java -version"></a>查看安装情况 java -version</h3><div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063095031.png" class>

</div>

<h3 id="默认安装路径-usr-lib-jvm"><a href="#默认安装路径-usr-lib-jvm" class="headerlink" title="默认安装路径 /usr/lib/jvm"></a>默认安装路径 /usr/lib/jvm</h3><div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063117229.png" class>

</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;profile</span><br><span class="line">#JAVA INFO START</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_111</span><br><span class="line">export JRE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_111&#x2F;jre</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:$PATH</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">#JAVA INFO END</span><br></pre></td></tr></table></figure>
<p>保存，退出！  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; <span class="built_in">source</span> /etc/profile    <span class="comment">#使之立即生效</span></span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063195536.png" class>

</div>

<h4 id="建议也设置默认启动"><a href="#建议也设置默认启动" class="headerlink" title="建议也设置默认启动"></a>建议也设置默认启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;rc.local</span><br><span class="line"></span><br><span class="line">#JAVA INFO START</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_45</span><br><span class="line">export JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_45&#x2F;jre</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:$PATH</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$CLASSPATH</span><br><span class="line">#JAVA INFO END</span><br></pre></td></tr></table></figure>
<h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><h3 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h3><div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063283073.png" class>

</div>

<h3 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h3><div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063297873.png" class>

</div>

<h3 id="访问tomcat"><a href="#访问tomcat" class="headerlink" title="访问tomcat"></a>访问tomcat</h3><div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063313524.png" class>

</div>

<h3 id="管理tomcat"><a href="#管理tomcat" class="headerlink" title="管理tomcat"></a>管理tomcat</h3><div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063336994.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063351495.png" class>

</div>

<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol>
<li>查看操作系统相关信息</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/issue</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建需要下载rpm软件包的目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /taokey/tools</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看下是否有系统自带mysql的rpm包，如果有，需要删除自带的旧rpm包。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063466033.png" class>

</div>

<ol start="4">
<li>yum -y remove mysql-libs-5.1*</li>
</ol>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063488211.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063494660.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063507615.png" class>

</div>

<p>rpm -qa | grep mysql</p>
<ol start="5">
<li>在MySQL官网下载安装MySQL-5.6.21所需的rpm软件包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MySQL-client-5.6.21-1.rhel5.x86_64.rpm  </span><br><span class="line">MySQL-devel-5.6.21-1.rhel5.x86_64.rpm  </span><br><span class="line">MySQL-server-5.6.21-1.rhel5.x86_64.rpm</span><br><span class="line"></span><br><span class="line">wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-server-5.6.21-1.rhel5.x86_64.rpm</span><br><span class="line">wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-devel-5.6.21-1.rhel5.x86_64.rpm</span><br><span class="line">wget http://dev.mysql.com/Downloads/MySQL-5.6/MySQL-client-5.6.21-1.rhel5.x86_64.rpm</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063560437.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063565329.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063572043.png" class>

</div>

<h3 id="安装离线包"><a href="#安装离线包" class="headerlink" title="安装离线包"></a>安装离线包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bj_db1 tools]<span class="comment"># rpm -ivh MySQL-server-5.6.21-1.rhel5.x86_64.rpm</span></span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063659593.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063687872.png" class>

</div>

<p>安装MySQL-server报错，原因是没有安装libaio，系统缺少libaio.so此软件包，下边yum安装一下libaio.so软件包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bj_db1 tools]<span class="comment"># yum install -y libaio</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh MySQL-client-5.6.21-1.rhel5.x86_64.rpm</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063754258.png" class>

</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh MySQL-devel-5.6.21-1.rhel5.x86_64.rpm</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063779874.png" class>

</div>

<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/share/mysql/my-default.cnf /etc/my.cnf</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063822170.png" class>

</div>

<h3 id="初始化root密码"><a href="#初始化root密码" class="headerlink" title="初始化root密码"></a>初始化root密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bj_db1 tools]<span class="comment"># /usr/bin/mysql_install_db</span></span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063871500.png" class>

</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bj_db1 tools]<span class="comment"># ps -ef | grep mysql</span></span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063915297.png" class>

</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bj_db1 tools]<span class="comment"># netstat -anpt | grep 3306</span></span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063943633.png" class>

</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bj_db1 tools]<span class="comment"># more /root/.mysql_secret</span></span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063971034.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063975827.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063983400.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590063991353.png" class>

</div>

<h3 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h3><div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590064022373.png" class>

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590064027896.png" class>

</div>

<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> caibaitongdb <span class="keyword">default</span> charset utf8 <span class="keyword">COLLATE</span> utf8_bin;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Jdk1-6-mysql5-6-tomcat1-6%E5%AE%89%E8%A3%85/1590064060371.png" class>

</div>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>安装部署</tag>
        <tag>jdk</tag>
        <tag>mysql</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux cpu过高分析</title>
    <url>/2021/02/05/Linux-cpu%E8%BF%87%E9%AB%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="CPU使用率过高"><a href="#CPU使用率过高" class="headerlink" title="CPU使用率过高"></a>CPU使用率过高</h2><p>在高负载情况下CPU持续使用率高一般没有问题，但是导致任务无法正常调度或者load持续增加就需要重点关注，并且定位具体原因。（<strong>一般计算密集型应用 CPU 使用率偏高 load 偏低，IO 密集型相反。</strong>）</p>
<a id="more"></a>

<h3 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h3><div align="center">

<img src="/2021/02/05/Linux-cpu%E8%BF%87%E9%AB%98%E5%88%86%E6%9E%90/1587429499354.png" class title="CPU使用率计算公式">

</div>

<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ol>
<li>频繁 FullGC/YongGC</li>
<li>代码异常，出现死循环</li>
<li>死锁</li>
</ol>
<h3 id="定位步骤"><a href="#定位步骤" class="headerlink" title="定位步骤"></a>定位步骤</h3><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><ol>
<li>登录服务器之后使用<a href="#_Top">top</a>命令，并且输入1按照cpu使用率降序排序获取使用率最高的线程</li>
<li>perf top -g -p pid查看调用关系（-g开启调用关系分析，-p指定线程号）</li>
<li>top -Hp pid可以查看某个进程的线程信息（ ps mp pid -o THREAD,tid）</li>
<li>jstack 线程ID 可以查看某个线程的堆栈情况，特别对于hung挂死的线程，可以使用选项-F强制打印dump信息jstack -F pid</li>
<li>执行 jstack pid|grep -A 10 pid的16进制，得到线程堆栈信息中1371这个线程所在行的后面10行</li>
</ol>
<h2 id="load过高"><a href="#load过高" class="headerlink" title="load过高"></a>load过高</h2><h2 id="cpu-wait过高"><a href="#cpu-wait过高" class="headerlink" title="cpu_wait过高"></a>cpu_wait过高</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.aliyun.com/article/757655?spm=a2cdg.index.lists.18">重启大法好！线上常见问题排查手册</a></li>
<li><a href="https://github.com/alibaba/arthas">arthas开源组件</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>性能分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CPU过高</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux /proc/vmstat详解</title>
    <url>/2021/02/05/Linux-proc-vmstat%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>内核中虚拟内存的统计信息，对于性能分析有很大益处</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nr_free_pages 24320</span><br><span class="line">nr_alloc_batch 293</span><br><span class="line">nr_inactive_anon 13215</span><br><span class="line">nr_active_anon 58077</span><br><span class="line">nr_inactive_file 148719</span><br><span class="line">nr_active_file 172552</span><br><span class="line">nr_unevictable 0</span><br><span class="line">nr_mlock 0</span><br><span class="line">nr_anon_pages 19933</span><br><span class="line"><span class="comment"># 映射到文件的页数</span></span><br><span class="line">nr_mapped 8526</span><br><span class="line">nr_file_pages 348571</span><br><span class="line"><span class="comment"># 脏页数</span></span><br><span class="line">nr_dirty 16</span><br><span class="line"><span class="comment"># 会写页数</span></span><br><span class="line">nr_writeback 0</span><br><span class="line">nr_slab_reclaimable 17986</span><br><span class="line">nr_slab_unreclaimable 2986</span><br><span class="line"><span class="comment"># 分配到页面的页数</span></span><br><span class="line">nr_page_table_pages 1396</span><br><span class="line">nr_kernel_stack 123</span><br><span class="line"><span class="comment"># 不稳定页数</span></span><br><span class="line">nr_unstable 0</span><br><span class="line">nr_bounce 0</span><br><span class="line">nr_vmscan_write 0</span><br><span class="line">nr_vmscan_immediate_reclaim 26</span><br><span class="line">nr_writeback_temp 0</span><br><span class="line">nr_isolated_anon 0</span><br><span class="line">nr_isolated_file 0</span><br><span class="line">nr_shmem 27300</span><br><span class="line">nr_dirtied 8354426</span><br><span class="line">nr_written 8097732</span><br><span class="line">numa_hit 1187165492</span><br><span class="line">numa_miss 0</span><br><span class="line">numa_foreign 0</span><br><span class="line">numa_interleave 12459</span><br><span class="line">numa_local 1187165492</span><br><span class="line">numa_other 0</span><br><span class="line">workingset_refault 552268</span><br><span class="line">workingset_activate 81267</span><br><span class="line">workingset_nodereclaim 0</span><br><span class="line">nr_anon_transparent_hugepages 47</span><br><span class="line">nr_free_cma 0</span><br><span class="line">nr_dirty_threshold 94636</span><br><span class="line">nr_dirty_background_threshold 31545</span><br><span class="line"><span class="comment"># 从启动到现在读入的内存页数</span></span><br><span class="line">pgpgin 3168538</span><br><span class="line"><span class="comment"># 从启动到现在换出的内存页数</span></span><br><span class="line">pgpgout 49091671</span><br><span class="line"><span class="comment"># 从启动到现在读入的交换分区页数</span></span><br><span class="line">pswpin 0</span><br><span class="line"><span class="comment"># 从启动到现在换出的交换分区页数</span></span><br><span class="line">pswpout 0</span><br><span class="line"><span class="comment"># 从启动到现在dma存储区分配的页数</span></span><br><span class="line">pgalloc_dma 3730811</span><br><span class="line"><span class="comment"># 从启动到现在dma32存储区分配的页数</span></span><br><span class="line">pgalloc_dma32 1237816587</span><br><span class="line"><span class="comment"># 从启动到现在普通存储区分配的页数</span></span><br><span class="line">pgalloc_normal 0</span><br><span class="line">pgalloc_movable 0</span><br><span class="line"><span class="comment"># 从启动到现在释放的页数</span></span><br><span class="line">pgfree 1241571794</span><br><span class="line"><span class="comment"># 从启动到现在激活的页数</span></span><br><span class="line">pgactivate 2698296</span><br><span class="line"><span class="comment"># 从启动到现在去激活的页数</span></span><br><span class="line">pgdeactivate 747037</span><br><span class="line"><span class="comment"># 从启动到现在二级页面错误数</span></span><br><span class="line">pgfault 4099623847</span><br><span class="line"><span class="comment"># 从启动到现在一级页面错误数</span></span><br><span class="line">pgmajfault 4447</span><br><span class="line">pglazyfreed 0</span><br><span class="line"><span class="comment"># 从启动到现在DMA存储区再填充的页面数</span></span><br><span class="line">pgrefill_dma 2398</span><br><span class="line">pgrefill_dma32 778799</span><br><span class="line"><span class="comment"># 从启动到现在普通存储区填充的页数</span></span><br><span class="line">pgrefill_normal 0</span><br><span class="line">pgrefill_movable 0</span><br><span class="line">pgsteal_kswapd_dma 6587</span><br><span class="line">pgsteal_kswapd_dma32 1977434</span><br><span class="line">pgsteal_kswapd_normal 0</span><br><span class="line">pgsteal_kswapd_movable 0</span><br><span class="line">pgsteal_direct_dma 0</span><br><span class="line">pgsteal_direct_dma32 0</span><br><span class="line">pgsteal_direct_normal 0</span><br><span class="line">pgsteal_direct_movable 0</span><br><span class="line"><span class="comment"># 从启动到现在kswapd后台进程扫描的DMA存储区页面数</span></span><br><span class="line">pgscan_kswapd_dma 6645</span><br><span class="line">pgscan_kswapd_dma32 1992050</span><br><span class="line"><span class="comment"># 从启动到现在kswapd后台进程扫描的普通存储区页面数</span></span><br><span class="line">pgscan_kswapd_normal 0</span><br><span class="line">pgscan_kswapd_movable 0</span><br><span class="line"><span class="comment"># 从启动到现在DMA存储区被直接回收的页面数</span></span><br><span class="line">pgscan_direct_dma 0</span><br><span class="line">pgscan_direct_dma32 0</span><br><span class="line"><span class="comment"># 从启动到现在普通存储区被直接回收的页面数</span></span><br><span class="line">pgscan_direct_normal 0</span><br><span class="line">pgscan_direct_movable 0</span><br><span class="line">pgscan_direct_throttle 0</span><br><span class="line">zone_reclaim_failed 0</span><br><span class="line"><span class="comment"># kswapd 之外其他线程在回收过程中，因为回收 inode 而释放的 pagecache page 个数（累计值）</span></span><br><span class="line">pginodesteal 0</span><br><span class="line"><span class="comment"># 从启动到现在被扫描的切片数</span></span><br><span class="line">slabs_scanned 1120768</span><br><span class="line"><span class="comment"># 在kswapd回收的过程中，因为回收inode而释放的 pagecache page 个数（累计值）</span></span><br><span class="line">kswapd_inodesteal 105460</span><br><span class="line">kswapd_low_wmark_hit_quickly 47</span><br><span class="line">kswapd_high_wmark_hit_quickly 198</span><br><span class="line"><span class="comment"># 从启动到现在通过kswapd调用来回收的页面数</span></span><br><span class="line">pageoutrun 563</span><br><span class="line"><span class="comment"># 从启动到现在请求直接回收的页面数</span></span><br><span class="line">allocstall 0</span><br><span class="line"><span class="comment"># 从启动到现在轮换的页面数</span></span><br><span class="line">pgrotated 24</span><br><span class="line">drop_pagecache 0</span><br><span class="line">drop_slab 0</span><br><span class="line">numa_pte_updates 0</span><br><span class="line">numa_huge_pte_updates 0</span><br><span class="line">numa_hint_faults 0</span><br><span class="line">numa_hint_faults_local 0</span><br><span class="line">numa_pages_migrated 0</span><br><span class="line">pgmigrate_success 0</span><br><span class="line">pgmigrate_fail 0</span><br><span class="line">compact_migrate_scanned 0</span><br><span class="line">compact_free_scanned 0</span><br><span class="line">compact_isolated 0</span><br><span class="line">compact_stall 0</span><br><span class="line">compact_fail 0</span><br><span class="line">compact_success 0</span><br><span class="line">htlb_buddy_alloc_success 129</span><br><span class="line">htlb_buddy_alloc_fail 0</span><br><span class="line">unevictable_pgs_culled 0</span><br><span class="line">unevictable_pgs_scanned 0</span><br><span class="line">unevictable_pgs_rescued 0</span><br><span class="line">unevictable_pgs_mlocked 0</span><br><span class="line">unevictable_pgs_munlocked 0</span><br><span class="line">unevictable_pgs_cleared 0</span><br><span class="line">unevictable_pgs_stranded 0</span><br><span class="line">thp_fault_alloc 5482</span><br><span class="line">thp_fault_fallback 345</span><br><span class="line">thp_collapse_alloc 606</span><br><span class="line">thp_collapse_alloc_failed 48146</span><br><span class="line">thp_split 180</span><br><span class="line">thp_zero_page_alloc 2</span><br><span class="line">thp_zero_page_alloc_failed 0</span><br><span class="line">balloon_inflate 0</span><br><span class="line">balloon_deflate 0</span><br><span class="line">balloon_migrate 0</span><br><span class="line">swap_ra 0</span><br><span class="line">swap_ra_hit 0</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt">/proc/vmstat帮助手册</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>性能分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>proc</tag>
        <tag>vmstat</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux timewait问题分析</title>
    <url>/2021/02/05/Linux-timewait%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="TCP协议说明"><a href="#TCP协议说明" class="headerlink" title="TCP协议说明"></a>TCP协议说明</h2><p>TCP协议规定，对于已经建立的连接，网络双方要进行四次握手才能成功断开连接，如果缺少了其中某个步骤，将会使连接处于假死状态，连接本身占用的资源不会被释放。网络服务器程序要同时管理大量连接，所以很有必要保证无用连接完全断开，否则大量僵死的连接会浪费许多服务器资源。在众多TCP状态中，最值得注意的状态有两个：<strong>CLOSE_WAIT和TIME_WAIT。</strong></p>
<a id="more"></a>

<h3 id="TCP建立连接的过程"><a href="#TCP建立连接的过程" class="headerlink" title="TCP建立连接的过程"></a>TCP建立连接的过程</h3><div align="center">

<img src="/2021/02/05/Linux-timewait%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/1602666879773.png" class title="TCP建立连接的过程">

</div>

<h3 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h3><div align="center">

<img src="/2021/02/05/Linux-timewait%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/1602667375240.png" class title="TCP断开连接过程">

</div>

<h3 id="常用配置参数"><a href="#常用配置参数" class="headerlink" title="常用配置参数"></a>常用配置参数</h3><div align="center">

<img src="/2021/02/05/Linux-timewait%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/1602667762547.png" class title="tcp常用配置">

<img src="/2021/02/05/Linux-timewait%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/1606352049779.png" class title="tcp优化点">

</div>

<h2 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h2><h3 id="LISTENING状态"><a href="#LISTENING状态" class="headerlink" title="LISTENING状态"></a>LISTENING状态</h3><p>FTP服务启动后首先处于侦听（LISTENING）状态。</p>
<h3 id="ESTABLISHED状态"><a href="#ESTABLISHED状态" class="headerlink" title="ESTABLISHED状态"></a>ESTABLISHED状态</h3><p>ESTABLISHED的意思是建立连接。表示两台机器正在通信。</p>
<h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h3><p>对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭</p>
<h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p>我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。TCP协议规定TIME_WAIT状态会一直持续2MSL(Max Segment Lifetime，即两倍的分段最大生存期，Windows下默认为4分钟)，以此来确保旧的连接状态不会对新连接产生影响。<strong>处于TIME_WAIT状态的连接占用的资源不会被内核释放</strong>，所以作为服务器，在可能的情况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。  </p>
<p>目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误。<br><strong>TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证.</strong></p>
<h3 id="SYN-SENT状态"><a href="#SYN-SENT状态" class="headerlink" title="SYN_SENT状态"></a>SYN_SENT状态</h3><p>SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED，此时SYN_SENT状态非常短暂。但如果发现SYN_SENT非常多且在向不同的机器发出，那你的机器可能中了冲击波或震荡波 之类的病毒了。这类病毒为了感染别的计算机，它就要扫描别的计算机，在扫描的过程中对每个要扫描的计算机都要发出了同步请求，这也是出现许多 SYN_SENT的原因。</p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><div align="center">

<img src="/2021/02/05/Linux-timewait%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/1588043788007.png" class title="TCP状态转换图">


<img src="/2021/02/05/Linux-timewait%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/1594448316079.png" class title="TCP状态转换图">


</div>

<h2 id="TIME-WAIT配置"><a href="#TIME-WAIT配置" class="headerlink" title="TIME_WAIT配置"></a>TIME_WAIT配置</h2><h3 id="windows-机器设置"><a href="#windows-机器设置" class="headerlink" title="windows 机器设置"></a>windows 机器设置</h3><p>在HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters,右键添加名为TcpTimedWaitDelay的<br>DWORD键,设置为60,以缩短TIME_WAIT的等待时间</p>
<h3 id="ubuntu机器设置"><a href="#ubuntu机器设置" class="headerlink" title="ubuntu机器设置"></a>ubuntu机器设置</h3><p><code>vi /etc/sysctl.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1:表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击</span></span><br><span class="line"><span class="comment"># 默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="comment"># 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="comment"># 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line"><span class="comment"># 修改系統默认的 TIMEOUT 时间</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"><span class="comment"># 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</span></span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br><span class="line"><span class="comment"># 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8192</span><br><span class="line"><span class="comment"># 表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为5000。</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br></pre></td></tr></table></figure>
<h2 id="查看系统TCP连接资源命令"><a href="#查看系统TCP连接资源命令" class="headerlink" title="查看系统TCP连接资源命令"></a>查看系统TCP连接资源命令</h2><p><code>netstat -n | awk &#39;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</code></p>
<p>一般情况下，系统的socket资源默认5000个。（非官方）</p>
<h2 id="TCP协议中有TIME-WAIT这个状态的原因"><a href="#TCP协议中有TIME-WAIT这个状态的原因" class="headerlink" title="TCP协议中有TIME_WAIT这个状态的原因"></a>TCP协议中有TIME_WAIT这个状态的原因</h2><ol>
<li>防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）</li>
<li>可靠的关闭TCP连接。在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发<br>fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。</li>
</ol>
<h2 id="TIME-WAIT造成的影响"><a href="#TIME-WAIT造成的影响" class="headerlink" title="TIME_WAIT造成的影响"></a>TIME_WAIT造成的影响</h2><ol>
<li>场景：在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接，会出现大量socket处于TIME_WAIT状态<ol>
<li>高并发可以让服务器在短时间范围内同时占用大量端口（0~65535）</li>
<li>短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。</li>
</ol>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>命令参考《<a href="book/linux-netstat-ss.md">netstat/ss</a>》</li>
<li><a href="https://www.cnblogs.com/dadonggg/p/8778318.html">解决TIME_WAIT过多造成的问题</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>性能分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>timewait</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 性能分析思路与工具</title>
    <url>/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h2><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611133930457.png" class>

</div>
<a id="more"></a>

<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611133995578.png" class>

</div>

<h2 id="CPU时间量级"><a href="#CPU时间量级" class="headerlink" title="CPU时间量级"></a>CPU时间量级</h2><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134065698.png" class>

</div>

<h2 id="三部曲"><a href="#三部曲" class="headerlink" title="三部曲"></a>三部曲</h2><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134095303.png" class>

</div>

<h2 id="分析视角"><a href="#分析视角" class="headerlink" title="分析视角"></a>分析视角</h2><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134132100.png" class>

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134149886.png" class>

</div>

<h2 id="常用性能分析工具"><a href="#常用性能分析工具" class="headerlink" title="常用性能分析工具"></a>常用性能分析工具</h2><h3 id="CPU性能工具"><a href="#CPU性能工具" class="headerlink" title="CPU性能工具"></a>CPU性能工具</h3><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1594448604003.png" class>

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1594448790369.png" class>


</div>

<h3 id="内存分析工具"><a href="#内存分析工具" class="headerlink" title="内存分析工具"></a>内存分析工具</h3><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1594448638953.png" class>

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1594448740381.png" class>


</div>

<h3 id="文件磁盘性能分析工具"><a href="#文件磁盘性能分析工具" class="headerlink" title="文件磁盘性能分析工具"></a>文件磁盘性能分析工具</h3><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1594448675711.png" class>

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1594448755937.png" class>

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1594448777177.png" class>


</div>

<h3 id="网络性能分析工具"><a href="#网络性能分析工具" class="headerlink" title="网络性能分析工具"></a>网络性能分析工具</h3><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1594448706341.png" class>

</div>

<h3 id="Analysis-and-Tools"><a href="#Analysis-and-Tools" class="headerlink" title="Analysis and Tools"></a>Analysis and Tools</h3><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611133105522.png" class>

</div>

<h3 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h3><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134224092.png" class>

</div>

<h2 id="定位CPU瓶颈"><a href="#定位CPU瓶颈" class="headerlink" title="定位CPU瓶颈"></a>定位CPU瓶颈</h2><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134201912.png" class>

</div>

<h2 id="定位IO瓶颈"><a href="#定位IO瓶颈" class="headerlink" title="定位IO瓶颈"></a>定位IO瓶颈</h2><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134256935.png" class>

</div>

<h2 id="定位锁瓶颈"><a href="#定位锁瓶颈" class="headerlink" title="定位锁瓶颈"></a>定位锁瓶颈</h2><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134286008.png" class>

</div>

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134314979.png" class>

</div>

<h2 id="内存和对象管理"><a href="#内存和对象管理" class="headerlink" title="内存和对象管理"></a>内存和对象管理</h2><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134340771.png" class>

</div>

<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><div align="center">

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134379518.png" class>

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134384936.png" class>

<img src="/2021/02/05/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/1611134398412.png" class>

</div>

]]></content>
      <categories>
        <category>Linux</category>
        <category>性能分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令之TOP</title>
    <url>/2021/02/05/Linux%E5%91%BD%E4%BB%A4%E4%B9%8BTOP/</url>
    <content><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@incloudos logs]<span class="comment"># top -h</span></span><br><span class="line">  procps-ng version 3.3.10</span><br><span class="line">Usage:</span><br><span class="line">  top -hv | -bcHiOSs -d secs -n max -u|U user -p pid(s) -o field -w [cols]</span><br><span class="line">s – 改变画面更新频率</span><br><span class="line">l – 关闭或开启第一部分第一行 top 信息的表示</span><br><span class="line">t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示</span><br><span class="line">m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示</span><br><span class="line">N – 以 PID 的大小的顺序排列表示进程列表</span><br><span class="line">P – 以 CPU 占用率大小的顺序排列进程列表</span><br><span class="line">M – 以内存占用率大小的顺序排列进程列表</span><br><span class="line">h – 显示帮助</span><br><span class="line">n – 设置在进程列表所显示进程的数量</span><br><span class="line">q – 退出 top</span><br><span class="line">s – 改变画面更新周期</span><br><span class="line">请在top里面按下E，注意是大写。你会发现内存那一行的最左侧，</span><br><span class="line">也就是Mem前面，会有Kib、MiB、GiB等单位变化，</span><br><span class="line">但是数字后面不会直接写明单位。</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><ul>
<li>top查看进程使用资源情况</li>
<li>top -c显示详细的进程信息</li>
<li>top -bn1静态显示所有进程</li>
<li>q退出，数值1显示所有核cpu，大写字母M按内存使用排序，大写字母P按照cpu使用排序</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top - 19:40:49 up 104 days, 11:55,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:  87 total,   2 running,  85 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  2046936 total,   148592 free,   282184 used,  1616160 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  1461432 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    1 root      20   0  125496   3980   2516 S  0.0  0.2   5:54.39 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S  0.0  0.0   0:00.25 kthreadd</span><br><span class="line">    4 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H</span><br></pre></td></tr></table></figure>
<h2 id="显示列"><a href="#显示列" class="headerlink" title="显示列"></a>显示列</h2><p>默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0lax">序号</th>
    <th class="tg-0lax">列名</th>
    <th class="tg-0lax">解释</th>
  </tr>
  <tr>
    <td class="tg-0lax">a</td>
    <td class="tg-0lax">PID</td>
    <td class="tg-0lax">进程id</td>
  </tr>
  <tr>
    <td class="tg-0lax">b</td>
    <td class="tg-0lax">PPID</td>
    <td class="tg-0lax">父进程id</td>
  </tr>
  <tr>
    <td class="tg-0lax">c</td>
    <td class="tg-0lax">RUSER</td>
    <td class="tg-0lax">Real user name</td>
  </tr>
  <tr>
    <td class="tg-0lax">d</td>
    <td class="tg-0lax">UID</td>
    <td class="tg-0lax">进程所有者的用户id</td>
  </tr>
  <tr>
    <td class="tg-0lax">e</td>
    <td class="tg-0lax">USER</td>
    <td class="tg-0lax">进程所有者的用户名</td>
  </tr>
  <tr>
    <td class="tg-0lax">f</td>
    <td class="tg-0lax">GROUP</td>
    <td class="tg-0lax">进程所有者的组名</td>
  </tr>
  <tr>
    <td class="tg-0lax">g</td>
    <td class="tg-0lax">TTY</td>
    <td class="tg-0lax">启动进程的终端名。不是从终端启动的进程则显示为 ?</td>
  </tr>
  <tr>
    <td class="tg-0lax">h</td>
    <td class="tg-0lax">PR</td>
    <td class="tg-0lax">优先级</td>
  </tr>
  <tr>
    <td class="tg-0lax">i</td>
    <td class="tg-0lax">NI</td>
    <td class="tg-0lax">nice值。负值表示高优先级，正值表示低优先级</td>
  </tr>
  <tr>
    <td class="tg-0lax">j</td>
    <td class="tg-0lax">P</td>
    <td class="tg-0lax">最后使用的CPU，仅在多CPU环境下有意义</td>
  </tr>
  <tr>
    <td class="tg-0lax">k</td>
    <td class="tg-0lax">%CPU</td>
    <td class="tg-0lax">上次更新到现在的CPU时间占用百分比</td>
  </tr>
  <tr>
    <td class="tg-0lax">l</td>
    <td class="tg-0lax">TIME</td>
    <td class="tg-0lax">进程使用的CPU时间总计，单位秒</td>
  </tr>
  <tr>
    <td class="tg-0lax">m</td>
    <td class="tg-0lax">TIME+</td>
    <td class="tg-0lax">进程使用的CPU时间总计，单位1/100秒</td>
  </tr>
  <tr>
    <td class="tg-0lax">n</td>
    <td class="tg-0lax">%MEM</td>
    <td class="tg-0lax">进程使用的物理内存百分比，simply RES divided by total physical memory</td>
  </tr>
  <tr>
    <td class="tg-0lax">o</td>
    <td class="tg-0lax">VIRT</td>
    <td class="tg-0lax">
进程使用的虚拟内存总量，单位kb。<br>
VIRT：virtual memory usage 虚拟内存<br>
1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等<br>
2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量<br>
</td>
  </tr>
  
  <tr>
    <td class="tg-0lax">p</td>
    <td class="tg-0lax">SWAP</td>
    <td class="tg-0lax">进程使用的虚拟内存中，被换出的大小，单位kb。</td>
  </tr>
  <tr>
    <td class="tg-0lax">q</td>
    <td class="tg-0lax">RES</td>
    <td class="tg-0lax">
进程使用的、未被换出的物理内存大小，单位kb。<br>
RES：resident memory usage 常驻内存
</td>
  </tr>
  <tr>
    <td class="tg-0lax">r</td>
    <td class="tg-0lax">CODE</td>
    <td class="tg-0lax">可执行代码占用的物理内存大小，单位kb</td>
  </tr>
  <tr>
    <td class="tg-0lax">s</td>
    <td class="tg-0lax">DATA</td>
    <td class="tg-0lax">
可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb<br>
1、数据占用的内存。如果top没有显示，按f键可以显示出来。<br>
2、真正的该程序要求的数据空间，是真正在运行中要使用的。<br>
</td>
  </tr>
  <tr>
    <td class="tg-0lax">t</td>
    <td class="tg-0lax">SHR</td>
    <td class="tg-0lax">
共享内存大小，单位kb<br>
SHR：shared memory 共享内存<br>
1、除了自身进程的共享内存，也包括其他进程的共享内存<br>
2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小<br>
3、swap out后，它将会降下来<br>
</td>
  </tr>
  <tr>
    <td class="tg-0lax">u</td>
    <td class="tg-0lax">nFLT</td>
    <td class="tg-0lax">页面错误次数</td>
  </tr>
  <tr>
    <td class="tg-0lax">v</td>
    <td class="tg-0lax">nDRT</td>
    <td class="tg-0lax">最后一次写入到现在，被修改过的页面数。</td>
  </tr>
  <tr>
    <td class="tg-0lax">w</td>
    <td class="tg-0lax">S</td>
    <td class="tg-0lax">进程状态。（D=不可中断的睡眠状态，R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</td>
  </tr>
  <tr>
    <td class="tg-0lax">x</td>
    <td class="tg-0lax">COMMAND</td>
    <td class="tg-0lax">命令名/命令行</td>
  </tr>
  <tr>
    <td class="tg-0lax">y</td>
    <td class="tg-0lax">WCHAN</td>
    <td class="tg-0lax">若该进程在睡眠，则显示睡眠中的系统函数名</td>
  </tr>
  <tr>
    <td class="tg-0lax">z</td>
    <td class="tg-0lax">Flags</td>
    <td class="tg-0lax">任务标志，参考 sched.h</td>
  </tr>
</table>

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>top命令作为Linux下最常用的性能分析工具之一，可以监控、收集进程的CPU、IO、内存使用情况。比如我们可以通过top命令获得一个进程使用了多少虚拟内存（VIRT）、物理内存（RES）、共享内存（SHR）。</p>
<h2 id="VIRT-RES-SHR的准确含义"><a href="#VIRT-RES-SHR的准确含义" class="headerlink" title="VIRT RES SHR的准确含义"></a>VIRT RES SHR的准确含义</h2><ol>
<li>top命令通过解析/proc/&lt;pid&gt;/statm统计VIRT和RES和SHR字段值。</li>
<li>VIRT是申请的虚拟内存总量。</li>
<li>RES是进程使用的物理内存总和。</li>
<li>SHR是RES中”映射至文件”的物理内存总和。包括：<ul>
<li>程序的代码段。</li>
<li>动态库的代码段。</li>
<li>通过mmap做的文件映射。</li>
<li>通过mmap做的匿名映射，但指明了MAP_SHARED属性。</li>
<li>通过shmget申请的共享内存。</li>
</ul>
</li>
<li>/proc/&lt;pid&gt;/smaps内Shared_*统计的是RES中映射数量&gt;=2的物理内存。</li>
<li>/proc/&lt;pid&gt;/smaps内Private_*统计的是RES中映射数量=1的物理内存。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.sina.com.cn/s/blog_4e41487001016eio.html">剖析top命令显示的VIRT RES SHR值</a></li>
<li><a href="https://www.cnblogs.com/shengulong/p/8513652.html">top命令查看线程信息和jstack使用介绍</a></li>
<li><a href="http://blog.51cto.com/13578154/2088684">10.1-10.5 w查看系统负载 vmstat , top, sar, nload</a></li>
<li><a href="http://man7.org/linux/man-pages/man1/top.1.html">Linux TOP官方帮助文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>性能分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>TOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令之iostat</title>
    <url>/2021/02/05/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Biostat/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>iostat 主要用于输出磁盘IO 和 CPU的统计信息。<br>iostat属于sysstat软件包。可以用yum install sysstat 直接安装。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: iostat [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]</span><br><span class="line">Options are:</span><br><span class="line">[ -c ] [ -d ] [ -h ] [ -k | -m ] [ -N ] [ -t ] [ -V ] [ -x ] [ -y ] [ -z ]</span><br><span class="line">[ -j &#123; ID | LABEL | PATH | UUID | ... &#125; ]</span><br><span class="line">[ [ -T ] -g &lt;group_name&gt; ] [ -p [ &lt;device&gt; [,...] | ALL ] ]</span><br><span class="line">[ &lt;device&gt; [...] | ALL ]</span><br></pre></td></tr></table></figure>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul>
<li>-c： 显示CPU使用情况</li>
<li>-d： 显示磁盘使用情况</li>
<li>-N： 显示磁盘阵列(LVM) 信息</li>
<li>-n： 显示NFS 使用情况</li>
<li>-k： 以 KB 为单位显示</li>
<li>-m： 以 M 为单位显示</li>
<li>-t： 报告每秒向终端读取和写入的字符数和CPU的信息</li>
<li>-V： 显示版本信息</li>
<li>-x： 显示详细信息</li>
<li>-p：[磁盘] 显示磁盘和分区的情况<a id="more"></a>

</li>
</ul>
<h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><h3 id="显示所有设备负载情况"><a href="#显示所有设备负载情况" class="headerlink" title="显示所有设备负载情况"></a>显示所有设备负载情况</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Linux 3.10.0-1062.4.1.el7.x86_64 (instance-gctg007a) 	04/20/2020 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.60    0.05    0.46    0.04    0.01   98.85</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">vda               1.33         0.07        11.68     657419  105232080</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>第一行</td>
<td>最上面指示系统版本、主机名和当前日期</td>
</tr>
<tr>
<td>avg-cpu</td>
<td>总体cpu使用情况统计信息，对于多核cpu，这里为所有cpu的平均值</td>
</tr>
<tr>
<td>Device</td>
<td>各磁盘设备的IO统计信息</td>
</tr>
</tbody></table>
<h4 id="cpu属性值说明"><a href="#cpu属性值说明" class="headerlink" title="cpu属性值说明"></a>cpu属性值说明</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%user</td>
<td>CPU在用户态执行进程的时间百分比。</td>
</tr>
<tr>
<td>%nice</td>
<td>CPU在用户态模式下，用于nice操作，所占用CPU总时间的百分比</td>
</tr>
<tr>
<td>%system</td>
<td>CPU处在内核态执行进程的时间百分比</td>
</tr>
<tr>
<td>%iowait</td>
<td>CPU用于等待I/O操作占用CPU总时间的百分比</td>
</tr>
<tr>
<td>%steal</td>
<td>管理程序(hypervisor)为另一个虚拟进程提供服务而等待虚拟CPU的百分比</td>
</tr>
<tr>
<td>%idle</td>
<td>CPU空闲时间百分比</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 若 %iowait 的值过高，表示硬盘存在I/O瓶颈 </span><br><span class="line">2. 若 %idle 的值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量 </span><br><span class="line">3. 若 %idle 的值持续低于1，则系统的CPU处理能力相对较低，表明系统中最需要解决的资源是 CPU</span><br></pre></td></tr></table></figure>
<h4 id="disk属性值说明"><a href="#disk属性值说明" class="headerlink" title="disk属性值说明"></a>disk属性值说明</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Device</td>
<td>设备名称</td>
</tr>
<tr>
<td>tps</td>
<td>每秒向磁盘设备请求数据的次数，包括读、写请求，为rtps与wtps的和。出于效率考虑，每一次IO下发后并不是立即处理请求，而是将请求合并(merge)，这里tps指请求合并后的请求计数。</td>
</tr>
<tr>
<td>Blk_read/s</td>
<td>Indicate the amount of data read from the device expressed in a number of blocks per second. Blocks are equivalent to sectors with kernels 2.4 and later and therefore have a size of 512 bytes. With older kernels, a block is of indeterminate size.</td>
</tr>
<tr>
<td>Blk_wrtn/s</td>
<td>Indicate the amount of data written to the device expressed in a number of blocks per second.</td>
</tr>
<tr>
<td>Blk_read</td>
<td>取样时间间隔内读扇区总数量</td>
</tr>
<tr>
<td>Blk_wrtn</td>
<td>取样时间间隔内写扇区总数量</td>
</tr>
</tbody></table>
<ul>
<li>iostat 1 5：间隔1秒，总共显示5次</li>
<li>iostat -d 2：每隔2秒,显示一次设备统计信息.</li>
<li>iostat -d 2 3：每隔2秒,显示一次设备统计信息.总共输出3次.</li>
<li>iostat -x sda sdb 2 3：每隔2秒显示一次sda, sdb两个设备的扩展统计信息,共输出3次.</li>
<li>iostat -p sda 2 3：每隔2秒显示一次sda及上面所有分区的统计信息,共输出3次.</li>
<li>iostat -m：以M为单位显示所有信息</li>
<li>iostat -d sda：显示指定硬盘信息</li>
<li>iostat -t：报告每秒向终端读取和写入的字符数。</li>
<li>iostat -d -k 1 1：查看TPS和吞吐量信息            </li>
<li>iostat -d -x -k 1 1：查看设备使用率（%util）、响应时间（await）</li>
<li>iostat -c 1 2：间隔1秒显示一次，总共显示2次（查看CPU的状态）</li>
</ul>
<h4 id="显示详细负载信息"><a href="#显示详细负载信息" class="headerlink" title="显示详细负载信息"></a>显示详细负载信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Linux 3.10.0-1062.4.1.el7.x86_64 (instance-gctg007a) 	04/20/2020 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.00     1.14    0.00    1.32     0.07    11.68    17.72     0.00    0.87    5.07    0.86   0.47   0.06</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rrqm/s</td>
<td>每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并</td>
</tr>
<tr>
<td>wrqm/s</td>
<td>每秒对该设备的写请求被合并次数</td>
</tr>
<tr>
<td>r/s</td>
<td>每秒完成的读 I/O 设备次数</td>
</tr>
<tr>
<td>w/s</td>
<td>每秒完成的写 I/O 设备次数</td>
</tr>
<tr>
<td>rkB/s</td>
<td>每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节</td>
</tr>
<tr>
<td>wkB/s</td>
<td>每秒写K字节数。是 wsect/s 的一半</td>
</tr>
<tr>
<td>avgrq-sz</td>
<td>平均每次IO操作的数据量(扇区数为单位)</td>
</tr>
<tr>
<td>avgqu-sz</td>
<td>平均等待处理的IO请求队列长度</td>
</tr>
<tr>
<td>rsec/s</td>
<td>每秒读扇区数。即 rsect/s</td>
</tr>
<tr>
<td>wsec/s</td>
<td>每秒写扇区数。即 wsect/s</td>
</tr>
<tr>
<td>r_await</td>
<td>每个读操作平均所需的时间，不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间</td>
</tr>
<tr>
<td>w_await</td>
<td>每个写操作平均所需的时间，不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间</td>
</tr>
<tr>
<td>await</td>
<td>平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)</td>
</tr>
<tr>
<td>svctm</td>
<td>平均每次IO请求的处理时间(毫秒为单位)</td>
</tr>
<tr>
<td>%util</td>
<td>采用周期内用于IO操作的时间比率，即IO队列非空的时间比率；一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>备注：如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。如果avgqu-sz比较大，也表示有当量io在等待。</strong></p>
</blockquote>
<h4 id="重点关注参数"><a href="#重点关注参数" class="headerlink" title="重点关注参数"></a>重点关注参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、iowait% 表示CPU等待IO时间占整个CPU周期的百分比，如果iowait值超过50%，或者明显大于%system、%user以及%idle，表示IO可能存在问题。</span><br><span class="line">2、avgqu-sz 表示磁盘IO队列长度，即IO等待个数。</span><br><span class="line">3、await 表示每次IO请求等待时间，包括等待时间和处理时间</span><br><span class="line">4、svctm 表示每次IO请求处理的时间</span><br><span class="line">5、%util 表示磁盘忙碌情况，一般该值超过80%表示该磁盘可能处于繁忙状态。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>性能分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>iostat</tag>
        <tag>磁盘分析</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis系统化学习之缓存</title>
    <url>/2021/02/05/MyBatis%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>Mybatis中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的 sqlsession 是可以共享的。</p>
<a id="more"></a>

<div align="center">

<img src="/2021/02/05/MyBatis%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BC%93%E5%AD%98/1589028256048.png" class title="MyBatis缓存示意图">

</div>

<h2 id="Mybatis-的一级缓存原理（sqlsession-级别）"><a href="#Mybatis-的一级缓存原理（sqlsession-级别）" class="headerlink" title="Mybatis 的一级缓存原理（sqlsession 级别）"></a>Mybatis 的一级缓存原理（sqlsession 级别）</h2><p>第一次发出一个查询 sql，sql 查询结果写入 sqlsession 的一级缓存中，缓存使用的数据结构是一个 map。<br>key：MapperID+offset+limit+Sql+所有的入参<br>value：用户信息<br>同一个 sqlsession 再次发出相同的 sql，就从缓存中取出数据。如果两次中间出现 commit 操作（修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。 </p>
<h2 id="二级缓存原理（mapper-基本）"><a href="#二级缓存原理（mapper-基本）" class="headerlink" title="二级缓存原理（mapper 基本）"></a>二级缓存原理（mapper 基本）</h2><p>二级缓存的范围是mapper 级别（mapper同一个命名空间），mapper以命名空间为单位创建缓存数据结构，结构是 map。mybatis 的二级缓存是通过 CacheExecutor 实现的。CacheExecutor 其实是 Executor 的代理对象。所有的查询操作，在 CacheExecutor 中都会先匹配缓存中是否存在，不存在则查询数据库。<br>key：MapperID+offset+limit+Sql+所有的入参<br>具体使用需要配置： </p>
<ol>
<li>   Mybatis 全局配置中启用二级缓存配置 </li>
<li>   在对应的 Mapper.xml 中配置 cache 节点 </li>
<li>   在对应的 select 查询节点中添加 useCache=true </li>
</ol>
]]></content>
      <categories>
        <category>开源框架</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>MyBatis</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之优化技巧</title>
    <url>/2021/02/04/MySQL%E4%B9%8B%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h2><ol>
<li>配置文件的快速查找<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/libexec/mysqld --verbose --<span class="built_in">help</span>|grep -A 1 <span class="string">&#x27;Default options&#x27;</span></span><br><span class="line">200815 16:01:04 [Note] Plugin <span class="string">&#x27;FEEDBACK&#x27;</span> is disabled.</span><br><span class="line">Default options are <span class="built_in">read</span> from the following files <span class="keyword">in</span> the given order:</span><br><span class="line">/etc/mysql/my.cnf /etc/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure></li>
<li>配置项使用小写，单词之间使用横线或下划线分隔，并且使用统一的规范</li>
<li>作用域：全局、会话、对象<a id="more"></a>

</li>
</ol>
<h2 id="Buffer-Pool设置思路"><a href="#Buffer-Pool设置思路" class="headerlink" title="Buffer Pool设置思路"></a>Buffer Pool设置思路</h2><ol>
<li>从服务器内存开始，减去系统本身使用内存，减去其他服务使用内存（如果存在）</li>
<li>减去MySQL本身使用到的内存（比如为每个查询操作分配的一些缓冲）</li>
<li>减去足够让操作系统缓存InnoDB日志文件的内存，至少是足够缓存最近经常访问的部分；预留至少可以缓存二进制日志最后一部分以便用于主从复制</li>
<li>减去其他配置的MySQL缓冲和缓存需要的内存（比如MyISAM的Key Cache或Query Cache）</li>
<li>除以105%，向下取整</li>
</ol>
<h2 id="InnoDB缓冲池（InnoDB-Buffer-Pool）"><a href="#InnoDB缓冲池（InnoDB-Buffer-Pool）" class="headerlink" title="InnoDB缓冲池（InnoDB Buffer Pool）"></a>InnoDB缓冲池（InnoDB Buffer Pool）</h2><h3 id="缓存内容"><a href="#缓存内容" class="headerlink" title="缓存内容"></a>缓存内容</h3><ol>
<li>索引</li>
<li>行数据</li>
<li>自适应哈希索引</li>
<li>Insert Buffer</li>
<li>锁</li>
<li>其他内部数据结构</li>
</ol>
<h2 id="线程缓存"><a href="#线程缓存" class="headerlink" title="线程缓存"></a>线程缓存</h2><ol>
<li>保存当前没有与连接关联但是准备为后面新的连接服务的线程。</li>
<li>使用<strong>thread_cache_size</strong>进行设置。</li>
<li>线程池中的每个线程或者休眠状态的线程占用内存大小为256KB。</li>
<li>常用观察参数<ul>
<li>Threads_cached：线程缓存内的线程的数量。</li>
<li>Threads_connected：当前打开的连接的数量。</li>
<li>Threads_created：创建用来处理连接的线程数。如果Threads_created较大，你可能要增加thread_cache_size值。缓存访问率的计算方法Threads_created/Connections。</li>
<li>Threads_running：激活的（非睡眠状态）线程数</li>
</ul>
</li>
</ol>
<h2 id="Table-Cache"><a href="#Table-Cache" class="headerlink" title="Table Cache"></a>Table Cache</h2><ol>
<li>表.frm文件的解析结果</li>
<li>打开表的缓存：table_open_cache，每个线程独有（表.frm文件的解析结果）</li>
<li>表定义缓存：table_definition_cache，全局</li>
<li>参考opened_tables参数进行缓存配置的调整</li>
</ol>
<h2 id="IO配置"><a href="#IO配置" class="headerlink" title="IO配置"></a>IO配置</h2><h2 id="并发配置"><a href="#并发配置" class="headerlink" title="并发配置"></a>并发配置</h2><ol>
<li>innodb_thread_concurrency：CPU数量 * 磁盘数量 * 2</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>调优</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之原理分析-Count</title>
    <url>/2021/02/07/MySQL%E4%B9%8B%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-Count/</url>
    <content><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>COUNT(expr) [over_clause]</p>
<p>Returns a count of the number of non-NULL values of expr in the rows retrieved by a SELECT statement. The result is a BIGINT value.</p>
<p>If there are no matching rows, COUNT() returns 0.</p>
<p>This function executes as a window function if over_clause is present. over_clause is as described in Section 12.21.2, “Window Function Concepts and Syntax”.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> student.student_name,<span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">       <span class="keyword">FROM</span> student,course</span><br><span class="line">       <span class="keyword">WHERE</span> student.student_id<span class="operator">=</span>course.student_id</span><br><span class="line">       <span class="keyword">GROUP</span> <span class="keyword">BY</span> student_name;</span><br></pre></td></tr></table></figure>
<p>COUNT(*) is somewhat different in that it returns a count of the number of rows retrieved, whether or not they contain NULL values.</p>
<a id="more"></a>

<p>通过官方文档说明可以得出以下结论：  </p>
<ol>
<li>返回的是<code>select</code>中<code>expr</code>不为<code>null</code>的数据</li>
<li>返回的数据类型是<code>bigint</code></li>
<li>如果命中数据则返回0</li>
<li>count(*)包含值为null的行数，count(column_name)返回的是该列非空的数据</li>
<li>一种聚合方式，用于统计结果集</li>
<li>用法：count(*)、count(pkid)、count(cloumn_name)、count(1)</li>
</ol>
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。所以，count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test_count` (</span><br><span class="line">  `a` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> test_count <span class="keyword">VALUES</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> test_count <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> test_count <span class="keyword">VALUES</span>(<span class="number">11</span>, <span class="number">112</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> test_count <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="keyword">null</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="count-、count-常量）与count-column-name-的区别"><a href="#count-、count-常量）与count-column-name-的区别" class="headerlink" title="count(*)、count(常量）与count(column_name)的区别"></a>count(*)、count(常量）与count(column_name)的区别</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [test]<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_count;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+</span></span><br><span class="line"><span class="operator">|</span> a    <span class="operator">|</span> b    <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">11</span>   <span class="operator">|</span> <span class="number">112</span>  <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [test]<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">count</span>(a),<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> test_count;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> <span class="built_in">count</span>(a) <span class="operator">|</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span>        <span class="number">3</span> <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>通过运行结果可知：<strong>COUNT(常量) 和 COUNT(<em>)表示的是直接查询符合条件的数据库表的行数（可为null）。而COUNT(column_name)表示的是查询符合条件的列的值不为NULL的行数。**<br>另外，COUNT(</em>)是 **SQL92</strong> 定义的标准统计行数的语法，因为他是标准语法，所以MySQL数据库对他进行过很多优化。</p>
<blockquote>
<p>SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）。</p>
</blockquote>
<h3 id="Count-优化"><a href="#Count-优化" class="headerlink" title="Count(*)优化"></a>Count(*)优化</h3><p>MySQL针对不同的存储引擎做了不同的优化，目前常用的存储引擎是InnoDB和MyISAM。这两种存储引擎关键的区别是<strong>MyISAM不支持事务，MyISAM中的锁是表级锁；而InnoDB支持事务，并且支持行级锁。</strong></p>
<ol>
<li>MyISAM优化：（前提：<strong>单表，无其他返回数据、无where</strong>），数据库会把表的总行单独记录（保障条件：表级锁，数据是顺序处理），COUNT(1) is only subject to the same optimization if the first column is defined as NOT NULL.</li>
<li>InnoDB优化：由于事务性，所以数据变化的可能性会增大，导致看到的数据量是不准确的；SELECT COUNT(*) statements only count rows visible to the current transaction；InnoDB在数据扫描过程中做了优化<ul>
<li>MySQL 5.7.18之前使用的是<code>clustered index</code>扫描</li>
<li>MySQL 5.7.18之后会优先使用<code>secondary index</code>，如果索引没有完全在buffer pool可能会导致比较耗时，一种实现方式可以使用一种计数器来实现。（非主键索引的必要性）</li>
</ul>
</li>
</ol>
<h3 id="count-与count-1"><a href="#count-与count-1" class="headerlink" title="count(*)与count(1)"></a>count(*)与count(1)</h3><blockquote>
<p>InnoDB handles SELECT COUNT(<em>) and SELECT COUNT(1) operations in the same way. There is no performance difference.<br>总结：官方说明count(</em>)与count(1)在性能上是没有差异，建议大家使用count(*)</p>
</blockquote>
<h3 id="执行统计原理"><a href="#执行统计原理" class="headerlink" title="执行统计原理"></a>执行统计原理</h3><h4 id="count-主键-id"><a href="#count-主键-id" class="headerlink" title="count(主键 id)"></a>count(主键 id)</h4><p>InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
<h4 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h4><p>InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。单看这两个用法的差别的话，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p>
<h4 id="count-字段"><a href="#count-字段" class="headerlink" title="count(字段)"></a>count(字段)</h4><p>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；<br>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</p>
<h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><p>并不会把全部字段取出来，而是专门做了优化，不取值。count(<em>)按行累加。结论如下：<br>按照效率排序，count(字段)&lt;count(主键id)&lt;count(1)≈count(</em>)</p>
<h3 id="COUNT-DISTINCT-expr-expr…-使用"><a href="#COUNT-DISTINCT-expr-expr…-使用" class="headerlink" title="COUNT(DISTINCT expr,[expr…])使用"></a>COUNT(DISTINCT expr,[expr…])使用</h3><p>COUNT(DISTINCT expr,[expr…])</p>
<p>Returns a count of the number of rows with different non-NULL expr values.</p>
<p>If there are no matching rows, COUNT(DISTINCT) returns 0.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> results) <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure>
<p>In MySQL, you can obtain the number of distinct expression combinations that do not contain NULL by giving a list of expressions. In standard SQL, you would have to do a concatenation of all expressions inside COUNT(DISTINCT …).</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="阿里规范"><a href="#阿里规范" class="headerlink" title="阿里规范"></a>阿里规范</h3><ol>
<li>【强制】不要使用count(列名)或count(常量)来替代count(<em>)，count(</em>)是SQL92定义的标准统计行数的语法，与数据库无关，与NULL和非NULL无关。<blockquote>
<p>说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列值为NULL的行。</p>
</blockquote>
</li>
<li>【强制】count(distinct column) 计算该列除NULL外的不重复行数。<blockquote>
<p>注意，count(distinct column1, column2)，如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。</p>
</blockquote>
</li>
<li>【强制】当某一列的值全为NULL时，count(column)的返回结果为0，但sum(column)的返回结果为NULL，因此使用sum()时需注意避免NPE问题。<blockquote>
<p>正例：可以使用如下方式避免sum的NPE问题：SELECT IFNULL(SUM(column), 0) FROM table;</p>
</blockquote>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.toutiao.com/i6790650338174042632/">简简单单SELECT COUNT语句，竟被面试官吊起来锤</a></li>
<li><a href="https://www.mysqlzh.com/">MySQL中文官方文档</a></li>
<li><a href="https://dev.mysql.com/doc/">MySQL英文官方文档</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-functions.html#function_count">MySQL Count官方语法</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Count</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之原理分析-排序</title>
    <url>/2021/02/14/MySQL%E4%B9%8B%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><div align="center">

<img src="/2021/02/14/MySQL%E4%B9%8B%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.jpg" class title="常用排序算法">

</div>

<h2 id="sort-buffer-size"><a href="#sort-buffer-size" class="headerlink" title="sort_buffer_size"></a>sort_buffer_size</h2><h3 id="sort-buffer-size的特点"><a href="#sort-buffer-size的特点" class="headerlink" title="sort_buffer_size的特点"></a>sort_buffer_size的特点</h3><ol>
<li>每个线程都会分配一个固定的大小，作为排序的buffer</li>
<li>默认256KB，线程独有</li>
<li>使用场景：排序比较大，且内存充足、并发不大时，可以适当增加该值，如果太大会耗尽内存（例如：500个连接将会消耗 500*sort_buffer_size(8M)=4G内存）</li>
<li>connection级别的参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存</li>
<li>内存分配方式：超过2KB的时候，就会使用mmap() 而不是 malloc() 来进行内存分配，导致效率降低</li>
<li>调优检查：explain select*from table where order limit；出现filesort（外部排序）</li>
</ol>
<a id="more"></a>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort_buffer_size &#x3D; 512K</span><br></pre></td></tr></table></figure>
<h3 id="sort-buffer-size与待排序数据（data）的关系"><a href="#sort-buffer-size与待排序数据（data）的关系" class="headerlink" title="sort_buffer_size与待排序数据（data）的关系"></a>sort_buffer_size与待排序数据（data）的关系</h3><ol>
<li>data &lt;= sort buffer：在内存中进行排序即可。内部排序使用的是<strong>快速排序</strong>（<strong>内排序</strong>）</li>
<li>data &gt; sort buffer：MySQL 需要借助外部<strong>容器（通常是文件）进行排序</strong>。通常会将待排序数据分成多个“小文件”，对各个“小文件”进行排序，再汇总成一个有序的“大文件”。外部排序使用的是<strong>归并排序</strong></li>
</ol>
<h2 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h2><p><strong>two-pass、single-pass</strong></p>
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><ol>
<li>只要与最终结果集有关的字段都会被放进 sort buffer，而不管该字段本身是否参与排序。</li>
<li>步骤是：<ul>
<li>首先使用索引检索数据（可能回表，如果使用覆盖索引则不需要），把数据放入buffer中</li>
<li>然后在buffer中进行排序，并且返回最终结果</li>
</ul>
</li>
</ol>
<h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><ol>
<li>rowid定义：如果有主键则使用主键，否则由MySQL自动创建长度为6字节的rowId</li>
<li>rowid排序：<strong>只将与排序相关的字段和 rowId 放入 sort buffer，其余结果集需要用到的数据在排序完成后，通过 rowId 回表取得</strong></li>
<li>解决全字段排序出现“外部文件排序”的低效率问题</li>
<li>缺点：排序后的数据需要再次回表（需要额外数据时）</li>
</ol>
<h3 id="优先队列排序"><a href="#优先队列排序" class="headerlink" title="优先队列排序"></a>优先队列排序</h3><ol>
<li>MySQL 针对带有 LIMIT 的 ORDER BY 语句的优化：使用优先队列进行排序</li>
<li>步骤：<ul>
<li>在所有待排序的数据，取数量为 LIMIT的数据，构建一个堆</li>
<li>不断的取下一行数据，更新堆节点</li>
<li>当所有行的扫描完，得到最终的排序结果</li>
</ul>
</li>
</ol>
<h3 id="选择策略"><a href="#选择策略" class="headerlink" title="选择策略"></a>选择策略</h3><p>MySQL会在尽可能的情况下选择全字段排序。通过参数 <strong>max_length_for_sort_data</strong> 可以控制用于排序的行数据最大长度，默认值为 1024 字节。如果超过该值则会使用rowid排序。</p>
<h3 id="临时表排序"><a href="#临时表排序" class="headerlink" title="临时表排序"></a>临时表排序</h3><p>通常对于一个执行较慢的排序语句，在使用 EXPLAIN 进行执行过程分析的时候除了能看到 <strong>Using filesort</strong> 以外，还能看到 <strong>Using temporary</strong>，代表在排序过程中使用到了临时表。</p>
<h4 id="内存临时表排序"><a href="#内存临时表排序" class="headerlink" title="内存临时表排序"></a>内存临时表排序</h4><ol>
<li>MySQL 优先使用内存临时表。当 MySQL 使用内存临时表时，临时表存储引擎为 memory 。</li>
<li>如果当前 MySQL 使用的是内存临时表的话，将会直接使用 rowId 排序</li>
<li>使用 rowId 可以在 sort buffer 容纳给多的行，避免或减少外部排序文件的使用。</li>
</ol>
<h4 id="磁盘临时表排序"><a href="#磁盘临时表排序" class="headerlink" title="磁盘临时表排序"></a>磁盘临时表排序</h4><ol>
<li><strong>tmp_table_size</strong> 参数限制了内存临时表的大小，默认值是 16M。</li>
<li>超过该值转换为磁盘临时表。</li>
<li>使用磁盘临时表的时候，表储存引擎将不再是 memory，而是由 <strong>internal_tmp_disk_storage_engine</strong> 参数控制，默认为 InnoDB 。这时候 MySQL 会根据单行大小是否超过 max_length_for_sort_data 决定采用全字段排序还是 rowId 排序。</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>进行文件排序使用的临时存储空间会比想象的大得多，因为对<strong>每一个排序记录都会分配一个足够长的定长空间来存放</strong></li>
<li>关联查询<ul>
<li>order by中的列都来源于第一个表：MySQL会在处理第一个表时就排序，explain看到“Using filesort”</li>
<li>其他情况：“Using temporary；Using filesort” </li>
</ul>
</li>
<li>Limit会在排序之后生效（MySQL会针对limit进行优化）</li>
<li>使用BLOB或Text字段时，只会使用前缀，然后忽略剩下部分的值，可以使用<code>max_sort_length</code>指定前缀的带下</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.toutiao.com/i6928270827142038027">MySQL 排序的艺术：你真的懂 Order By 吗？</a></li>
<li>《高性能MySQL》</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>语法分析</tag>
        <tag>排序</tag>
        <tag>order by</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之日志-事务日志</title>
    <url>/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>MySQL会最大程度的利用缓存，从而提高数据的访问效率。那么换一句话来说，任何高性能的系统都必须利用到缓存，从各个层面来讲，缓存都发挥了巨大的作用。再上升到一个高度提炼一下：缓存和队列是实现高性能的必走之路。那么对于数据库来说这个却是个很棘手的问题，要保证数据更高效率的读取和存储，所以要利用到缓存。但是要保证数据的一致性，则必须保证所有的数据都必须准确无误的存储到数据库中，及时发生意外，也要保证数据可恢复。我们知道InnoDB是一个事务安全的存储引擎，而一致性是事务ACID中的一个重要特性。InnoDB存储引擎主要是通过InnoDB事务日志实现数据一致性的，InnoDB事务日志包括重做（redo、循环写入）日志，以及回滚（undo）日志。</p>
<a id="more"></a>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>事务日志（InnoDB特有的日志）可以帮助提高事务的效率。<br>事物日志是innodb专用功能,这里只考虑innod存储引擎。<br>出于性能和故障恢复的考虑，MySQL 服务器不会立即执行事务，而是先将事务记录在日志里面，这样可以将随机IO转换成顺序IO，从而提高IO性能。<br>事物日志默认情况下会有两个文件，名称分别为ib_logfile0和ib_logfile1。当其中一个写满时，MySQL会将事务日志写入另一个日志文件(先清空原有内容)。当 MySQL 从崩溃中恢复时，会读取事务日志，将其中已经 commit 的事务写入数据库，没有 commit 的事务 rollback 。<br>在事物提交时，innodb是否将缓冲到文件中同步，只要提交则立刻同步，同时又不会保证每个语句都同步，因此性能不会有特别大的影响。<br>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。<br>事务日志采用追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。<br>事务日志持久以后，内存中被修改的数据在后台可以慢慢的刷回到磁盘。目前大多数的存储引擎都是这样实现的，我们通常称之为预写式日志，修改数据需要写两次磁盘。<br>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具有的恢复方式则视存储引擎而定。<br>事务日志是被轮转的,一启动就分配完毕了, 并且是连续的存储空间,默认每个文件的大小为5M<br>主要功能: 将随机I/O转换为顺序I/O<br>ib_logfile0, ib_logfile1, 这两个文件如果坏了那么对于mysql来说是致命的, 所以建议事务log使用raid<br>会把一些相关信息记录事务日志中(记录对数据文件数据修改的物理位置或叫做偏移量);<br>作用:在系统崩溃重启时，作事务重做；在系统正常时，每次checkpoint时间点，会将之前写入事务应用到数据文件中。<br>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。  </p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/1587544132375.png" class>

</div>

<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/1587544168998.png" class title="redo log循环写入">

</div>

<h2 id="查看事务日志定义"><a href="#查看事务日志定义" class="headerlink" title="查看事务日志定义"></a>查看事务日志定义</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/1587544274091.png" class>

</div>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name               <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------+----------+</span></span><br><span class="line"># 定义内存空间的大小，万一都写在buffer里面，如果进程崩溃，也会丢失事物，</span><br><span class="line"># 因此避免这种情况，一旦事物提交了，那么需要立即同步到磁盘中，而不是间断同步</span><br><span class="line"># 事务日志缓存区,可设置<span class="number">1</span>M<span class="operator">~</span><span class="number">8</span>M,默认<span class="number">8</span>M,延迟事务日志写入磁盘,</span><br><span class="line"># 启用大的事务日志缓存,可以将完整运行大事务日志，暂时存放在事务缓存区中,</span><br><span class="line"># 不必(事务提交前)写入磁盘保存,同时也起到节约磁盘空间占用;</span><br><span class="line"><span class="operator">|</span> innodb_log_buffer_size      <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_log_checksums        <span class="operator">|</span> <span class="keyword">ON</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_log_compressed_pages <span class="operator">|</span> <span class="keyword">ON</span>       <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 控制事务日志ib_logfile的大小,范围<span class="number">5</span>MB<span class="operator">~</span><span class="number">4</span>G；</span><br><span class="line"># 所有事务日志ib_logfile0<span class="operator">+</span>ib_logfile1<span class="operator">+</span>..累加大小不能超过<span class="number">4</span>G，</span><br><span class="line"># 事务日志大，checkpoint会少,节省磁盘IO，</span><br><span class="line"># 但是大的事务日志意味着数据库crash时，恢复起来较慢.</span><br><span class="line"># 引入问题:修改该参数大小，导致ib_logfile文件的大小和之前存在的文件大小不匹配</span><br><span class="line"># 解决方式：在干净关闭数据库情况下，删除ib_logfile，而后重启数据库，会自行创建该文件;</span><br><span class="line">#每个日志的单位大小为<span class="number">5</span>MB，如果有些大数据的话，则需要将其调大，</span><br><span class="line">#否则恢复起来会比较慢，但是太大了也会导致恢复比较慢</span><br><span class="line"><span class="operator">|</span> innodb_log_file_size        <span class="operator">|</span> <span class="number">50331648</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 至少有两个</span><br><span class="line"><span class="operator">|</span> innodb_log_files_in_group   <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 定义innodb事务日志组的位置，</span><br><span class="line"># 定义事物日志组的位置，一般来讲会有<span class="number">2</span>个日志，</span><br><span class="line"># 一个写满后会重建文件（达到轮询功能，写满后会同步到磁盘并将其清空）</span><br><span class="line"># 一般来讲，日志文件大小是固定的，凡是mysql已启动日志空间会在磁盘上立即分配，</span><br><span class="line"># 因为他们的主要功能是将随机IO转为顺序IO ，默认大小是每个文件为<span class="number">5</span>MB，</span><br><span class="line"># 明确说明事物日志的路径保存在.<span class="operator">/</span> 表示在当前路径下</span><br><span class="line"><span class="operator">|</span> innodb_log_group_home_dir   <span class="operator">|</span> .<span class="operator">/</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_log_write_ahead_size <span class="operator">|</span> <span class="number">8192</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------+----------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h4><p>在事务提交时innodb是否同步日志从缓冲到文件中（1表示事务一提交就同步不提交每隔一秒同步一次，性能会很差造成大量的磁盘I/O；定义为2表示只有在事务提交时才会同步但是可能会丢失整个事务 ）<br>innodb_flush_log_at_trx_commit：控制事务日志何时写盘和刷盘，安全递增：0,2,1；事务缓存区:log_buffer;<br>如果innodb_flush_log_at_trx_commit设置为0，log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行.该模式下，在事务提交的时候，不会主动触发写入磁盘的操作。<br>如果innodb_flush_log_at_trx_commit设置为1，每次事务提交时MySQL都会把log buffer的数据写入log file，并且flush(刷到磁盘)中去. （最安全）<br>如果innodb_flush_log_at_trx_commit设置为2，每次事务提交时MySQL都会把log buffer的数据写入log file.但是flush(刷到磁盘)操作并不会同时进行。该模式下,MySQL会每秒执行一次 flush(刷到磁盘)操作。<br>适用环境:</p>
<ul>
<li>0:磁盘IO能力有限,安全方便较差,无复制或复制延迟可以接受，如日志性业务，mysql损坏丢失1s事务数据;</li>
<li>2:数据安全性有要求，可以丢失一点事务日志，复制延迟也可以接受，OS损坏时才可能丢失数据;</li>
<li>1:数据安全性要求非常高，且磁盘IO能力足够支持业务，如充值消费，敏感业务;</li>
</ul>
<h4 id="innodb-mirrored-log-groups"><a href="#innodb-mirrored-log-groups" class="headerlink" title="innodb_mirrored_log_groups"></a>innodb_mirrored_log_groups</h4><p>表示对日志组做镜像</p>
<h3 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a>文件位置</h3><div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/1587544946386.png" class>

</div>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/ggxxkkll/article/details/7616739">数据库日志文件– undo log 、redo log、 undo/redo log</a></li>
<li><a href="https://blog.csdn.net/leonpenn/article/details/72778901">InnoDB事务日志（redo log 和 undo log）详解</a></li>
<li><a href="https://www.iteye.com/blog/dinglin-907123">MySQL源码学习：ib_logfile、bin-log与主从同步</a></li>
<li><a href="https://blog.csdn.net/hackerwin7/article/details/39896173">Mysql日志抽取与解析</a></li>
<li><a href="https://blog.csdn.net/u010440155/article/details/54914353">mysql data文件夹下的ibdata1 文件作用</a></li>
<li><a href="https://blog.csdn.net/donghaixiaolongwang/article/details/60961603">mysql——innodb事务日志详解</a></li>
<li><a href="https://blog.csdn.net/mydriverc2/article/details/50629599">inlog，redo log，undo log区别</a></li>
<li><a href="http://www.itwendao.com/article/detail/450198.html">高性能MySQL学习笔记（3） — InnoDB事务日志（redo log 和 undo log）详解</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务日志</tag>
        <tag>redo</tag>
        <tag>undo</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之日志-扩展</title>
    <url>/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="数据日志文件比对"><a href="#数据日志文件比对" class="headerlink" title="数据日志文件比对"></a>数据日志文件比对</h2><h3 id="ib-logfile与log-bin区别"><a href="#ib-logfile与log-bin区别" class="headerlink" title="ib_logfile与log-bin区别"></a>ib_logfile与log-bin区别</h3><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <td class="tg-0lax">ib_logfile</td>
    <td class="tg-0lax">
        记录系统的回滚，重做日志（在你修改数据之前，会先把 修改的操作 作为日志先记录下来）<br>
        记录文件的物理更改<br>
        记录的是redo log和undo log（应该记录在ibdata1中）的信息，这里记录的基本是commit之前的数据
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">mysql-bin.******</td>
    <td class="tg-0lax">
        记录系统的所有更新记录，数据库的更细日志，记录的是逻辑更改<br>
        主从：mysql会把日志发送到slave，salve会接收日志，然后解析日志，把里面的sql语句重新应用到数据库里，于是就能同步数据了<br>
        记录的是已经执行完毕的对数据库的dml和ddl信息，这里记录的基本是commit之后的数据信息。
    </td>
  </tr>
</table>

<a id="more"></a>

<h3 id="redo、undo、binlog的区别"><a href="#redo、undo、binlog的区别" class="headerlink" title="redo、undo、binlog的区别"></a>redo、undo、binlog的区别</h3><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0lax"></th>
    <th class="tg-0lax">redo</th>
    <th class="tg-0lax">undo</th>
    <th class="tg-0lax">binlog</th>
  </tr>
  <tr>
    <td class="tg-0lax">作用</td>
    <td class="tg-0lax">保持事务的持久性</td>
    <td class="tg-0lax">帮助事务回滚及MVCC的功能</td>
    <td class="tg-0lax">进行Point-In_Time的恢复及主从复制的建立</td>
  </tr>
  <tr>
    <td class="tg-0lax">产生主体</td>
    <td class="tg-0lax">InnoDB</td>
    <td class="tg-0lax">MySql</td>
    <td class="tg-0lax">MySql</td>
  </tr>
  <tr>
    <td class="tg-0lax">类型</td>
    <td class="tg-0lax">物理日志，只记录有关InnoDB引擎本身的事务日志。</td>
    <td class="tg-0lax">逻辑日志</td>
    <td class="tg-0lax">
        记录的都是关于一个事务的具体操作内容,逻辑日志。<br>
        记录所有与MySQL数据库有关的日志记录，包括InnoDB、MyISAM、Heap等其他存储引擎的日志。
    </td>
  </tr>

  <tr>
    <td class="tg-0lax">内容</td>
    <td class="tg-0lax">每个页的修改，重做日志主要是记录已经全部完成的事务,即执行了commit的日志，在默认情况下重做日志的值记录在iblogfile0 以及iblogfile1重做日志中。</td>
    <td class="tg-0lax">修改前的行数据，回滚日志主要记录已经部分完成并且写入硬盘的未完成事务，默认情况情况下，回滚日志的信息记录在表空间文件，共享表空间文件ibdata1或者独享表空间未见ibd中。</td>
    <td class="tg-0lax">执行的SQL语句</td>
  </tr>
  <tr>
    <td class="tg-0lax">每个事务的日志数量</td>
    <td class="tg-0lax">事务执行中不断写入，多事务可并发写入</td>
    <td class="tg-0lax">看修改的行数据量</td>
    <td class="tg-0lax">事务提交后记录一条SQL语句,根据配置执行</td>
  </tr>
  <tr>
    <td class="tg-0lax">幂等性</td>
    <td class="tg-0lax">是</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">否</td>
  </tr>
  <tr>
    <td class="tg-0lax">日志文件</td>
    <td class="tg-0lax">ib_logfile</td>
    <td class="tg-0lax">Ibdata</td>
    <td class="tg-0lax">mysql-bin.******</td>
  </tr>
  <tr>
    <td class="tg-0lax">事务性</td>
    <td class="tg-0lax">INNODB存储引擎的重做日志，由于其记录是物理操作日志，因此每个事务对应多个日志条目，并且事务的重做日志写入是并发的，并非在事务提交时写入，做其在文件中记录的顺序并非是事务开始的顺序。</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">二进制日志仅在事务提交时记录，并且对于每一个事务，仅在事务提交时记录，并且对于每一个事务，仅包含对应事务的一个日志。</td>
  </tr>
</table>

<ol>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志（但是可以设置清理策略）。</li>
</ol>
<h3 id="ibdata"><a href="#ibdata" class="headerlink" title="ibdata"></a>ibdata</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>ibdata1是一个用来构建innodb系统表空间的文件，这个文件包含了innodb表的元数据（数据字典）、<br>撤销记录（FIL_PAGE_UNDO_LOG）**<strong>**</strong>出现问题的可能性比较大、<br>修改buffer（innodb_ibuf_max_size 设置最大变更缓冲区<br>双写buffer（innodb_doublewrite_file 来将双写缓冲区存储到一个分离的文件）<br>如果file-per-table选项打开的话，该文件则不一定包含所有表的数据。当innodb_file_per_table选项打开的话，新创建表的数据和索引则不会存在系统表空间中，而是存放在各自表的.ibd文件中。<br>使用命令：<code>SHOW ENGINE INNODB STATUS \g;</code>查看当前二进制的状态。<br>显然这个文件会越来越大，<code>innodb_autoextend_increment</code>选项则指定了该文件每次自动增长的步进，默认是8M。  </p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E6%89%A9%E5%B1%95/1587545996242.png" class>

</div>

<h4 id="导致该文件变大的原因"><a href="#导致该文件变大的原因" class="headerlink" title="导致该文件变大的原因"></a>导致该文件变大的原因</h4><p>显然ibdata文件存的是数据库的表数据，如缓存，索引等。所以随着数据库越来越大，表也会越大，这个无法避免的。</p>
<h4 id="瘦身"><a href="#瘦身" class="headerlink" title="瘦身"></a>瘦身</h4><ol>
<li>按照类型分类<ul>
<li>数据文件与日志信息分文件保存，对于日志文件可以定期执行清理。</li>
</ul>
</li>
<li>或者定期数据备份和恢复<ul>
<li>先把数据库文件备份下来，然后直接删除ibdata文件，重新导入数据库文件即可。这样就可以把ibdata中的日志和缓存都删除掉了。</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 备份全部数据库，执行命令</span><br><span class="line">mysqldump <span class="operator">-</span>q <span class="operator">-</span>uroot <span class="operator">-</span>ppassword <span class="comment">--add-drop-table --all-databases &gt;/var/lib/mysql/backall.sql</span></span><br><span class="line"># 做完此步后，停止数据库服务。</span><br><span class="line">service mysqld stop</span><br><span class="line"># 在配置文件中设置如下参数</span><br><span class="line">innodb_file_per_table<span class="operator">=</span><span class="number">1</span></span><br><span class="line"># 验证配置是否生效，可以重启mysql后,执行</span><br><span class="line">service mysqld restart</span><br><span class="line"># 登陆之后使用命令查询 <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%per_table%&#x27;</span>;</span><br><span class="line"># 还原数据库</span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">&lt;</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>backall.sql</span><br></pre></td></tr></table></figure>
<h5 id="删除原数据文件后"><a href="#删除原数据文件后" class="headerlink" title="删除原数据文件后"></a>删除原数据文件后</h5><div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E6%89%A9%E5%B1%95/1589449237143.png" class>

</div>

<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>为了添加一个数据文件到表空间中，首先要关闭 MySQL 数据库，编辑 my.cnf 文件，确认innodb ibdata文件的实际情况和my.cnf的配置是否一致，这里有两种情况：</p>
<ol>
<li>my.cnf的配置<br><code>innodb_data_file_path=ibdata1:10G;ibdata2:10G:autoextend</code><br>如果当前数据库正在使用ibdata1，或者使用ibdata2，但ibdata2没有超过10G，则对my.cnf配置直接改成：<br><code>innodb_data_file_path=ibdata1:10G;ibdata2:10G;ibdata3:10G:autoextend</code></li>
<li>如果设置了最后一个ibdata自动扩展时，有可能最后一个ibdata的占用空间大于my.cnf的配置空间。例如：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> mysql<span class="variable">@test</span>:<span class="operator">/</span>data1<span class="operator">/</span>mysqldata<span class="operator">/</span>innodb<span class="operator">/</span>data<span class="operator">&gt;</span> ls <span class="operator">-</span>lh</span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>rw<span class="comment">---- 1 mysql mysql 10737418240 2010-01-26 16:34 ibdata1</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>rw<span class="comment">---- 1 mysql mysql 16106127360 2010-01-26 16:34 ibdata2</span></span><br></pre></td></tr></table></figure>
<p>这时，需要精确的计算ibdata2的大小 15360M，修改：</p>
<p><code>innodb_data_file_path=ibdata1:10G;ibdata2:15360M;ibdata3:10G:autoextend</code></p>
<p>重启mysql。</p>
<p>注意：<br>1、扩容前注意磁盘空间是否足够。<br>2、restart后关注是否生成了新的ibdata。</p>
<h5 id="更多说明"><a href="#更多说明" class="headerlink" title="更多说明"></a>更多说明</h5><p>如果，最后一个文件以关键字 autoextend 来描述，那么编辑 my.cnf 的过程中，必须检查最后一个文件的尺寸，并使它向下接近于 1024 * 1024 bytes (= 1 MB) 的倍数（比方说现在autoextend 的/ibdata/ibdata1为18.5M，而在旧的my.ini中为10M，则需要修改为<code>innodb_data_file_path = /ibdata/ibdata1:19M;</code> 且必须是19M，如果指定20M，就会报错。），并在 innodb_data_file_path 中明确指定它的尺寸。然后你可以添加另一个数据文件。记住只有 innodb_data_file_path 中的最后一个文件可以被指定为 auto-extending。<br>一个例子：假设起先仅仅只有一个 auto-extending 数据文件 ibdata1 ，这个文件接近于 988 MB。下面是添加了另一个 auto-extending 数据文件后的可能示例 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">innodb_data_home_dir <span class="operator">=</span></span><br><span class="line">innodb_data_file_path <span class="operator">=</span> <span class="operator">/</span>ibdata<span class="operator">/</span>ibdata1:<span class="number">988</span>M;<span class="operator">/</span>disk2<span class="operator">/</span>ibdata2:<span class="number">50</span>M:autoextend</span><br></pre></td></tr></table></figure>
<h2 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a>日志分析工具</h2><ol>
<li>mysqldumpslowmysql：官方提供的慢查询日志分析工具</li>
<li>mysqlsla：hackmysql.com 推出的一款日志分析工具(该网站还维护了 mysqlreport，mysqlidxchk 等比较实用的mysql 工具)。 整体来说，功能非常强大。输出的数据报表非常有利于分析慢查询的原因，包括执行频率、数据量、查询消耗等。</li>
<li>myprofi：纯 php 写的一个开源分析工具.项目在 sourceforge 上。功能上，列出了总的慢查询次数和类型、去重后的 sql 语句、执行次数及其占总的 slow log 数量的百分比。从整体输出样式来看，比 mysql-log-filter 还要简洁，省去了很多不必要的内容。对于只想看 sql 语句及执行次数的用户来说，比较推荐。</li>
<li>mysql-log-filter：google code 上找到的一个分析工具，提供了 python 和 php 两种可执行的脚本。 特色功能除了统计信息外，还针对输出内容做了排版和格式化，保证整体输出的简洁。喜欢简洁报表的朋友，推荐使用一下。</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="主从不一致"><a href="#主从不一致" class="headerlink" title="主从不一致"></a>主从不一致</h3><p>在m/s环境中,innodb写完ib_logfile后,服务异常关闭，会不会主库能用ib_logfile恢复数据，而<br>binlog没写导致从库同步时少少这个事务？从而导致主从不一致;</p>
<h4 id="redo日志写入方式"><a href="#redo日志写入方式" class="headerlink" title="redo日志写入方式"></a>redo日志写入方式</h4><ol>
<li>ib_logfile写入当前事务更新数据，并标上事务准备trx_prepare</li>
<li>写入bin-log</li>
<li>ib_logfile当前事务提交提交trx_commit</li>
</ol>
<h4 id="恢复方式"><a href="#恢复方式" class="headerlink" title="恢复方式"></a>恢复方式</h4><p>如果ib_logfile已经写入事务准备,那么在恢复过程中，会依据bin-log中该事务是否存在恢复数据。<br>假设:</p>
<ol>
<li>结束后异常,因没有写入bin-log，从库不会同步这个事务，主库上，重启时，在恢复日志中这个事务没有commit，即rollback这个事务.</li>
<li>结束后异常，这会bin-log已经写入，从库会同步这个事务。主库依据恢复日志和bin-log，也正常恢复此事务</li>
</ol>
<p>综上描述:bin-log写入完成，主从会正常完成事务；bin-log没有写入，主从库rollback事务;不会出现主从库不一致问题.</p>
<h3 id="日志文件备份"><a href="#日志文件备份" class="headerlink" title="日志文件备份"></a>日志文件备份</h3><p>备份的时候可以使用flush logs，关闭当前的所有日志文件，然后产生新的日志文件。关闭日志文件后，可以采用物理方式备份。 另外flush logs可以添加具体的日志类型：</p>
<ol>
<li>flush error logs</li>
<li>flush general logs</li>
<li>flush binary logs</li>
<li>flush slow logs</li>
</ol>
<h3 id="Checkpoint机制"><a href="#Checkpoint机制" class="headerlink" title="Checkpoint机制"></a>Checkpoint机制</h3><p>MySQL服务器崩溃后，重新启动MySQL服务时，由于重做日志（redo）与回滚日志（undo）日志的存在，InnoDB通过回滚日志（undo）日志将所有已部分完成并写入硬盘的未完成事务进行回滚操作（rollback）。然后将重做日志（redo）日志中的事务全部重新执行一遍即可恢复所有的数据。但是数据量过大，为了缩短恢复的时间InnoDB引入了Checkpoint 机制。</p>
<h4 id="Checkpoint-机制原理"><a href="#Checkpoint-机制原理" class="headerlink" title="Checkpoint 机制原理"></a>Checkpoint 机制原理</h4><p>假设在某个时间点，所有的脏页（dirty page）都被刷新到了硬盘上，这个时间点之前的所有重做日志（redo）就不需要重做了.系统就就下这个时间点重做日志的结尾位置作为Checkpoint,Checkpoint之前的重做日志也就不需要再重做了，可以放心的删除掉。为了更好的利用重做日志（redo）的空间,InnoDb采用轮循的策略使用重做日志空间，因此InnoDB的重做日志文件至少为2个。通过Checkpoint 机制，通过重做日志（redo）将数据库崩溃时已经完成但还没有来得及将缓存中已经修改但还未完全写入外存的事务进行重做（undo）操作，即可保证数据的一致性，也可以缩短恢复时间。</p>
<h3 id="脏页（dirty-page）"><a href="#脏页（dirty-page）" class="headerlink" title="脏页（dirty page）"></a>脏页（dirty page）</h3><p>当事务需要修改某条记录是，InnoDB首先将该数据所在的数据块从外存中读取到硬盘中，事务提交后，InnoDB修改数据页中的记录，这时缓存的数据页已经和外存中的数据块已经不一样了，此时缓存中的数据页称为脏页（dirty page）,脏页刷新到外存中，变为干净页（clean page）。<br>备注：一个内存页默认为4K，或者4K的倍数。你可以把内存想象成一本可以擦洗的书，每次MySQL读数据的时候，向内存申请几张干净的书页，然后书写上去。当数据刷新到硬盘之后，这些数据页马上被擦除，供其他程序使用。</p>
<h3 id="日志序列号（log-sequence-number）"><a href="#日志序列号（log-sequence-number）" class="headerlink" title="日志序列号（log sequence number）"></a>日志序列号（log sequence number）</h3><p>日志序列号（LSN）是日志空间中每条日志的结束点，用字节偏移量表示，在Checkpoin和恢复时使用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/ggxxkkll/article/details/7616739">数据库日志文件– undo log 、redo log、 undo/redo log</a></li>
<li><a href="https://blog.csdn.net/leonpenn/article/details/72778901">InnoDB事务日志（redo log 和 undo log）详解</a></li>
<li><a href="https://www.iteye.com/blog/dinglin-907123">MySQL源码学习：ib_logfile、bin-log与主从同步</a></li>
<li><a href="https://blog.csdn.net/hackerwin7/article/details/39896173">Mysql日志抽取与解析</a></li>
<li><a href="https://blog.csdn.net/u010440155/article/details/54914353">mysql data文件夹下的ibdata1 文件作用</a></li>
<li><a href="https://blog.csdn.net/donghaixiaolongwang/article/details/60961603">mysql——innodb事务日志详解</a></li>
<li><a href="https://blog.csdn.net/mydriverc2/article/details/50629599">inlog，redo log，undo log区别</a></li>
<li><a href="http://www.itwendao.com/article/detail/450198.html">高性能MySQL学习笔记（3） — InnoDB事务日志（redo log 和 undo log）详解</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之日志-查询日志</title>
    <url>/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>默认情况下查询日志是关闭的。由于查询日志会记录用户的所有操作，其中还包含增删查改等信息，</p>
<ol>
<li>insert查询为了避免数据冲突，如果此前插入过数据，而如果跟主键或唯一键的数据重复那肯定会报错</li>
<li>update时也会查询因为更新的时候很可能会更新某一块数据</li>
<li>delete查询，只删除符合条件的数据</li>
</ol>
<p>MySQL普通查询日志记录MySQL服务实例所有的操作，如select、update、insert、delete等操作，无论该操作是否成功执行。还有MySQL客户机与MySQL服务端连接及断开的相关信息，无论连接成功还是失败。<br>注意：由于普通查询日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。在并发操作大的环境下会产生大量的信息从而导致不必要的磁盘IO，会影响mysql的性能的。如若不是为了调试数据库的目的建议不要开启查询日志。</p>
<ol>
<li>log = on|off 是否开启日志功能, 这个设置包含了查询日志和慢查询日志</li>
<li>general_log = on|off 是否开启查询日志</li>
<li>general_log_file = /path/to/file 指定查询日志的位置</li>
<li>log_output = FILE|table 日志输出的位置, 这个指令对慢查询日志也起作用<a id="more"></a>

</li>
</ol>
<h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span>  variables <span class="keyword">like</span> <span class="string">&#x27;%general_log%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>incloudos.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>拓展解析：日志的输出位置一般有三种方式：file(文件)，table(表)，none(不保存)；其中前两个输出位置可以同时定义，none表示是开启日志功能但是不记录日志信息。file就是通过general_log_file  等方式定义的，而输出位置定义为表时查看日志的内容方式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use mysql;#所在数据库</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mysql           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> columns_priv              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> db                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> engine_cost               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> event                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> func                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log               <span class="operator">|</span>查询日志表</span><br><span class="line"><span class="operator">|</span> gtid_executed             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> help_category             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> help_keyword              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> help_relation             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> help_topic                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_index_stats        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_table_stats        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ndb_binlog_index          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> plugin                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> proc                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> procs_priv                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> proxies_priv              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> server_cost               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> servers                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slave_master_info         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slave_relay_log_info      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slave_worker_info         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_log                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tables_priv               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> time_zone                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> time_zone_leap_second     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> time_zone_name            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> time_zone_transition      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> time_zone_transition_type <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">user</span>                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">31</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/ggxxkkll/article/details/7616739">数据库日志文件– undo log 、redo log、 undo/redo log</a></li>
<li><a href="https://blog.csdn.net/leonpenn/article/details/72778901">InnoDB事务日志（redo log 和 undo log）详解</a></li>
<li><a href="https://www.iteye.com/blog/dinglin-907123">MySQL源码学习：ib_logfile、bin-log与主从同步</a></li>
<li><a href="https://blog.csdn.net/hackerwin7/article/details/39896173">Mysql日志抽取与解析</a></li>
<li><a href="https://blog.csdn.net/u010440155/article/details/54914353">mysql data文件夹下的ibdata1 文件作用</a></li>
<li><a href="https://blog.csdn.net/donghaixiaolongwang/article/details/60961603">mysql——innodb事务日志详解</a></li>
<li><a href="https://blog.csdn.net/mydriverc2/article/details/50629599">inlog，redo log，undo log区别</a></li>
<li><a href="http://www.itwendao.com/article/detail/450198.html">高性能MySQL学习笔记（3） — InnoDB事务日志（redo log 和 undo log）详解</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>查询日志</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之日志-错误日志</title>
    <url>/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在mysql数据库中，错误日志功能是默认开启的。并且，错误日志无法被禁止。默认情况下，错误日志存储在mysql数据库的数据文件中。错误日志文件通常的名称为hostname.err。其中，hostname表示服务器主机名。<br>错误日志信息可以自己进行配置的，错误日志所记录的信息是可以通过log-error和log-warnings来定义的，其中log-err是定义是否启用错误日志的功能和错误日志的存储位置，log-warnings是定义是否将警告信息也定义至错误日志中。默认情况下错误日志大概记录以下几个方面的信息：服务器启动和关闭过程中的信息（未必是错误信息，如mysql如何启动InnoDB的表空间文件的、如何初始化自己的存储引擎的等等）、服务器运行过程中的错误信息、事件调度器运行一个事件时产生的信息、在从服务器上启动服务器进程时产生的信息。</p>
<a id="more"></a>

<h2 id="记录内容"><a href="#记录内容" class="headerlink" title="记录内容"></a>记录内容</h2><p>默认情况下错误日志也记录以下几个方面的消息：  </p>
<ol>
<li>服务器启动和关闭过程中的信息：未必是错误信息，比如mysql是如何去初始化存储引擎的过程记录在错误日志里等等</li>
<li>服务器运行过程中的错误信息：如sock文件找不到，无法加载mysql数据库的数据文件，如果忘记初始化mysql或data dir路径找不到，或权限不正确等，都会记录在此。error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来</li>
<li>事件调度器运行一个事件时产生的信息：一旦mysql调度启动一个计划任务的时候，它也会将相关信息记录在错误日志中</li>
<li>在从服务器上启动从服务器进程时产生的信息：在复制环境下，从服务器进程的信息也会被记录进错误日</li>
</ol>
<h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><p>log_error可以直接定义为文件路径，也可以为ON|OFF；log_warings只能使用1|0来定义开关启动。<br>log_error = on|文件路径 是否启用错误日志,on表示开启,文件路径表示指定自定义日志路径<br>log_warnings = 1|0 是否记录warnings信息到错误日志中  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error&#x27;</span>\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Variable_name: log_error</span><br><span class="line">        <span class="keyword">Value</span>: <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysqld<span class="operator">-</span>error.log</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>更改错误日志位置可以使用log_error来设置形式如下：</p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/1589443071013.png" class title="错误日志">

</div>

<p>log_error=DIR/[filename]</p>
<blockquote>
<p>说明：其中，DIR参数指定错误日志的路径filename参数是错误日志的名称，没有指定该参数时默认为主机名。重启mysql服务器即可生效。</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">27</span>:<span class="number">58.691227</span>Z <span class="number">0</span> [Warning] <span class="type">TIMESTAMP</span> <span class="keyword">with</span> implicit <span class="keyword">DEFAULT</span> <span class="keyword">value</span> <span class="keyword">is</span> deprecated. Please use <span class="comment">--explicit_defaults_for_timestamp server option (see documentation for more details).</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">27</span>:<span class="number">58.700431</span>Z <span class="number">0</span> [Warning] You need <span class="keyword">to</span> use <span class="comment">--log-bin to make --log-slave-updates work.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">27</span>:<span class="number">59.357341</span>Z <span class="number">0</span> [Warning] InnoDB: <span class="keyword">New</span> log files created, LSN<span class="operator">=</span><span class="number">45790</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">27</span>:<span class="number">59.462957</span>Z <span class="number">0</span> [Warning] InnoDB: Creating <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">constraint</span> <span class="keyword">system</span> tables.</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">00.410778</span>Z <span class="number">1</span> [Warning] <span class="string">&#x27;user&#x27;</span> entry <span class="string">&#x27;root@localhost&#x27;</span> ignored <span class="keyword">in</span> <span class="comment">--skip-name-resolve mode.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">00.410831</span>Z <span class="number">1</span> [Warning] <span class="string">&#x27;user&#x27;</span> entry <span class="string">&#x27;mysql.sys@localhost&#x27;</span> ignored <span class="keyword">in</span> <span class="comment">--skip-name-resolve mode.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">00.410860</span>Z <span class="number">1</span> [Warning] <span class="string">&#x27;db&#x27;</span> entry <span class="string">&#x27;sys mysql.sys@localhost&#x27;</span> ignored <span class="keyword">in</span> <span class="comment">--skip-name-resolve mode.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">00.410881</span>Z <span class="number">1</span> [Warning] <span class="string">&#x27;proxies_priv&#x27;</span> entry <span class="string">&#x27;@ root@localhost&#x27;</span> ignored <span class="keyword">in</span> <span class="comment">--skip-name-resolve mode.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">00.410940</span>Z <span class="number">1</span> [Warning] <span class="string">&#x27;tables_priv&#x27;</span> entry <span class="string">&#x27;sys_config mysql.sys@localhost&#x27;</span> ignored <span class="keyword">in</span> <span class="comment">--skip-name-resolve mode.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.222131</span>Z <span class="number">0</span> [Warning] Changed limits: max_open_files: <span class="number">5000</span> (requested <span class="number">10000</span>)</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.222594</span>Z <span class="number">0</span> [Warning] Changed limits: table_open_cache: <span class="number">1495</span> (requested <span class="number">2000</span>)</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.429941</span>Z <span class="number">0</span> [Warning] <span class="type">TIMESTAMP</span> <span class="keyword">with</span> implicit <span class="keyword">DEFAULT</span> <span class="keyword">value</span> <span class="keyword">is</span> deprecated. Please use <span class="comment">--explicit_defaults_for_timestamp server option (see documentation for more details).</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.431994</span>Z <span class="number">0</span> [Note] <span class="operator">/</span>usr<span class="operator">/</span>sbin<span class="operator">/</span>mysqld (mysqld <span class="number">5.7</span><span class="number">.17</span><span class="operator">-</span>log) starting <span class="keyword">as</span> process <span class="number">2255</span> ...</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.435711</span>Z <span class="number">0</span> [Warning] You need <span class="keyword">to</span> use <span class="comment">--log-bin to make --log-slave-updates work.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.438402</span>Z <span class="number">0</span> [Note] InnoDB: PUNCH HOLE support available</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.438441</span>Z <span class="number">0</span> [Note] InnoDB: Mutexes <span class="keyword">and</span> rw_locks use GCC <span class="keyword">atomic</span> builtins#Mutexes（互斥量）和rw_locks（行级锁）是GCC编译的是InnoDB内置的。</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.438448</span>Z <span class="number">0</span> [Note] InnoDB: Uses event mutexes</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.438454</span>Z <span class="number">0</span> [Note] InnoDB: GCC builtin __atomic_thread_fence() <span class="keyword">is</span> used <span class="keyword">for</span> memory barrier</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.438460</span>Z <span class="number">0</span> [Note] InnoDB: Compressed tables use zlib <span class="number">1.2</span><span class="number">.3</span>#默认压缩工具是zlib</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.438469</span>Z <span class="number">0</span> [Note] InnoDB: <span class="keyword">Using</span> Linux native AIO</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.440212</span>Z <span class="number">0</span> [Note] InnoDB: Number <span class="keyword">of</span> pools: <span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.440425</span>Z <span class="number">0</span> [Note] InnoDB: <span class="keyword">Using</span> CPU crc32 instructions</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.443133</span>Z <span class="number">0</span> [Note] InnoDB: Initializing buffer pool, total size <span class="operator">=</span> <span class="number">128</span>M, instances <span class="operator">=</span> <span class="number">1</span>, chunk size <span class="operator">=</span> <span class="number">128</span>M#InnoDB引擎的缓冲池（buffer pool）的值大小</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.457773</span>Z <span class="number">0</span> [Note] InnoDB: Completed initialization <span class="keyword">of</span> buffer pool</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.461218</span>Z <span class="number">0</span> [Note] InnoDB: If the mysqld execution <span class="keyword">user</span> <span class="keyword">is</span> authorized, page cleaner thread priority can be changed. See the man page <span class="keyword">of</span> setpriority().</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.474457</span>Z <span class="number">0</span> [Note] InnoDB: Highest supported file format <span class="keyword">is</span> Barracuda.</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.490641</span>Z <span class="number">0</span> [Note] InnoDB: Creating shared tablespace <span class="keyword">for</span> temporary tables</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.490762</span>Z <span class="number">0</span> [Note] InnoDB: Setting file <span class="string">&#x27;./ibtmp1&#x27;</span> size <span class="keyword">to</span> <span class="number">12</span> MB. Physically writing the file <span class="keyword">full</span>; Please wait ...</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.548037</span>Z <span class="number">0</span> [Note] InnoDB: File <span class="string">&#x27;./ibtmp1&#x27;</span> size <span class="keyword">is</span> now <span class="number">12</span> MB.</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.549679</span>Z <span class="number">0</span> [Note] InnoDB: <span class="number">96</span> redo <span class="keyword">rollback</span> segment(s) found. <span class="number">96</span> redo <span class="keyword">rollback</span> segment(s) <span class="keyword">are</span> active.</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.549703</span>Z <span class="number">0</span> [Note] InnoDB: <span class="number">32</span> non<span class="operator">-</span>redo <span class="keyword">rollback</span> segment(s) <span class="keyword">are</span> active.</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.551022</span>Z <span class="number">0</span> [Note] InnoDB: Waiting <span class="keyword">for</span> purge <span class="keyword">to</span> <span class="keyword">start</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.601254</span>Z <span class="number">0</span> [Note] InnoDB: <span class="number">5.7</span><span class="number">.17</span> started; log sequence number <span class="number">2534561</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.602149</span>Z <span class="number">0</span> [Note] InnoDB: Loading buffer pool(s) <span class="keyword">from</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>ib_buffer_pool</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.602726</span>Z <span class="number">0</span> [Note] Plugin <span class="string">&#x27;FEDERATED&#x27;</span> <span class="keyword">is</span> disabled.</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.604540</span>Z <span class="number">0</span> [Note] InnoDB: Buffer pool(s) load completed <span class="keyword">at</span> <span class="number">171210</span> <span class="number">15</span>:<span class="number">28</span>:<span class="number">04</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.610872</span>Z <span class="number">0</span> [Warning] Failed <span class="keyword">to</span> <span class="keyword">set</span> up SSL because <span class="keyword">of</span> the following SSL library error: SSL context <span class="keyword">is</span> <span class="keyword">not</span> usable <span class="keyword">without</span> certificate <span class="keyword">and</span> private key</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.610909</span>Z <span class="number">0</span> [Note] Server hostname (bind<span class="operator">-</span>address): <span class="string">&#x27;*&#x27;</span>; port: <span class="number">3306</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.610980</span>Z <span class="number">0</span> [Note] IPv6 <span class="keyword">is</span> available.</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.611001</span>Z <span class="number">0</span> [Note]   <span class="operator">-</span> <span class="string">&#x27;::&#x27;</span> resolves <span class="keyword">to</span> <span class="string">&#x27;::&#x27;</span>;#主机名解析</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.611025</span>Z <span class="number">0</span> [Note] Server socket created <span class="keyword">on</span> IP: <span class="string">&#x27;::&#x27;</span>.</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.623503</span>Z <span class="number">0</span> [Warning] <span class="string">&#x27;user&#x27;</span> entry <span class="string">&#x27;root@localhost&#x27;</span> ignored <span class="keyword">in</span> <span class="comment">--skip-name-resolve mode.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.623583</span>Z <span class="number">0</span> [Warning] <span class="string">&#x27;user&#x27;</span> entry <span class="string">&#x27;mysql.sys@localhost&#x27;</span> ignored <span class="keyword">in</span> <span class="comment">--skip-name-resolve mode.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.623624</span>Z <span class="number">0</span> [Warning] <span class="string">&#x27;db&#x27;</span> entry <span class="string">&#x27;sys mysql.sys@localhost&#x27;</span> ignored <span class="keyword">in</span> <span class="comment">--skip-name-resolve mode.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.623645</span>Z <span class="number">0</span> [Warning] <span class="string">&#x27;proxies_priv&#x27;</span> entry <span class="string">&#x27;@ root@localhost&#x27;</span> ignored <span class="keyword">in</span> <span class="comment">--skip-name-resolve mode.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.625694</span>Z <span class="number">0</span> [Warning] <span class="string">&#x27;tables_priv&#x27;</span> entry <span class="string">&#x27;sys_config mysql.sys@localhost&#x27;</span> ignored <span class="keyword">in</span> <span class="comment">--skip-name-resolve mode.</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.637286</span>Z <span class="number">0</span> [Note] Event Scheduler: Loaded <span class="number">0</span> events#事件调度器没有任何事件，因为没有装载。</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.637536</span>Z <span class="number">1</span> [Note] Event Scheduler: scheduler thread started <span class="keyword">with</span> id <span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.637618</span>Z <span class="number">0</span> [Note] Executing <span class="string">&#x27;SELECT * FROM INFORMATION_SCHEMA.TABLES;&#x27;</span> <span class="keyword">to</span> <span class="keyword">get</span> a list <span class="keyword">of</span> tables <span class="keyword">using</span> the deprecated <span class="keyword">partition</span> engine. You may use the startup option <span class="string">&#x27;--disable-partition-engine-check&#x27;</span> <span class="keyword">to</span> <span class="keyword">skip</span> this check.</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.637635</span>Z <span class="number">0</span> [Note] Beginning <span class="keyword">of</span> list <span class="keyword">of</span> non<span class="operator">-</span>natively partitioned tables</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.654416</span>Z <span class="number">0</span> [Note] <span class="keyword">End</span> <span class="keyword">of</span> list <span class="keyword">of</span> non<span class="operator">-</span>natively partitioned tables</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-10</span>T07:<span class="number">28</span>:<span class="number">04.654591</span>Z <span class="number">0</span> [Note] <span class="operator">/</span>usr<span class="operator">/</span>sbin<span class="operator">/</span>mysqld: ready <span class="keyword">for</span> connections.#mysql启动完成等待客户端的请求。</span><br><span class="line">Version: <span class="string">&#x27;5.7.17-log&#x27;</span>  socket: <span class="string">&#x27;/var/lib/mysql/mysql.sock&#x27;</span>  port: <span class="number">3306</span>  MySQL Community Server (GPL)#创建一个本地sock用于本地连接。</span><br></pre></td></tr></table></figure>
<h2 id="删除日志"><a href="#删除日志" class="headerlink" title="删除日志"></a>删除日志</h2><p>在mysql5.5.7之前：数据库管理员可以删除很长时间之前的错误日志，以保证mysql服务器上的硬盘空间。mysql数据库中，可以使用mysqladmin命令开启新的错误日志。mysqladmin命令的语法如下：mysqladmin –u root –pflush-logs也可以使用登录mysql数据库中使用FLUSHLOGS语句来开启新的错误日志。<br>在mysql5.5.7之后：服务器将关闭此项功能。只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的：方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv host_name.err host_name.err-old</span><br><span class="line">mysqladmin flush-logs</span><br><span class="line">mv host_name.err-old backup-directory</span><br><span class="line"></span><br><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/1589443206690.png" class>

</div>

<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/1589443228792.png" class>

</div>

<p>On Windows, use rename rather than mv.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/ggxxkkll/article/details/7616739">数据库日志文件– undo log 、redo log、 undo/redo log</a></li>
<li><a href="https://blog.csdn.net/leonpenn/article/details/72778901">InnoDB事务日志（redo log 和 undo log）详解</a></li>
<li><a href="https://www.iteye.com/blog/dinglin-907123">MySQL源码学习：ib_logfile、bin-log与主从同步</a></li>
<li><a href="https://blog.csdn.net/hackerwin7/article/details/39896173">Mysql日志抽取与解析</a></li>
<li><a href="https://blog.csdn.net/u010440155/article/details/54914353">mysql data文件夹下的ibdata1 文件作用</a></li>
<li><a href="https://blog.csdn.net/donghaixiaolongwang/article/details/60961603">mysql——innodb事务日志详解</a></li>
<li><a href="https://blog.csdn.net/mydriverc2/article/details/50629599">inlog，redo log，undo log区别</a></li>
<li><a href="http://www.itwendao.com/article/detail/450198.html">高性能MySQL学习笔记（3） — InnoDB事务日志（redo log 和 undo log）详解</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>错误日志</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之查询性能优化</title>
    <url>/2021/02/17/MySQL%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="查询速度慢的原因"><a href="#查询速度慢的原因" class="headerlink" title="查询速度慢的原因"></a>查询速度慢的原因</h2><ol>
<li>生命周期太长：从客户端到服务端，然后在服务端进行解析、生成执行计划、执行（包括数据的分组聚合处理等）、并返回结果</li>
<li>资源消耗：网络资源、CPU资源、锁等待、IO资源</li>
<li>访问的数据太多，大多数是行数据，也包括列数据<ul>
<li>是否向数据库请求了不需要的数据<ul>
<li>查询不需要的数据，比如<code>LIMIT 1000000,10</code></li>
<li>是否返回了全部列，比如<code>select * from </code></li>
<li>重复查询相同的数据，可以使用缓存解决</li>
</ul>
</li>
<li>MySQL是否在扫描额外的记录，可以使用<code>explain</code>分析，关注以下三个指标<ul>
<li>响应时间<ul>
<li> 服务时间：数据库处理这个查询实际消耗的时间</li>
<li> 排队时间：等待时间，比如IO操作、锁等待等</li>
</ul>
</li>
<li>扫描的行数<ul>
<li> 通过<code>explain</code>中的<code>type</code>列获取访问类型（全表扫描、范围扫描、唯一索引查询、常数引用等）</li>
<li>使用where条件的方式<ul>
<li> 在索引中使用where过滤数据，存储引擎层完成</li>
<li> 索引覆盖扫描（Extra中出现Using index），服务层直接在索引中处理，不需要回表</li>
<li> 冲数据表中返回数据（Extra中出现Using index），服务层完成（先从数据库中获取数据，然后在过滤数据）</li>
</ul>
</li>
</ul>
</li>
<li>返回的行数<ul>
<li>优化技巧（扫描比返回的数据多）<ul>
<li> 使用索引覆盖扫描</li>
<li> 修改表结构</li>
<li> 重新SQL<a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><ol>
<li>一个复杂查询还是多个复杂查询，根据实际情况确认是否拆分</li>
<li>切分查询，比如定期清理数据</li>
<li>分解关联查询<ul>
<li>提高缓存命中和利用率</li>
<li>减少锁竞争</li>
<li>应用层做关联，提高性能和扩展性以及利用数据库的拆分</li>
<li>减少冗余记录查询 </li>
</ul>
</li>
</ol>
<h2 id="查询执行的原理"><a href="#查询执行的原理" class="headerlink" title="查询执行的原理"></a>查询执行的原理</h2><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><div align="center">

<img src="/2021/02/17/MySQL%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%9F%A5%E8%AF%A2SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class title="查询SQL执行流程">

</div>

<h3 id="客户端-服务端通信协议"><a href="#客户端-服务端通信协议" class="headerlink" title="客户端/服务端通信协议"></a>客户端/服务端通信协议</h3><ol>
<li>半双工通信协议：客户端和服务端收发数据不能同时发生，并且一端开始之后另一端必须接收完整消息才能响应</li>
<li>使用<code>max_allowed_packet</code>控制一次查询的数据包大小（查询语句很长时）</li>
<li>由于客户端必须接收完整的服务端数据才能让服务器停止发送，当服务端返回数据较多时，通常使用limit进行限制</li>
</ol>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><ol>
<li>校验用户名和密码</li>
<li>校验当前用户拥有的权限</li>
</ol>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><ol>
<li>数据结构类似于hashtable，key：sql，value：数据集</li>
<li>适用于静态表（不变化的表），只要是表经常变化则缓存会失效，严重影响性能（8.0中以去掉）</li>
<li>查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，<strong>查询结果都不会被缓存</strong></li>
<li>失效：表结构变化和表数据变化</li>
<li>可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存</li>
<li><strong>尽量不要开启查询缓存</strong></li>
</ol>
<h3 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h3><h4 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h4><ol>
<li>生成一个解析树</li>
<li>解析器：根据语法进行验证和解析。比如错误的关键字、关键字的顺序、引号是否匹配</li>
<li>预处理：进一步验证解析树，比如表和列表是否存在，比如别名是否冲突歧义</li>
<li>最终生成合法的解析树</li>
</ol>
<h4 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h4><p>选择成本最优的执行计划，可以通过查询当前会话的last_query_cost进行判断。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [information_schema]<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">2.399000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure>
<p>value：表示做**个数据页的随机查找，统计信息（由存储引擎实现）包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等</p>
<h5 id="导致执行计划不准确的原因"><a href="#导致执行计划不准确的原因" class="headerlink" title="导致执行计划不准确的原因"></a>导致执行计划不准确的原因</h5><ol>
<li>统计信息不准确</li>
<li>不会考虑不受其控制的操作成本（用户自定义函数、存储过程）</li>
<li>MySQL认为的最优跟我们想的不一样</li>
<li>不考虑并发查询</li>
<li>并不是任何时候都是基于成本的控制，比如全文索引</li>
<li>执行计划中的成本估算不等同于实际执行的成本</li>
</ol>
<h5 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h5><ol>
<li>静态优化：直接对解析树进行优化，比如简单的代数运算，常用优化等，并且优化后一直生效</li>
<li>动态优化：需要依赖上下文，每次都需要重新评估</li>
</ol>
<h5 id="支持的优化类型"><a href="#支持的优化类型" class="headerlink" title="支持的优化类型"></a>支持的优化类型</h5><ol>
<li>重新定义关联表的顺序</li>
<li>将外连接转换为内连接</li>
<li>使用等价变化规则，比如(a &lt; b and b = c) and a = 5,优化为：b &gt; 5 and b = c and a = 5</li>
<li>优化count、max、min等函数：找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端</li>
<li>预估并转换常数表达式</li>
<li>覆盖索引扫描</li>
<li>子查询优化：转换成多个查询</li>
<li>提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询），适用于distinct、not exists、left join</li>
<li>等值传播</li>
<li>in的使用，不完全等同于or，通过二分查找的方式完成，如果太多会影响查询性能</li>
</ol>
<h4 id="MySQL中的关联查询"><a href="#MySQL中的关联查询" class="headerlink" title="MySQL中的关联查询"></a>MySQL中的关联查询</h4><ol>
<li>在MySQL中任意查询都是一次关联查询</li>
<li>任何关联查询都是嵌套查询<ul>
<li>在一个表中循环获取单条数据</li>
<li>在另一个表中匹配数据，直到所有表匹配完成</li>
<li>根据各个表匹配的行，返回查询中的各个列 </li>
</ul>
</li>
</ol>
<h4 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h4><p>MySQL生成一颗指令树（左深度优先树），然后通过存储引擎来完成针对这个树的查找，可以通过explain extend，再执行show warning就可以查看重构出的查询。</p>
<h4 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h4><h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><p><strong>参考<a href="https://www.sunliaodong.cn/2021/02/14/MySQL%E4%B9%8B%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E6%8E%92%E5%BA%8F/" target="_blank">排序优化</a></strong></p>
<h3 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h3><ol>
<li>通过调用存储引擎实现的接口来完成，这些接口被称为handler API</li>
<li>查询过程中的每一张表由一个handler实例表示（在查询优化节点完成创建）</li>
<li>包括表的所有列名、索引统计信息等</li>
<li>并不是所有的操作都是由handler完成，比如表锁（如果是所有存储引擎的共性则有服务层完成（时间、日期函数、视图、触发器等），否则由具体的存储引擎完成）</li>
</ol>
<h3 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h3><ol>
<li>即时查询结果为空，也会返回数据，比如影响行数</li>
<li>返回结果根据实际情况是否缓存</li>
<li>数据返回客户端是一个增量、逐步的过程</li>
<li>每一行数据满足通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送</li>
</ol>
<h2 id="查询优化器的局限性"><a href="#查询优化器的局限性" class="headerlink" title="查询优化器的局限性"></a>查询优化器的局限性</h2><h3 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--原始SQL</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course t </span><br><span class="line"><span class="keyword">where</span> t.course_id <span class="keyword">in</span> (</span><br><span class="line">   <span class="keyword">select</span> course_id <span class="keyword">from</span> course_teacher ct <span class="keyword">where</span> ct.teacher_id <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="comment">--MySQL针对in优化后SQL(可使用 explain extended查看执行效率，通过show warnings;查询优化后SQL)</span></span><br><span class="line"><span class="comment">--不同版本优化效果不同</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course t </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (</span><br><span class="line">   <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course_teacher ct </span><br><span class="line">   <span class="keyword">where</span> ct.teacher_id <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line">   <span class="keyword">and</span> t.course_id <span class="operator">=</span> ct.course_id);</span><br></pre></td></tr></table></figure>
<ol>
<li>如果子项比较少，可以使用<code>group_concat()</code>优化</li>
<li>可以使用内联或exists优化，但是效果不一定理想（大部分比较优）</li>
<li>一旦使用了DISTINCT和GROUP BY，那么在查询的执行过程中，通常会产生历史表</li>
</ol>
<h3 id="UNION的限制"><a href="#UNION的限制" class="headerlink" title="UNION的限制"></a>UNION的限制</h3><ol>
<li>MySQL无法将限制条件从外层下推到内层，所以根据实际需求在每个子项中增加限制条件</li>
<li>UNION的原理是把数据放到临时表中，然后取出需要的数据，但是顺序不一定，所以可以根据实际需要增加排序操作</li>
</ol>
<h3 id="索引合并优化"><a href="#索引合并优化" class="headerlink" title="索引合并优化"></a>索引合并优化</h3><p>MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。</p>
<h3 id="等值传递"><a href="#等值传递" class="headerlink" title="等值传递"></a>等值传递</h3><p>比如前面说的in，会有传递的优化；但是如果关联表比较大会影响性能，但是这种情况很少出现。</p>
<h3 id="并发执行：不支持"><a href="#并发执行：不支持" class="headerlink" title="并发执行：不支持"></a>并发执行：不支持</h3><h3 id="哈希关联"><a href="#哈希关联" class="headerlink" title="哈希关联"></a>哈希关联</h3><ol>
<li>MySQL本身没有实现正在意义的哈希关联（都是嵌套查询），可以通过哈希索引实现；memory 存储引擎使用哈希索引</li>
<li>mariadb已经支持哈希关联</li>
</ol>
<h3 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h3><h3 id="最大值、最小值优化"><a href="#最大值、最小值优化" class="headerlink" title="最大值、最小值优化"></a>最大值、最小值优化</h3><h3 id="同一个表上查询和更新"><a href="#同一个表上查询和更新" class="headerlink" title="同一个表上查询和更新"></a>同一个表上查询和更新</h3><h2 id="具体查询优化"><a href="#具体查询优化" class="headerlink" title="具体查询优化"></a>具体查询优化</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《高性能MySQL》</li>
<li><a href="https://www.toutiao.com/i6925236642320073229">面试官：select语句和update语句分别是怎么执行的？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1103154">万字总结：学习MySQL优化原理，这一篇就够了！</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">The InnoDB Storage Engine</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>调优</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>查询性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之索引</title>
    <url>/2021/02/05/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<ol>
<li>索引是存储引擎用于快速找到记录的一种数据结构；对于性能的好坏起到决定性的作用</li>
<li>通过索引号找到对应的数据编号，然后根据编号或对应数据的详细信息</li>
<li>MySQL中的索引在存储引擎中实现<a id="more"></a>

</li>
</ol>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="B-Tree（一般常用B-Tree）"><a href="#B-Tree（一般常用B-Tree）" class="headerlink" title="B-Tree（一般常用B+Tree）"></a>B-Tree（一般常用B+Tree）</h3><ol>
<li>MyISAM使用前缀压缩技术使得索引更小，InnoDB则按照原数据格式进行存储</li>
<li>MyISAM索引通过数据的物理位置引用被索引的行，InnoDB则根据主键引用被索引的行</li>
<li>BTree中所有的值都是按顺序存储，并且每个叶子到根节点的距离相同</li>
<li>从索引的根节点开始进行检索，根节点的槽中存放了子节点的指针，存储引擎根据这些指针向下查找</li>
<li>叶子节点的指针指向被索引的数据</li>
<li>索引对多个值进行排序的依据是create table 语句中定义索引时列的顺序</li>
<li>可以使用BTree索引的查询类型：适用于全键值、键值范围或键值前缀；同时适用于order by<ul>
<li>全值匹配：索引中所有的列进行完全匹配</li>
<li>最左前缀：最左索引列</li>
<li>列前缀：匹配某列值的开头部分</li>
<li>范围值：匹配索引的第一列</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询：覆盖索引</li>
</ul>
</li>
<li>限制<ul>
<li>如果不是按照索引的最左列开始查找，则不能使用索引</li>
<li>不能跳过索引中的列进行索引查询</li>
<li>如果查询中有某个列是范围查询，则其右侧的所有列无法使用索引进行优化查询 </li>
</ul>
</li>
</ol>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><ol>
<li>基于哈希表实现，只有精确匹配索引所有列的查询才有效</li>
<li>只有memory引擎显示支持哈希索引（默认索引类型）</li>
<li>原理：对于每一行，存储引擎会对所有索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码不同。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</li>
</ol>
<h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><ol>
<li>哈希索引只包含哈希值和行指针，不存储字段值，所以无法实现覆盖索引</li>
<li>哈希索引数据并不是按照索引值顺序存储（使用slot排序，slot维护指向行的指针），所以无法排序</li>
<li>哈希索引使用所有列进行生成哈希码，所以不支持部分索引列匹配查询，并且只能等值查询</li>
<li>在没有hash冲突的情况下，访问哈希索引的数据快，冲突较多时增加维护成本和查询效率</li>
<li>InnoDB中使用自适应哈希索引来生成哈希索引</li>
</ol>
<h3 id="空间数据索引（R-Tree）"><a href="#空间数据索引（R-Tree）" class="headerlink" title="空间数据索引（R-Tree）"></a>空间数据索引（R-Tree）</h3><ol>
<li>MyISAM支持空间索引，可以用于存储地理数据</li>
</ol>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><ol>
<li>全文索引适用于match against操作而不是where操作</li>
</ol>
<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ol>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>所以可以将随机IO转换成顺序IO</li>
</ol>
<p>注意：对于TB级别的数据，定位单条记录的意义不大，所以经常使用块级别原数据技术来替代索引。</p>
<h2 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>如果查询中的列不是独立的，比如有计算，有函数调用则无法正常使用索引。独立列表示索引不能是表达式的一部分，也不能是函数的参数。以下是反例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> t_ba_user <span class="keyword">where</span> age <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> t_ba_user <span class="keyword">where</span> length(user_name) <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3><ol>
<li>如果索引很长的字符列，会使索引变得大且慢，处理方式一种是使用哈希索引，一种是限制索引的长度。</li>
<li>索引选择性计算：不重复索引值数量/数据表的记录总数，越接近于1选择性越高，索引唯一索引定位数据的速度快</li>
<li>计算完整列的选择性，并是前缀的选择性接近于完整列的选择性</li>
<li>前缀索引是一种能够是索引更小，更快的有效办法，但是无法用于排序和分组，也无法使用前缀索引进行覆盖查询</li>
</ol>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p><strong>错误的认知：</strong></p>
<ol>
<li>为每个列创建独立的索引</li>
<li>按照错误的顺序创建多列索引</li>
</ol>
<p>在MySQL5.0+的版本中提供了“索引合并”的概念，一定层度上能够处理单列索引的局限；OR条件进行联合（union）、AND条件的相交（intersection）、以及OR与AND的组合；如果出现相关的“索引合并”则需要进行索引单列到多列的优化。可以使用optimizer_switch关闭合并功能。也可以使用explain分析sql的执行计划进行优化。</p>
<h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><ol>
<li>索引可以按照升序或降序进行扫描，以满足精确符合列顺序的排序、分组、去重等子句的查询需求</li>
<li>将选择性最高的列放在索引的最前列，并且需要重复考虑整体基数，但最好优先考虑随机IO和排序产生的性能影响</li>
<li>可能需要根据那些运行频率较高的查询来调整列的顺序，让这种情况下索引的选择性最高</li>
</ol>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><ol>
<li>一种数据存储方式，InnoDB中聚簇索引实际上是在同一个数据结构中保存了B-Tree索引和数据行。</li>
<li>数据行实际存储在叶子页中。</li>
<li>通过主键进行聚簇索引的管理，如果没有主键则选择一个唯一非空索引替代，如果还是没有数据库则使用默认的rowid管理</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>可以把</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><h3 id="索引使用原则"><a href="#索引使用原则" class="headerlink" title="索引使用原则"></a>索引使用原则</h3><ol>
<li>选择唯一性索引：唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。 </li>
<li>为经常需要排序、分组和联合操作的字段建立索引： </li>
<li>为常作为查询条件的字段建立索引。 </li>
<li>限制索引的数目： <ul>
<li>越多的索引，会使更新表变得很浪费时间。 </li>
<li>尽量使用数据量少的索引 </li>
</ul>
</li>
<li>如果索引的值很长，那么查询的速度会受到影响：尽量使用前缀来索引 </li>
<li>如果索引字段的值很长，最好使用值的前缀来索引。  </li>
<li>删除不再使用或者很少使用的索引 </li>
<li>最左前缀匹配原则，非常重要的原则。 </li>
<li>尽量选择区分度高的列作为索引：区分度的公式是表示字段不重复的比例 </li>
<li>索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。 </li>
<li>尽量的扩展索引，不要新建索引。  </li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之日志-中继日志</title>
    <url>/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>中继日志用于主从复制架构中的从服务器上，从服务器的 slave 进程从主服务器处获取二进制日志的内容并写入中继日志，然后由 IO 进程读取并执行中继日志中的语句。在复制过程中产生的日志一个线程读取别人的二进制日志,存到本地叫做中继日志,然后本地在开启一个线程去读取中继日志在本地做回放,就完成了数据的同步</p>
<a id="more"></a>

<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p>max_relay_log_size 最大中继日志大小<br>relay_log_info_file=relay-log.info 中继日志存放的文件  </p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>中继日志</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse使用技巧</title>
    <url>/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="集成javap命令"><a href="#集成javap命令" class="headerlink" title="集成javap命令"></a>集成javap命令</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li>eclipse中点击工具栏: Run &gt; External Tools &gt; External Tools Configuration</li>
<li>双击”程序”</li>
<li>修改配置</li>
</ol>
<div align="center">

<img src="/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1588039059895.png" class title="执行javap">

</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Name: javap(随意)</span><br><span class="line">location: jdk实际路径</span><br><span class="line">Working Directory:$&#123;workspace_loc&#125;\$&#123;project_name&#125; （不要改）</span><br><span class="line">Arguments:-c -verbose  -classpath  $&#123;workspace_loc&#125;/ $&#123;project_name&#125;/bin/$&#123;java_type_name&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><div align="center">

<img src="/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1588039225454.png" class title="eclipse配置">

</div>

<h3 id="javap的命令说明"><a href="#javap的命令说明" class="headerlink" title="javap的命令说明"></a>javap的命令说明</h3><p>参考《<a href="https://www.sunliaodong.cn/2021/02/04/Javap%E8%AF%A6%E8%A7%A3/">javap详解</a>》</p>
<h2 id="debug使用技巧"><a href="#debug使用技巧" class="headerlink" title="debug使用技巧"></a>debug使用技巧</h2><h3 id="常用快捷键说明"><a href="#常用快捷键说明" class="headerlink" title="常用快捷键说明"></a>常用快捷键说明</h3><ol>
<li>Step Into (also F5) 跳入</li>
<li>Step Over (also F6) 跳过</li>
<li>Step Return (also F7) 执行完当前method，然后return跳出此method</li>
<li>step Filter 逐步过滤 一直执行直到遇到未经过滤的位置或断点(设置Filter:window-preferences-java-Debug-step Filtering)</li>
<li>resume 重新开始执行debug,一直运行直到遇到breakpoint</li>
<li>hit count 设置执行次数 适合程序中的for循环(设置 breakpoint view-右键hit count)</li>
<li>inspect 检查 运算。执行一个表达式显示执行值</li>
<li>watch 实时地监视变量的变化</li>
<li>我们常说的断点(breakpoints)是指line breakpoints,除了line breakpoints,还有其他的断点类型：field(watchpoint)breakpoint,method breakpoint,exception breakpoint.</li>
<li>field breakpoint 也叫watchpoint(监视点) 当成员变量被读取或修改时暂挂</li>
<li>添加method breakpoint 进入/离开此方法时暂挂(Run-method breakpoint)</li>
<li>添加Exception breakpoint 捕抓到Execption时暂挂(待续…)</li>
</ol>
<h3 id="断点属性"><a href="#断点属性" class="headerlink" title="断点属性"></a>断点属性</h3><ol>
<li>hit count 执行多少次数后暂挂 用于循环</li>
<li>enable condition 遇到符合你输入条件(为ture\改变时)就暂挂</li>
<li>suspend thread 多线程时暂挂此线程</li>
<li>suspend VM 暂挂虚拟机</li>
<li>variables 视图里的变量可以改变变量值，在variables 视图选择变量点击右键–change value.一次来进行快速调试。</li>
<li>debug 过程中修改了某些code后–〉save&amp;build–&gt;resume–&gt;重新暂挂于断点</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">  MyDate aa = <span class="keyword">new</span> MyDate();</span><br><span class="line">  aa.addDays(day);                      =============》(<span class="number">1</span>)</span><br><span class="line">  System.out.println(<span class="string">&quot;eeeeeeeeeeeeeee&quot;</span>);=============》(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">addDays</span><span class="params">(<span class="keyword">int</span> more_days)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);               =============》(<span class="number">3</span>)</span><br><span class="line">    String result = <span class="string">&quot;&quot;</span>;         =============》(<span class="number">4</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);               =============》(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>你在(1)处加断点，运行到此处时如果Step Into (also F5)为跳入，则接着执行到(3)。再执行Step Over (also F6)执行本行，则执行到(4)。最后执行Step Return (also F7)，则跳出addDays方法，跳到(2)</p>
<h2 id="配置-author"><a href="#配置-author" class="headerlink" title="配置@author"></a>配置@author</h2><ol>
<li>eclipse-&gt;window-&gt;preference-&gt;java-&gt;code  styple-&gt;code template-&gt;Code-&gt;New Java files </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">点击 Edit </span><br><span class="line">$&#123;filecomment&#125;</span><br><span class="line">$&#123;package_declaration&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 孙辽东</span></span><br><span class="line"><span class="comment">* <span class="doctag">@E</span>-mail:sld880311@126.com</span></span><br><span class="line"><span class="comment">* <span class="doctag">@qq</span>:767768553</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 创建时间：$&#123;date&#125; $&#123;time&#125;</span></span><br><span class="line"><span class="comment">* 简单说明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$&#123;typecomment&#125;</span><br><span class="line">$&#123;type_declaration&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在建立类文件的时候输入“/**”的时候自动出来的：eclipse-&gt;window-&gt;preference-&gt;java-&gt;code  styple-&gt;code template-&gt;comments-&gt;typles,点击 Edit ，就可以根据自己需要编写了</li>
</ol>
]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>git详解</title>
    <url>/2021/02/04/git%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="提交本地工程到github"><a href="#提交本地工程到github" class="headerlink" title="提交本地工程到github"></a>提交本地工程到github</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;注释&quot;</span></span><br><span class="line">git remote add origin https://github.com/sld880311/parkspaceagent</span><br><span class="line"></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="comment">#如果出现fatal: refusing to merge unrelated histories</span></span><br><span class="line">使用如下命令 git pull origin master --allow-unrelated-histories</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="代码提交示意图"><a href="#代码提交示意图" class="headerlink" title="代码提交示意图"></a>代码提交示意图</h3><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589535948892.png" class title="git代码提交示意图">

</div>

<h3 id="官方参考图"><a href="#官方参考图" class="headerlink" title="官方参考图"></a>官方参考图</h3><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589535987537.png" class title="git官网提交提示图">

</div>

<h2 id="使用图解"><a href="#使用图解" class="headerlink" title="使用图解"></a>使用图解</h2><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589536030194.png" class title="git命令使用详解">

</div>

<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h3><h4 id="–-filename"><a href="#–-filename" class="headerlink" title="– filename"></a>– filename</h4><p>把filename文件在工作区的修改撤销到最近一次git add 或 git commit时的内容。</p>
<h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。</p>
<p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</p>
<p>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</p>
<p>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p>
<h2 id="分支详解"><a href="#分支详解" class="headerlink" title="分支详解"></a>分支详解</h2><h2 id="忽略文件参考"><a href="#忽略文件参考" class="headerlink" title="忽略文件参考"></a>忽略文件参考</h2><p>在工程下建立文件.gitignore,复制以下内容  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.ear</span><br><span class="line"></span><br><span class="line"># ignore Maven generated target folders</span><br><span class="line">target</span><br><span class="line"></span><br><span class="line"># ignore eclipse files</span><br><span class="line">.project</span><br><span class="line">.classpath</span><br><span class="line">.settings</span><br><span class="line">.metadata</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/shih/p/6826743.html">git重要的三个命令stash, checkout, reset的一些总结</a></li>
<li><a href="https://blog.csdn.net/hughgilbert/article/details/70473348">Git学习（三）——staging area 工作原理</a></li>
<li><a href="https://segmentfault.com/q/1010000007679514">git中stash的工作原理是什么？</a></li>
<li><a href="https://blog.csdn.net/chenj_freedom/article/details/50543152">git教程 - 概念 原理 使用</a></li>
<li><a href="https://www.cnblogs.com/houpeiyong/p/5890748.html">git revert和git reset的区别</a></li>
<li><a href="https://blog.csdn.net/hudashi/article/details/7664460">代码回滚：git reset、git checkout和git revert区别和联系</a></li>
<li><a href="https://blog.csdn.net/ibingow/article/details/7541402">git reflog</a></li>
</ol>
]]></content>
      <categories>
        <category>常用工具</category>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+github+next部署个人博客</title>
    <url>/2021/02/03/%E4%BD%BF%E7%94%A8hexo-github-next%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"><span class="comment"># 修改原</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 改回去</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>
<h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>使用npm安装hexo(<a href="https://hexo.io/zh-cn/">详细文档</a>)，命令是<code>npm install -g hexo-cli</code>,安装完成之后初始化博客,命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir sld880311.github.io</span><br><span class="line"><span class="built_in">cd</span> sld880311.github.io</span><br><span class="line">hexo init </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>初始化完成之后目录结构如下：<a id="more"></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 网站的配置信息，您可以在此配置大部分的参数。 </span></span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds <span class="comment"># 模版文件夹</span></span><br><span class="line">├── <span class="built_in">source</span>  <span class="comment"># 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span></span><br><span class="line">|   ├── _drafts <span class="comment"># 草稿文件</span></span><br><span class="line">|   └── _posts <span class="comment"># 文章Markdowm文件 </span></span><br><span class="line">└── themes  <span class="comment"># 主题文件夹</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s         <span class="comment"># 启动服务，然后可以使用 http://localhost:4000访问</span></span><br><span class="line">hexo init      <span class="comment">#生成文档</span></span><br><span class="line">hexo g         <span class="comment">#生成网页</span></span><br><span class="line">hexo clean     <span class="comment">#清除网页</span></span><br><span class="line">hexo d         <span class="comment">#部署博客</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h2 id="特殊配置"><a href="#特殊配置" class="headerlink" title="特殊配置"></a>特殊配置</h2><h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>获取<code>cat ~/.ssh/id_rsa.pub</code>中的数据，如果没有数据需要按照以下命令配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;sunliaodong&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;sld880311@hotmail.com&quot;</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;sld880311@hotmail.com&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后把生成的key添加中自己的github中即可。</p>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><h4 id="修改根目录下的-config-yml"><a href="#修改根目录下的-config-yml" class="headerlink" title="修改根目录下的_config.yml"></a>修改根目录下的_config.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/sld880311/sld880311.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h4 id="安装部署插件hexo-deployer-git"><a href="#安装部署插件hexo-deployer-git" class="headerlink" title="安装部署插件hexo-deployer-git"></a>安装部署插件hexo-deployer-git</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h4 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<h3 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h3><h4 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<h4 id="修改根目录的-config-yml"><a href="#修改根目录的-config-yml" class="headerlink" title="修改根目录的_config.yml"></a>修改根目录的_config.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章字数统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="修改主题-config-yml"><a href="#修改主题-config-yml" class="headerlink" title="修改主题_config.yml"></a>修改主题_config.yml</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br><span class="line">  item_text_post: <span class="literal">true</span></span><br><span class="line">  item_text_total: <span class="literal">true</span></span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>
<h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章名称&quot;</span>      <span class="comment"># 使用命令创建文章</span></span><br><span class="line">hexo new page categories  <span class="comment"># 定义分类</span></span><br><span class="line">hexo new page tags        <span class="comment"># 定义标签</span></span><br><span class="line">hexo new page about       <span class="comment"># 定义关于</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://theme-next.iissnan.com/">theme-next.iissnan</a></li>
<li><a href="https://theme-next.js.org/docs/">theme-next.js</a></li>
<li><a href="https://www.jianshu.com/p/446ec02bb0a8">Hexo+Next搭建个人博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/185015237">hexo之主题优化篇</a></li>
<li><a href="https://segmentfault.com/a/1190000017986794">超详细Hexo+Github Page搭建技术博客教程【持续更新】</a></li>
<li><a href="https://blog.csdn.net/u014786530/article/details/103548737">Hexo+NexT搭建个人博客</a></li>
<li><a href="https://blog.csdn.net/qq_40930491/article/details/87902310">从头开始搭建hexo+github+hexo-theme-next主题博客（高级设置）</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式协议之ZAB</title>
    <url>/2021/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B9%8BZAB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式算法之Paxos</title>
    <url>/2021/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E4%B9%8BPaxos/</url>
    <content><![CDATA[<p>解决的问题是一个分布式系统如何就某个值（决议）<strong>达成一致（共识问题）</strong>。<br>一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。</p>
<a id="more"></a>

<h2 id="Paxos中的角色"><a href="#Paxos中的角色" class="headerlink" title="Paxos中的角色"></a>Paxos中的角色</h2><ol>
<li>Proposer： 只要 Proposer 发的提案被半数以上 Acceptor 接受，Proposer 就认为该提案里的 value 被选定了。 </li>
<li>Acceptor： 只要 Acceptor 接受了某个提案，Acceptor 就认为该提案里的 value 被选定了。 </li>
<li>Learner： Acceptor 告诉 Learner 哪个 value 被选定，Learner 就认为那个 value 被选定。 </li>
</ol>
<p>Paxos 算法分为两个阶段。具体如下：<br>阶段一（准leader确定 ）：<br>(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。 (b) 如果一个 Acceptor 收到一个编号为 N 的 Prepare 请求，且 N 大于该 Acceptor 已经响应过的所有 Prepare 请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给 Proposer，同时该 Acceptor 承诺不再接受任何编号小于 N 的提案。<br>阶段二（leader确认）：<br>(a)    如果 Proposer 收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应，那么它就会发送一个针对[N,V]提案的 Accept 请求给半数以上的 Acceptor。注意：V 就是收到的响应中编号最大的提案的 value，如果响应中不包含任何提案，那么 V 就由 Proposer 自己决定。<br>(b)    如果 Acceptor 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号大于 N 的 Prepare 请求做出过响应，它就接受该提案。 </p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Paxos</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式算法之Raft</title>
    <url>/2021/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E4%B9%8BRaft/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>常见面试题汇总</title>
    <url>/2021/02/07/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<ol>
<li><a href="https://www.cnblogs.com/aspirant/p/9166944.html">select、poll、epoll之间的区别(搜狗面试)</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>技术体系总结</title>
    <url>/2021/02/07/%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Java技术体系模块图"><a href="#Java技术体系模块图" class="headerlink" title="Java技术体系模块图"></a>Java技术体系模块图</h2><div align="center">

<img src="/2021/02/07/%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93/1589506462204.png" class title="Java技术体系模块图">

</div>
<a id="more"></a>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之布隆过滤器</title>
    <url>/2021/03/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路，存储位置要么是磁盘，要么是内存。很多时候要么是以时间换空间，要么是以空间换时间。  </p>
<p>在响应时间要求比较严格的情况下，如果我们存在内里，那么随着集合中元素的增加，我们需要的存储空间越来越大，以及检索的时间越来越长，导致内存开销太大、时间效率变低。  </p>
<p>此时需要考虑解决的问题就是，<strong>在数据量比较大的情况下，既满足时间要求，又满足空间的要求</strong>。即我们需要一个时间和空间消耗都比较小的数据结构和算法。Bloom Filter就是一种解决方案。</p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。<strong>布隆过滤器可以用于检索一个元素是否在一个集合中</strong>。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。  </p>
<p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p>
<div align="center">

<img src="/2021/03/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1589094551971.png" class title="1589094551971.png">

</div>

<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>bloom filter之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性</p>
<ol>
<li><strong>存在误判</strong>，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</li>
<li><strong>删除困难</strong>。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用Counting Bloom Filter</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>布隆过滤器有许多实现与优化，Guava中就提供了一种Bloom Filter的实现。</p>
<ol>
<li>在使用bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp，</li>
<li>在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的大小。</li>
</ol>
<p>对于一个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的大小m，以及hash函数的个数k，并选择hash函数</p>
<h3 id="Bit数组大小选择"><a href="#Bit数组大小选择" class="headerlink" title="Bit数组大小选择"></a>Bit数组大小选择</h3><p>根据预估数据量n以及误判率fpp，bit数组大小的m的计算方式：  </p>
<div align="center">

<img src="/2021/03/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1589094591649.png" class title="bit数组大小计算">

</div>

<h4 id="com-google-common-hash-BloomFilter源码"><a href="#com-google-common-hash-BloomFilter源码" class="headerlink" title="com.google.common.hash.BloomFilter源码"></a>com.google.common.hash.BloomFilter源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算 Bloom Filter的bit位数m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;See http://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives for the</span></span><br><span class="line"><span class="comment"> * formula.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 预期数据量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 误判率 (must be 0 &lt; p &lt; 1)</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">@VisibleForTesting</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">optimalNumOfBits</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">double</span> p)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (p == <span class="number">0</span>) &#123; </span><br><span class="line">    p = Double.MIN_VALUE; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span>) (-n * Math.log(p) / (Math.log(<span class="number">2</span>) * Math.log(<span class="number">2</span>))); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算最佳k值，即在Bloom过滤器中插入的每个元素的哈希数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;See http://en.wikipedia.org/wiki/File:Bloom_filter_fp_probability.svg for the formula.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 预期数据量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m bloom filter中总的bit位数 (must be positive)</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">@VisibleForTesting</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">optimalNumOfHashFunctions</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> m)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// (m / n) * log(2), but avoid truncation due to division! </span></span><br><span class="line">  <span class="keyword">return</span> Math.max(<span class="number">1</span>, (<span class="keyword">int</span>) Math.round((<span class="keyword">double</span>) m / n * Math.log(<span class="number">2</span>))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈希函数选择"><a href="#哈希函数选择" class="headerlink" title="哈希函数选择"></a>哈希函数选择</h3><p>由预估数据量n以及bit数组长度m，可以得到一个hash函数的个数k：</p>
<div align="center">

<img src="/2021/03/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1589094678057.png" class title="1589094678057.png">

</div>

<p>哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。<br>哈希函数个数k、位数组大小m、加入的字符串数量n的关系可以参考Bloom Filters - the math，Bloom_filter-wikipedia  </p>
<p>BloomFilter实现的另一个重点就是怎么利用hash函数把数据映射到bit数组中。Guava的实现是对元素通过MurmurHash3计算hash值，将得到的hash值取高8个字节以及低8个字节进行计算，以得当前元素在bit数组中对应的多个位置。MurmurHash3算法详见:Murmur哈希，于2008年被发明。这个算法hbase,redis,kafka都在使用。</p>
<p>这个过程的实现在两个地方：</p>
<ol>
<li>将数据放入bloom filter中</li>
<li>判断数据是否已在bloom filter中</li>
</ol>
<p>这两个地方的实现大同小异，区别只是，前者是put数据，后者是查数据。<br>这里看一下put的过程，hash策略以MURMUR128_MITZ_64为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, LockFreeBitArray bits)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> bitSize = bits.bitSize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//利用MurmurHash3得到数据的hash值对应的字节数组</span></span><br><span class="line">  <span class="keyword">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//取低8个字节、高8个字节，转成long类型</span></span><br><span class="line">  <span class="keyword">long</span> hash1 = lowerEight(bytes);</span><br><span class="line">  <span class="keyword">long</span> hash2 = upperEight(bytes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> bitsChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里的combinedHash = hash1 + i * hash2</span></span><br><span class="line">  <span class="keyword">long</span> combinedHash = hash1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据combinedHash，得到放入的元素在bit数组中的k个位置，将其置1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; i++) &#123;</span><br><span class="line">    bitsChanged |= bits.set((combinedHash &amp; Long.MAX_VALUE) % bitSize);</span><br><span class="line">    combinedHash += hash2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitsChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> expectedInsertions = <span class="number">10000000</span>;</span><br><span class="line">        <span class="keyword">double</span> fpp = <span class="number">0.00001</span>;</span><br><span class="line">        BloomFilter&lt;CharSequence&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), expectedInsertions, fpp);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> containsString = bloomFilter.mightContain(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        System.out.println(containsString);</span><br><span class="line">        BloomFilter&lt;Email&gt; emailBloomFilter = BloomFilter</span><br><span class="line">                .create((Funnel&lt;Email&gt;) (from, into) -&gt; into.putString(from.getDomain(), Charsets.UTF_8),</span><br><span class="line">                        expectedInsertions, fpp);</span><br><span class="line">        emailBloomFilter.put(<span class="keyword">new</span> Email(<span class="string">&quot;sage.wang&quot;</span>, <span class="string">&quot;quanr.com&quot;</span>)); </span><br><span class="line">        <span class="keyword">boolean</span> containsEmail = emailBloomFilter.mightContain(<span class="keyword">new</span> Email(<span class="string">&quot;sage.wangaaa&quot;</span>, <span class="string">&quot;quanr.com&quot;</span>));</span><br><span class="line">        System.out.println(containsEmail);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> String domain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>常见的几个应用场景：  </p>
<ol>
<li>cerberus在收集监控数据的时候, 有的系统的监控项量会很大, 需要检查一个监控项的名字是否已经被记录到db过了, 如果没有的话就需要写入db.</li>
<li>爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</li>
<li>垃圾邮件过滤。如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>分布式</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>布隆过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>（Singleton Pattern、单态模式、单件模式、对象创建型模式），单例模式的特点：</p>
<ol>
<li>构造方法私有化；(不能被实例化和继承)</li>
<li>实例化的变量引用私有化；</li>
<li>获取实例的方法共有。</li>
</ol>
<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><ol>
<li>唯一的对象实例</li>
<li>保证一个类仅有一个实例，并提供一个访问他的全局访问点</li>
<li>有状态（可变的单例对象，可以组成状态仓库）、无状态（工具类）</li>
</ol>
<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>在下面的情况下可以使用Singleton模式：</p>
<ol>
<li>当类只能有一个实例而且客户可以从一个总所周知的访问点访问它时。</li>
<li>当这个唯一实例应该是通过子类可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
<li>系统只需要一个实例的对象，而这个对象又会被经常创建。</li>
</ol>
<a id="more"></a>

<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><div align="center">

<img src="/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1588206615300.png" class title="单例模式结构图">

</div>

<h2 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h2><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><ol>
<li>定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作。</li>
<li>可能负责创建它自己的唯一实例。</li>
</ol>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="懒汉模式（延迟加载）"><a href="#懒汉模式（延迟加载）" class="headerlink" title="懒汉模式（延迟加载）"></a>懒汉模式（延迟加载）</h3><h4 id="普通实现-非线程安全"><a href="#普通实现-非线程安全" class="headerlink" title="普通实现-非线程安全"></a>普通实现-非线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：非线程安全</p>
</blockquote>
<h4 id="锁在方法上-synchronized-线程安全"><a href="#锁在方法上-synchronized-线程安全" class="headerlink" title="锁在方法上(synchronized)-线程安全"></a>锁在方法上(synchronized)-线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：线程安全，效率低</p>
</blockquote>
<h4 id="同步代码块（synchronized）-线程不安全"><a href="#同步代码块（synchronized）-线程不安全" class="headerlink" title="同步代码块（synchronized）-线程不安全"></a>同步代码块（synchronized）-线程不安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton1.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：线程安全，效率低</p>
</blockquote>
<h4 id="DCL模式实现-线程安全"><a href="#DCL模式实现-线程安全" class="headerlink" title="DCL模式实现-线程安全"></a>DCL模式实现-线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 防止重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton1.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++ ) &#123;</span><br><span class="line">			es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() </span><br><span class="line">							+  Singleton1.getInstance());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="为什么需要使用volatile"><a href="#为什么需要使用volatile" class="headerlink" title="为什么需要使用volatile"></a>为什么需要使用volatile</h5><p><code>instance = new Singleton()</code>主要是完成了以下三个事情</p>
<ol>
<li>给instance实例分配内存；</li>
<li>初始化instance的构造器；</li>
<li>将instance对象指向分配的内存空间（注意到这步时instance就非null了）</li>
</ol>
<p>JVM会进行指令优化为：  </p>
<ol>
<li>给instance实例分配内存；</li>
<li>将instance对象指向分配的内存空间；—会出现线程安全问题</li>
<li>初始化instance的构造器；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.Singleton1包含com.sunld.Singleton1</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/Singleton1.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">4</span>-<span class="number">30</span>; size <span class="number">620</span> bytes</span><br><span class="line">  MD5 checksum 69d5cbecd81034e77060fee87c23526c</span><br><span class="line">  Compiled from <span class="string">&quot;Singleton1.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">Singleton1</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/Singleton1</span><br><span class="line">   #2 = Utf8               com/sunld/Singleton1</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               instance</span><br><span class="line">   #6 = Utf8               Lcom/sunld/Singleton1;</span><br><span class="line">   #7 = Utf8               &lt;clinit&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Fieldref           #1.#11         // com/sunld/Singleton1.instance:Lcom/sunld/Singleton1;</span><br><span class="line">  #11 = NameAndType        #5:#6          // instance:Lcom/sunld/Singleton1;</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Methodref          #3.#16         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = NameAndType        #14:#8         // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #17 = Utf8               this</span><br><span class="line">  #18 = Utf8               getInstance</span><br><span class="line">  #19 = Utf8               ()Lcom/sunld/Singleton1;</span><br><span class="line">  #20 = Methodref          #1.#16         // com/sunld/Singleton1.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Utf8               StackMapTable</span><br><span class="line">  #22 = Class              #23            // java/lang/Class</span><br><span class="line">  #23 = Utf8               java/lang/Class</span><br><span class="line">  #24 = Class              #25            // java/lang/Throwable</span><br><span class="line">  #25 = Utf8               java/lang/Throwable</span><br><span class="line">  #26 = Utf8               SourceFile</span><br><span class="line">  #27 = Utf8               Singleton1.java</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: aconst_null</span><br><span class="line">         1: putstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.sunld.<span class="function">Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()Lcom/sunld/Singleton1;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">         <span class="number">3</span>: ifnonnull     <span class="number">35</span></span><br><span class="line">         6: ldc           #1                  // class com/sunld/Singleton1</span><br><span class="line">         <span class="number">8</span>: dup</span><br><span class="line">         <span class="number">9</span>: astore_0</span><br><span class="line">        <span class="number">10</span>: monitorenter</span><br><span class="line">        11: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">14</span>: ifnonnull     <span class="number">27</span></span><br><span class="line">        17: new           #1                  // class com/sunld/Singleton1</span><br><span class="line">        <span class="number">20</span>: dup</span><br><span class="line">        21: invokespecial #20                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        24: putstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">27</span>: aload_0</span><br><span class="line">        <span class="number">28</span>: monitorexit</span><br><span class="line">        <span class="number">29</span>: goto          <span class="number">35</span></span><br><span class="line">        <span class="number">32</span>: aload_0</span><br><span class="line">        <span class="number">33</span>: monitorexit</span><br><span class="line">        <span class="number">34</span>: athrow</span><br><span class="line">        35: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">38</span>: areturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">            <span class="number">11</span>    <span class="number">29</span>    <span class="number">32</span>   any</span><br><span class="line">            <span class="number">32</span>    <span class="number">34</span>    <span class="number">32</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">17</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">27</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">35</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">3</span></span><br><span class="line">        frame_type = <span class="number">252</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">27</span></span><br><span class="line">          locals = [ class java/lang/Class ]</span><br><span class="line">        frame_type = <span class="number">68</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Singleton1.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="饿汉模式（立即加载）"><a href="#饿汉模式（立即加载）" class="headerlink" title="饿汉模式（立即加载）"></a>饿汉模式（立即加载）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论:</p>
<ol>
<li>线程安全</li>
<li>在获取变量的过程中不能有其他操作，以防出现线程安全问题</li>
</ol>
</blockquote>
<h3 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ObjectStreamException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonInner</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner1</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> SingletonInner instance = <span class="keyword">new</span> SingletonInner();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInner1.instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 防止序列化之后变成多例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ObjectStreamException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">readResoObject</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInner1.instance;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++ ) &#123;</span><br><span class="line">			es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() </span><br><span class="line">							+  SingletonInner.getInstance());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举实现单例"><a href="#枚举实现单例" class="headerlink" title="枚举实现单例"></a>枚举实现单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//私有化构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">	<span class="comment">//定义一个静态枚举类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个枚举对象，该对象天生为单例</span></span><br><span class="line">        INSTANCE;</span><br><span class="line">		<span class="keyword">private</span> EnumSingleton enumSingleton;</span><br><span class="line">		<span class="comment">//私有化枚举的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        	enumSingleton = <span class="keyword">new</span> EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enumSingleton;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对外暴露一个获取EnumSingleton对象的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstnce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：<br>枚举可以解决反序列化会破坏单例的问题</p>
<blockquote>
<p>在枚举序列化的时候，Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。</p>
</blockquote>
</blockquote>
<h3 id="单例注册工厂"><a href="#单例注册工厂" class="headerlink" title="单例注册工厂"></a>单例注册工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonRegistryFactory</span> <span class="keyword">implements</span> <span class="title">FactoryInterface</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity = <span class="number">50</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonRegistryFactory singleRegistry = <span class="keyword">new</span> SingletonRegistryFactory();</span><br><span class="line">	<span class="comment">//保证线程安全</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String,Object&gt; singletonCache = Collections.synchronizedMap(<span class="keyword">new</span> LRULinkedHashMap&lt;String, Object&gt;(maxCapacity));</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 私有构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonRegistryFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonRegistryFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> singleRegistry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.singletonCache.get(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object sharedBean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.put(beanName, sharedBean);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.clear();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>客户职能通过Singleton的Instance操作访问一个Singleton的实例。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="对唯一实例的受控访问"><a href="#对唯一实例的受控访问" class="headerlink" title="对唯一实例的受控访问"></a>对唯一实例的受控访问</h3><p>因为Singleton类封装它的唯一实例，所以它可以严格的控制客户怎样以及何时访问它。</p>
<h3 id="缩小名空间"><a href="#缩小名空间" class="headerlink" title="缩小名空间"></a>缩小名空间</h3><p>Singleton模式是对全局变量的一种改进。它避免了那些存储唯一实例的全局变量污染名空间。</p>
<h3 id="允许对操作和表示的精化"><a href="#允许对操作和表示的精化" class="headerlink" title="允许对操作和表示的精化"></a>允许对操作和表示的精化</h3><p>Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时刻配置应用。</p>
<h3 id="允许可变数目的实例"><a href="#允许可变数目的实例" class="headerlink" title="允许可变数目的实例"></a>允许可变数目的实例</h3><p>这个模式使得你易于改变你的想法，并允许Singleton类的多个实例。此外，你可以用相同的方法来控制应用所使用的实例的数目。只允许访问Singleton实例的操作需要改变。</p>
<h3 id="比类操作更灵活"><a href="#比类操作更灵活" class="headerlink" title="比类操作更灵活"></a>比类操作更灵活</h3><p>另一种封装单件功能的方式是使用类操作。但这种语言技术难以改变设计你允许一个类有多个实例。此外，静态成员函数不是虚函数，因此子类不能多态的重定义它们。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>实例控制，保证实例的唯一性</li>
<li>灵活性，因为类控制了实例化过程，所以类可以灵活更改实例化过程。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>需要提供详细文档提供开发者使用，防止开发混乱</li>
<li>不能解决删除单个对象的问题，可以使用缓存管理技术管理单例对象</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="保证一个唯一的实例"><a href="#保证一个唯一的实例" class="headerlink" title="保证一个唯一的实例"></a>保证一个唯一的实例</h3><p>Singleton模式使得这个唯一实例是类的一般实例，但该类被写成只有一个实例能被创建。做到这一点的一个常用方法是将创建这个实例的操作隐藏在一个类操作后面，由它保证只有一个实例被创建。这个操作可以访问保存唯一实例的变量，而且它可以保证这个变量在返回值之前用这个唯一实例初始化。这种方法保证了单件在它的首次使用前被创建和使用。</p>
<h3 id="创建Singleton类的子类"><a href="#创建Singleton类的子类" class="headerlink" title="创建Singleton类的子类"></a>创建Singleton类的子类</h3><p>主要问题与其说是定义子类不如说是建立它的唯一实例，这样客户就可以使用它。事实上，指向单件实例的变量必须用子类的实例进行初始化。最简单的技术是在Singleton的Instance操作中决定你想使用的是哪一个单件。  </p>
<p>另一个选择Singleton的子类的方法是将Instance的实现从父类中分离出来，将它放入子类。<br>一个更灵活的方法是使用一个单件注册表（registry of singleton）。可能的Singleton类的集合不是由Instance定义的，Singleton类可以根据名字在一个众所周知的注册表中注册它们的单件实例。<br>这个注册表在字符串名字和单件之间建立映射。当Instance需要一个单件时，它参考注册表，根据名字请求单件。</p>
<h2 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h2><p>各种工具类的使用，建议使用缓存技术管理单例对象</p>
<h3 id="Spring框架中实现的例子"><a href="#Spring框架中实现的例子" class="headerlink" title="Spring框架中实现的例子"></a>Spring框架中实现的例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework.adapter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Singleton to publish a shared DefaultAdvisorAdapterRegistry instance.</span></span><br><span class="line"><span class="comment"> * 抽象化类使其不可实例化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DefaultAdvisorAdapterRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvisorAdapterRegistry</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Keep track of a single instance so we can return it to classes that request it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AdvisorAdapterRegistry instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the singleton &#123;<span class="doctag">@link</span> DefaultAdvisorAdapterRegistry&#125; instance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AdvisorAdapterRegistry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Reset the singleton &#123;<span class="doctag">@link</span> DefaultAdvisorAdapterRegistry&#125;, removing any</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> AdvisorAdapterRegistry#registerAdvisorAdapter(AdvisorAdapter) registered&#125;</span></span><br><span class="line"><span class="comment">	 * adapters.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h2><ol>
<li>Abstract Factory Pattern中的具体工厂</li>
<li>Builder Pattern中的指导者</li>
<li>Facade Pattern中的Facade参与者</li>
<li>Prototype Pattern中的原型管理器</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/codingmengmeng/p/9846131.html">DCL单例模式</a></li>
<li><a href="https://www.toutiao.com/i6821004595079152141/">被面试官虐过之后，他轻蔑的问我：你还说你了解单例模式吗?</a></li>
</ol>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试</title>
    <url>/2021/02/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ol>
<li>软件测试的最基本单元，针对软件中的基本组成部分进行测试，比如一个模块、一个方法；</li>
<li>目的是验证最小单位的正确性，其正确性依赖详细设计</li>
<li>主要方法有控制流测试、数据流测试、排错测试、分域测试等等。</li>
<li>过程：研发整个过程中需要实施，尤其是针对关键核心代码的准确性测试</li>
<li>优点： <ul>
<li>一个好的单元测试将会在产品开发的阶段发现大部分的缺陷，并且修改他们的成本也很低；</li>
<li>在软件开发的后期阶段，缺陷的修改将会变得更加困难，要消耗大量的时间和费用。</li>
<li>经过单元测试的系统，系统集成过程将会达达的简化。<a id="more"></a>

</li>
</ul>
</li>
</ol>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><ol>
<li>集成测试发生在模块交互和UI集成阶段</li>
<li>目的是检查软件单位之间的接口是否正确。</li>
<li>策略主要有自顶向下和自底向上两种。</li>
<li>集成测试也叫做组装测试，通常在单元测试的基础上，将所有的程序模块进行有序的、递增的测试。</li>
<li>集成测试是检验程序单元或部件的接口关系，逐步集成为符合设计要求的程序部件或整个系统。</li>
<li>软件集成的过程是一个持续的过程，会形成很多个临时版本，在每个版本提交时，都需要进行冒烟测试，即对程序主要功能进行验证。</li>
</ol>
<h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><p>系统测试是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等满足其规约所指定的要求，检查软件的行为和输出是否正确并非一项简单的任务，它被称为测试的“先知者问题”。因此，系统测试应该按照测试计划进行，其输入、输出和其他动态运行行为应该与软件规约进行对比。软件系统测试方法很多，主要有功能测试、性能测试、随机测试等等。</p>
<h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><p>验收测试旨在向软件的购买者展示该软件系统满足其用户的需求。它的测试数据通常是系统测试的测试数据的子集。所不同的是，验收测试常常有软件系统的购买者代表在现场，甚至是在软件安装使用的现场。这是软件在投入使用之前的最后测试。</p>
<p>验收测试（用户接受度测试、用户体验测试，UAT：user acceptance test）</p>
<p>(1).alpha测试：由最终的用户在开发的环境中，对软件进行测试（在实际中已经常由开发方自主完成）；</p>
<p>(2).beta测试：由最终的用户在实际的环境中进行测试使用。对于一些没有固定用户群体的公共类软件（办公软件，游戏，输入法），一般会发行公测版（beta版），让用用户免费使用，发现bug后进行信息反馈。</p>
<h2 id="测试的价值"><a href="#测试的价值" class="headerlink" title="测试的价值"></a>测试的价值</h2><ol>
<li>测试越多，额外测试的价值越少。第一个测试最有可能是针对代码<strong>最重要的区域</strong>，因此带来高价值与高风险。当我们为几乎所有事情编写测试后，那些仍然没有测试覆盖的地方很有可能是最不重要和最不可能破坏的。<div align="center">

</div></li>
</ol>
<img src="/2021/02/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1597710996282.png" class>



<ol start="2">
<li>第一个稳态表明编写更多更好的测试不再带来额外的价值。第二个稳态进一步爬升，从我们想法的改变中发现更多的回报（将测试认为是丰富的资源，而不仅仅是验证工具，可以出尽高质量代码的编写和个人思考问题的提升）–<strong>影响生产力</strong><div align="center">

</div></li>
</ol>
<img src="/2021/02/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1597711435963.png" class>

<img src="/2021/02/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1597717234915.png" class>
<p>单元测试对生产力的影响</p>


<h2 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><h4 id="测试准则"><a href="#测试准则" class="headerlink" title="测试准则"></a>测试准则</h4><ol>
<li>满足AIR原则<ul>
<li>A：Automatic（自动化）</li>
<li>I：Independent（独立性）</li>
<li>R：Repeatable（可重复）</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/neo_ustc/article/details/22612759">符合27条准则</a></li>
</ol>
<h4 id="结构规范"><a href="#结构规范" class="headerlink" title="结构规范"></a>结构规范</h4><ol>
<li>目录结构：不要与源码混合在一起，与源码的路径保持一致</li>
<li>命名规范：与源码具有一致性要求，并且体现其测试功能，比如源码UserService，测试代码应该是UserServiceTest</li>
</ol>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>Arrange：准备当前测试场景的前置条件</li>
<li>Action：执行被测试方法</li>
<li>Assert：对被测试方法的执行结果进行断言判断（几乎每种测试框架都提供了Assert库，当然，也可以根据情况丰富我们自己的Assert库）</li>
</ol>
<h3 id="编码原则"><a href="#编码原则" class="headerlink" title="编码原则"></a>编码原则</h3><h4 id="必须符合-BCDE-原则"><a href="#必须符合-BCDE-原则" class="headerlink" title="必须符合 BCDE 原则"></a>必须符合 BCDE 原则</h4><ol>
<li>B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li>
<li>C：Correct，正确的输入，并得到预期的结果。</li>
<li>D：Design，与设计文档相结合，来编写单元测试。</li>
<li>E：Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到预期的结果。</li>
</ol>
<h4 id="避免以下情况"><a href="#避免以下情况" class="headerlink" title="避免以下情况"></a>避免以下情况</h4><ol>
<li>构造方法中做的事情过多。</li>
<li>存在过多的全局变量和静态方法。</li>
<li>存在过多的外部依赖。</li>
<li>存在过多的条件语句。</li>
</ol>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ol>
<li>涉及到的某些扩展模块可以使用mock模拟</li>
<li>测试用例不要使用@ignored或者被注释掉，切记切记。</li>
</ol>
<h3 id="测试用例的设计"><a href="#测试用例的设计" class="headerlink" title="测试用例的设计"></a>测试用例的设计</h3><ol>
<li>使用一种或多种白盒测试方法分析模块的逻辑关系</li>
<li>使用黑盒测试方法依照需求说明补充测试用例</li>
</ol>
<h4 id="接口功能性测试"><a href="#接口功能性测试" class="headerlink" title="接口功能性测试"></a>接口功能性测试</h4><p>接口功能的正确性,即保证接口能够被正常调用，并输出有效数据!</p>
<ol>
<li>是否被顺利调用</li>
<li>参数是否符合预期</li>
</ol>
<h4 id="局部数据结构测试"><a href="#局部数据结构测试" class="headerlink" title="局部数据结构测试"></a>局部数据结构测试</h4><p>保证数据结构的正确性</p>
<ol>
<li>变量是否有初始值或在某场景下是否有默认值</li>
<li>变量是否溢出</li>
</ol>
<h4 id="边界条件测试"><a href="#边界条件测试" class="headerlink" title="边界条件测试"></a>边界条件测试</h4><ol>
<li>变量无赋值(null)</li>
<li>变量是数值或字符</li>
<li>主要边界：最大值，最小值，无穷大</li>
<li>溢出边界：在边界外面取值+/-1</li>
<li>临近边界：在边界值之内取值+/-1</li>
<li>字符串的边界，引用 “变量字符”的边界</li>
<li>字符串的设置，空字符串</li>
<li>字符串的应用长度测试</li>
<li>空白集合</li>
<li>目标集合的类型和应用边界</li>
<li>集合的次序</li>
<li>变量是规律的，测试无穷大的极限，无穷小的极限</li>
</ol>
<h5 id="逻辑性测试"><a href="#逻辑性测试" class="headerlink" title="逻辑性测试"></a>逻辑性测试</h5><ol>
<li>精度问题</li>
<li>死代码</li>
<li>表达式判断</li>
<li>具体的业务逻辑（需要参与详细设计进行评估测试，并且加强代码走查），<strong>比如数据的使用范围，数据的最终一致性，数据的依赖性</strong></li>
</ol>
<h4 id="所有独立代码测试"><a href="#所有独立代码测试" class="headerlink" title="所有独立代码测试"></a>所有独立代码测试</h4><p>保证每一句代码，所有分支都测试完成，主要包括代码覆盖率，异常处理通路测试</p>
<ol>
<li>语句覆盖率：每个语句都执行到了</li>
<li>判定覆盖率：每个分支都执行到了</li>
<li>条件覆盖率：每个条件都返回布尔</li>
<li>路径覆盖率：每个路径都覆盖到了</li>
</ol>
<h4 id="异常模块测试"><a href="#异常模块测试" class="headerlink" title="异常模块测试"></a>异常模块测试</h4><p>后续处理模块测试:是否包闭当前异常或者对异常形成消化,是否影响结果!</p>
<h3 id="测试目标"><a href="#测试目标" class="headerlink" title="测试目标"></a>测试目标</h3><p><strong>语句覆盖率：&gt;=70% 分支覆盖率：100% 函数覆盖率：100% 行覆盖率： &gt;=80%</strong></p>
<p>最主要的目的是发现bug，解决bug，提高研发生产力。</p>
<h3 id="编写单元测试的技巧"><a href="#编写单元测试的技巧" class="headerlink" title="编写单元测试的技巧"></a>编写单元测试的技巧</h3><ol>
<li><strong>不应该编写成功通过的单元测试</strong>：以发现问题的角度去编写测试用例，让测试用例逐步变成通过</li>
<li><strong>测试类应该只测试一个功能</strong></li>
<li><strong>测试类具备可读性</strong>，规范的注释，以及相关的测试用例</li>
<li><strong>良好的命名规范</strong></li>
<li><strong>把断言从行为中分离出来</strong>：你的断言应该用来检验结果，而不是执行逻辑操作的。</li>
<li><strong>使用具体的输入</strong>-不要使用任何的自动化测试数据来输入，像date()这些产生的数据会引入差异。</li>
<li><strong>把测试类分类</strong>，放在不同的地方-从逻辑的角度看，当没有错误指向特定的问题时这更容易去查找。</li>
<li><strong>好的测试都是</strong>：一些独立的测试类-你应该让测试类与其他的测试、环境设置等没有任何依赖。这利于创建多个测试点。</li>
<li><strong>不要包含私有的方法</strong>：他们都是一些具体的实现，不应该包含在单元测试里。</li>
<li><strong>不要连接数据库或者数据源</strong>-这是不靠谱的。因为你不能确保数据服务总是一样的并且能够创建测试点，创建用于测试的数据库，并且快速完成数据的回收</li>
<li><strong>一个测试不要超过一个模拟(mock对象)</strong>-我们努力去消除错误和不一致性。</li>
<li><strong>单元测试不是集成测试</strong>-如果你想测试结果，不要使用单元测试。</li>
<li><strong>测试必须具有确定性</strong>-你需要一个确定的预测结果，所以，如果有时候测试通过了，但是不意味着完成测试了。</li>
<li><strong>保持你的测试是幂等的</strong>-你应该能够运行你的测试多次而不改变它的输出结果，并且测试也不应该改变任何的数据或者添加任何东西。无论是运行一次还是一百万次，它的效果都应该是一样的。</li>
<li><strong>测试类一次仅测试一个类，测试方法一次仅测试一个方法</strong>-组织方法能够在问题出现时检测出来，并帮你确定测试依赖。</li>
<li><strong>在你的测试里使用异常</strong>-你在测试里会遇到异常，所以，请不要忽略它，要使用它。</li>
<li><strong>不要使用你自己的测试类去测试第三方库的功能</strong>-大多数好的库都应该有它们自己的测试，如果没考虑用mocks去产生一致性的结果的话。</li>
<li><strong>限制规则</strong>-当在一些规则下写测试时，记住你的限制和它们（最小和最大）设置成最大的一致性。</li>
<li><strong>测试类不应该需要配置或者自定义安装</strong>-你的测试类应该能够给任何人使用并且使它运行。“在我的机器上运行”不应该出现在这。</li>
</ol>
<h2 id="基于Python-unittest的示例"><a href="#基于Python-unittest的示例" class="headerlink" title="基于Python unittest的示例"></a>基于Python unittest的示例</h2><h3 id="准备测试对象"><a href="#准备测试对象" class="headerlink" title="准备测试对象"></a>准备测试对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># UnitTest/unit_test/course.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CourseManage</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, course</span>):</span></span><br><span class="line">        self.course = course</span><br><span class="line">        self.students = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_course</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;课程:&quot;</span>, self.course)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_student</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.students.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_students</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;所有学员:&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> student <span class="keyword">in</span> self.students:</span><br><span class="line">            print(<span class="string">&#x27;-&#x27;</span>, student)</span><br></pre></td></tr></table></figure>
<h3 id="正常使用该对象"><a href="#正常使用该对象" class="headerlink" title="正常使用该对象"></a>正常使用该对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unit_test.course <span class="keyword">import</span> CourseManage</span><br><span class="line"></span><br><span class="line">course = CourseManage(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">course.show_course()</span><br><span class="line">print(<span class="string">&quot;准备录入学员...&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Enter &#x27;q&#x27; at any time to quit.\n&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    resp = <span class="built_in">input</span>(<span class="string">&quot;Student&#x27;s Name: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> resp == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> resp:</span><br><span class="line">        course.add_student(resp.title())</span><br><span class="line">print(<span class="string">&quot;\n录入完毕...&quot;</span>)</span><br><span class="line">course.show_students()</span><br></pre></td></tr></table></figure>
<p>数据正常输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">课程: Python</span><br><span class="line">准备录入学员...</span><br><span class="line">Enter <span class="string">&#x27;q&#x27;</span> at <span class="built_in">any</span> time to quit.</span><br><span class="line"></span><br><span class="line">Student<span class="string">&#x27;s Name: oliver queen</span></span><br><span class="line"><span class="string">Student&#x27;</span>s Name: barry allen</span><br><span class="line">Student<span class="string">&#x27;s Name: kara</span></span><br><span class="line"><span class="string">Student&#x27;</span>s Name: sara lance</span><br><span class="line">Student<span class="string">&#x27;s Name: q</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">录入完毕...</span></span><br><span class="line"><span class="string">所有学员:</span></span><br><span class="line"><span class="string">- Oliver Queen</span></span><br><span class="line"><span class="string">- Barry Allen</span></span><br><span class="line"><span class="string">- Kara</span></span><br><span class="line"><span class="string">- Sara Lance</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Process finished with exit code 0</span></span><br></pre></td></tr></table></figure>
<h3 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># UnitTest/unit_test/test/test_course.py</span></span><br><span class="line"><span class="comment"># 添加用户，使用断言assertIn验证</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> unit_test.course <span class="keyword">import</span> CourseManage</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCourseManage</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add_student</span>(<span class="params">self</span>):</span></span><br><span class="line">        course = CourseManage(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">        name = <span class="string">&#x27;snart&#x27;</span></span><br><span class="line">        course.add_student(name.title())</span><br><span class="line">        self.assertIn(<span class="string">&#x27;Snart&#x27;</span>, course.students)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>
<h3 id="常用断言方法"><a href="#常用断言方法" class="headerlink" title="常用断言方法"></a>常用断言方法</h3><p>模块在unittest.TestCase类中提供了很多断言方法，之前已经用一个了。下面是6个常用的断言方法：</p>
<ol>
<li>assertEqual(a, b) ： 核实a == b</li>
<li>assertNotEqual(a, b) ： 核实a != b</li>
<li>assertTrue(x) ： 核实x为True</li>
<li>assertFalse(x) ： 核实x为False</li>
<li>assertIn(item, list) ： 核实item在list中</li>
<li>assertNotIn(item, list) ： 核实item不在list中</li>
</ol>
<h3 id="特殊方法说明"><a href="#特殊方法说明" class="headerlink" title="特殊方法说明"></a>特殊方法说明</h3><ol>
<li>setUp()&amp;tearDown()：在每个测试方法（用例）运行时被调用一次</li>
<li>setUp()主要实现测试前的初始化工作，而tearDown()则主要实现测试完成后的垃圾回收等工作 </li>
<li>setUpClass()&amp;tearDownClass(): 全程只调用一次，必须使用@classmethod 装饰器</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何快速推荐单元测试"><a href="#如何快速推荐单元测试" class="headerlink" title="如何快速推荐单元测试"></a>如何快速推荐单元测试</h3><p>需要有研发流程和研发文化的支持。</p>
<div align="center">

<img src="/2021/02/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1597716819955.png" class title="研发代码提交流程">

</div>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://petroware.no/html/unittesting.html">Unit Testing Guidelines</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1570016">单元测试的用例清单</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1005432">实践单元测试的姿势</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1399249">Golang UnitTest单元测试</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1382018">Python的单元测试</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1564228">Python 单元测试（unittest)</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1509641">Java单元测试之JUnit 5快速上手</a></li>
</ol>
]]></content>
      <categories>
        <category>测试</category>
        <category>研发效能</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>道德经</title>
    <url>/2021/03/10/%E9%81%93%E5%BE%B7%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="01-天地之始，万物之母"><a href="#01-天地之始，万物之母" class="headerlink" title="01 天地之始，万物之母"></a>01 天地之始，万物之母</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>道可道，非常道；<br>名可名，非常名。<br>无，名天地之始；<br>有，名万物之母。<br>故常无，欲以观其妙；<br>常有，欲以观其徼。<br>此两者，同出而异名，同谓之玄。<br>玄之又玄，众妙之门。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<a id="more"></a>

<h2 id="02-为而不恃，功成弗居"><a href="#02-为而不恃，功成弗居" class="headerlink" title="02 为而不恃，功成弗居"></a>02 为而不恃，功成弗居</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>天下皆知美之为美，斯恶矣；<br>皆知善之为善，斯不善矣。<br>故有无相生，难易相成，长短相较，高下相倾，音声相和，前后相随，恒也。<br>是以圣人处无为之事，行不言之教；<br>万物作而弗始，生而弗有，为而弗恃，功成而弗居。<br>夫唯弗居，是以不去。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="03-圣人之治，无为而治"><a href="#03-圣人之治，无为而治" class="headerlink" title="03 圣人之治，无为而治"></a>03 圣人之治，无为而治</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>不尚贤，使民不争。<br>不贵难得之货，使民不为盗。<br>不见可欲，使民心不乱。<br>是以圣人之治，<br>虚其心，实其腹，弱其志，强其骨，<br>常使民无知无欲，<br>使夫智者不敢为也，<br>为无为，则无不治</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="04-挫锐解纷，和光同尘"><a href="#04-挫锐解纷，和光同尘" class="headerlink" title="04 挫锐解纷，和光同尘"></a>04 挫锐解纷，和光同尘</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>道冲，而用之或不盈。<br>渊兮，似万物之宗。<br>挫其锐，解其纷，和其光，同其尘。<br>湛兮似或存。<br>吾不知谁之子，象帝之先。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="05-多言数穷，不如守中"><a href="#05-多言数穷，不如守中" class="headerlink" title="05 多言数穷，不如守中"></a>05 多言数穷，不如守中</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>天地不仁，以万物为刍狗。<br>圣人不仁，以百姓为刍狗。<br>天地之间，其犹橐龠乎？<br>虚而不屈，动而愈出。<br>多言数穷，不如守中。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="06-玄牝之门，谓天地根"><a href="#06-玄牝之门，谓天地根" class="headerlink" title="06 玄牝之门，谓天地根"></a>06 玄牝之门，谓天地根</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>谷神不死，是谓玄牝。<br>玄牝之门，是谓天地根。<br>绵绵若存，用之不勤。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>道德经</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM HotSpot虚拟机对象探秘</title>
    <url>/2021/02/05/JVM-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/</url>
    <content><![CDATA[<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<div align="center">

<img src="/2021/02/05/JVM-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" class title="对象的内存布局">

</div>

<a id="more"></a>

<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>Object Header（64或96bit）,包括：Mark Word（32bit）、Klass World（32bits）、array length（32bits，存在数据组对象时）</p>
<h4 id="Markword"><a href="#Markword" class="headerlink" title="Markword"></a>Markword</h4><p>在HotSpot中，GC堆上的对象需要维持一些状态信息，具体如下：</p>
<ol>
<li>unused：表示未使用</li>
<li>身份哈希码（identity hash code），采用延迟加载技术。调用<code>System.identityHashCode()</code>计算后会写入对象头中。当对象加锁后（偏向、轻量级、重量级），MarkWord的字节没有足够的空间保存hashCode，因此该值会移动到管程Monitor中。</li>
<li>当前是否已被GC标记（只在GC过程中需要）</li>
<li>当前对象年龄（经历GC的次数，最大15）这就是-XX:MaxTenuringThreshold选项最大值为15的原因</li>
<li>biased_lock：对象是否启用偏向锁标记，只占1个二进制位</li>
<li>lock：2位的锁状态标记位</li>
</ol>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-sjuo{background-color:#C2FFD6;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;状态&nbsp;&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;标志位&nbsp;&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;&nbsp;存储内容&nbsp;&nbsp;&nbsp;&nbsp;</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;未锁定&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;01&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;对象哈希码、对象分代年龄&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;轻量级锁定&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;指向锁记录的指针&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;膨胀(重量级锁定)&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;执行重量级锁定的指针&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;GC标记&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;空(不需要记录信息)&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;可偏向&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;01&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;偏向线程ID、偏向时间戳、对象分代年龄&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<ol start="7">
<li>最近持有该对象锁的线程ID（用于偏向锁）</li>
<li>epoch：偏向锁的时间戳</li>
<li>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针。</li>
<li>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针。</li>
</ol>
<h5 id="32位虚拟机markword"><a href="#32位虚拟机markword" class="headerlink" title="32位虚拟机markword"></a>32位虚拟机markword</h5><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-baqh{text-align:center;vertical-align:top}
.tg .tg-29iq{background-color:#FFFFC7;text-align:center;vertical-align:top}
.tg .tg-fw9x{background-color:#96FFFB;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-fw9x" rowspan="3">锁状态</th>
    <th class="tg-29iq" colspan="5">32bit</th>
  </tr>
  <tr>
    <td class="tg-29iq" colspan="2">25bit</td>
    <td class="tg-29iq">4bit</td>
    <td class="tg-29iq">1bit</td>
    <td class="tg-29iq">2bit</td>
  </tr>
  <tr>
    <td class="tg-29iq">23bit</td>
    <td class="tg-29iq">2bit</td>
    <td class="tg-29iq">age</td>
    <td class="tg-29iq">偏向模式</td>
    <td class="tg-29iq">标志位</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-fw9x">未锁定</td>
    <td class="tg-baqh" colspan="2">对象哈希码（25）</td>
    <td class="tg-baqh">分代年龄</td>
    <td class="tg-baqh">0</td>
    <td class="tg-baqh">01</td>
  </tr>
  <tr>
    <td class="tg-fw9x">轻量级锁<br>自旋锁<br>无锁</td>
    <td class="tg-baqh" colspan="4">指向调用栈中锁记录指针（Lock Record）<br>ptr_to_lock_record(30)</td>
    <td class="tg-baqh">00</td>
  </tr>
  <tr>
    <td class="tg-fw9x">重量级锁定<br>（锁碰撞）</td>
    <td class="tg-baqh" colspan="4">指向互斥量（重量级锁）的指针<br>ptr_to_heavyweigth_monitor(30)</td>
    <td class="tg-baqh">10</td>
  </tr>
  <tr>
    <td class="tg-fw9x">GC标记</td>
    <td class="tg-baqh" colspan="4">空（30，CMS过程中用到的标记信息）</td>
    <td class="tg-baqh">11</td>
  </tr>
  <tr>
    <td class="tg-fw9x">可偏向</td>
    <td class="tg-baqh">当前线程指针JavaThread*（23）</td>
    <td class="tg-baqh">Epoch</td>
    <td class="tg-baqh">分代年龄</td>
    <td class="tg-baqh">1</td>
    <td class="tg-baqh">01</td>
  </tr>
</tbody>
</table>

<h5 id="64位虚拟机markword"><a href="#64位虚拟机markword" class="headerlink" title="64位虚拟机markword"></a>64位虚拟机markword</h5><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-mukq{background-color:#96FFFB;border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-hafo{background-color:#fffc9e;border-color:inherit;text-align:center;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-mukq" rowspan="3">锁状态</th>
    <th class="tg-hafo" colspan="7">64bit</th>
  </tr>
  <tr>
    <td class="tg-hafo" colspan="3">56bit</td>
    <td class="tg-hafo">1bit</td>
    <td class="tg-hafo">4bit</td>
    <td class="tg-hafo">1bit</td>
    <td class="tg-hafo">2bit</td>
  </tr>
  <tr>
    <td class="tg-hafo">25bit</td>
    <td class="tg-hafo">29bit</td>
    <td class="tg-hafo">2bit</td>
    <td class="tg-hafo">1bit</td>
    <td class="tg-hafo">age</td>
    <td class="tg-hafo">偏向模式</td>
    <td class="tg-hafo">标志位</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-mukq">未锁定</td>
    <td class="tg-c3ow">unused</td>
    <td class="tg-c3ow" colspan="2">对象哈希码（31）</td>
    <td class="tg-c3ow">unused</td>
    <td class="tg-c3ow">分代年龄</td>
    <td class="tg-c3ow">0</td>
    <td class="tg-c3ow">01</td>
  </tr>
  <tr>
    <td class="tg-mukq">轻量级锁<br>自旋锁<br>无锁</td>
    <td class="tg-c3ow" colspan="6">指向调用栈中锁记录指针（Lock Record）<br>ptr_to_lock_record(62)</td>
    <td class="tg-c3ow">00</td>
  </tr>
  <tr>
    <td class="tg-mukq">重量级锁定<br>（锁碰撞）</td>
    <td class="tg-c3ow" colspan="6">指向互斥量（重量级锁）的指针<br>ptr_to_heavyweigth_monitor(62)</td>
    <td class="tg-c3ow">10</td>
  </tr>
  <tr>
    <td class="tg-mukq">GC标记</td>
    <td class="tg-c3ow" colspan="6">空（CMS过程中用到的标记信息）</td>
    <td class="tg-c3ow">11</td>
  </tr>
  <tr>
    <td class="tg-mukq">可偏向</td>
    <td class="tg-c3ow" colspan="2">当前线程指针JavaThread*（54）</td>
    <td class="tg-c3ow">Epoch（2）</td>
    <td class="tg-c3ow">unused</td>
    <td class="tg-c3ow">分代年龄</td>
    <td class="tg-c3ow">1</td>
    <td class="tg-c3ow">01</td>
  </tr>
</tbody>
</table>

<h4 id="klass"><a href="#klass" class="headerlink" title="klass"></a>klass</h4><p>对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例.</p>
<ol>
<li>在Hotspot中，所有存储在由GC管理的堆（Java堆和PermGen）的子类的实例都有一个_klass字段，用于指向一个描述自身的元数据的对象</li>
<li>Java对象和数组对象的klass并不是Java中的Class。klass用于运行而Class只用于Java中的反射；klass中有_java_mirror字段执行java中的class</li>
<li>可压缩：每个Class的属性指针（即静态变量）、每个对象的属性指针（即对象变量）、普通对象数组的每个元素指针</li>
<li>不可压缩：比如指向Metaspace的Class对象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等</li>
</ol>
<h4 id="数组长度（只有数组对象有）"><a href="#数组长度（只有数组对象有）" class="headerlink" title="数组长度（只有数组对象有）"></a>数组长度（只有数组对象有）</h4><p>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><ol>
<li>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li>
<li>在Hotspot中对象实例数据紧跟在对象头后面分配空间</li>
<li>字段的分配顺序与代码中的顺序和Hotspot的分配策略相关</li>
<li>无论哪种策略都必须满足<ul>
<li>宽度相同的字段总是相邻分配</li>
<li>不同宽度的字段可能存在对象填充（padding）</li>
</ul>
</li>
<li>一般是基类声明的实例字段会出现在派生类声明字段之前，但是如果开启压缩模式时派生类较短的字段可能会插入到基类的实例字段之间的对齐填充部分</li>
<li>相关参数，参考FieldsAllocationStyle、CompactFields</li>
</ol>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><ol>
<li>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。</li>
<li>在Hotspot中，GC堆上的对象要求<strong>起始地址是8的倍数，占用的空间也必须是8的倍数</strong>，如果不足则用0补齐</li>
<li>对齐可能出现不同宽度的字段之间，也可能出现在对象的末尾</li>
<li>不存在为对齐数据时则不会对齐填充</li>
<li><strong>对象头部分正好是8字节的倍数</strong>（1倍或者2倍）</li>
<li>对象实例数据部分没有对齐时，就需要通过对齐填充来补全</li>
</ol>
<h2 id="对象大小计算"><a href="#对象大小计算" class="headerlink" title="对象大小计算"></a>对象大小计算</h2><ol>
<li>在32位系统下，存放Class指针的空间大小是4字节,MarkWord是4字节，对象头为8字节。</li>
<li>在64位系统下，存放Class指针的空间大小是8字节,MarkWord是8字节，对象头为16字节。</li>
<li>64位压缩，<ul>
<li>对象：存放Class指针的空间大小是4字节，MarkWord是8字节，对象头为12字节+对齐4=16字节。 </li>
<li>数组：MarkWord是8字节+存放Class指针的空间大小是4字节+数组长度4字节=16字节。</li>
</ul>
</li>
<li>静态属性不算在对象大小内。</li>
</ol>
<div align="center">

<img src="/2021/02/05/JVM-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/1589104073081.png" class title="对象大小计算">

</div>

<div align="center">

<img src="/2021/02/05/JVM-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/1589104088136.png" class title="对象大小计算">

</div>

<h2 id="对象分析工具JOL"><a href="#对象分析工具JOL" class="headerlink" title="对象分析工具JOL"></a>对象分析工具JOL</h2><h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="虚拟机信息"><a href="#虚拟机信息" class="headerlink" title="虚拟机信息"></a>虚拟机信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.vm.VM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回有关当前 VM 模式的信息详细信息</span></span><br><span class="line">        <span class="comment">//ClassLayout:class的内存内存布局</span></span><br><span class="line">        <span class="comment">//parseInstance:表示解析传入的对象</span></span><br><span class="line">        <span class="comment">//toPrintable:表示转换为一种可输出的格式打印</span></span><br><span class="line">        System.out.println(VM.current().details());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># WARNING: Unable to attach Serviceability Agent. You can try again with escalated privileges. Two options: a) use -Djol.tryWithSudo=true to try with sudo; b) echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line"># Running 64-bit HotSpot VM.</span><br><span class="line"># Using compressed oop with 3-bit shift.</span><br><span class="line"># Using compressed klass with 3-bit shift.</span><br><span class="line"># WARNING | Compressed references base/shifts are guessed by the experiment!</span><br><span class="line"># WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.</span><br><span class="line"># WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.</span><br><span class="line"># Objects are 8 bytes aligned.</span><br><span class="line"># Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span><br><span class="line"># Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span><br></pre></td></tr></table></figure>
<ol>
<li>第一行表示警告信息，可以忽略</li>
<li>第二行表示使用的虚拟机是64位</li>
<li>第三行表示启用普通对象指针压缩，即-XX:+UseCompressedOops</li>
<li>第四行表示启用类型指针压缩，即-XX:+UseCompressedClassPointers开启参数</li>
<li>第八行：对象的大小必须8bytes对齐。</li>
<li>第九行：表示字段类型的指针长度（bytes），依次为引用句柄（对象指针），byte, boolean, char, short, int, float, double, long类型。</li>
<li>第十行：表示数组类型的指针长度（bytes），依次为引用句柄（对象指针），byte, boolean, char, short, int, float, double, long类型。</li>
</ol>
<h3 id="普通对象信息"><a href="#普通对象信息" class="headerlink" title="普通对象信息"></a>普通对象信息</h3><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------- obj1 details ------------&quot;</span>);</span><br><span class="line">        JoLObj  obj1 = <span class="keyword">new</span> JoLObj();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoLObj</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number_1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> number_2 = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> number_3 = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.sunld.jvm.JoLObj object internals:</span><br><span class="line"> OFFSET  SIZE      TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>           (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>           (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>           (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>       <span class="keyword">int</span> JoLObj.number                             <span class="number">256</span></span><br><span class="line">     <span class="number">16</span>     <span class="number">4</span>       <span class="keyword">int</span> JoLObj.number_2                           <span class="number">11</span></span><br><span class="line">     <span class="number">20</span>     <span class="number">1</span>   <span class="keyword">boolean</span> JoLObj.flag                               <span class="keyword">false</span></span><br><span class="line">     <span class="number">21</span>     <span class="number">3</span>           (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">3</span> bytes external = <span class="number">3</span> bytes total</span><br></pre></td></tr></table></figure>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><ol>
<li>使用了64位vm，且进行了压缩</li>
<li>对象头占用12个Byte。 （8个Byte的markword，和被压缩后的klasss point为4个Byte）</li>
<li>对象实例9个Byte（int：4 + int：4 + boolean：1）</li>
<li>对齐占用了3个字节（因为在64位虚拟机上对象的大小必须是Word字长的倍数，既8字节的倍数）</li>
<li>静态变量不在对象头中</li>
</ol>
<h3 id="hashcode分析"><a href="#hashcode分析" class="headerlink" title="hashcode分析"></a>hashcode分析</h3><h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JoLObj  obj1 = <span class="keyword">new</span> JoLObj();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------- before hash ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1 hashcode is: &quot;</span> + Integer.toBinaryString(obj1.hashCode()));</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1 hashcode is: &quot;</span> + Integer.toHexString(obj1.hashCode()));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------- after hash ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoLObj</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number_1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> number_2 = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> number_3 = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.sunld.jvm.JoLObj object internals:</span><br><span class="line"> OFFSET  SIZE      TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>           (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>           (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>           (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>       <span class="keyword">int</span> JoLObj.number                             <span class="number">256</span></span><br><span class="line">     <span class="number">16</span>     <span class="number">4</span>       <span class="keyword">int</span> JoLObj.number_2                           <span class="number">11</span></span><br><span class="line">     <span class="number">20</span>     <span class="number">1</span>   <span class="keyword">boolean</span> JoLObj.flag                               <span class="keyword">false</span></span><br><span class="line">     <span class="number">21</span>     <span class="number">3</span>           (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">3</span> bytes external = <span class="number">3</span> bytes total</span><br><span class="line"></span><br><span class="line">obj1 hashcode is: <span class="number">100100001101111100011011011100</span></span><br><span class="line">obj1 hashcode is: 2437c6dc</span><br><span class="line">----------- after hash ------------</span><br><span class="line">com.sunld.jvm.JoLObj object internals:</span><br><span class="line"> OFFSET  SIZE      TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>           (object header)                           <span class="number">01</span> dc c6 <span class="number">37</span> (<span class="number">00000001</span> <span class="number">11011100</span> <span class="number">11000110</span> <span class="number">00110111</span>) (<span class="number">935779329</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>           (object header)                           <span class="number">24</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00100100</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">36</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>           (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>       <span class="keyword">int</span> JoLObj.number                             <span class="number">256</span></span><br><span class="line">     <span class="number">16</span>     <span class="number">4</span>       <span class="keyword">int</span> JoLObj.number_2                           <span class="number">11</span></span><br><span class="line">     <span class="number">20</span>     <span class="number">1</span>   <span class="keyword">boolean</span> JoLObj.flag                               <span class="keyword">false</span></span><br><span class="line">     <span class="number">21</span>     <span class="number">3</span>           (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">3</span> bytes external = <span class="number">3</span> bytes total</span><br></pre></td></tr></table></figure>
<h4 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h4><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax"></th>
    <th class="tg-0lax">对象markword（小端）</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">计算hashcode前</td>
    <td class="tg-0lax">00000001 00000000 00000000 00000000 00000000 00000000 00000000 00000000</td>
  </tr>
  <tr>
    <td class="tg-0lax">计算hashcode后</td>
    <td class="tg-0lax">00000001 11011100 11000110 00110111 00100100 00000000 00000000 00000000</td>
  </tr>
</tbody>
</table>

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax"></th>
    <th class="tg-0lax">对象markword（大端）</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">计算hashcode前</td>
    <td class="tg-0lax">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</td>
  </tr>
  <tr>
    <td class="tg-0lax">计算hashcode后</td>
    <td class="tg-0lax">00000000 00000000 00000000 00100100 00110111 11000110 11011100 00000001</td>
  </tr>
</tbody>
</table>

<ol>
<li>在未计算hashcode之前，markword中默认都是0，计算之后保存到对象头的markword中</li>
<li>25bit表示unused</li>
<li>31bit表示hashcode：0100100 00110111 11000110 11011100</li>
<li>4bit（0000）表示age， GC中分代年龄。由于age只有4位，所以最大值为15</li>
<li>1个bit为：biased_lock，值为0，表示无偏向锁（计算hashcode后不在使用偏向锁）</li>
<li>2个bit为：lock状态，值为01，表示未锁定</li>
</ol>
<h3 id="age变化"><a href="#age变化" class="headerlink" title="age变化"></a>age变化</h3><h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;nativeOrder:&quot;</span> + ByteOrder.nativeOrder()); <span class="comment">//查看当前JVM使用字节序是大端、小端。</span></span><br><span class="line">        JoLObj  obj1 = <span class="keyword">new</span> JoLObj();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------- before gc ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        System.gc(); <span class="comment">// 人工发起GC</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------- after GC ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoLObj</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number_1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> number_2 = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> number_3 = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.sunld.jvm.JoLObj object internals:</span><br><span class="line"> OFFSET  SIZE      TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>           (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>           (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>           (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>       <span class="keyword">int</span> JoLObj.number                             <span class="number">256</span></span><br><span class="line">     <span class="number">16</span>     <span class="number">4</span>       <span class="keyword">int</span> JoLObj.number_2                           <span class="number">11</span></span><br><span class="line">     <span class="number">20</span>     <span class="number">1</span>   <span class="keyword">boolean</span> JoLObj.flag                               <span class="keyword">false</span></span><br><span class="line">     <span class="number">21</span>     <span class="number">3</span>           (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">3</span> bytes external = <span class="number">3</span> bytes total</span><br><span class="line"></span><br><span class="line">----------- after GC ------------</span><br><span class="line">com.sunld.jvm.JoLObj object internals:</span><br><span class="line"> OFFSET  SIZE      TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>           (object header)                           09 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00001001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">9</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>           (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>           (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>       <span class="keyword">int</span> JoLObj.number                             <span class="number">256</span></span><br><span class="line">     <span class="number">16</span>     <span class="number">4</span>       <span class="keyword">int</span> JoLObj.number_2                           <span class="number">11</span></span><br><span class="line">     <span class="number">20</span>     <span class="number">1</span>   <span class="keyword">boolean</span> JoLObj.flag                               <span class="keyword">false</span></span><br><span class="line">     <span class="number">21</span>     <span class="number">3</span>           (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">3</span> bytes external = <span class="number">3</span> bytes total</span><br></pre></td></tr></table></figure>
<h4 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h4><p>可以看到大端的最后一个字节数据：从00000001变成了00001001，既age增加了1</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>关于锁的对象头分析请参考<a href="https://www.sunliaodong.cn/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%94%81/" target="_blank">java并发编程之锁</a></p>
<h2 id="对象的定位"><a href="#对象的定位" class="headerlink" title="对象的定位"></a>对象的定位</h2><p>参考：<a href="https://www.sunliaodong.cn/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" target="_blank">JVM内存区域</a></p>
<h3 id="HotSpot对象模型"><a href="#HotSpot对象模型" class="headerlink" title="HotSpot对象模型"></a>HotSpot对象模型</h3><p>HotSpot中采用了<strong>OOP-Klass</strong>模型，它是描述Java对象实例的模型，它分为两部分：</p>
<ol>
<li>类加载到内存时封装为<strong>klass</strong>，klass包含类的元数据信息（比如类的方法、常量池等信息，类似于java.lang.Class对象）</li>
<li><strong>OOP（Ordinary Object Pointer）</strong> ：普通对象指针，包含MarkWord（存储当前指针指向的对象运行时的一些状态数据） 和元数据指针（指向klass，表示使用的对象类型）</li>
</ol>
<blockquote>
<p>HotSopt JVM的设计者把对象模型拆成<strong>klass和oop</strong>，其中oop中不含有任何虚函数，而klass就含有虚函数表，可以进行method dispatch。<br>HotSpot中，OOP-Klass实现的代码都在/hotspot/src/share/vm/oops/路径下，oop的实现为<strong>instanceOop 和 arrayOop</strong>，他们来描述对象头，其中arrayOop对象用于描述数组类型。</p>
</blockquote>
<p>以下就是oop.hhp文件中oopDesc的源码，可以看到两个变量_mark就是MarkWord，_metadata就是元数据指针，指向klass对象，这个指针压缩的是32位，未压缩的是64位；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> markOop _mark; <span class="comment">// 标识运行时数据</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">metadata</span> &#123;</span></span><br><span class="line">  Klass* _klass;</span><br><span class="line">  narrowKlass _compressed_klass;</span><br><span class="line">&#125; _metadata; <span class="comment">//klass指针</span></span><br></pre></td></tr></table></figure>
<p>一个Java对象在内存中的布局可以连续分成两部分：instanceOop（继承自oop.hpp）和实例数据；通过栈帧中的对象引用reference找到Java堆中的对象，再通过对象的<strong>instanceOop中的元数据指针klass来找到方法区中的instanceKlass</strong>，从而确定该对象的类型。执行过程：</p>
<ol>
<li><strong>类加载</strong>：在JVM内部创建一个instanceKlass对象表示这个类的运行时元数据（类似Class对象）</li>
<li><strong>初始化对象的时候</strong>（执行invokespecial ***::），JVM就会创建一个instanceOopDesc对象表示这个对象的实例，然后进行Mark Word的填充，将元数据指针指向Klass对象，并填充实例变量。</li>
<li>元数据—— instanceKlass 对象会存在元空间（方法区）</li>
<li>对象实例—— instanceOopDesc 会存在Java堆。Java虚拟机栈中会存有这个对象实例的引用。</li>
</ol>
<h3 id="成员变量重排序"><a href="#成员变量重排序" class="headerlink" title="成员变量重排序"></a>成员变量重排序</h3><p>为了提高性能，每个对象的起始地址都对齐于8字节，当封装对象的时候为了高效率，对象字段声明的顺序会被重排序成下列基于字节大小的顺序：</p>
<ol>
<li>double (8字节) 和 long (8字节)</li>
<li>int (4字节) 和 float (4字节)</li>
<li>short (2字节) 和 char (2字节)：char在java中是2个字节。java采用unicode，2个字节（16位）来表示一个字符。</li>
<li>boolean (1字节) 和 byte (1字节)</li>
<li>reference引用 (4/8 字节)</li>
<li>&lt;子类字段重复上述顺序&gt;</li>
</ol>
<p>我们可以测试一下java对不同类型的重排序，使用jdk1.8，采用反射的方式先获取到unsafe类，然后获取到每个field在类里面的偏移地址，就能看出来了<br>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Contended;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> contended_boolean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">byte</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> contended_short;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">char</span> d;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">short</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">float</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> contended_int;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> contended_double;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> g;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;ALL&quot;)</span></span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, SecurityException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;e:int    \t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;e&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;g:double \t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;g&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;h:long   \t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;h&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;f:float  \t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;f&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;c:short  \t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;c&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;d:char   \t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;d&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;a:byte   \t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;a&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;b:boolean\t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;b&quot;</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;contended_boolean:boolean\t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;contended_boolean&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;contended_short:short\t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;contended_short&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;contended_int:int\t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;contended_int&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;contended_double:double\t&quot;</span>+UNSAFE.objectFieldOffset(TypeSequence.class.getDeclaredField(<span class="string">&quot;contended_double&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码运行结果如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e:<span class="keyword">int</span>    	<span class="number">40</span></span><br><span class="line">g:<span class="keyword">double</span> 	<span class="number">24</span></span><br><span class="line">h:<span class="keyword">long</span>   	<span class="number">32</span></span><br><span class="line">f:<span class="keyword">float</span>  	<span class="number">44</span></span><br><span class="line">c:<span class="keyword">short</span>  	<span class="number">54</span></span><br><span class="line">d:<span class="keyword">char</span>   	<span class="number">52</span></span><br><span class="line">a:<span class="keyword">byte</span>   	<span class="number">57</span></span><br><span class="line">b:<span class="keyword">boolean</span>	<span class="number">58</span></span><br><span class="line">contended_boolean:<span class="keyword">boolean</span>	<span class="number">56</span></span><br><span class="line">contended_short:<span class="keyword">short</span>	<span class="number">12</span></span><br><span class="line">contended_int:<span class="keyword">int</span>	<span class="number">48</span></span><br><span class="line">contended_double:<span class="keyword">double</span>	<span class="number">16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了int字段跑到了前面来了，还有两个添加了contended注解的字段外，其它字段都是按照重排序的顺序，类型由最长到最短的顺序排序的；</p>
<h4 id="对象头对成员变量排序的影响"><a href="#对象头对成员变量排序的影响" class="headerlink" title="对象头对成员变量排序的影响"></a>对象头对成员变量排序的影响</h4><p>由于对象头有12个字节，会优先选择一个字段填充为16字节，所以int调整到前面；但是如果无法调整则使用padding来填充。</p>
<h4 id="扩展contended对成员变量排序的影响"><a href="#扩展contended对成员变量排序的影响" class="headerlink" title="扩展contended对成员变量排序的影响"></a>扩展contended对成员变量排序的影响</h4><ol>
<li>解决cpu缓存行伪共享问题的</li>
<li>加了contended注解的字段会按照声明的顺序放到末尾，contended注解如果是用在类的field上会在该field前面插入128字节的padding，如果是用在类上则会在类所有field的前后都加上128字节的padding</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.toutiao.com/i6799522958990639628">记一次生产频繁出现 Full GC 的 GC日志图文详解</a></li>
<li><a href="http://openjdk.java.net/">openjdk</a></li>
<li><a href="https://github.com/openjdk/jol">jol</a></li>
<li><a href="https://blog.csdn.net/zyplanke/article/details/106893992">Java对象头Object Header、偏向锁、轻量锁、重量锁研究</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
        <tag>Java内存对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存区域</title>
    <url>/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/1589456413403.png" class title="JVM内存区域知识图谱">

</div>

<a id="more"></a>

<h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><ol>
<li>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。</li>
<li>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束而创建/销毁，线程共享区域随虚拟机的启动/关闭而创建/销毁。</li>
<li>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用（NIO，DirectByteBuffer）</li>
</ol>
<div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" class>

</div>

<h2 id="程序计数器-线程私有"><a href="#程序计数器-线程私有" class="headerlink" title="程序计数器(线程私有)"></a>程序计数器(线程私有)</h2><p> 由于JAVA的多线程是通过线程轮流切换分配处理时间的方式实现，为了保证能够恢复到线程的正确位置，每个线程再启动的时候都会创建<strong>一块较小的内存区域</strong>，这块区域是<strong>线程隔离</strong>的，生命周期同线程绑定，线程结束，则释放该内存区域，可以看作是当前线程所执行的字节码的行号子令器。  </p>
<p><strong>字节码子令器的工作模式是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</strong>  </p>
<p>计数器的大小是一个字长，因此既可以持有一个本地指针，又可以持有一个returnAddress。计数器中记录的内容根据方法类型就行划分，如果当前方法是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址（可以是一个本地指针，也可以是在方法字节码中相对于该方法起始指令的偏移量）；如果方法是Native方法，这个计数器记录的内容则为Undefined。  </p>
<blockquote>
<p>Each thread of a running program has its own pc register, or program counter, which is created when the thread is started. The pc register is one word in size, so it can hold both a native pointer and a returnValue. As a thread executes a Java method, the pc register contains the address of the current instruction being executed by the thread. An “address” can be a native pointer or an offset from the beginning of a method’s bytecodes. If a thread is executing a native method, the value of the pc register is undefined.</p>
</blockquote>
<p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p>
<h3 id="程序计数器总结"><a href="#程序计数器总结" class="headerlink" title="程序计数器总结"></a>程序计数器总结</h3><ol>
<li>占用的 JVM 内存空间较小</li>
<li>每个线程生命周期内独享自己的程序计数器（内部存放的是字节码指令的地址引用）</li>
<li>不会发生 OOM</li>
</ol>
<h2 id="虚拟机栈-线程私有"><a href="#虚拟机栈-线程私有" class="headerlink" title="虚拟机栈(线程私有)"></a>虚拟机栈(线程私有)</h2><p>用于描述java方法执行的线程内存模型，每个方法被执行的时候线程都会在栈中创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、返回值等信息的数据集。生命周期与线程同步，每个方法从调用到执行完成就是一个栈帧在VM Stack中入栈出栈的过程。</p>
<div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/1589457383204.png" class>

</div>

<p>栈帧的数据结构：  </p>
<ol>
<li>局部变量表：输入参数和输出参数以及方法内的变量；</li>
<li>操作数栈：记录出栈和入栈的操作；</li>
<li>栈帧数据：包括类文件、方法等等。</li>
</ol>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>可以理解为使用素组管理内存的方式，从0开始；存放编译期可知的Java基本类型（8种）、对象引用、入参信息以及出参信息（returnAddress）。</p>
<h4 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h4><p>局部变量表中存储空间以局部变量槽（Slot，32位）表示，局部变量表所需要的内存在编译阶段完成分配。64位的long和double使用两个slot。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runClassMethod</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">long</span> l,<span class="keyword">float</span> f,<span class="keyword">double</span> d,Object o,<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">runInstanceMethod</span><span class="params">(<span class="keyword">char</span> c,<span class="keyword">double</span> d,<span class="keyword">short</span> s,<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/1589512957352.png" class>

</div>

<p>runInstanceMethod的局部变量区第一项是个reference（引用），它指定的就是对象本身的引用，也就是我们常用的this,但是在runClassMethod方法中，没这个引用，那是因为runClassMethod是个静态方法。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>与局部变量表类似，组织成一个以字长为单位的数组。但是是使用出栈入栈的方式进行访问；操作数栈是临时数据的存储区域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a= <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c = a+b;</span><br></pre></td></tr></table></figure>
<p>对应的操作数栈变化为：  </p>
<div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/1589513290674.png" class>

</div>

<blockquote>
<p>JVM实现里，有一种基于栈的指令集(Hotspot，oracle JVM)，还有一种基于寄存器的指令集(DalvikVM，安卓 JVM)</p>
</blockquote>
<h3 id="帧数据区"><a href="#帧数据区" class="headerlink" title="帧数据区"></a>帧数据区</h3><p>帧数据区存放了指向常量池的指针地址，当某些指令需要获得常量池的数据时，通过帧数据区中的指针地址来访问常量池的数据。此外，帧数据区还存放方法正常返回和异常终止需要的一些数据。</p>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</li>
<li>如果VM栈可以动态扩展，在初始化新线程时没有足够内存创建栈则抛出OutOfMemoryError异常。</li>
</ol>
<h3 id="虚拟机栈图解"><a href="#虚拟机栈图解" class="headerlink" title="虚拟机栈图解"></a>虚拟机栈图解</h3><div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%9B%BE%E8%A7%A3.png" class title="虚拟机栈图解">

</div>

<h3 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># -Xss ：用于设置栈的大小，栈的大小决定了方法调用的深度。</span><br><span class="line"># 设置线程栈大小为 512k（以字节为单位）</span><br><span class="line">-Xss 512k</span><br></pre></td></tr></table></figure>
<h3 id="虚拟机栈总结"><a href="#虚拟机栈总结" class="headerlink" title="虚拟机栈总结"></a>虚拟机栈总结</h3><ol>
<li>内部结构是栈帧，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法返回地址等信息</li>
<li>某方法在调用另一个方法是通过动态链接在常量池中查询方法的引用，进而完成方法调用</li>
<li>某方法在调用另一个方法的过程，即是一个栈帧在虚拟机中的入栈到出栈的过程</li>
<li>虚拟机中的方法入栈的顺序和方法的调用顺序是一致的</li>
</ol>
<h2 id="本地方法栈-线程私有"><a href="#本地方法栈-线程私有" class="headerlink" title="本地方法栈(线程私有)"></a>本地方法栈(线程私有)</h2><p>与Java Stack类似，主要区别是，Java Stack用于执行Java方法服务，本地方法栈用于native方法服务。</p>
<ol>
<li>和虚拟机栈类似，内部结构是栈帧，每个 Native 方法执行时创建一个栈帧</li>
<li>该部分没有规定内存大小</li>
</ol>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>当调用一个native方法时，jvm使用c-linkage模型支持native调用，并且创建一个C栈，由于《Java虚拟机规范》没有对该实现有具体要求，所以不同厂商的实现方式不同，比如HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。它的具体做法是在本地方法栈中登记native方法，在执行引擎执行时加载Native Liberies。</p>
<h2 id="Java堆（Heap-线程共享）-运行时数据区"><a href="#Java堆（Heap-线程共享）-运行时数据区" class="headerlink" title="Java堆（Heap-线程共享）-运行时数据区"></a>Java堆（Heap-线程共享）-运行时数据区</h2><ol>
<li>线程共享区域</li>
<li>存储对象和数组数据</li>
<li>垃圾回收重点关注区域（内存最大的一块区域）</li>
<li>从 GC 的角度还可以细分为:<strong>新生代(Eden区、From Survivor区和To Survivor区)和老年代。</strong></li>
<li>从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB），以提升对象分配时的效率。</li>
<li>通过-Xmx和-Xms设置内存大小，内存溢出则出现OOM错误，最小默认为物理内存的1/64，最大为物理内存的1/4</li>
<li>默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列</li>
<li>建议-Xmx和-Xms设置一致</li>
</ol>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><ol>
<li>存放新创建的对象</li>
<li>占用堆的1/3空间</li>
<li>回收机制：MinorGC</li>
<li>划分Eden 区、ServivorFrom、ServivorTo 三个区。</li>
<li>可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。</li>
</ol>
<h4 id="Eden-区"><a href="#Eden-区" class="headerlink" title="Eden 区"></a>Eden 区</h4><p>Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。</p>
<h4 id="ServivorFrom"><a href="#ServivorFrom" class="headerlink" title="ServivorFrom"></a>ServivorFrom</h4><p>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p>
<h4 id="ServivorTo"><a href="#ServivorTo" class="headerlink" title="ServivorTo"></a>ServivorTo</h4><p>保留了一次 MinorGC 过程中的幸存者。</p>
<h4 id="MinorGC-的过程（复制-gt-清空-gt-互换）"><a href="#MinorGC-的过程（复制-gt-清空-gt-互换）" class="headerlink" title="MinorGC 的过程（复制-&gt;清空-&gt;互换）"></a>MinorGC 的过程（复制-&gt;清空-&gt;互换）</h4><ol>
<li>MinorGC 采用复制算法。</li>
<li>把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；</li>
<li>清空 Eden 和 ServicorFrom 中的对象；</li>
<li>ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC的ServicorFrom 区。</li>
</ol>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><ol>
<li>存放生命周期较长的对象</li>
<li>该区域对象比较稳定，MajorGC不会频繁执行</li>
<li>进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。</li>
<li>当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。</li>
<li>MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</li>
<li>新建对象直接进入该区域的条件：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。</li>
<li>内存大小为-Xmx对应的值减去-Xmn对应的值</li>
</ol>
<h3 id="内存展现图例"><a href="#内存展现图例" class="headerlink" title="内存展现图例"></a>内存展现图例</h3><div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/1589511590668.png" class>

</div>

<h3 id="内存参数设置"><a href="#内存参数设置" class="headerlink" title="内存参数设置"></a>内存参数设置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 设置堆区的初始大小</span><br><span class="line">-Xms1024m</span><br><span class="line"># 设置堆区的存储空间最大值，一般与堆区的初始大小相等</span><br><span class="line">-Xmx1024m</span><br><span class="line"># 设置年轻代堆的大小</span><br><span class="line">-Xmn512m</span><br><span class="line"># 设置如下参数，在出现OOM时进行堆转储</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"># 设置以上设置时，需配置以下参数，堆转储文件输出的位置</span><br><span class="line">-XX:HeapDumpPath=/usr/log/java_dump.hprof</span><br></pre></td></tr></table></figure>
<h2 id="方法区-永久代（Permanent-Generation，线程共享）"><a href="#方法区-永久代（Permanent-Generation，线程共享）" class="headerlink" title="方法区/永久代（Permanent Generation，线程共享）"></a>方法区/永久代（Permanent Generation，线程共享）</h2><ol>
<li>线程共享</li>
<li>存储被jvm加载的类型信息、常量、静态变量、即时编译期编译后的代码缓存数据</li>
<li>HotSpot VM也会针对该区域进行垃圾回收，主要是针对常量池回收和类型卸载，收益比较低</li>
<li>内存不足出现OOM</li>
<li>JDK8之后使用元空间替代了永久代</li>
<li>默认最小16MB，最大64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小</li>
</ol>
<div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%8E%E6%B0%B8%E4%B9%85%E4%BB%A3.png" class title="方法区与永久代">
<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9C%A8%E4%B8%8D%E5%90%8CJDK%E7%89%88%E6%9C%AC%E6%AF%94%E8%BE%83.png" class title="方法区在不同JDK版本比较">
<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB.png" class title="方法区和元空间的区别">

</div>

<h3 id="内存参数设置-1"><a href="#内存参数设置-1" class="headerlink" title="内存参数设置"></a>内存参数设置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># jdk1.7 设置永久代内存初始大小</span><br><span class="line">-XX:PermSize=512m</span><br><span class="line"># jdk1.7 设置永久代内存最大值</span><br><span class="line">-XX:MaxPermSize=512m</span><br><span class="line"># jdk1.8 设置元空间内存初始大小</span><br><span class="line">-XX:MetaspaceSize=1024m</span><br><span class="line"># jdk1.8 设置元空间内存最大值</span><br><span class="line">-XX:MaxMetaspaceSize=1024m</span><br></pre></td></tr></table></figure>
<h3 id="JAVA8-与元数据"><a href="#JAVA8-与元数据" class="headerlink" title="JAVA8 与元数据"></a>JAVA8 与元数据</h3><p>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。<strong>类的元数据放入native memory, 字符串池和类的静态变量放入 java 堆中</strong>，这样可以加载多少类的元数据就不再由<br>MaxPermSize 控制, 而由系统的实际可用空间来控制。</p>
<h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><ol>
<li>Class文件中的常量池表</li>
<li>存放编译期生成的各种<strong>字面量和符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>相较于Class文件常量池，运行时常量池更具动态性，在运行期间也可以将新的变量放入常量池中，而不是一定要在编译时确定的常量才能放入。最主要的运用便是String类的intern()方法。</li>
<li>内存不足会出现OOM</li>
</ol>
<div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/1589103068348.png" class>

</div>

<h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><ol>
<li>不属于JVM运行时的数据区域</li>
<li>内存不足会出现OOM错误</li>
<li>JDK中NIO使用通道和缓冲区的IO方式，使用native函数库直接在堆外分配内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作</li>
<li>受限于本机内存</li>
</ol>
<h2 id="执行引擎-Execution-Engine"><a href="#执行引擎-Execution-Engine" class="headerlink" title="执行引擎(Execution Engine)"></a>执行引擎(Execution Engine)</h2><p>执行引擎执行包在装载类的方法中的指令，也就是方法。执行引擎以指令为单位读取Java字节码。它就像一个CPU一样，一条一条地执行机器指令。每个字节码指令都由一个1字节的操作码和附加的操作数组成。执行引擎取得一个操作码，然后根据操作数来执行任务，完成后就继续执行下一条操作码。</p>
<p>执行引擎必须把字节码转换成可以直接被JVM执行的语言。字节码可以通过以下两种方式转换成合适的语言：</p>
<ol>
<li>解释器： 一条一条地读取，解释并执行字节码执行，所以它可以很快地解释字节码，但是执行起来会比较慢。</li>
<li>即时编译器：用来弥补解释器的缺点，执行引擎首先按照解释执行的方式来执行，然后在合适的时候，即时编译器把整段字节码编译成本地代码。然后，执行引擎就没有必要再去解释执行方法了，它可以直接通过本地代码去执行。执行本地代码比一条一条进行解释执行的速度快很多，编译后的代码可以执行的很快，因为本地代码是保存在缓存里的。</li>
</ol>
<div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/1589103093701.png" class>

</div>

<h2 id="场景内存溢出分析"><a href="#场景内存溢出分析" class="headerlink" title="场景内存溢出分析"></a>场景内存溢出分析</h2><h2 id="对象分析-ObjectA-a-new-ObjectA"><a href="#对象分析-ObjectA-a-new-ObjectA" class="headerlink" title="对象分析(ObjectA a = new ObjectA())"></a>对象分析(ObjectA a = new ObjectA())</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" class title="对象创建过程">

</div>

<ol>
<li>在虚拟机栈创建栈帧</li>
<li>栈帧内创建对象的引用</li>
<li>方法区进行类的加载</li>
<li>Java 堆区进行分配内存并内存初始化</li>
<li>回到栈帧中初始化对象的数据</li>
</ol>
<h3 id="内存分配过程"><a href="#内存分配过程" class="headerlink" title="内存分配过程"></a>内存分配过程</h3><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><ol>
<li>支持<strong>压缩功能</strong>的垃圾收集器Serial、ParNew 等（Compact 过程），</li>
<li>分开已使用和未使用的内存，两者之间使用一个指针作为分界点指示器</li>
<li>分配内存只需移动指针，分界点指示器向未使用的内存一侧移动一段与对象大小相等的空间</li>
</ol>
<div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98.png" class title="指针碰撞分配内存">

</div>

<h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><ol>
<li>使用<strong>标记清除（Mark-Sweep）算法</strong>的 CMS 垃圾回收器</li>
<li>内存划分成网格区（Region），内存分配不规整，即已使用的和未使用的内存随机分布</li>
<li>JVM 维护一个记录表，用于记录那些内存可用于分配</li>
<li>需要给对象分配内存区域时，寻找一块足够大的内存空间分配给对象，并更新记录表</li>
</ol>
<div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98.png" class title="空闲列表分配内存">

</div>

<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="同步处理"><a href="#同步处理" class="headerlink" title="同步处理"></a>同步处理</h4><p>内存分配的动作采用同步机制，JVM 为了增加效率采用了 CAS 方式。</p>
<h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><ol>
<li>全称：Thread Local Allocation Buffer</li>
<li>原理：每个线程在 Java 堆中预先分配一小块内存，叫做本地线程分配缓冲区。类似于ThreadLocal</li>
<li>哪个线程需要分配内存先去各自的 TLAB 中分配，但是这个缓冲区比较小，是为了加速对象的分配。只有在线程的 TLAB 用完才会去堆中进行内存分配，此时才需要同步机制。</li>
</ol>
<div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/TLAB%E7%BC%93%E5%86%B2%E5%8C%BA.png" class title="TLAB缓冲区">

</div>

<h3 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h3><h4 id="直接访问（HotSpot使用）"><a href="#直接访问（HotSpot使用）" class="headerlink" title="直接访问（HotSpot使用）"></a>直接访问（HotSpot使用）</h4><div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F-%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE.png" class title="对象访问方式-直接访问">

</div>

<p><strong>优点</strong>：相对于句柄访问定位的方式，减少了一次指针定位的开销（也减少了句柄池的存储空间），HotSpot JVM 实现采用的是直接访问的方式进行对象访问定位。</p>
<h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><div align="center">

<img src="/2021/02/05/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" class title="对象访问方式-句柄访问">

</div>

<p><strong>优点</strong>：在垃圾回收的时候对象要经常转移，这时候只需改变句柄中指向对象实例数据的指针即可（不用修改 reference）</p>
<h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>参考《<a href="https://www.sunliaodong.cn/2021/02/05/JVM-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/" target="_blank">JVM HotSpot虚拟机对象探秘</a>》。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="JVM-中-GC-参数的设置"><a href="#JVM-中-GC-参数的设置" class="headerlink" title="JVM 中 GC 参数的设置"></a>JVM 中 GC 参数的设置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 在控制台输出GC情况</span><br><span class="line">-verbose:gc </span><br><span class="line"># GC日志输出</span><br><span class="line">-XX:+PrintGC</span><br><span class="line"># GC日志详细输出</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"># GC输出时间戳</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"># GC日志输出指定文件中</span><br><span class="line">-Xloggc:/log/gc.log</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://www.toutiao.com/i6797907413220459019">从Java代码运行聊到JVM及对象创建-分配-定位-布局-垃圾回收</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之Condition</title>
    <url>/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;Condition在jdk1.5中开始出现，主要是用来替代传统Object对象中的wait和notify方法，Object的wait和notify/notify是与<font color="red">对象监视器</font>配合完成线程间的等待/通知机制，而Condition与Lock配合完成等待通知机制，前者是java底层级别的（配合synchronized），后者是语言级别的（配合Lock），具有更高的可控制性和扩展性相比来说更加安全和  高效。</p>
<a id="more"></a>

<h2 id="Condition与Object的比对"><a href="#Condition与Object的比对" class="headerlink" title="Condition与Object的比对"></a>Condition与Object的比对</h2><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-amwm">比对项</th>
    <th class="tg-amwm">Object Monitor Methods</th>
    <th class="tg-amwm">Condition</th>
  </tr>
  <tr>
    <td class="tg-0lax">前置条件</td>
    <td class="tg-0lax">获取对象锁</td>
    <td class="tg-0lax">使用Lock.lock()获取锁<br><span style="font-weight:400;font-style:normal">使用Lock.newCondition()获取Condition</span><br></td>
  </tr>
  <tr>
    <td class="tg-0lax">调用方式</td>
    <td class="tg-0lax">Object.wait()</td>
    <td class="tg-0lax">Condition.await()</td>
  </tr>
  <tr>
    <td class="tg-0lax">等待队列个数</td>
    <td class="tg-0lax">1</td>
    <td class="tg-0lax">多个</td>
  </tr>
  <tr>
    <td class="tg-0lax">当前线程释放锁并进入等待状态</td>
    <td class="tg-0lax">支持</td>
    <td class="tg-0lax">支持</td>
  </tr>
  <tr>
    <td class="tg-0lax">当前线程释放锁并进入等待状态，在等待状态中不响应中断</td>
    <td class="tg-0lax">不支持</td>
    <td class="tg-0lax">支持<br><span style="font-weight:400;font-style:normal">awaitUninterruptibly()</span><br></td>
  </tr>
  <tr>
    <td class="tg-0lax">当前线程释放锁并进入超时等待状态</td>
    <td class="tg-0lax">支持</td>
    <td class="tg-0lax">支持</td>
  </tr>
  <tr>
    <td class="tg-0lax">当前线程释放锁并进入等待状态到某个时刻</td>
    <td class="tg-0lax">不支持</td>
    <td class="tg-0lax">支持<br><span style="font-weight:400;font-style:normal">awaitUntil(Date deadline)</span><br></td>
  </tr>
  <tr>
    <td class="tg-0lax">唤醒等待队列中的一个线程</td>
    <td class="tg-0lax">支持notify</td>
    <td class="tg-0lax">支持signal</td>
  </tr>
  <tr>
    <td class="tg-0lax">唤醒等待队列中的所有线程</td>
    <td class="tg-0lax">支持notifyAll</td>
    <td class="tg-0lax">支持signalAll</td>
  </tr>
  <tr>
    <td class="tg-0lax">随机性</td>
    <td class="tg-0lax">唤醒随机</td>
    <td class="tg-0lax">可以唤醒指定条件的线程</td>
  </tr>
</table>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>一般使用的时候定义为成员变量，condition可以根据实际情况定义为多个，注意在使用过程中锁的释放、中断响应以及等待通知处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionExample1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	以成员变量的方式定义锁</span></span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//	获取condition</span></span><br><span class="line">	<span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lockInterruptibly();</span><br><span class="line">			condition.await();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lockInterruptibly();</span><br><span class="line">			condition.signal();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="等待方法"><a href="#等待方法" class="headerlink" title="等待方法"></a>等待方法</h2><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程进入等待状态，如果其他线程调用condition的signal</span></span><br><span class="line"><span class="comment"> * 或者signalAll方法并且当前线程获取Lock从await方法返回，</span></span><br><span class="line"><span class="comment"> * 如果在等待状态中被中断会抛出被中断异常；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同awaitNanos，支持自定义时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<h3 id="awaitUninterruptibly"><a href="#awaitUninterruptibly" class="headerlink" title="awaitUninterruptibly"></a>awaitUninterruptibly</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同await，但是不响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="awaitNanos"><a href="#awaitNanos" class="headerlink" title="awaitNanos"></a>awaitNanos</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程进入等待状态直到被通知，中断或者超时；返回剩余时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<h3 id="awaitUntil"><a href="#awaitUntil" class="headerlink" title="awaitUntil"></a>awaitUntil</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程进入等待状态直到被通知，中断或者到了某个时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<h2 id="唤醒方法"><a href="#唤醒方法" class="headerlink" title="唤醒方法"></a>唤醒方法</h2><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒一个等待在condition上的线程，将该线程从等待队列中转移到同步队列中，</span></span><br><span class="line"><span class="comment"> * 如果在同步队列中能够竞争到Lock则可以从等待方法中返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有等待在condition上的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/1587461246450.png" class title="condition类图">

</div>

<h3 id="队列实现原理"><a href="#队列实现原理" class="headerlink" title="队列实现原理"></a>队列实现原理</h3><p>Condition使用Lock的newCondition方法获取（Condition newCondition();）具体实现过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回了AbstractQueuedSynchronizer中的内部类ConditionObject，Condition内部与lock（AQS思想）一样维护了一个等待队列（每个condition中都会维护一个队列）。所有调用condition.await方法的线程会加入到等待队列中，并且线程状态转换为等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类<font color="red">AbstractQueuedSynchronizer.Node</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/1587458843343.png" class>

</div>

<ol>
<li>调用condition.await方法后线程依次尾插入到等待队列中，如图队列中的线程引用依次为Thread-0,Thread-1,Thread-2….Thread-8；</li>
<li>等待队列是一个单向队列。</li>
<li>多次调用lock.newCondition()方法创建多个condition对象，也就是一个lock可以持有多个等待队列。而在之前利用Object的方式实际上是指在对象Object对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列。</li>
</ol>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/1587458891983.png" class>

</div>

<h3 id="await原理"><a href="#await原理" class="headerlink" title="await原理"></a>await原理</h3><p>当前线程进入等待状态直到被唤醒或中断，则当前线程将进入运行状态且从await方法中返回运行情况，包括：</p>
<ol>
<li>其他线程调用该condition的signal或signalall方法，而当前线程被选中唤醒</li>
<li>其他线程（调用interrupt）中断当前线程</li>
<li>如果当前等待线程从await方法返回，则表明该线程已经获取了condition对象所对应的锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment"> *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment"> *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用该方法之后，使当前获取lock的线程进入等待队列，</span></span><br><span class="line"><span class="comment"> * 如果该线程能够从await()方法返回的话一定是该线程获取了与condition相关联的lock。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//响应中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 1. 将当前线程包装成Node，插入到等待队列中尾部；</span></span><br><span class="line">    <span class="comment">// 只有被signal/signalAll后会使得当前线程从等待队列中移至到同步队列中去</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;<span class="comment">//退出条件：条件为false或者执行到break</span></span><br><span class="line">    	<span class="comment">// 3. 当前线程进入到等待状态,直到获得lock后才会从await方法返回，或者在等待时被中断会做中断处理</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span></span><br><span class="line">    <span class="comment">// 退出await方法必须是已经获得了condition引用（关联）的lock</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 5. 处理被中断的情况</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前线程分装成Node，并且加入到队尾（该队列没有头的链式队列与AQS中的带头链式队列不同）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invokes release with current state value; returns saved state.</span></span><br><span class="line"><span class="comment"> * Cancels node and throws exception on failure.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the condition node for this wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous sync state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 调用AQS的模板方法release方法释放AQS的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">        	<span class="comment">// 成功释放，正常返回</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 释放失败，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/1587459856757.png" class title="当前线程加入等待队列">

</div>

<blockquote>
<p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。调用condition.await方法的线程必须是已经获得了lock，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的Node尾插入到等待队列中</p>
</blockquote>
<h3 id="signal-signalall原理"><a href="#signal-signalall原理" class="headerlink" title="signal/signalall原理"></a>signal/signalall原理</h3><p>唤醒一个等待在condition上的线程，该线程从等待方法返回前必须获得与该condition相关的锁。<br>调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment"> * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment"> * owning lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment"> *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先检测当前线程是否已经获取到了lock，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 获取等待队列中的头节点进行处理,将其移动到同步队列并使用LockSupport唤醒节点中的线程</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment"> * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment"> * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将头节点从等待队列中移除</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// while中transferForSignal方法对头结点做真正的处理</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用condition的signal的前提条件是当前线程已经获取了lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而<font color="red">移入到同步队列后才有机会使得等待线程被唤醒</font>，即从await方法中的LockSupport.park(this)方法中返回，从而才有机会使得调用await方法的线程成功退出。</p>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/1587460222343.png" class>

</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment"> * Returns true if successful.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment"> * cancelled before signal)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">      * 更新头节点状态为0</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">      * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">      * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">      * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="comment">//等待队列中的头节点安全的移动到同步队列中</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 移动完成之后唤醒该节点的线程，唤醒后的线程，</span></span><br><span class="line"><span class="comment">       * 将从await方法中的while循环中退出，</span></span><br><span class="line"><span class="comment">       * 进而调用同步器的acquireQueued方法加入到获取同步状态的竞争者。</span></span><br><span class="line"><span class="comment">       * 成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，</span></span><br><span class="line"><span class="comment">       * 此时该线程已经成功地获取了锁。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves all threads from the wait queue for this condition to</span></span><br><span class="line"><span class="comment"> * the wait queue for the owning lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment"> *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and transfers all nodes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/1587461964158.png" class>

</div>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.jianshu.com/p/28387056eeb4">详解Condition的await和signal等待/通知机制</a></li>
<li>《Java并发编程的艺术》</li>
<li><a href="https://blog.csdn.net/bohu83/article/details/51098106">java condition使用及分析</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程控制</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之Executors</title>
    <url>/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BExecutors/</url>
    <content><![CDATA[<h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行<strong>很多短期异步任务</strong>的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。因此，长时间保持空闲的线程池不会使用任何资源。</p>
<a id="more"></a>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a thread pool that creates new threads as needed, but</span></span><br><span class="line"><span class="comment">* will reuse previously constructed threads when they are</span></span><br><span class="line"><span class="comment">* available.  These pools will typically improve the performance</span></span><br><span class="line"><span class="comment">* of programs that execute many short-lived asynchronous tasks.</span></span><br><span class="line"><span class="comment">* Calls to &#123;<span class="doctag">@code</span> execute&#125; will reuse previously constructed</span></span><br><span class="line"><span class="comment">* threads if available. If no existing thread is available, a new</span></span><br><span class="line"><span class="comment">* thread will be created and added to the pool. Threads that have</span></span><br><span class="line"><span class="comment">* not been used for sixty seconds are terminated and removed from</span></span><br><span class="line"><span class="comment">* the cache. Thus, a pool that remains idle for long enough will</span></span><br><span class="line"><span class="comment">* not consume any resources. Note that pools with similar</span></span><br><span class="line"><span class="comment">* properties but different details (for example, timeout parameters)</span></span><br><span class="line"><span class="comment">* may be created using &#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125; constructors.</span></span><br><span class="line"><span class="comment">* - 为每一个任务创建一个线程，并且也可以重用已有的线程，无核心线程数量，</span></span><br><span class="line"><span class="comment">* - 超过60s的空闲线程将弃用，但是会受到系统实际内存的线程</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* - 当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，</span></span><br><span class="line"><span class="comment">* - 因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；</span></span><br><span class="line"><span class="comment">* - 若池中线程空闲时间超过指定大小，则该线程会被销毁。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* - 适用：大小无界线程池，执行很多短期异步的小程序或者负载较轻的服务器；或负载较轻的服务器</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a thread pool that creates new threads as needed, but</span></span><br><span class="line"><span class="comment">* will reuse previously constructed threads when they are</span></span><br><span class="line"><span class="comment">* available, and uses the provided</span></span><br><span class="line"><span class="comment">* ThreadFactory to create new threads when needed.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> threadFactory the factory to use when creating new threads</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if threadFactory is null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="execute执行流程"><a href="#execute执行流程" class="headerlink" title="execute执行流程"></a>execute执行流程</h3><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BExecutors/1587885350899.png" class title="execute执行流程">

</div>

<ol>
<li><p>执行<code>SynchronousQueue.offer（Runnabletask）</code>;如果当前maximumPool中有空闲线程正在执行<code>SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）</code>，那么主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成</p>
</li>
<li><p>当初始maximumPool为空，或者maximumPool中当前没有空闲线程时，将没有线程执行<code>SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）</code>。此时CachedThreadPool会创建一个新线程执行任务，execute()方法执行完成。</p>
</li>
<li><p>在步骤2）中新创建的线程将任务执行完后，会执行<code>SynchronousQueue. poll（keepAliveTime，TimeUnit.NANOSECONDS）</code>。这个poll操作会让空闲线程最多在SynchronousQueue中等待60秒钟。如果60秒钟内主线程提交了一个新任务（主线程执行步骤1）），那么这个空闲线程将执行主线程提交的新任务；否则，这个空闲线程将终止。由于空闲60秒的空闲线程会被终止，因此长时间保持空闲的CachedThreadPool不会使用任何资源。SynchronousQueue是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。CachedThreadPool使用SynchronousQueue，把主线程提交的任务传递给空闲线程执行。</p>
<div align="center">

</div></li>
</ol>
<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BExecutors/1587885884366.png" class title="CachedThreadPool任务传递示意图">



<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，<strong>CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源</strong>。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.threadpool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPoolTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">			es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;run:::&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----结果</span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">7</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">6</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">6</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>通过结果可以发现：</p>
<ol>
<li>根据线程名称判断使用到了线程池</li>
<li>根据线程名称的编号可以判断线程被复用</li>
<li>无限性可以通过调整循环次数和增加等待时间测试（由于内存原因未模拟）</li>
</ol>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><p>创建一个可重用固定线程数的线程池，可控制线程最大并发数，超出的线程会在队列中等待，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a thread pool that reuses a fixed number of threads</span></span><br><span class="line"><span class="comment">* operating off a shared unbounded queue.  At any point, at most</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> nThreads&#125; threads will be active processing tasks.</span></span><br><span class="line"><span class="comment">* If additional tasks are submitted when all threads are active,</span></span><br><span class="line"><span class="comment">* they will wait in the queue until a thread is available.</span></span><br><span class="line"><span class="comment">* If any thread terminates due to a failure during execution</span></span><br><span class="line"><span class="comment">* prior to shutdown, a new one will take its place if needed to</span></span><br><span class="line"><span class="comment">* execute subsequent tasks.  The threads in the pool will exist</span></span><br><span class="line"><span class="comment">* until it is explicitly &#123;<span class="doctag">@link</span> ExecutorService#shutdown shutdown&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> nThreads the number of threads in the pool</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> nThreads &lt;= 0&#125;</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* - 创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；</span></span><br><span class="line"><span class="comment">* - 如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* - 适用：执行长期的任务，性能好很多；为了满足资源管理的需求，而需要限制当前线程的数量；负载比较重的服务器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a thread pool that reuses a fixed number of threads</span></span><br><span class="line"><span class="comment">* operating off a shared unbounded queue, using the provided</span></span><br><span class="line"><span class="comment">* ThreadFactory to create new threads when needed.  At any point,</span></span><br><span class="line"><span class="comment">* at most &#123;<span class="doctag">@code</span> nThreads&#125; threads will be active processing</span></span><br><span class="line"><span class="comment">* tasks.  If additional tasks are submitted when all threads are</span></span><br><span class="line"><span class="comment">* active, they will wait in the queue until a thread is</span></span><br><span class="line"><span class="comment">* available.  If any thread terminates due to a failure during</span></span><br><span class="line"><span class="comment">* execution prior to shutdown, a new one will take its place if</span></span><br><span class="line"><span class="comment">* needed to execute subsequent tasks.  The threads in the pool will</span></span><br><span class="line"><span class="comment">* exist until it is explicitly &#123;<span class="doctag">@link</span> ExecutorService#shutdown</span></span><br><span class="line"><span class="comment">* shutdown&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> nThreads the number of threads in the pool</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> threadFactory the factory to use when creating new threads</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if threadFactory is null</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> nThreads &lt;= 0&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="execute执行过程"><a href="#execute执行过程" class="headerlink" title="execute执行过程"></a>execute执行过程</h3><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BExecutors/1587886474032.png" class>

</div>

<ul>
<li>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把keepAliveTime设置为0L，意味着多余的空闲线程会被立即终止。</li>
<li>2）在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加LinkedBlockingQueue。</li>
<li>3）线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。</li>
</ul>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。使用无界队列作为工作队列会对线程池带来如下影响。</p>
<ul>
<li>1）当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li>
<li>2）由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li>
<li>3）由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li>
<li>4）由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或shutdownNow()）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.threadpool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPoolTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">			es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;run:::&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----结果</span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">run:::pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>通过结果发下：</p>
<ol>
<li>可以控制线程池的最大数</li>
</ol>
<h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a thread pool that can schedule commands to run after a</span></span><br><span class="line"><span class="comment">* given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool,</span></span><br><span class="line"><span class="comment">* even if they are idle</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a newly created scheduled thread pool</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 创建一个固定核心大小的线程池，最大线程数没有限制，</span></span><br><span class="line"><span class="comment">* 线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，</span></span><br><span class="line"><span class="comment">* 如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，</span></span><br><span class="line"><span class="comment">* 这是一种按照超时时间排序的队列结构</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 适用：需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a thread pool that can schedule commands to run after a</span></span><br><span class="line"><span class="comment">* given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool,</span></span><br><span class="line"><span class="comment">* even if they are idle</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment">* creates a new thread</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a newly created scheduled thread pool</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if threadFactory is null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a single-threaded executor that can schedule commands</span></span><br><span class="line"><span class="comment">* to run after a given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">* (Note however that if this single</span></span><br><span class="line"><span class="comment">* thread terminates due to a failure during execution prior to</span></span><br><span class="line"><span class="comment">* shutdown, a new one will take its place if needed to execute</span></span><br><span class="line"><span class="comment">* subsequent tasks.)  Tasks are guaranteed to execute</span></span><br><span class="line"><span class="comment">* sequentially, and no more than one task will be active at any</span></span><br><span class="line"><span class="comment">* given time. Unlike the otherwise equivalent</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> newScheduledThreadPool(1)&#125; the returned executor is</span></span><br><span class="line"><span class="comment">* guaranteed not to be reconfigurable to use additional threads.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the newly created scheduled executor</span></span><br><span class="line"><span class="comment">* - 适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">      (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a single-threaded executor that can schedule commands</span></span><br><span class="line"><span class="comment">* to run after a given delay, or to execute periodically.  (Note</span></span><br><span class="line"><span class="comment">* however that if this single thread terminates due to a failure</span></span><br><span class="line"><span class="comment">* during execution prior to shutdown, a new one will take its</span></span><br><span class="line"><span class="comment">* place if needed to execute subsequent tasks.)  Tasks are</span></span><br><span class="line"><span class="comment">* guaranteed to execute sequentially, and no more than one task</span></span><br><span class="line"><span class="comment">* will be active at any given time. Unlike the otherwise</span></span><br><span class="line"><span class="comment">* equivalent &#123;<span class="doctag">@code</span> newScheduledThreadPool(1, threadFactory)&#125;</span></span><br><span class="line"><span class="comment">* the returned executor is guaranteed not to be reconfigurable to</span></span><br><span class="line"><span class="comment">* use additional threads.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> threadFactory the factory to use when creating new</span></span><br><span class="line"><span class="comment">* threads</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a newly created scheduled executor</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if threadFactory is null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">      (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p>
<h3 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates an Executor that uses a single worker thread operating</span></span><br><span class="line"><span class="comment">* off an unbounded queue. (Note however that if this single</span></span><br><span class="line"><span class="comment">* thread terminates due to a failure during execution prior to</span></span><br><span class="line"><span class="comment">* shutdown, a new one will take its place if needed to execute</span></span><br><span class="line"><span class="comment">* subsequent tasks.)  Tasks are guaranteed to execute</span></span><br><span class="line"><span class="comment">* sequentially, and no more than one task will be active at any</span></span><br><span class="line"><span class="comment">* given time. Unlike the otherwise equivalent</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> newFixedThreadPool(1)&#125; the returned executor is</span></span><br><span class="line"><span class="comment">* guaranteed not to be reconfigurable to use additional threads.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 创建只有一个线程的线程池，且线程的存活时间是无限的；</span></span><br><span class="line"><span class="comment">* 当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 适用：一个任务一个任务执行的场景（顺序执行）；并且在任意时间点，不会有多个线程是活动的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates an Executor that uses a single worker thread operating</span></span><br><span class="line"><span class="comment">* off an unbounded queue, and uses the provided ThreadFactory to</span></span><br><span class="line"><span class="comment">* create a new thread when needed. Unlike the otherwise</span></span><br><span class="line"><span class="comment">* equivalent &#123;<span class="doctag">@code</span> newFixedThreadPool(1, threadFactory)&#125; the</span></span><br><span class="line"><span class="comment">* returned executor is guaranteed not to be reconfigurable to use</span></span><br><span class="line"><span class="comment">* additional threads.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> threadFactory the factory to use when creating new</span></span><br><span class="line"><span class="comment">* threads</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if threadFactory is null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="execute执行过程-1"><a href="#execute执行过程-1" class="headerlink" title="execute执行过程"></a>execute执行过程</h3><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BExecutors/1587887145755.png" class>

</div>

<ol>
<li>如果当前运行的线程数少于corePoolSize（即线程池中无运行的线程），则创建一个新线程来执行任务。</li>
<li>在线程池完成预热之后（当前线程池中有一个运行的线程），将任务加入Linked-BlockingQueue</li>
<li>线程执行完1中的任务后，会在一个无限循环中反复从LinkedBlockingQueue获取任务来执行。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
<li>《Java并发编程》</li>
<li>《Java多线程编程核心技术》</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>Java线程池</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
        <tag>Executors</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之ThreadLocal</title>
    <url>/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="API描述"><a href="#API描述" class="headerlink" title="API描述"></a>API描述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* This <span class="class"><span class="keyword">class</span> <span class="title">provides</span> <span class="title">thread</span>-<span class="title">local</span> <span class="title">variables</span>.  <span class="title">These</span> <span class="title">variables</span> <span class="title">differ</span> <span class="title">from</span></span></span><br><span class="line"><span class="class">* <span class="title">their</span> <span class="title">normal</span> <span class="title">counterparts</span> <span class="title">in</span> <span class="title">that</span> <span class="title">each</span> <span class="title">thread</span> <span class="title">that</span> <span class="title">accesses</span> <span class="title">one</span> (<span class="title">via</span> <span class="title">its</span></span></span><br><span class="line"><span class="class">* </span>&#123;<span class="meta">@code</span> get&#125; or &#123;<span class="meta">@code</span> set&#125; method) has its own, independently initialized</span><br><span class="line">* copy of the variable.  &#123;<span class="meta">@code</span> ThreadLocal&#125; instances are typically <span class="keyword">private</span></span><br><span class="line">* <span class="function"><span class="keyword">static</span> fields in classes that wish to associate state with a <span class="title">thread</span> <span class="params">(e.g.,</span></span></span><br><span class="line"><span class="function"><span class="params">* a user ID or Transaction ID)</span>.</span></span><br></pre></td></tr></table></figure>
<p><code>ThreadLocal</code>提供一种线程本地变量。这种变量是一种副本的概念，在多线程环境下访问（get、set）能够保证各个线程间的变量互相隔离。<code>ThreadLocal</code>通常定义为了<code>private static</code>，用来关联线程和线程上下文（比如userId或事物ID）。<code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p>
<a id="more"></a>

<div align="center">

<img src="http://www.plantuml.com/plantuml/svg/NS_12i8m3CRnUvyYu4KHdq2HYHU57OltsCOjaBMZpOeWlhlTQSFhbnz_I9CLaqw362UOCzW-4VesEfIJFSF7761CN509NXnGW8E2BkY6kRz6JySLh4bb1nUD0xjxKEeeGQ2tBdXJSLHoIXviRR8ooWDbektEx66Sdb8B5ZhIzL0YUyXrir1c_7zADCGo9xwceU3hMpy0">

</div>

<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ol>
<li>让某个需要用到的对象实现线程之间的隔离（每个线程都有自己独立的对象）</li>
<li>可以在任何方法中轻松的获取到该对象</li>
<li>根据共享对象生成的时机选择使用initialValue方法还是set方法</li>
<li>对象初始化的时机由我们控制的时候使用initialValue 方式</li>
<li>如果对象生成的时机不由我们控制的时候使用 set 方式</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>达到线程安全的目的</li>
<li>不需要加锁，执行效率高</li>
<li>更加节省内存，节省开销</li>
<li>免去传参的繁琐，降低代码耦合度</li>
</ol>
<h3 id="ThreadLocal与锁的区别"><a href="#ThreadLocal与锁的区别" class="headerlink" title="ThreadLocal与锁的区别"></a>ThreadLocal与锁的区别</h3><ol>
<li>lock 的资源是多个线程共享的，所以访问的时候需要加锁。</li>
<li>ThreadLocal 是每个线程都有一个副本，是不需要加锁的。</li>
<li>lock 是通过时间换空间的做法。</li>
<li>ThreadLocal 是典型的通过空间换时间的做法。</li>
</ol>
<h3 id="结构解析"><a href="#结构解析" class="headerlink" title="结构解析"></a>结构解析</h3><h4 id="JDK早期设计"><a href="#JDK早期设计" class="headerlink" title="JDK早期设计"></a>JDK早期设计</h4><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal/1587690655937.png" class title="ThreadLocal早期设计">

</div>

<p>在早期的设计中每个 <code>ThreadLocal</code> 创建一个 <code>ThreadLocalMap</code>，然后用<strong>线程</strong>作为 Map 的 key，要存储的局部变量作为 Map 的 value，这样达到线程隔离的目的。<strong>由于该线程绑定的变量不能被自动的回收，因为变量存储在 ThreadLocal 里，必须显式的去回收。(容易出现内存泄露)</strong></p>
<h4 id="JDK1-8设计"><a href="#JDK1-8设计" class="headerlink" title="JDK1.8设计"></a>JDK1.8设计</h4><p>在<code>Thread</code>类中维护了<code>ThreadLocalMap</code>；这个变量用于存储<code>ThreadLocal</code>，因为在同一个线程当中可以有多个<code>ThreadLocal</code>，并且多次调用<code>get()</code>所以需要在内部维护一个<code>ThreadLocalMap</code>用来存储多个<code>ThreadLocal</code>。<code>Thread</code>中的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">* by the ThreadLocal class.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment">* maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment">* 父线程难道子线程共享的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>如下图所示：</p>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal/1587690972564.png" class>
<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal/1587467884480.png" class title="ThreadLocal内部结构">

</div>

<p><strong>通过代码分析得出以下结论：</strong></p>
<ol>
<li>① 每个 <code>Thread</code> 内部都有一个 <code>ThreadLocalMap</code> <code>ThreadLocal.ThreadLocalMap threadLocals = null;</code>达到线程隔离</li>
<li>② <code>ThreadLocalMap</code> 里面存储 <code>ThreadLocal</code> 对象（key） 和 线程的变量副本（value）<code>t.threadLocals = new ThreadLocalMap(this, firstValue);</code>；使用静态并<code>ThreadLocal</code>作为key，将不同对象的引用保存到不同线程的<code>ThreadLocalMap</code>中。</li>
<li>③ <code>Thread</code> 内部的 <code>ThreadLocalMap</code> 是由 <code>ThreadLocal</code> 维护的，由 <code>ThreadLocal</code> 负责向 ThreadLocalMap 设置和获取变量值</li>
<li>④ 对于不同的线程，每次获取副本值时，别的线程并不能获取当前线程的副本值，形成副本的隔离，互不干扰</li>
</ol>
<p>如下图所示：</p>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal/1587468037170.png" class>

</div>

<p><strong>好处：</strong></p>
<ol>
<li>① 每个 ThreadLocalMap 存储的 Entry 数量变少</li>
<li>② 当 Thread 销毁时，ThreadLocalMap 也随之销毁，减少内存的使用</li>
</ol>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>获取当前线程中绑定的局部两类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* Returns the value in the current thread&#x27;s copy of this</span></span><br><span class="line"><span class="comment">	* thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">	* current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">	* by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@return</span> the current thread&#x27;s value of this thread-local</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1.获取当前线程中的ThreadLocalMap</span></span><br><span class="line">	Thread t = Thread.currentThread();</span><br><span class="line">	ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 2.1 如果不为空：使用当前ThreadLocal获取map中的Entry，如果不为空则获取值</span></span><br><span class="line"><span class="comment">	* 2.2 map 为空 或者 e 为空，通过 initialValue ，也就是 NULL，</span></span><br><span class="line"><span class="comment">	*     然后用 TL 的引用和 value 作为 firstKey 和 firstValue 创建新的 map</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">		ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">			T result = (T)e.value;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>使用线程本地变量的方式存储数据，绑定到当前线程中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sets the current thread&#x27;s copy of this thread-local variable</span></span><br><span class="line"><span class="comment">* to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">* override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">* method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span></span><br><span class="line"><span class="comment">*        this thread-local.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">	Thread t = Thread.currentThread(); <span class="comment">// 1.获取当前线程</span></span><br><span class="line">	ThreadLocalMap map = getMap(t); <span class="comment">// 2.获取当前线程中的ThreadLocalMap</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 3.1 如果map不为空则设置数据，key为ThreadLocal</span></span><br><span class="line"><span class="comment">	* 3.2 如果为空，则给该线程创建 map ，并设置初始值</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">		map.set(<span class="keyword">this</span>, value);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">* InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">	t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reomove"><a href="#reomove" class="headerlink" title="reomove"></a>reomove</h3><p>清空数据，防止内存泄露</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the current thread&#x27;s value for this thread-local</span></span><br><span class="line"><span class="comment"> * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment"> * reinitialized by invoking its &#123;<span class="doctag">@link</span> #initialValue&#125; method,</span></span><br><span class="line"><span class="comment"> * unless its value is &#123;<span class="doctag">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment"> * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> initialValue&#125; method in the current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a>initialValue</h3><p>该方法用于设置初始值，并且在调用get()方法时才会被触发，所以是懒加载。但是如果在get()之前进行了set()操作，这样就不会调用initialValue()。通常每个线程只能调用一次本方法，但是调用了remove()后就能再次调用.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current thread&#x27;s &quot;initial value&quot; for this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  This method will be invoked the first</span></span><br><span class="line"><span class="comment"> * time a thread accesses the variable with the &#123;<span class="doctag">@link</span> #get&#125;</span></span><br><span class="line"><span class="comment"> * method, unless the thread previously invoked the &#123;<span class="doctag">@link</span> #set&#125;</span></span><br><span class="line"><span class="comment"> * method, in which case the &#123;<span class="doctag">@code</span> initialValue&#125; method will not</span></span><br><span class="line"><span class="comment"> * be invoked for the thread.  Normally, this method is invoked at</span></span><br><span class="line"><span class="comment"> * most once per thread, but it may be invoked again in case of</span></span><br><span class="line"><span class="comment"> * subsequent invocations of &#123;<span class="doctag">@link</span> #remove&#125; followed by &#123;<span class="doctag">@link</span> #get&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation simply returns &#123;<span class="doctag">@code</span> null&#125;; if the</span></span><br><span class="line"><span class="comment"> * programmer desires thread-local variables to have an initial</span></span><br><span class="line"><span class="comment"> * value other than &#123;<span class="doctag">@code</span> null&#125;, &#123;<span class="doctag">@code</span> ThreadLocal&#125; must be</span></span><br><span class="line"><span class="comment"> * subclassed, and this method overridden.  Typically, an</span></span><br><span class="line"><span class="comment"> * anonymous inner class will be used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value for this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment"> * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><h4 id="ThreadLocalMap类图"><a href="#ThreadLocalMap类图" class="headerlink" title="ThreadLocalMap类图"></a>ThreadLocalMap类图</h4><div align="center">

<img src="http://www.plantuml.com/plantuml/svg/2yaioKbLK0h9A4fDJF79JqxCyKqiUBvnzzFP-vIuk1AJYakA4fDB599p4ekB5O9IqrABKlEIKxaW_F3Kn6nqCTUyag9AA1lLL2uki9o2bgukkWoAGGesDK0L47FG154jn6fBDHUgySzdjRoSE_DPG-FJjjQNpIk0NkFILIWeoYnBB4bLAClFJ54eJYtHGD9WOs-da9rQgQFWdvIL2lHwMM9EQQeckgQYrDpyibGi-f1LGloRdbe2Pc1LZAuwEbQX934f9nL9F3ElHA4uimfTg0HeMd56VauALoqNSjWhe8S0A48n0w5E0RkZ4FxM1Af13WDhe4K0">

</div>

<h4 id="ThreadLocalMap源码"><a href="#ThreadLocalMap源码" class="headerlink" title="ThreadLocalMap源码"></a>ThreadLocalMap源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The table, resized as necessary.</span></span><br><span class="line"><span class="comment">* table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The number of entries in the table.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The next size value at which to resize.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>
<p>通过源码分析ThreadLocalMap与HashMap的结构类似。</p>
<h4 id="ThreadLocalMap保存数据"><a href="#ThreadLocalMap保存数据" class="headerlink" title="ThreadLocalMap保存数据"></a>ThreadLocalMap保存数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Set the value associated with key.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">	<span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">	<span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">	<span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">	Entry[] tab = table;</span><br><span class="line">	<span class="keyword">int</span> len = tab.length;</span><br><span class="line">	<span class="comment">// 计算hash索引位置</span></span><br><span class="line">	<span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 使用线性探测法查找元素（顺序查找数据，找到则结束，并且在查找数据时必须比对key是否相等）</span></span><br><span class="line">	<span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">			e != <span class="keyword">null</span>;</span><br><span class="line">			e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">		ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (k == key) &#123;<span class="comment">// 如果key存在则直接覆盖</span></span><br><span class="line">			e.value = value;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果key为空，但是value不为空则说明ThreadLocal作为key已经被回收，需要进行数据交换</span></span><br><span class="line">			replaceStaleEntry(key, value, i);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">	<span class="keyword">int</span> sz = ++size;</span><br><span class="line">	<span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">		rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过源码分析如下：</strong></p>
<ol>
<li><p>每个<code>ThreadLocal</code>对象都有一个hash值 <code>threadLocalHashCode</code> ，每初始化一个<code>ThreadLocal</code>对象，hash值就增加一个固定的大小 <strong>0x61c88647</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ThreadLocals rely on per-thread linear-probe hash maps attached</span></span><br><span class="line"><span class="comment">    * to each thread (Thread.threadLocals and</span></span><br><span class="line"><span class="comment">    * inheritableThreadLocals).  The ThreadLocal objects act as keys,</span></span><br><span class="line"><span class="comment">    * searched via threadLocalHashCode.  This is a custom hash code</span></span><br><span class="line"><span class="comment">    * (useful only within ThreadLocalMaps) that eliminates collisions</span></span><br><span class="line"><span class="comment">    * in the common case where consecutively constructed ThreadLocals</span></span><br><span class="line"><span class="comment">    * are used by the same threads, while remaining well-behaved in</span></span><br><span class="line"><span class="comment">    * less common cases.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the next hash code.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在set数据时首先根据<code>threadLocalHashCode</code>对key进行hash，如果当前位置没数据数据则初始化一个Entry放到该位置上。</p>
</li>
<li><p>如果有数据则继续判断当前位置的key是否与当前设置的key相同，如果是则替换当前Entry中的value</p>
</li>
<li><p>如果key不同则for循环继续查找。</p>
</li>
</ol>
<h4 id="ThreadLocalMap与HashMap的区别"><a href="#ThreadLocalMap与HashMap的区别" class="headerlink" title="ThreadLocalMap与HashMap的区别"></a>ThreadLocalMap与HashMap的区别</h4><p>主要体现在hash冲突解决上。</p>
<ol>
<li>HashMap 的数据结构是数组+链表</li>
<li>ThreadLocalMap的数据结构仅仅是数组</li>
<li>HashMap 是通过链地址法解决hash 冲突的问题</li>
<li>ThreadLocalMap 是通过开放地址法来解决hash 冲突的问题</li>
<li>HashMap 里面的Entry 内部类的引用都是强引用</li>
<li>ThreadLocalMap里面的Entry 内部类中的<strong>key 是弱引用，value 是强引用</strong></li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>某个对象不会再被使用，但是该对象的内存却无法被收回。</p>
<h4 id="Java引用的说明（后续会在JVM垃圾回收中详细说明）"><a href="#Java引用的说明（后续会在JVM垃圾回收中详细说明）" class="headerlink" title="Java引用的说明（后续会在JVM垃圾回收中详细说明）"></a>Java引用的说明（后续会在JVM垃圾回收中详细说明）</h4><p>Java中存在四种引用类型：<strong>强、弱、软、虚</strong>  </p>
<ol>
<li>强引用：最常见的是使用new创建的对象，只要存在对象引用，GC就不会回收</li>
<li>软引用：<code>SoftReference</code>实现，当系统内存不足时才会被回收</li>
<li>弱引用：<code>WeakReference</code>实现，GC 一旦发现弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</li>
<li>虚引用：<code>PhantomReference</code>实现，必须和引用队列联合使用，主要用于跟踪对象被垃圾回收的状态</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment"> * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment"> * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment"> * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment"> * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment"> * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><ol>
<li>正常情况: 当Thread运行结束后，ThreadLocal中的value会被回收，因为没有任何强引用了</li>
<li>非正常情况<br>当Thread一直在运行始终不结束，强引用就不会被回收，存在以下调用链 Thread–&gt;ThreadLocalMap–&gt;Entry(key为null)–&gt;value因为调用链中的 value 和 Thread 存在强引用，所以value无法被回收，就有可能出现OOM。JDK的设计已经考虑到了这个问题，所以在set()、remove()、resize()方法中会扫描到key为null的Entry，并且把对应的value设置为null，这样value对象就可以被回收。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Double the capacity of the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是只有在调用set()、remove()、resize()这些方法时才会进行这些操作，如果没有调用这些方法并且线程不停止，那么调用链就会一直存在，所以可能会发生内存泄漏。</p>
</blockquote>
<h4 id="ThreadLocalMap-Entry被定义为弱引用的原因"><a href="#ThreadLocalMap-Entry被定义为弱引用的原因" class="headerlink" title="ThreadLocalMap.Entry被定义为弱引用的原因"></a>ThreadLocalMap.Entry被定义为弱引用的原因</h4><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal/1587696845088.png" class title="ThreadLocalMap.Entry">

</div>

<p><code>ThreadLocal</code>作为Map中的key，被定义为弱引用，当把<code>ThreadLocal</code>实例设置为<code>null</code>时，gc就可以顺利回收<code>ThreadLocal</code>。但是如果value正常被当前线程使用，只有在当前线程结束之后才能被回收，这也是JDK1.8之后的升级，降低内存泄露的概率。</p>
<h4 id="避免方式"><a href="#避免方式" class="headerlink" title="避免方式"></a>避免方式</h4><p>调用remove()方法，就会删除对应的Entry对象，可以避免内存泄漏，所以使用完ThreadLocal后，要调用remove()方法。</p>
<h3 id="空指针问题"><a href="#空指针问题" class="headerlink" title="空指针问题"></a>空指针问题</h3><p>调用get方法如果返回值为基本类型，则会出现空指针异常，如果是包装类则不会出现。</p>
<h3 id="共享对象问题"><a href="#共享对象问题" class="headerlink" title="共享对象问题"></a>共享对象问题</h3><p>如果在每个线程中ThreadLocal.set()进去的东西本来就是多个线程共享的同一对象，比如static对象，那么多个线程调用ThreadLocal.get()获取的内容还是同一个对象，还是会发生线程安全问题。</p>
<h3 id="可以不使用ThreadLocal就不要强行使用"><a href="#可以不使用ThreadLocal就不要强行使用" class="headerlink" title="可以不使用ThreadLocal就不要强行使用"></a>可以不使用ThreadLocal就不要强行使用</h3><p>如果在任务数很少的时候，在局部方法中创建对象就可以解决问题，这样就不需要使用ThreadLocal。</p>
<h3 id="优先使用框架的支持，而不是自己创造"><a href="#优先使用框架的支持，而不是自己创造" class="headerlink" title="优先使用框架的支持，而不是自己创造"></a>优先使用框架的支持，而不是自己创造</h3><p>例如在Spring框架中，如果可以使用RequestContextHolder，那么就不需要自己维护ThreadLocal，因为自己可能会忘记调用remove()方法等，造成内存泄漏。</p>
<h4 id="源码参考-RequestContextHolder"><a href="#源码参考-RequestContextHolder" class="headerlink" title="源码参考(RequestContextHolder)"></a>源码参考(RequestContextHolder)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2016 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.web.context.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.faces.context.FacesContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.NamedInheritableThreadLocal;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.NamedThreadLocal;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ClassUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holder class to expose the web request in the form of a thread-bound</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> RequestAttributes&#125; object. The request will be inherited</span></span><br><span class="line"><span class="comment"> * by any child threads spawned by the current thread if the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> inheritable&#125; flag is set to &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Use &#123;<span class="doctag">@link</span> RequestContextListener&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.web.filter.RequestContextFilter&#125; to expose</span></span><br><span class="line"><span class="comment"> * the current web request. Note that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.web.servlet.DispatcherServlet&#125;</span></span><br><span class="line"><span class="comment"> * already exposes the current request by default.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> RequestContextListener</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.filter.RequestContextFilter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.DispatcherServlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestContextHolder</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsfPresent =</span><br><span class="line">			ClassUtils.isPresent(<span class="string">&quot;javax.faces.context.FacesContext&quot;</span>, RequestContextHolder.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder =</span><br><span class="line">			<span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Request attributes&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder =</span><br><span class="line">			<span class="keyword">new</span> NamedInheritableThreadLocal&lt;&gt;(<span class="string">&quot;Request context&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Reset the RequestAttributes for the current thread.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resetRequestAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		requestAttributesHolder.remove();</span><br><span class="line">		inheritableRequestAttributesHolder.remove();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Bind the given RequestAttributes to the current thread,</span></span><br><span class="line"><span class="comment">	 * &lt;i&gt;not&lt;/i&gt; exposing it as inheritable for child threads.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> attributes the RequestAttributes to expose</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setRequestAttributes(RequestAttributes, boolean)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRequestAttributes</span><span class="params">(<span class="meta">@Nullable</span> RequestAttributes attributes)</span> </span>&#123;</span><br><span class="line">		setRequestAttributes(attributes, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Bind the given RequestAttributes to the current thread.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> attributes the RequestAttributes to expose,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; to reset the thread-bound context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> inheritable whether to expose the RequestAttributes as inheritable</span></span><br><span class="line"><span class="comment">	 * for child threads (using an &#123;<span class="doctag">@link</span> InheritableThreadLocal&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRequestAttributes</span><span class="params">(<span class="meta">@Nullable</span> RequestAttributes attributes, <span class="keyword">boolean</span> inheritable)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (attributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">			resetRequestAttributes();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (inheritable) &#123;</span><br><span class="line">				inheritableRequestAttributesHolder.set(attributes);</span><br><span class="line">				requestAttributesHolder.remove();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				requestAttributesHolder.set(attributes);</span><br><span class="line">				inheritableRequestAttributesHolder.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the RequestAttributes currently bound to the thread.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the RequestAttributes currently bound to the thread,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if none bound</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestAttributes <span class="title">getRequestAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		RequestAttributes attributes = requestAttributesHolder.get();</span><br><span class="line">		<span class="keyword">if</span> (attributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">			attributes = inheritableRequestAttributesHolder.get();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> attributes;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the RequestAttributes currently bound to the thread.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Exposes the previously bound RequestAttributes instance, if any.</span></span><br><span class="line"><span class="comment">	 * Falls back to the current JSF FacesContext, if any.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the RequestAttributes currently bound to the thread</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IllegalStateException if no RequestAttributes object</span></span><br><span class="line"><span class="comment">	 * is bound to the current thread</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setRequestAttributes</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ServletRequestAttributes</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> FacesRequestAttributes</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> javax.faces.context.FacesContext#getCurrentInstance()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestAttributes <span class="title">currentRequestAttributes</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">		RequestAttributes attributes = getRequestAttributes();</span><br><span class="line">		<span class="keyword">if</span> (attributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (jsfPresent) &#123;</span><br><span class="line">				attributes = FacesRequestAttributesFactory.getFacesRequestAttributes();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (attributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No thread-bound request found: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Are you referring to request attributes outside of an actual web request, &quot;</span> +</span><br><span class="line">						<span class="string">&quot;or processing a request outside of the originally receiving thread? &quot;</span> +</span><br><span class="line">						<span class="string">&quot;If you are actually operating within a web request and still receive this message, &quot;</span> +</span><br><span class="line">						<span class="string">&quot;your code is probably running outside of DispatcherServlet/DispatcherPortlet: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;In this case, use RequestContextListener or RequestContextFilter to expose the current request.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> attributes;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Inner class to avoid hard-coded JSF dependency.</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FacesRequestAttributesFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestAttributes <span class="title">getFacesRequestAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			FacesContext facesContext = FacesContext.getCurrentInstance();</span><br><span class="line">			<span class="keyword">return</span> (facesContext != <span class="keyword">null</span> ? <span class="keyword">new</span> FacesRequestAttributes(facesContext) : <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li><p>To keep state with a thread (user-id, transaction-id, logging-id)</p>
</li>
<li><p>To cache objects which you need frequently</p>
</li>
<li><p>最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Session&gt; threadSession = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">        Session s = (Session) threadSession.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                s = getSessionFactory().openSession();</span><br><span class="line">                threadSession.set(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2></li>
</ol>
<h3 id="如果父子线程共享变量"><a href="#如果父子线程共享变量" class="headerlink" title="如果父子线程共享变量"></a>如果父子线程共享变量</h3><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><h3 id="hash冲突解决"><a href="#hash冲突解决" class="headerlink" title="hash冲突解决"></a>hash冲突解决</h3><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>hash(key)之后的地址i构成一个同义词单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。</p>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal/1587708395831.png" class>

</div>

<p><strong>链地址法特点</strong></p>
<ol>
<li>处理冲突简单，且无堆积现象，平均查找长度短。</li>
<li>链表中的结点是动态申请的，适合构造表不能确定长度的情况。</li>
<li>删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</li>
<li>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间。</li>
</ol>
<h4 id="开放地址法（线性探测法）"><a href="#开放地址法（线性探测法）" class="headerlink" title="开放地址法（线性探测法）"></a>开放地址法（线性探测法）</h4><p>hash(key)一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal/1587708550090.png" class>

</div>

<p><strong>开放地址法特点</strong></p>
<ol>
<li>容易产生堆积问题，不适于大规模的数据存储。</li>
<li>散列函数的设计对冲突会有很大的影响，插入时可能会出现多次冲突的现象。</li>
<li>删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂。</li>
</ol>
<h4 id="ThreadLocalMap采用开放地址法原因"><a href="#ThreadLocalMap采用开放地址法原因" class="headerlink" title="ThreadLocalMap采用开放地址法原因"></a>ThreadLocalMap采用开放地址法原因</h4><ol>
<li>ThreadLocal 中看到一个属性 HASH_INCREMENT = 0x61c88647 ，0x61c88647 是一个神奇的数字，让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table</li>
<li>ThreadLocal 往往存放的数据量不会特别大（而且key 是弱引用又会被垃圾回收，及时让数据量更小），这个时候开放地址法简单的结构会显得更省空间，同时数组的查询效率也是非常高，加上第一点的保障，冲突概率也低</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
<li><a href="https://www.toutiao.com/i6750511984854172173/">吃透源码的每一个细节和设计原理–ThreadLocal</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程控制</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之内存模型</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>作用：屏蔽各种硬件和操作系统内存的访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果，定义了Java虚拟机与计算机内存是如何协同工作的，是一种主存与工作内存的抽象概念，并且底层对应CPU的寄存器、缓存、硬件内存以及CPU指令优化等</li>
<li>简称：Java Memory Model简称JMM</li>
<li>目的：定义程序中各个变量的访问规则，以及在必须时如何同步地访问共享变量，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节<a id="more"></a>

</li>
</ol>
<p>JVM内存模型如下图</p>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1588163546487.png" class title="JVM内存模型">

</div>

<ol>
<li><strong>Head（堆）</strong>：<ul>
<li>运行时的数据区，堆是由垃圾回收机制来负责的。</li>
<li><strong>运行时动态分配内存大小，并且由GC动态完成内存的回收</strong></li>
<li><strong>存取速度相对要慢</strong></li>
</ul>
</li>
<li><strong>Stack（栈）</strong>：<ul>
<li>存取速度比堆要快，仅次于计算机里的寄存器</li>
<li>数据可共享</li>
<li>栈中的数据的大小以及生存期必须是确定的，缺乏一些灵活性</li>
<li><strong>栈中主要用来存储一些基本数据类型和引用数据类型</strong></li>
</ul>
</li>
</ol>
<p><font color="red"><strong>Java内存模型要求调用栈和本地变量存放在线程栈（Thread Stack）上，而对象则存放在堆上</strong>。一个本地变量也可能是指向一个对象的引用，这种情况下这个保存对象引用的本地变量是存放在线程栈上的，但是对象本身则是存放在堆上的。一个对象可能包含方法，而这些方法可能包含着本地变量，这些本地变量仍然是存放在线程栈上的。即使这些方法所属的对象是存放在堆上的。一个对象的成员变量，可能会随着所属对象而存放在堆上，不管这个成员变量是原始类型还是引用类型。<strong>静态成员变量则是随着类的定义一起存放在堆上</strong>。存放在堆上的对象，可以被持有这个对象的引用的线程访问。当一个线程可以访问某个对象时，它也可以访问该对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，那么它们都将会访问这个方法中的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。</font></p>
<p>JMM 体现在以下几个方面：</p>
<ol>
<li><strong>原子性</strong> - 保证指令不会受到线程上下文切换的影响</li>
<li><strong>可见性</strong> - 保证指令不会受 cpu 缓存的影响</li>
<li><strong>有序性</strong> - 保证指令不会受 cpu 指令并行优化的影响</li>
</ol>
<p>java中多线程通信基于共享内存的方式，并且JMM保证了共享内存的可见性和有序性的问题，锁解决了原子性的问题。</p>
<h3 id="Java内存模型和硬件内存架构之间的桥接"><a href="#Java内存模型和硬件内存架构之间的桥接" class="headerlink" title="Java内存模型和硬件内存架构之间的桥接"></a>Java内存模型和硬件内存架构之间的桥接</h3><ol>
<li>硬件内存架构中不区分线程栈和堆，所有的数据都存储在主内存中或CPU缓存中和CPU内部的寄存器中</li>
<li>JMM中区分主内存（线程共享）和线程工作内存（线程私有，JMM中的抽象概念）</li>
<li><strong>Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。主内存则可理解为物理主存的抽象</strong></li>
<li>JVM内存模型只是一种对物理内存的划分而已，它只局限在物理内存，而且只局限在JVM进程中的的物理内存。举个例子，A和线程B要通信，必须经历两个步骤:<ul>
<li>首先线程A要把本地内存A中更新过的共享变量刷新到主内存里</li>
<li>然后线程B再到主内存中去读取线程A更新的共享变量，这样就完成了两个线程之间的通信了</li>
</ul>
</li>
</ol>
<h3 id="Java内存模型定义同步的八种操作"><a href="#Java内存模型定义同步的八种操作" class="headerlink" title="Java内存模型定义同步的八种操作"></a>Java内存模型定义同步的八种操作</h3><p>JLS定义了线程对主存的操作指令：<code>lock，unlock，read，load，use，assign，store，write</code>。这些行为是不可分解的原子操作，在使用上相互依赖，</p>
<ol>
<li>read-load从主内存复制变量到当前工作内存，</li>
<li>use-assign执行代码改变共享变量值，</li>
<li>store-write用工作内存数据刷新主存相关内容。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ol>
<h3 id="多线程的三个特性"><a href="#多线程的三个特性" class="headerlink" title="多线程的三个特性"></a>多线程的三个特性</h3><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><ol>
<li>一个原子操作在CPU中不可以中断或暂停后在调度，全执行或全不执行，但是x++不是原子操作<ul>
<li>a.将变量x 值取出放在寄存器中 </li>
<li>b.将将寄存器中的值+1 </li>
<li>c.将寄存器中的值赋值给x。 </li>
</ul>
</li>
<li>JMM中的原子性操作：<code>read、load、use、assign、store和write</code>，大致可以认为基础数据类型的访问和读写是具备原子性的</li>
<li>更大范围的操作保证原子性：在JMM中针对synchronized关键字增加了字节码指令monitorenter和monitorexit</li>
<li>业务代码控制：锁（lock和unlock）</li>
</ol>
<h4 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性(Visibility)"></a>可见性(Visibility)</h4><ol>
<li>使用主内存和工作内存保证可见性</li>
<li>关键字：<code>volatile</code>，具体说明，参考后续章节</li>
</ol>
<h4 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性(Ordering)"></a>有序性(Ordering)</h4><p>Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。</p>
<h3 id="JMM抽象结构"><a href="#JMM抽象结构" class="headerlink" title="JMM抽象结构"></a>JMM抽象结构</h3><ol>
<li>共享数据：实例域、静态域、数组存储在堆中，线程间共享</li>
<li>非共享数据：局部变量、方法参数、异常处理器参数</li>
</ol>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1590914067946.png" class title="java内存模型抽象结构示意图">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1590914160544.png" class title="线程之间的通信">

</div>

<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p><strong>happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见；规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结</strong></p>
<ol>
<li>❑ 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>❑ 监视器锁规则：线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li>
<li>❑ volatile变量规则：线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li>
<li>❑ 线程 start 前对变量的写，对该线程开始后对该变量的读可见</li>
<li>❑ 线程结束前对变量的写，对其它线程得知它结束后的读可见</li>
<li>❑ 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见</li>
<li>❑ 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li>
<li>❑ 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
</ol>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h3><ol>
<li><strong>同步</strong>：一种弱的同步机制，用来确保将变量的更新操作通知到其他线程，Volatile修饰变量的单个读/写，可以看做使用同一个锁完成的同步操作。</li>
<li><strong>可见性</strong><ul>
<li><strong>读</strong>： 执行<strong>read-&gt;load-&gt;use</strong>，每次使用时都需要从主内存中获取最新的数据</li>
<li><strong>写</strong>： 执行<strong>assign-&gt;store-&gt;write</strong>，每次更新完后都会回写到主内存</li>
</ul>
</li>
<li><strong>禁止指令重排序</strong></li>
<li><strong>场景</strong>：一个变量被多个线程共享，线程直接给这个变量赋值。</li>
<li><strong>保证线程安全的前置条件</strong><ul>
<li>单个读/写</li>
<li>不同的volatile变量之间，不能互相依赖</li>
</ul>
</li>
<li><strong>原子性</strong>：只能对原子性（单个读/写）操作具备线程安全性</li>
<li><strong>原理</strong>：普通变量的获取首先把主内存的数据获取到CPU缓存中，然后通过缓存使用；被volatile修饰的变量JVM保证了每次读变量都从内存中读，跳过 CPU cache 这一步，直接通过主内存获取数据</li>
</ol>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LazySingleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将代码转换为汇编指令，在汇编指令的中我们可以找到如下信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0000000002931351</span>: lock add dword ptr [rsp],0h ;*putstatic instance--将双字节的栈指针寄存器+<span class="number">0</span></span><br><span class="line">; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">12</span> (line <span class="number">13</span>) --赋值</span><br></pre></td></tr></table></figure>
<p>在使用volatile关键字修饰之后JMM会增加一个<strong>lock前缀指令的内存屏障</strong>，完成以下功能：</p>
<ol>
<li>禁止指令重排序</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ol>
<blockquote>
<p>这里需注意虽然volatile关键字保证了变量对于线程的可见性，但并不保证线程安全。</p>
</blockquote>
<h3 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h3><div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1590929114372.png" class title="volatile重排序规则表">

</div>


<h4 id="内存屏障的使用"><a href="#内存屏障的使用" class="headerlink" title="内存屏障的使用"></a>内存屏障的使用</h4><p>基于保守策略的JMM内存屏障插入策略。  </p>
<ol>
<li>❑ 在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>❑ 在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>❑ 在每个volatile读操作的前面插入一个LoadLoad屏障。</li>
<li>❑ 在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ol>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1590929400626.png" class title="volatile写：指令执行顺序示意图">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1590929489469.png" class title="volatile读：指令执行顺序示意图">

</div>

<h3 id="死循环代码"><a href="#死循环代码" class="headerlink" title="死循环代码"></a>死循环代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread.jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 不适用Volatile导致的死循环</span></span><br><span class="line"><span class="comment"> * 不同的CPU可能无法达到演示效果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/31 16:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDeadCircleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VolatileDeadCircleTest t = <span class="keyword">new</span> VolatileDeadCircleTest();</span><br><span class="line">        AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t.isRun())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程一致执行:&quot;</span> + (count.getAndIncrement()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        sleep(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 计划停止子线程，但是和预期可能不一致，最终会停止</span></span><br><span class="line">        t.setRun(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> run;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRun</span><span class="params">(<span class="keyword">boolean</span> run)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.run = run;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="锁的内存语义synchronized"><a href="#锁的内存语义synchronized" class="headerlink" title="锁的内存语义synchronized"></a>锁的内存语义synchronized</h2><ol>
<li>锁可以让临界区互斥执行</li>
<li>重要的同步手段</li>
<li>释放锁的线程向获取同一个锁的线程发送消息（唤醒）</li>
</ol>
<h3 id="锁的释放、获取"><a href="#锁的释放、获取" class="headerlink" title="锁的释放、获取"></a>锁的释放、获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread.jmm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/6/3 17:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123; <span class="comment">//1</span></span><br><span class="line">        a++;                           <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">                                       <span class="comment">//3</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123; <span class="comment">//4</span></span><br><span class="line">        System.out.println(a);         <span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">                                       <span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1591177153382.png" class>

</div>

<ol>
<li>线程之间使用同一个锁存在先后顺序</li>
<li>某个方法使用完成之后释放对应的锁，其他线程可竞争获取该锁</li>
<li>synchronized使用的是监视器锁</li>
<li>锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义（释放锁之后会把共享数据刷入主存并且使其他线程的本地内存中的变量无效）</li>
</ol>
<h3 id="锁内存语义实现"><a href="#锁内存语义实现" class="headerlink" title="锁内存语义实现"></a>锁内存语义实现</h3><h2 id="final的内存语义"><a href="#final的内存语义" class="headerlink" title="final的内存语义"></a>final的内存语义</h2><p>对final域的读写更像是普通变量访问。</p>
<h3 id="final域的重排序规则"><a href="#final域的重排序规则" class="headerlink" title="final域的重排序规则"></a>final域的重排序规则</h3><ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread.jmm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/31 21:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;                         <span class="comment">// 普通变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;                   <span class="comment">// final变量</span></span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalExample</span><span class="params">()</span></span>&#123;         <span class="comment">// 构造函数</span></span><br><span class="line">        i = <span class="number">1</span>;                     <span class="comment">// 普通变量赋值</span></span><br><span class="line">        j = <span class="number">2</span>;                     <span class="comment">// final变量赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;   <span class="comment">// 写线程A执行</span></span><br><span class="line">        obj = <span class="keyword">new</span> FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;   <span class="comment">// 读线程B执行</span></span><br><span class="line">        FinalExample object = obj; <span class="comment">// 读对象引用</span></span><br><span class="line">        <span class="keyword">int</span> a = object.i;          <span class="comment">// 读普通变量</span></span><br><span class="line">        <span class="keyword">int</span> b = object.j;          <span class="comment">// 读final变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h3><ol>
<li>JMM禁止编译器把final域的写重排序到构造函数之外</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li>
<li>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障</li>
<li>写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</li>
</ol>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1590930859921.png" class title="写final域的重排序规则">

</div>

<h3 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h3><p><strong>编译器会在读final域操作的前面插入一个LoadLoad屏障，防止初次读对象引用与初次读该对象包含的final域出现重排序。</strong>    </p>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1590931029214.png" class title="读final域的重排序规则">

</div>

<h3 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h3><p>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。  </p>
<h3 id="final引用不能从构造函数内“溢出”"><a href="#final引用不能从构造函数内“溢出”" class="headerlink" title="final引用不能从构造函数内“溢出”"></a>final引用不能从构造函数内“溢出”</h3><p>在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。</p>
<h2 id="CPU高速缓存详解"><a href="#CPU高速缓存详解" class="headerlink" title="CPU高速缓存详解"></a>CPU高速缓存详解</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>JVM模型中的主要概念：</p>
<ol>
<li><strong>线程共享（线程不安全）：堆内存、全局变量、主内存</strong></li>
<li><strong>线程私有（线程安全）：本地内存，栈内存，局部变量</strong></li>
</ol>
<p>线程共享数据的使用是由<strong>硬件架构</strong>决定，JVM针对硬件做了更高层级的封装和抽象，并且提供并发场景下的安全保证和API。java语言层面使用<strong>Synchronize，Volatile</strong>等关键字实现。</p>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1588162960377.png" class title="主内存和CPU高速缓存的模型图">

</div>

<h3 id="硬件内存模型"><a href="#硬件内存模型" class="headerlink" title="硬件内存模型"></a>硬件内存模型</h3><ol>
<li>引入CPU缓存的目的：<strong>解决CPU运算速度与内存读写速度不匹配</strong>，加快读取速度，提高CPU的利用率</li>
<li>位置：位于CPU与内存之间的临时存储器，对比主存内存空间小，但是交换速度快</li>
</ol>
<h4 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h4><ol>
<li><p><strong>一级缓存（L1 Cache）：一级数据缓存（Data Cache，D-Cache，L1d）和一级指令缓存(Instruction Cache，I-Cache，L1i)，分别用于存放数据和指令。</strong></p>
</li>
<li><p><strong>二级缓存（L2 Cache）：分内部和外部两种芯片。内部的芯片二级缓存运行速度与主频相同，而外部的二级缓存则只有主频的一半。L2高速缓存容量也会影响CPU的性能，原则是越大越好，现在家庭用CPU容量最大的是4MB，而服务器和工作站上用CPU的L2高速缓存普遍大于4MB，有的高达8MB或者19MB</strong>。</p>
</li>
<li><p><strong>三级缓存（L3 Cache）：在拥有三级缓存的CPU中，只有约5%的数据需要从内存中调用，这进一步提高了CPU的效率。具有较大L3缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度。</strong></p>
</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li>读取数据的流程：<strong>CPU读取数据的顺序是先Cache后内存（结构：CPU -&gt; cache -&gt; memory）</strong></li>
<li>Cache命中率可达<strong>90%左右</strong></li>
<li>CPU Cache的意义：提高吞吐量和CPU利用率</li>
<li>局部性原理<ul>
<li>时间局部性：如果某个数据被访问，那么在不久的将来它很可能再次被访问</li>
<li>空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问</li>
</ul>
</li>
</ol>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1588163172625.png" class title="CPU缓存演进过程">

</div>

<h3 id="缓存SRAM与内存DRAM的区别"><a href="#缓存SRAM与内存DRAM的区别" class="headerlink" title="缓存SRAM与内存DRAM的区别"></a>缓存SRAM与内存DRAM的区别</h3><p>内存的DRAM其实是SDRAM（同步动态随机储存器），是DRAM（Dynamic RAM，动态）的一种。DRAM只含一个晶体管和一个电容器，集成度非常高，可以轻松做出<strong>大容量（内存）</strong>，但是因为靠电容器来储存信息，所以需要不断刷新补充电容器的电荷，否则内部的数据即会消失。  </p>
<p>充电放电之间的时间差导致了DRAM比SRAM的反应要缓慢得多。<strong>高速缓存基本上都是采用SRAM存储器</strong>，SRAM是英文Static RAM的缩写，它是一种具有静态存取功能的存储器，不需要刷新电路即能保存它内部存储的数据。  </p>
<p>SRAM相比DRAM的复杂度就高了不止一点点，所以导致SRAM的集成度很低，也是前期CPU缓存不能集成进CPU内部也有这个原因。因此相同容量的DRAM内存可以设计为较小的体积，但是SRAM却需要很大的体积，这也是不能将缓存容量做得太大的重要原因。  </p>
<blockquote>
<p>它的特点归纳如下：优点是节能、速度快、不需要刷新时间所以凸显其数据传输速度很快，缺点是集成度低、相同的容量体积较大、而且价格较高，只能少量用于关键性系统以提高效率。SRAM和DRAM的电路图大致如下：</p>
</blockquote>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1588163250216.png" class>

</div>

<p>在一套完整的计算机体系中，一般会包含如下存储介质，它们分别是<strong>寄存器，高速缓存，内存，硬盘</strong>。它们的容量由小到大，访问速度由高到底，成本由高到低，体积则是由小到大。因此，寄存器，高速缓存等容易集成在CPU或是主板上，但是由于其成本高，所以不会大规模使用，而内存，硬盘成本较低，但体积大，不方便集成，所以可以作为外设，安装在主板上。这些存储介质的大小和访问速度大致如下图：</p>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1588163280193.png" class>

</div>

<h3 id="缓存一致性（MESI）"><a href="#缓存一致性（MESI）" class="headerlink" title="缓存一致性（MESI）"></a>缓存一致性（MESI）</h3><p>在多核CPU中，内存中的数据会在多个核心中存在数据副本，某一个核心发生修改操作，就产生了数据不一致的问题。而一致性协议正是用于保证多个CPU cache之间缓存共享数据的一致。试想下面一个问题：</p>
<ol>
<li>Core 0读取了一个字节，根据局部性原理，它相邻的字节同样被被读入Core 0的缓存</li>
<li>Core 1做了上面同样的工作，这样Core 0与Core 1的缓存拥有同样的数据</li>
<li>Core 0修改了那个字节，被修改后，那个字节被写回Core 0的缓存，但是该信息并没有写回主存</li>
<li>Core 1访问该字节，由于Core 0并未将数据写回主存，数据不同步</li>
</ol>
<h4 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h4><p>高速缓存其实就是一组称之为<strong>缓存行(cache line)的固定大小的数据块</strong>，其大小是以突发读或者突发写周期的大小为基础的。它是CPU缓存中可分配的<strong>最小存储单元</strong>，大小32字节、64字节、128字节不等，这与CPU架构有关，通常来说是64字节。当从CPU从内存中取数据到cache中时，会一次取一个cacheline大小的内存大小到cache中，然后存进相应的cacheline中。总结来说就是一句话：<font color="red">CPU不是按字节访问内存，而是以64字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。</font></p>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1588163379436.png" class>

</div>

<blockquote>
<p>工作方式：当CPU从cache中读取数据的时候，会比较地址是否相同，如果相同则检查cache line的状态，再决定该数据是否有效，无效则从主存中获取数据，或者根据一致性协议发生一次cache-to—chache的数据推送；<br>工作效率：当CPU能够从cache中拿到有效数据的时候，消耗几个机器周期，如果发生cache miss（缓存未命中），则会消耗几十上百个机器周期；  </p>
</blockquote>
<h4 id="MESI缓存一致性"><a href="#MESI缓存一致性" class="headerlink" title="MESI缓存一致性"></a>MESI缓存一致性</h4><p>CPU制造商制定了一个规则：<strong>当一个CPU修改缓存中的字节时，服务器中其他CPU会被通知，它们的缓存将视为无效。</strong>于是，在上面的情况下，Core 1发现自己的缓存中数据已无效，Core 0将立即把自己的数据写回主存，然后Core 1重新读取该数据，这个就是多级缓存-<strong>缓存一致性（MESI）。这协议用于保证多个CPU cache之间缓存共享数据的一致性。</strong>它定义了CacheLine的四种数据状态，而CPU对cache的四种操作可能会产生不一致的状态。因此缓存控制器监听到本地操作与远程操作的时候需要对地址一致的CacheLine状态做出一定的修改，从而保证数据在多个cache之间流转的一致性。  </p>
<p><strong>嗅探（snooping）协议</strong>，它的基本思想是：所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线：缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（<strong>同一个指令周期中，只有一个CPU缓存可以对内存读写</strong>）。CPU缓存控制器不仅仅在内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。<strong>只要某个处理器一写内存，其它处理器马上知道这块内存在它们的缓存段中已失效</strong>。ESI协议是当前最主流的缓存一致性协议，在MESI协议中，每个缓存行有4个状态，可用2个bit表示，它们分别是：</p>
<blockquote>
<p><strong>M（modify）</strong>：该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。总线监听：缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。<br><strong>E（exclusive）</strong>：该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。总线监听：缓存行必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。<br><strong>S（shared）</strong>：该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。总线监听：缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。<br><strong>I（invalid）</strong>：该Cache line无效。总线监听：无  </p>
</blockquote>
<p>只有当缓存行处于E或者M状态时，处理器是<strong>独占</strong>这个缓存行的。当处理器想写某个缓存行时，如果它没有独占权，它必须先发送一条”我要独占权”的请求给总线，这会通知其它处理器把它们拥有的同一缓存段的拷贝失效（如果有）。只有在获得独占权后，处理器才能开始修改数据—-并且此时这个处理器知道，这个缓存行只有一份拷贝，在我自己的缓存里，所以不会有任何冲突。反之，如果有其它处理器想读取这个缓存行（马上能知道，因为一直在嗅探总线），独占或已修改的缓存行必须先回到”共享”状态。如果是已修改的缓存行，那么还要先把内容回写到内存中。<strong>引起数据状态转换的CPU cache操作也有四种</strong>，因为所有CPU核的数据都会经过总线，因此这里其实对应的就是CPU在读取或写入数据时对总线的数据请求类型，分别如下：</p>
<ol>
<li>本地读取（Local read），简称LR：当前CPU核读本地高速缓存中的数据</li>
<li>本地写入（Local write），简称LW：当前CPU核将数据写到本地高速缓存中</li>
<li>远端读取（Remote read），简称RR：其他CPU核将主内存中的数据读取到高速缓存中来</li>
<li>远端写入（Remote write），简称RW：其他CPU核将高速缓存中的数据写回到主存里面去</li>
</ol>
<h3 id="状态转换和cache操作"><a href="#状态转换和cache操作" class="headerlink" title="状态转换和cache操作"></a>状态转换和cache操作</h3><h4 id="Modify"><a href="#Modify" class="headerlink" title="Modify"></a>Modify</h4><p>场景：当前CPU中数据的状态是Modifiy，表示当前CPU中拥有最新数据，虽然主存中的数据和当前CPU中的数据不一致，但是以当前CPU中的数据为准；  </p>
<blockquote>
<p>LR：此时如果发生local read，即当前CPU读数据，直接从cache中获取数据，拥有最新数据，因此状态不变；<br>LW：直接修改本地cache数据，修改后也是当前CPU拥有最新数据，因此状态不变；<br>RR：因为本地内存中有最新数据，当本地cache控制器监听到总线上有RR发生的时，必然是其他CPU发生了读主存的操作，此时为了保证一致性，当前CPU应该将数据写回主存，而随后的RR将会使得其他CPU和当前CPU拥有共同的数据，因此状态修改为S；<br>RW：当cache控制器监听到总线发生RW，当前CPU会将数据写回主存，因为随后的RW将会导致主存的数据修改，因此状态修改成I；  </p>
</blockquote>
<h4 id="Exclusive"><a href="#Exclusive" class="headerlink" title="Exclusive"></a>Exclusive</h4><p>场景：当前CPU中的数据状态是exclusive，表示当前CPU独占数据（其他CPU没有数据），并且和主存的数据一致；  </p>
<blockquote>
<p>LR：直接从本地cache中直接获取数据，状态不变；<br>LW：修改本地cache中的数据，状态修改成M（因为其他CPU中并没有该数据，不存在共享问题，因此不需要通知其他CPU修改cache line的状态为I）；<br>RR：本地cache中有最新数据，当cache控制器监听到总线上发生RR的时候，必然是其他CPU发生了读取主存的操作，而RR操作不会导致数据修改，因此两个CPU中的数据仍和主存中的数据一致，此时cache line状态修改为S；<br>RW：同RR，当cache控制器监听到总线发生RW，必然是其他CPU将最新数据写回到主存，此时为了保证缓存一致性，当前CPU的数据状态修改为I；  </p>
</blockquote>
<h4 id="Shared"><a href="#Shared" class="headerlink" title="Shared"></a>Shared</h4><p>场景：当前CPU中的数据状态是shared，表示当前CPU和其他CPU共享数据，且数据在多个CPU之间一致、多个CPU之间的数据和主存一致；  </p>
<blockquote>
<p>LR：直接从cache中读取数据，状态不变；<br>LW：发生本地写，并不会将数据立即写回主存，而是在稍后的一个时间再写回主存，因此为了保证缓存一致性，当前CPU的cache line状态修改为M，并通知其他拥有该数据的CPU该数据失效，其他CPU将cache line状态修改为I；<br>RR：状态不变，因为多个CPU中的数据和主存一致；<br>RW：当监听到总线发生了RW，意味着其他CPU发生了写主存操作，此时本地cache中的数据既不是最新数据，和主存也不再一致，因此当前CPU的cache line状态修改为I；  </p>
</blockquote>
<h4 id="Invalid"><a href="#Invalid" class="headerlink" title="Invalid"></a>Invalid</h4><p>场景：当前CPU中的数据状态是invalid，表示当前CPU中是脏数据，不可用，其他CPU可能有数据、也可能没有数据；  </p>
<blockquote>
<p>LR：因为当前CPU的cache line数据不可用，因此会发生读内存，此时的情形如下。如果其他CPU中无数据则状态修改为E；如果其他CPU中有数据且状态为S或E则状态修改为S；如果其他CPU中有数据且状态为M，那么其他CPU首先发生RW将M状态的数据写回主存并修改状态为S，随后当前CPU读取主存数据，也将状态修改为S；<br>LW：因为当前CPU的cache line数据无效，因此发生LW会直接操作本地cache，此时的情形如下。如果其他CPU中无数据，则将本地cache line的状态修改为M；如果其他CPU中有数据且状态为S或E，则修改本地cache，通知其他CPU将数据修改为I，当前CPU中的cache line状态修改为M；如果其他CPU中有数据且状态为M，则其他CPU首先将数据写回主存，并将状态修改为I，当前CPU中的cache line转台修改为M；<br>RR：监听到总线发生RR操作，表示有其他CPU读取内存，和本地cache无关，状态不变；<br>RW：监听到总线发生RW操作，表示有其他CPU写主存，和本地cache无关，状态不变；  </p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java中线程的本地内存，栈内存，局部变量这部分内存对应的硬件区域是在CPU的高速缓存或者寄存器中，而主存，堆内存，全局变量对应的是计算机的内存条中的内存或是虚拟内存。在并发情况下线程会优先逐级的从CPU的三级高速缓存中读取数据，如果高速缓存中没有数据就会从主存中读取数据。在多个线程同时需要从主存中读取统一数据的情况下，CPU总线提供了总线锁机制来保证正确的同步，当然这部分对于Java开发者来说不可能直接使用总线锁，这里JVM提供的内存模型就是对硬件机制的封装，因此只要正确使用JVM提供同步机制就可以了。语言层面就是synchronize，volatile，Lock类。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
<li><a href="https://www.toutiao.com/i6906078545806819848/">无锁队列Disruptor原理解析</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之线程常用方法</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/1590711795506.png" class title="Runnable类图">

</div>

<a id="more"></a>

<h2 id="常用方法汇总"><a href="#常用方法汇总" class="headerlink" title="常用方法汇总"></a>常用方法汇总</h2><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-sjuo{background-color:#C2FFD6;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">方法名</th>
    <th class="tg-0lax">static</th>
    <th class="tg-0lax">功能说明</th>
    <th class="tg-0lax">注意</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-sjuo">start()</td>
    <td class="tg-sjuo"></td>
    <td class="tg-sjuo">启动一个新线程，在新的线程运行 run 方法中的代码</td>
    <td class="tg-sjuo">start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException</td>
  </tr>
  <tr>
    <td class="tg-0lax">run()</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">新线程启动后会调用的方法</td>
    <td class="tg-0lax">如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建Thread 的子类对象，来覆盖默认行为</td>
  </tr>
  <tr>
    <td class="tg-sjuo">join()</td>
    <td class="tg-sjuo"></td>
    <td class="tg-sjuo">等待线程运行结束</td>
    <td class="tg-sjuo"></td>
  </tr>
  <tr>
    <td class="tg-0lax">join(long n)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">等待线程运行结束,多等待n 毫秒</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-sjuo">getId()</td>
    <td class="tg-sjuo"></td>
    <td class="tg-sjuo">获取线程长整型的 id</td>
    <td class="tg-sjuo">id唯一</td>
  </tr>
  <tr>
    <td class="tg-0lax">getName()</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">获取线程名</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-sjuo">setName(String)</td>
    <td class="tg-sjuo"></td>
    <td class="tg-sjuo">修改线程名</td>
    <td class="tg-sjuo"></td>
  </tr>
  <tr>
    <td class="tg-0lax">getPriority()</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">获取线程优先级</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-sjuo">setPriority(int)</td>
    <td class="tg-sjuo"></td>
    <td class="tg-sjuo">修改线程优先级</td>
    <td class="tg-sjuo">java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被CPU 调度的机率</td>
  </tr>
  <tr>
    <td class="tg-0lax">getState()</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">获取线程状态</td>
    <td class="tg-0lax">Java中线程状态是用 6 个enum 表示，分别为：NEW,RUNNABLE, BLOCKED, WAITING,TIMED_WAITING,TERMINATED</td>
  </tr>
  <tr>
    <td class="tg-sjuo">isInterrupted()</td>
    <td class="tg-sjuo"></td>
    <td class="tg-sjuo">判断是否被打断，</td>
    <td class="tg-sjuo">不会清除 打断标记</td>
  </tr>
  <tr>
    <td class="tg-0lax">isAlive()</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">线程是否存活（还没有运行完毕)
    </td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-sjuo">interrupt()</td>
    <td class="tg-sjuo"></td>
    <td class="tg-sjuo">打断线程</td>
    <td class="tg-sjuo">如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出InterruptedException，并清除打断标记；如果打断的正在运行的线程，则会设置 打断标记；park的线程被打断，也会设置打断标记</td>
  </tr>
  <tr>
    <td class="tg-0lax">interrupted()</td>
    <td class="tg-0lax">static</td>
    <td class="tg-0lax">判断当前线程是否被打断</td>
    <td class="tg-0lax">会清除 打断标记</td>
  </tr>
  <tr>
    <td class="tg-sjuo">currentThread()</td>
    <td class="tg-sjuo">static</td>
    <td class="tg-sjuo">获取当前正在执行的线程</td>
    <td class="tg-sjuo"></td>
  </tr>
  <tr>
    <td class="tg-sjuo">sleep(long n)</td>
    <td class="tg-sjuo">static</td>
    <td class="tg-sjuo">让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</td>
    <td class="tg-sjuo"></td>
  </tr>
  <tr>
    <td class="tg-0lax">yield()</td>
    <td class="tg-0lax">static</td>
    <td class="tg-0lax">提示线程调度器让出当前线程对CPU的使用</td>
    <td class="tg-0lax">主要是为了测试和调试x</td>
  </tr>
  <tr>
    <td class="tg-0lax">activeCount</td>
    <td class="tg-0lax">static</td>
    <td class="tg-0lax">程序中活跃的线程数</td>
    <td class="tg-0lax"></td>
  </tr>
   <tr>
    <td class="tg-0lax">enumerate</td>
    <td class="tg-0lax">static</td>
    <td class="tg-0lax">枚举程序中的线程</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">isDaemon()</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">一个线程是否为守护线程</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">setDaemon()</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)</td>
    <td class="tg-0lax"></td>
  </tr>
  
</tbody>
</table>

<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/1589109533903.png" class title="线程状态转换">

</div>

<h2 id="常用方法详解"><a href="#常用方法详解" class="headerlink" title="常用方法详解"></a>常用方法详解</h2><h3 id="线程中断（interrupt）"><a href="#线程中断（interrupt）" class="headerlink" title="线程中断（interrupt）"></a>线程中断（interrupt）</h3><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个<strong>中断标识位</strong>。 <strong>这个线程本身并不会因此而改变状态(如阻塞，终止等)。</strong></p>
<ol>
<li>调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。 </li>
<li>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。 </li>
<li>许多声明抛出InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。 </li>
<li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程thread的时候，可以调用thread.interrupt()方法，在线程的run方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。 </li>
<li>打断sleep、wait、join的线程，会清空打断状态（isInterrupted方法为false）</li>
<li>打断正常运行的线程，不会清空打断状态</li>
<li>打断park线程，不会清空打断状态</li>
</ol>
<h3 id="Join-等待其他线程终止"><a href="#Join-等待其他线程终止" class="headerlink" title="Join 等待其他线程终止"></a>Join 等待其他线程终止</h3><p>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。 </p>
<h4 id="为什么要用-join-方法"><a href="#为什么要用-join-方法" class="headerlink" title="为什么要用 join()方法"></a>为什么要用 join()方法</h4><p>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/28 14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread p = Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> D(p), String.valueOf(i));</span><br><span class="line">            t.start();</span><br><span class="line">            p = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ddd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">D</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; dd11d&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><ol>
<li>obj.wait() 让进入 object 监视器的线程到 waitSet 等待，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定（无限制等待），才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争</li>
<li>obj.notify() 在 object 上正在 waitSet 等待的线程中随意挑一个唤醒（发生在对实现做出决定时）</li>
<li>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/28 20:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1: 执行....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;1: 其它代码....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2: 执行....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;2: 其它代码....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 主线程两秒后执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;唤醒 obj 上其它线程&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"><span class="comment">//            obj.notify(); // 唤醒obj上一个线程</span></span><br><span class="line">             obj.notifyAll(); <span class="comment">// 唤醒obj上所有等待线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     notify:</span></span><br><span class="line"><span class="comment">     1: 执行....</span></span><br><span class="line"><span class="comment">     2: 执行....</span></span><br><span class="line"><span class="comment">     唤醒 obj 上其它线程</span></span><br><span class="line"><span class="comment">     1: 其它代码....</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     notifyal</span></span><br><span class="line"><span class="comment">     1: 执行....</span></span><br><span class="line"><span class="comment">     2: 执行....</span></span><br><span class="line"><span class="comment">     唤醒 obj 上其它线程</span></span><br><span class="line"><span class="comment">     2: 其它代码....</span></span><br><span class="line"><span class="comment">     1: 其它代码....</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="正确使用方式"><a href="#正确使用方式" class="headerlink" title="正确使用方式"></a>正确使用方式</h4><h3 id="sleep、yield、wait"><a href="#sleep、yield、wait" class="headerlink" title="sleep、yield、wait"></a>sleep、yield、wait</h3><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><ol>
<li>Object对象的方法，调用之后进入WAITING 状态</li>
<li>释放对象锁（wait 方法一般用在同步方法或同步代码块中）</li>
<li>只有等待其他线程通知或被中断后才能返回</li>
<li>调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li>
<li>需要配合synchronized使用</li>
</ol>
<h5 id="wait为什么需要配合synchronized使用"><a href="#wait为什么需要配合synchronized使用" class="headerlink" title="wait为什么需要配合synchronized使用"></a>wait为什么需要配合synchronized使用</h5><p><strong>防止出现死锁。</strong> </p>
<p>在wait（）的内部，会先释放锁obj1，然后进入阻塞状态，之后，它被另外一个线程用notify（）唤醒，去重新拿锁！其次，wait（）调用完成后，执行后面的业务逻辑代码，然后退出synchronized同步块，再次释放锁。内部伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wait()&#123;</span><br><span class="line">  <span class="comment">//释放锁</span></span><br><span class="line">  <span class="comment">//阻塞，等待被其他线程notify</span></span><br><span class="line">  <span class="comment">//重新获取锁</span></span><br><span class="line">  <span class="comment">//处理后续逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait（）和notify（）所作用的对象和synchronized所作用的对象是同一个，只能有一个对象，无法区分队列空和列队满两个条件。可以通过<strong>Condition</strong>实现。</p>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><ol>
<li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞），到了时间之后进入等待队列</li>
<li>不会释放锁（wait会）</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
<li>属于Thread类</li>
<li>不需要强制配额synchronized使用</li>
</ol>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><ol>
<li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，与其他线程一起重新竞争 CPU 时间片，然后调度执行其它线程</li>
<li>一般优先级高的会可能有效被调度，但是具体的实现依赖于操作系统的任务调度器</li>
</ol>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ol>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li>
<li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/28 8:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable task1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----------&gt;1---&quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable task2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">&quot;-----------&gt;2---&quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(task1, <span class="string">&quot;thread1&quot;</span> );</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(task2, <span class="string">&quot;thread2&quot;</span> );</span><br><span class="line">        t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="start-与-run-区别"><a href="#start-与-run-区别" class="headerlink" title="start 与 run 区别"></a>start 与 run 区别</h3><ol>
<li>start方法启动线程，真正实现了多线程运行。</li>
<li>使用start启动一个线程（处于就绪状态），然后线程会真正执行run方法  </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试run方法和start方法的区别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/27 20:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadRunAndStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">testRun</span><span class="params">(Thread t1)</span></span>&#123;</span><br><span class="line">        t1.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;do other things ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">testStart</span><span class="params">(Thread t1)</span></span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;do other things ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//顺序执行</span></span><br><span class="line"><span class="comment">//        TestThreadRunAndStart.testRun(t1);</span></span><br><span class="line">        <span class="comment">//异步执行</span></span><br><span class="line">        TestThreadRunAndStart.testStart(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="park-amp-unpark"><a href="#park-amp-unpark" class="headerlink" title="park&amp;unpark"></a>park&amp;unpark</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park();</span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/1590712088254.png" class title="LockSupport类图">

</div>

<ol>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】</li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
</ol>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/1590712868689.png" class>

</div>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程常用方法</tag>
        <tag>sleep</tag>
        <tag>wait</tag>
        <tag>join</tag>
        <tag>yield</tag>
        <tag>start</tag>
        <tag>run</tag>
        <tag>park</tag>
        <tag>unpark</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之线程控制手段</title>
    <url>/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%89%8B%E6%AE%B5/</url>
    <content><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%89%8B%E6%AE%B5/1591538272733.png" class title="CountDownLatch类图">

</div>
<a id="more"></a>

<p>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch 来实现这种功能了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在执行&quot;</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">				latch.countDown();</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在执行&quot;</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">				latch.countDown();</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;等待 2 个子线程执行完毕...&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			latch.await();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;2 个子线程已经执行完毕&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;继续执行主线程&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractQueuedSynchronizer.acquireSharedInterruptibly实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">	<span class="comment">// tryAcquireShared由具体的子类实现</span></span><br><span class="line">	<span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">		doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CountDownLatch.Sync.tryAcquireShared</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 只要state！=0，调用await（）方法的线程便会被放入AQS的阻塞队列，进入阻塞状态</span></span><br><span class="line">	<span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="countDown方法"><a href="#countDown方法" class="headerlink" title="countDown方法"></a>countDown方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractQueuedSynchronizer.releaseShared实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment">* threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">*        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">*        and can represent anything you like.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">// 由具体子类实现</span></span><br><span class="line">		doReleaseShared();<span class="comment">//一次性唤醒队列中所有阻塞的线程</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CountDownLatch.Sync.tryReleaseShared</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">int</span> c = getState();</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">			<span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CountDownLatch总结"><a href="#CountDownLatch总结" class="headerlink" title="CountDownLatch总结"></a>CountDownLatch总结</h3><p>因为是基于AQS 阻塞队列来实现的，所以可以让多个线程都阻塞在state=0条件上，通过countDown（）一直累减state，减到0后一次性唤醒所有线程。如图4-4所示，假设初始总数为M，N个线程await（），M个线程countDown（），减到0之后，N个线程被唤醒。</p>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%89%8B%E6%AE%B5/1591539301108.png" class>

</div>

<h3 id="CountDownLatch锁获取释放流程图"><a href="#CountDownLatch锁获取释放流程图" class="headerlink" title="CountDownLatch锁获取释放流程图"></a>CountDownLatch锁获取释放流程图</h3><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%89%8B%E6%AE%B5/CountDownLatch%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" class title="CountDownLatch锁获取释放流程图">

</div>

<h3 id="配合线程池使用"><a href="#配合线程池使用" class="headerlink" title="配合线程池使用"></a>配合线程池使用</h3><p>ExecutorService作为一个线程池，然后利用CountDownLatch可以让指定数量的线程都执行完再执行主线程的特性。就可以实现多线程提速了。<br>套路是这样的：<br>1、实现runnable接口实现一个run方法，里面执行我们的耗时复杂业务操作。<br>2、在循环里给list里的每个对象分配一个线程<br>3、使用CountDownLatch让主线程等待工作线程全部执行完毕后之后，再继续执行。  </p>
<h4 id="参考实例"><a href="#参考实例" class="headerlink" title="参考实例"></a>参考实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机生成一个数组，然后并发计算数组求和,注意：未处理中断和线程池关闭</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Theodore SUN</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; paramList;</span><br><span class="line">	<span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RunnerTask</span><span class="params">(List&lt;Integer&gt; paramList, CountDownLatch latch)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.paramList = paramList;</span><br><span class="line">		<span class="keyword">this</span>.latch = latch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot;====start====&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			<span class="keyword">for</span>(Integer i : paramList) &#123;</span><br><span class="line">				sum += i.intValue();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">				latch.countDown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot;====end====&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">				list.add((i + <span class="number">1</span>) * (j + <span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			taskList.add(list);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Integer&gt; returnList = Test.multiThreadProcess(taskList);</span><br><span class="line">		System.out.println(returnList);</span><br><span class="line">		System.exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService taskPool = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">multiThreadProcess</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; taskList)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		List&lt;Future&lt;Integer&gt;&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (taskList != <span class="keyword">null</span> &amp;&amp; !taskList.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 创建闭锁，计数器大小为任务多列的长多</span></span><br><span class="line">			CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(taskList.size());</span><br><span class="line">			<span class="keyword">for</span> (List&lt;Integer&gt; item : taskList) &#123;</span><br><span class="line">				list1.add(taskPool.submit(<span class="keyword">new</span> RunnerTask(item, latch)));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 主线程开始等待，直到计数器大小为0，返回结果</span></span><br><span class="line">			latch.await();</span><br><span class="line">			<span class="keyword">for</span>(Future&lt;Integer&gt; f : list1) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					list.add(f.get());</span><br><span class="line">				&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line">		taskPool.shutdown();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%89%8B%E6%AE%B5/1591540042030.png" class title="CyclicBarrier类图">

</div>

<ol>
<li>回环栅栏-等待至 barrier 状态再全部同时执行</li>
<li>可重用（回环）：当所有等待线程都被释放以后可重复使用</li>
<li>响应中断：线程没有到齐，如果有线程收到了中断信号，所有阻塞的线程也会被唤醒（breakBarrier）。然后count被重置为初始值（parties），重新开始。</li>
<li>我们暂且把这个状态就叫做 barrier，当调用 await()方法之后，线程就处于 barrier 了。</li>
<li>基于ReentrantLock+Condition实现</li>
<li>barrierAction只会被第n个线程执行1次（在唤醒其他n-1个线程之前）</li>
</ol>
<h3 id="CyclicBarrier常用方法"><a href="#CyclicBarrier常用方法" class="headerlink" title="CyclicBarrier常用方法"></a>CyclicBarrier常用方法</h3><p>CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本：</p>
<ol>
<li>public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务；</li>
<li>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。</li>
</ol>
<h3 id="CyclicBarrier源码分析"><a href="#CyclicBarrier源码分析" class="headerlink" title="CyclicBarrier源码分析"></a>CyclicBarrier源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Each use of the barrier is represented as a generation instance.</span></span><br><span class="line"><span class="comment">     * The generation changes whenever the barrier is tripped, or</span></span><br><span class="line"><span class="comment">     * is reset. There can be many generations associated with threads</span></span><br><span class="line"><span class="comment">     * using the barrier - due to the non-deterministic way the lock</span></span><br><span class="line"><span class="comment">     * may be allocated to waiting threads - but only one of these</span></span><br><span class="line"><span class="comment">     * can be active at a time (the one to which &#123;<span class="doctag">@code</span> count&#125; applies)</span></span><br><span class="line"><span class="comment">     * and all the rest are either broken or tripped.</span></span><br><span class="line"><span class="comment">     * There need not be an active generation if there has been a break</span></span><br><span class="line"><span class="comment">     * but no subsequent reset.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="comment">// 用于线程之间互相唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/** The number of parties */</span></span><br><span class="line">    <span class="comment">// 总线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* The command to run when tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment">     * on each generation.  It is reset to parties on each new</span></span><br><span class="line"><span class="comment">     * generation or when broken.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Updates state on barrier trip and wakes up everyone.</span></span><br><span class="line"><span class="comment">     * Called only while holding lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// signal completion of last generation</span></span><br><span class="line">        trip.signalAll();</span><br><span class="line">        <span class="comment">// set up next generation</span></span><br><span class="line">        count = parties;</span><br><span class="line">        generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets current barrier generation as broken and wakes up everyone.</span></span><br><span class="line"><span class="comment">     * Called only while holding lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        generation.broken = <span class="keyword">true</span>;</span><br><span class="line">        count = parties;</span><br><span class="line">        trip.signalAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;<span class="comment">// 响应中断</span></span><br><span class="line">                breakBarrier();<span class="comment">//唤醒所有被阻塞线程</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每个线程调用一次await则执行一次--count，当count==0时则唤醒其他所有线程</span></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)<span class="comment">// 一起唤醒之后可以执行一次回调</span></span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 可重用</span></span><br><span class="line">                    <span class="comment">// 唤醒其他所有线程，并且复原count</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">// count！=0的处理，需要阻塞自己</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();<span class="comment">//阻塞自己的时候释放锁，别的线程就可以执行该方法</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment">     * given number of parties (threads) are waiting upon it, and which</span></span><br><span class="line"><span class="comment">     * will execute the given barrier action when the barrier is tripped,</span></span><br><span class="line"><span class="comment">     * performed by the last thread entering the barrier.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment">     *        before the barrier is tripped</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> barrierAction the command to execute when the barrier is</span></span><br><span class="line"><span class="comment">     *        tripped, or &#123;<span class="doctag">@code</span> null&#125; if there is no action</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of parties required to trip this barrier.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of parties required to trip this barrier</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getParties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries if this barrier is in a broken state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if one or more parties broke out of this</span></span><br><span class="line"><span class="comment">     *         barrier due to interruption or timeout since</span></span><br><span class="line"><span class="comment">     *         construction or the last reset, or a barrier action</span></span><br><span class="line"><span class="comment">     *         failed due to an exception; &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> generation.broken;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resets the barrier to its initial state.  If any parties are</span></span><br><span class="line"><span class="comment">     * currently waiting at the barrier, they will return with a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> BrokenBarrierException&#125;. Note that resets &lt;em&gt;after&lt;/em&gt;</span></span><br><span class="line"><span class="comment">     * a breakage has occurred for other reasons can be complicated to</span></span><br><span class="line"><span class="comment">     * carry out; threads need to re-synchronize in some other way,</span></span><br><span class="line"><span class="comment">     * and choose one to perform the reset.  It may be preferable to</span></span><br><span class="line"><span class="comment">     * instead create a new barrier for subsequent use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">            nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of parties currently waiting at the barrier.</span></span><br><span class="line"><span class="comment">     * This method is primarily useful for debugging and assertions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of parties currently blocked in &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parties - count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        	<span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//以睡眠来模拟线程需要预定写入数据操作</span></span><br><span class="line">				Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;写入数据完毕，等待其他线程写入完毕&quot;</span>);</span><br><span class="line">				cyclicBarrier.await();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;所有线程写入完毕，继续处理其他任务，比如数据操作&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程Thread-1写入数据完毕，等待其他线程写入完毕</span></span><br><span class="line"><span class="comment">* 线程Thread-0写入数据完毕，等待其他线程写入完毕</span></span><br><span class="line"><span class="comment">* 线程Thread-2写入数据完毕，等待其他线程写入完毕</span></span><br><span class="line"><span class="comment">* 线程Thread-3写入数据完毕，等待其他线程写入完毕</span></span><br><span class="line"><span class="comment">* 所有线程写入完毕，继续处理其他任务，比如数据操作</span></span><br><span class="line"><span class="comment">* 所有线程写入完毕，继续处理其他任务，比如数据操作</span></span><br><span class="line"><span class="comment">* 所有线程写入完毕，继续处理其他任务，比如数据操作</span></span><br><span class="line"><span class="comment">* 所有线程写入完毕，继续处理其他任务，比如数据操作</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%89%8B%E6%AE%B5/1591537903457.png" class title="Semaphore类图">

</div>

<ol>
<li>信号量，Semaphore 可以控制同时访问的线程个数</li>
<li>通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 </li>
<li>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。</li>
<li>Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池实现互斥锁（计数器为1）。我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</li>
</ol>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%89%8B%E6%AE%B5/1591538120073.png" class title="多线程访问示意图">

</div>

<h3 id="Semaphore常用方法"><a href="#Semaphore常用方法" class="headerlink" title="Semaphore常用方法"></a>Semaphore常用方法</h3><ol>
<li>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</li>
<li>public void acquire(int permits):获取 permits 个许可</li>
<li>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。</li>
<li>public void release(int permits) { }:释放 permits 个许可</li>
</ol>
<p>上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法</p>
<ol>
<li>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false</li>
<li>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false</li>
<li>public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false</li>
<li>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits 个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false</li>
<li>还可以通过 availablePermits()方法得到可用的许可数目。</li>
</ol>
<h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例子：若一个工厂有5 台机器，但是有8个工人，</span></span><br><span class="line"><span class="comment"> * 一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Theodore SUN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> N = <span class="number">8</span>;            <span class="comment">//工人数</span></span><br><span class="line">		Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			<span class="keyword">new</span> Worker(i,semaphore).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">		<span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num,Semaphore semaphore)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.num = num;</span><br><span class="line">			<span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				semaphore.acquire(); </span><br><span class="line">				System.out.println(<span class="string">&quot;工人&quot;</span>+<span class="keyword">this</span>.num+<span class="string">&quot;占用一个机器在生产...&quot;</span>);</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;工人&quot;</span>+<span class="keyword">this</span>.num+<span class="string">&quot;释放出机器&quot;</span>);</span><br><span class="line">				semaphore.release(); </span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 工人0占用一个机器在生产...</span></span><br><span class="line"><span class="comment">	 * 工人1占用一个机器在生产...</span></span><br><span class="line"><span class="comment">	 * 工人2占用一个机器在生产...</span></span><br><span class="line"><span class="comment">	 * 工人3占用一个机器在生产...</span></span><br><span class="line"><span class="comment">	 * 工人5占用一个机器在生产...</span></span><br><span class="line"><span class="comment">	 * 工人0释放出机器</span></span><br><span class="line"><span class="comment">	 * 工人3释放出机器</span></span><br><span class="line"><span class="comment">	 * 工人7占用一个机器在生产...</span></span><br><span class="line"><span class="comment">	 * 工人5释放出机器</span></span><br><span class="line"><span class="comment">	 * 工人1释放出机器</span></span><br><span class="line"><span class="comment">	 * 工人2释放出机器</span></span><br><span class="line"><span class="comment">	 * 工人6占用一个机器在生产...</span></span><br><span class="line"><span class="comment">	 * 工人4占用一个机器在生产...</span></span><br><span class="line"><span class="comment">	 * 工人7释放出机器</span></span><br><span class="line"><span class="comment">	 * 工人4释放出机器</span></span><br><span class="line"><span class="comment">	 * 工人6释放出机器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。</li>
<li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li>
</ol>
<h3 id="Semaphore-与-ReentrantLock"><a href="#Semaphore-与-ReentrantLock" class="headerlink" title="Semaphore 与 ReentrantLock"></a>Semaphore 与 ReentrantLock</h3><ol>
<li>Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，</li>
<li>通过 acquire()与 release()方法来获得和释放临界资源。</li>
<li>Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</li>
<li>Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock 不同，其使用方法与ReentrantLock几乎一致。</li>
<li>Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</li>
<li>Semaphore的锁释放操作也由手动进行，因此与ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。</li>
</ol>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程控制手段</tag>
        <tag>CountDownLatch</tag>
        <tag>CyclicBarrier</tag>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之线程创建</title>
    <url>/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="通过Thread构建"><a href="#通过Thread构建" class="headerlink" title="通过Thread构建"></a>通过Thread构建</h2><p>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程。</p>
<a id="more"></a>

<h3 id="Thread定义"><a href="#Thread定义" class="headerlink" title="Thread定义"></a>Thread定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java</span></span><br><span class="line"><span class="comment"> * Virtual Machine allows an application to have multiple threads of</span></span><br><span class="line"><span class="comment"> * execution running concurrently.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Every thread has a priority. Threads with higher priority are</span></span><br><span class="line"><span class="comment"> * executed in preference to threads with lower priority. Each thread</span></span><br><span class="line"><span class="comment"> * may or may not also be marked as a daemon. When code running in</span></span><br><span class="line"><span class="comment"> * some thread creates a new &lt;code&gt;Thread&lt;/code&gt; object, the new</span></span><br><span class="line"><span class="comment"> * thread has its priority initially set equal to the priority of the</span></span><br><span class="line"><span class="comment"> * creating thread, and is a daemon thread if and only if the</span></span><br><span class="line"><span class="comment"> * creating thread is a daemon.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When a Java Virtual Machine starts up, there is usually a single</span></span><br><span class="line"><span class="comment"> * non-daemon thread (which typically calls the method named</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual</span></span><br><span class="line"><span class="comment"> * Machine continues to execute threads until either of the following</span></span><br><span class="line"><span class="comment"> * occurs:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt; has been</span></span><br><span class="line"><span class="comment"> *     called and the security manager has permitted the exit operation</span></span><br><span class="line"><span class="comment"> *     to take place.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;All threads that are not daemon threads have died, either by</span></span><br><span class="line"><span class="comment"> *     returning from the call to the &lt;code&gt;run&lt;/code&gt; method or by</span></span><br><span class="line"><span class="comment"> *     throwing an exception that propagates beyond the &lt;code&gt;run&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> *     method.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * There are two ways to create a new thread of execution. One is to</span></span><br><span class="line"><span class="comment"> * declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This</span></span><br><span class="line"><span class="comment"> * subclass should override the &lt;code&gt;run&lt;/code&gt; method of class</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be</span></span><br><span class="line"><span class="comment"> * allocated and started. For example, a thread that computes primes</span></span><br><span class="line"><span class="comment"> * larger than a stated value could be written as follows:</span></span><br><span class="line"><span class="comment"> * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     class PrimeThread extends Thread &#123;</span></span><br><span class="line"><span class="comment"> *         long minPrime;</span></span><br><span class="line"><span class="comment"> *         PrimeThread(long minPrime) &#123;</span></span><br><span class="line"><span class="comment"> *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         public void run() &#123;</span></span><br><span class="line"><span class="comment"> *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment"> *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     PrimeThread p = new PrimeThread(143);</span></span><br><span class="line"><span class="comment"> *     p.start();</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The other way to create a thread is to declare a class that</span></span><br><span class="line"><span class="comment"> * implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then</span></span><br><span class="line"><span class="comment"> * implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can</span></span><br><span class="line"><span class="comment"> * then be allocated, passed as an argument when creating</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other</span></span><br><span class="line"><span class="comment"> * style looks like the following:</span></span><br><span class="line"><span class="comment"> * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     class PrimeRun implements Runnable &#123;</span></span><br><span class="line"><span class="comment"> *         long minPrime;</span></span><br><span class="line"><span class="comment"> *         PrimeRun(long minPrime) &#123;</span></span><br><span class="line"><span class="comment"> *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         public void run() &#123;</span></span><br><span class="line"><span class="comment"> *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment"> *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     PrimeRun p = new PrimeRun(143);</span></span><br><span class="line"><span class="comment"> *     new Thread(p).start();</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Every thread has a name for identification purposes. More than</span></span><br><span class="line"><span class="comment"> * one thread may have the same name. If a name is not specified when</span></span><br><span class="line"><span class="comment"> * a thread is created, a new name is generated for it.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Unless otherwise noted, passing a &#123;<span class="doctag">@code</span> null&#125; argument to a constructor</span></span><br><span class="line"><span class="comment"> * or method in this class will cause a &#123;<span class="doctag">@link</span> NullPointerException&#125; to be</span></span><br><span class="line"><span class="comment"> * thrown.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Runnable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Runtime#exit(int)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #run()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/1590711873784.png" class title="Thread类图">

</div>

<p>通过JDK官方定义可以得出以下结论：</p>
<ol>
<li>线程是程序中的执行线程，java虚拟机允许应用程序并发的运行多个线程。</li>
<li>每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个守护程序。当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。</li>
<li>当 Java 虚拟机启动时，通常都会有单个非守护线程（它通常会调用某个指定类的 main 方法）。Java 虚拟机会继续执行线程，直到下列任一情况出现时为止：<ol>
<li>调用了 Runtime 类的 exit 方法，并且安全管理器允许退出操作发生。</li>
<li>非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 run 方法之外的异常。</li>
</ol>
</li>
</ol>
<h3 id="Thread原理（init方法）"><a href="#Thread原理（init方法）" class="headerlink" title="Thread原理（init方法）"></a>Thread原理（init方法）</h3><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如<strong>线程所属的线程组、线程优先级、是否是Daemon线程等信息</strong>。在new Thread时会调用以下方法进行实例化Thread对象。<br>初始化代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Initializes a Thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> g the Thread group</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> target the object whose run() method gets called</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name the name of the new Thread</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> stackSize the desired stack size for the new thread, or</span></span><br><span class="line"><span class="comment">*        zero to indicate that this parameter is to be ignored.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> acc the AccessControlContext to inherit, or</span></span><br><span class="line"><span class="comment">*            AccessController.getContext() if null</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> inheritThreadLocals if &#123;<span class="doctag">@code</span> true&#125;, inherit initial values for</span></span><br><span class="line"><span class="comment">*            inheritable thread-locals from the constructing thread</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="comment">//当前线程作为该线程的父线程</span></span><br><span class="line">	Thread parent = currentThread();</span><br><span class="line">	SecurityManager security = System.getSecurityManager();</span><br><span class="line">	<span class="comment">//线程组的获取：如果传入的参数为空首先获取系统默认的安全组，如果为空获取父线程的安全组</span></span><br><span class="line">	<span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">			what to do. */</span></span><br><span class="line">		<span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">			g = security.getThreadGroup();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">			use the parent thread group. */</span></span><br><span class="line">		<span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">			g = parent.getThreadGroup();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">		explicitly passed in. */</span></span><br><span class="line">	g.checkAccess();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		* Do we have the required permissions?</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	<span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">			security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g.addUnstarted();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.group = g;</span><br><span class="line">	<span class="comment">//设置daemon 、priority 属性为父线程对应的值</span></span><br><span class="line">	<span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">	<span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">	<span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">		<span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">	<span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">			acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">	<span class="keyword">this</span>.target = target;</span><br><span class="line">	setPriority(priority);</span><br><span class="line">	<span class="comment">//将父线程的InheritableThreadLocal复制过来</span></span><br><span class="line">	<span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">			ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">	<span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">	<span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set thread ID */</span></span><br><span class="line">	<span class="comment">//生成线程id（一个long型的字段threadSeqNumber）</span></span><br><span class="line">	tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过代码总结如下：<br>一个新构建的Thread对象（new Thread()）,是由其父线程（当前线程）进行空间分配，而子线程继承了父线程的Daemon、优先级和加载资源的contextClassLoader，以及可继承的ThreadLocal，同时会为子线程分配一个线程id。一个可以运行的线程对象完成初始化工作，并且在堆内存中等待运行。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 基于Thread实现线程的创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/27 18:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要实现的业务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;CreateThreadByThread.run() by extends Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多态创建线程</span></span><br><span class="line">        Thread o = <span class="keyword">new</span> CreateThreadByThread();</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        o.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CreateThreadByThread.run() by extends Thread</span></span><br></pre></td></tr></table></figure>
<ol>
<li>通过Thread源码发现（Thread implements Runnable）发现thread其实也是一个实现了runnable接口的一个实例，它代表一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。</li>
<li>其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。</li>
</ol>
<h2 id="通过Runnable构建"><a href="#通过Runnable构建" class="headerlink" title="通过Runnable构建"></a>通过Runnable构建</h2><p>如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个 Runnable 接口。</p>
<p><strong>把【线程】和【任务】（要执行的代码）分开</strong>  </p>
<ol>
<li>Thread 代表线程</li>
<li>Runnable 可运行的任务（线程要执行的代码）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过Runnable创建线程，实现业务与线程的解耦</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/27 18:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际执行的业务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;====CreateThreadByRunnable=====Runnable====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化线程</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CreateThreadByRunnable());</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK1.8之后的实现</span></span><br><span class="line">        Runnable task2 = () -&gt; System.out.println(<span class="string">&quot;task2 jdk8&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(task2, <span class="string">&quot;task2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//====CreateThreadByRunnable=====Runnable====</span></span><br><span class="line"><span class="comment">//task2 jdk8</span></span><br></pre></td></tr></table></figure>
<h2 id="通过ExecutorService、Callable、Future构建"><a href="#通过ExecutorService、Callable、Future构建" class="headerlink" title="通过ExecutorService、Callable、Future构建"></a>通过ExecutorService、Callable、Future构建</h2><p><strong>解决Thread和Runnable无法返回值的问题（可以通过共享变量实现）。</strong> 有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。</p>
<h3 id="Callable-JDK定义（泛型返回值V）"><a href="#Callable-JDK定义（泛型返回值V）" class="headerlink" title="Callable JDK定义（泛型返回值V）"></a>Callable JDK定义（泛型返回值V）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A task that returns a result and may throw an exception.</span></span><br><span class="line"><span class="comment"> * Implementors define a single method with no arguments called</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> call&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@code</span> Callable&#125; interface is similar to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.lang.Runnable&#125;, in that both are designed for classes whose</span></span><br><span class="line"><span class="comment"> * instances are potentially executed by another thread.  A</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Runnable&#125;, however, does not return a result and cannot</span></span><br><span class="line"><span class="comment"> * throw a checked exception.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@link</span> Executors&#125; class contains utility methods to</span></span><br><span class="line"><span class="comment"> * convert from other common forms to &#123;<span class="doctag">@code</span> Callable&#125; classes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Executor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the result type of method &#123;<span class="doctag">@code</span> call&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Callable在JDK中的定义使用-ExecutorService"><a href="#Callable在JDK中的定义使用-ExecutorService" class="headerlink" title="Callable在JDK中的定义使用(ExecutorService)"></a>Callable在JDK中的定义使用(ExecutorService)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>
<h3 id="Future说明"><a href="#Future说明" class="headerlink" title="Future说明"></a>Future说明</h3><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> taskSize = <span class="number">10</span>;</span><br><span class="line">		<span class="comment">// 创建线程池</span></span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">		<span class="comment">// 创建有返回值的任务</span></span><br><span class="line">		List&lt;Future&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">			list.add(pool.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="string">&quot;ddd:111  &quot;</span> + Thread.currentThread().getName();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//关闭线程池</span></span><br><span class="line">		pool.shutdown();</span><br><span class="line">		<span class="comment">// 获取结果</span></span><br><span class="line">		<span class="keyword">for</span>(Future&lt;String&gt; f : list) &#123;</span><br><span class="line">			System.out.println(f.get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/27 19:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByFuture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      创建任务对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; thread = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;FutureTask====&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      创建并且启动线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(thread).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处理返回值信息</span></span><br><span class="line">            System.out.println(thread.get() + <span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于线程池构建"><a href="#基于线程池构建" class="headerlink" title="基于线程池构建"></a>基于线程池构建</h2><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsThread2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			pool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: is running&quot;</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><h3 id="start源码"><a href="#start源码" class="headerlink" title="start源码"></a>start源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Causes this thread to begin execution; the Java Virtual Machine</span></span><br><span class="line"><span class="comment">* calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* The result is that two threads are running concurrently: the</span></span><br><span class="line"><span class="comment">* current thread (which returns from the call to the</span></span><br><span class="line"><span class="comment">* &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span></span><br><span class="line"><span class="comment">* &lt;code&gt;run&lt;/code&gt; method).</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* It is never legal to start a thread more than once.</span></span><br><span class="line"><span class="comment">* In particular, a thread may not be restarted once it has completed</span></span><br><span class="line"><span class="comment">* execution.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span></span><br><span class="line"><span class="comment">*               started.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>        #run()</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>        #stop()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">	* group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">	* to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">		* so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">		* and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">	group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		start0();</span><br><span class="line">		started = <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!started) &#123;</span><br><span class="line">				group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">			<span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">				it will be passed up the call stack */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过源码得出以下结论：</p>
<ol>
<li>对象初始化完成之后，通过执行start方法来执行这个线程，并且java虚拟机会调用该线程的run方法执行线程的业务逻辑；</li>
<li>调用start方法之后发现会同时有两个线程在执行：当前线程（parent线程【同步告知java虚拟机，只要线程规划器空闲，应立即启动调用start方法的线程】，从调用返回给start方法）和另一个线程（执行其run方法）。</li>
<li>并且多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。 </li>
</ol>
<h3 id="线程启动的注意事项"><a href="#线程启动的注意事项" class="headerlink" title="线程启动的注意事项"></a>线程启动的注意事项</h3><p>无论何种方式，启动一个线程，就要给它一个名字！这对排错诊断 系统监控有帮助。否则诊断问题时，无法直观知道某个线程的用途。</p>
<div align="center">

<img src="/2021/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/1587983785160.png" class title="线程启动注意事项">

</div>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Thread与Runnable"><a href="#Thread与Runnable" class="headerlink" title="Thread与Runnable"></a>Thread与Runnable</h3><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>Thread实现接口Runnable，并且实现了run方法，代码参考如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；</span></span><br><span class="line">		<span class="comment">//否则，该方法不执行任何操作并返回。</span></span><br><span class="line">		<span class="comment">//Thread 的子类应该重写该方法。</span></span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * If this thread was constructed using a separate</span></span><br><span class="line"><span class="comment">	     * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</span></span><br><span class="line"><span class="comment">	     * &lt;code&gt;Runnable&lt;/code&gt; object&#x27;s &lt;code&gt;run&lt;/code&gt; method is called;</span></span><br><span class="line"><span class="comment">	     * otherwise, this method does nothing and returns.</span></span><br><span class="line"><span class="comment">	     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	     * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</span></span><br><span class="line"><span class="comment">	     *</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span>     #start()</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">	            target.run();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p> 当执行到Thread类中的run()方法时，会首先判断target是否存在，存在则执行target中的run()方法，也就是实现了Runnable接口并重写了run()方法的类中的run()方法。当时如果该Runnable的子类是通过一个继承Thread的子类（该且重写了run方法），则真正执行的是Thread子类重写的run方法（由于多态的原因）。  </p>
<p>实现Runnable接口相比继承Thread类有如下优势：</p>
<ol>
<li>可以避免由于Java的单继承特性而带来的局限；</li>
<li>增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；</li>
<li>适合多个相同程序代码的线程区处理同一资源的情况。</li>
<li>用 Runnable 更容易与线程池等高级 API 配合</li>
<li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
<li>Thread是把线程和任务合并在了一起，Runnable是把线程和任务分开了</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
<li><a href="https://www.cnblogs.com/wxd0108/p/5479442.html">Java中的多线程你只要看这一篇就够了</a></li>
<li><a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin">线程</a></li>
<li><a href="https://www.cnblogs.com/lwbqqyumidi/p/3804883.html">Java总结篇系列：Java多线程（一）</a></li>
<li>《java并发编程实战》</li>
<li><a href="https://blog.csdn.net/hanhaiyinheguxing/article/details/51366541">多线程01：《疯狂Java讲义》学习笔记——线程概述</a></li>
<li><a href="https://blog.csdn.net/hla199106/article/details/47840505">java并发编程—如何创建线程以及Thread类的使用</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920357.html">Java并发编程：Thread类的使用</a></li>
<li><a href="https://www.cnblogs.com/loveer/p/11518402.html">Java中断机制</a></li>
<li><a href="https://www.cnblogs.com/hapjin/p/5450779.html">JAVA多线程之中断机制(如何处理中断？)</a></li>
<li><a href="https://blog.csdn.net/aboy123/article/details/38307539/">JAVA多线程实现的三种方式 </a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程创建</tag>
        <tag>Thread</tag>
        <tag>Runnable</tag>
        <tag>Callable</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之线程池总体架构</title>
    <url>/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>为了方便并发执行任务，出现了一种专门用来执行任务的实现，也就是<code>Executor</code>。<br>由此，任务提交者不需要再创建管理线程，使用更方便，也减少了开销。Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 <code>ExecutorService</code>。Executor定义规范。</p>
<a id="more"></a>

<h3 id="任务与线程执行器的关系"><a href="#任务与线程执行器的关系" class="headerlink" title="任务与线程执行器的关系"></a>任务与线程执行器的关系</h3><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/1587825891275.png" class title="任务与线程执行器的关系">

</div>

<h3 id="Executor类图"><a href="#Executor类图" class="headerlink" title="Executor类图"></a>Executor类图</h3><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/1588228165857.png" class title="Executor类图">

</div>

<h3 id="Executor两级调度模型"><a href="#Executor两级调度模型" class="headerlink" title="Executor两级调度模型"></a>Executor两级调度模型</h3><p>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/1587826068684.png" class title="Executor两级调度模型">

</div>

<h3 id="Executor框架结构"><a href="#Executor框架结构" class="headerlink" title="Executor框架结构"></a>Executor框架结构</h3><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/1587826248237.png" class title="Executor框架结构">

</div>

<p>一般的线程池主要分为以下 4 个组成部分：  </p>
<ol>
<li>线程池管理器：用于创建并管理线程池</li>
<li>工作线程：线程池中的线程</li>
<li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</li>
<li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li>
</ol>
<p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 <code>Executor、Executors、ExecutorService、ThreadPoolExecutor 、Callable、Future、FutureTask</code> 这几个类。</p>
<h3 id="Executor结构组件"><a href="#Executor结构组件" class="headerlink" title="Executor结构组件"></a>Executor结构组件</h3><ol>
<li>任务。包括被执行任务需要实现的接口：Runnable接口或Callable接口。Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled-ThreadPoolExecutor执行</li>
<li>任务的执行。包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）。</li>
<li>Executor：Executor框架的基础接口，它将任务的提交与任务的执行分离开来</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executor是一个可以提交任务的对象，Executor接口提供一种解耦的任务提交方式，</span></span><br><span class="line"><span class="comment"> * 这种提交方式源于每个任务如何被执行的机制，包括线程的使用细节和调度。</span></span><br><span class="line"><span class="comment"> * 这个接口通常用于明确创建线程的替代方式</span></span><br><span class="line"><span class="comment"> * For example, rather than</span></span><br><span class="line"><span class="comment"> * invoking &#123;<span class="doctag">@code</span> new Thread(new(RunnableTask())).start()&#125; for each</span></span><br><span class="line"><span class="comment"> * of a set of tasks, you might use:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Executor executor = &lt;em&gt;anExecutor&lt;/em&gt;;</span></span><br><span class="line"><span class="comment"> * executor.execute(new RunnableTask1());</span></span><br><span class="line"><span class="comment"> * executor.execute(new RunnableTask2());</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * Executor接口并不严格要求任务被异步执行，有时候能在当前调用的线程中立即执行。</span></span><br><span class="line"><span class="comment"> *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * class DirectExecutor implements Executor &#123;</span></span><br><span class="line"><span class="comment"> *   public void execute(Runnable r) &#123;</span></span><br><span class="line"><span class="comment"> *     r.run();</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 更多典型的场景下,任务被一些线程执行，</span></span><br><span class="line"><span class="comment"> * 而并不在当前线程下,下面的例子中，为每一个任务就产生了一个新的线程。</span></span><br><span class="line"><span class="comment"> *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * class ThreadPerTaskExecutor implements Executor &#123;</span></span><br><span class="line"><span class="comment"> *   public void execute(Runnable r) &#123;</span></span><br><span class="line"><span class="comment"> *     new Thread(r).start();</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *一些Executor的实现强加某种关于任务何时和如何被调度的限制，</span></span><br><span class="line"><span class="comment"> *下边的串行化的任务交给第二个executor去执行</span></span><br><span class="line"><span class="comment"> *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * class SerialExecutor implements Executor &#123;</span></span><br><span class="line"><span class="comment"> *   final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;();</span></span><br><span class="line"><span class="comment"> *   final Executor executor;</span></span><br><span class="line"><span class="comment"> *   Runnable active;</span></span><br><span class="line"><span class="comment"> *   SerialExecutor(Executor executor) &#123;</span></span><br><span class="line"><span class="comment"> *     this.executor = executor;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *   public synchronized void execute(final Runnable r) &#123;</span></span><br><span class="line"><span class="comment"> *     tasks.offer(new Runnable() &#123;</span></span><br><span class="line"><span class="comment"> *       public void run() &#123;</span></span><br><span class="line"><span class="comment"> *         try &#123;</span></span><br><span class="line"><span class="comment"> *           r.run();</span></span><br><span class="line"><span class="comment"> *         &#125; finally &#123;</span></span><br><span class="line"><span class="comment"> *           scheduleNext();</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *       &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;);</span></span><br><span class="line"><span class="comment"> *     if (active == null) &#123;</span></span><br><span class="line"><span class="comment"> *       scheduleNext();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *   protected synchronized void scheduleNext() &#123;</span></span><br><span class="line"><span class="comment"> *     if ((active = tasks.poll()) != null) &#123;</span></span><br><span class="line"><span class="comment"> *       executor.execute(active);</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在当前包下提供了一些实现ExecutorService接口的实现，这个接口是一个相对比较广泛的接口，</span></span><br><span class="line"><span class="comment"> * ThreadPoolExecutor　该类提供了一个可扩展的线程池实现。</span></span><br><span class="line"><span class="comment"> * Execturos静态类提供一些方便的工厂方法去创建不同的Executor</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 内存一致性影响：在当前线程的动作要优先于提交给Executor的任务对象，</span></span><br><span class="line"><span class="comment"> * 它们在真正开始执行的时侯，可能在另一个线程里了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *执行给定的命令任务在未来的某个时间点，</span></span><br><span class="line"><span class="comment">     *这个命令可能在一个新的线程里，或者在一个线程池里，也有可能就在前调用线程中。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>ThreadPoolExecutor：线程池的核心实现类，用来执行被提交的任务</li>
<li>ScheduledThreadPoolExecutor：线程池实现类，可以在给定的延迟后运行命令，或者定期执行。比Timer更灵活，功能更强大</li>
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</li>
<li>Future接口和实现Future接口的FutureTask代表异步计算的结果</li>
</ol>
<p>标记一下比较重要的类：</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:0px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:0px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-sjuo{background-color:#C2FFD6;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;ExecutorService：&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;真正的线程池接口。&nbsp;&nbsp;&nbsp;</th>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;ScheduledExecutorService&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;ThreadPoolExecutor&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;ExecutorService的默认实现。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;ScheduledThreadPoolExecutor&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-sjuo">&nbsp;&nbsp;&nbsp;继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。&nbsp;&nbsp;&nbsp;</td>
  </tr>
</table>

<p>Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<ol>
<li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 </li>
<li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
<li>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ol>
<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - 该接口提供了管理任务中断以及一个或多个异步任务执行的跟踪。</span></span><br><span class="line"><span class="comment"> * -</span></span><br><span class="line"><span class="comment"> * - ExecutorService可以被shutdown，执行之后会拒绝新任务的加入，包括两种关闭方式：</span></span><br><span class="line"><span class="comment"> * - shutdown：允许在中止之前提供的任务继续执行，</span></span><br><span class="line"><span class="comment"> * - shutdownNow：阻止等待中的任务，并试图阻止正在执行的任务,</span></span><br><span class="line"><span class="comment"> * - 当一个executor要中止的时侯，没有活动的任务执行，没有任务等待执行，没有新的任务被提交，</span></span><br><span class="line"><span class="comment"> * - 一个未使用的ExecutorService 将被shutdown,以允许资源被回收</span></span><br><span class="line"><span class="comment"> * -</span></span><br><span class="line"><span class="comment"> * - submit方法基于execute方法，</span></span><br><span class="line"><span class="comment"> * - 并且创建返回一个Future对象，该对象通常可以取消执行或等待直到任务完成</span></span><br><span class="line"><span class="comment"> * - invokeAny和invokeAll方法执行批量处理形式，执行一批任务然后等待一个或多个任务执行结束</span></span><br><span class="line"><span class="comment"> * - ExecutorCompletionService通常用于写这些方法的自定义变量。</span></span><br><span class="line"><span class="comment"> * -</span></span><br><span class="line"><span class="comment"> * - Executors 这个类提供工厂方法为了提供executor 服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Usage Examples&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Here is a sketch of a network service in which threads in a thread</span></span><br><span class="line"><span class="comment"> * pool service incoming requests. It uses the preconfigured &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Executors#newFixedThreadPool&#125; factory method:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * class NetworkService implements Runnable &#123;</span></span><br><span class="line"><span class="comment"> *   private final ServerSocket serverSocket;</span></span><br><span class="line"><span class="comment"> *   private final ExecutorService pool;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   public NetworkService(int port, int poolSize)</span></span><br><span class="line"><span class="comment"> *       throws IOException &#123;</span></span><br><span class="line"><span class="comment"> *     serverSocket = new ServerSocket(port);</span></span><br><span class="line"><span class="comment"> *     pool = Executors.newFixedThreadPool(poolSize);</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   public void run() &#123; // run the service</span></span><br><span class="line"><span class="comment"> *     try &#123;</span></span><br><span class="line"><span class="comment"> *       for (;;) &#123;</span></span><br><span class="line"><span class="comment"> *         pool.execute(new Handler(serverSocket.accept()));</span></span><br><span class="line"><span class="comment"> *       &#125;</span></span><br><span class="line"><span class="comment"> *     &#125; catch (IOException ex) &#123;</span></span><br><span class="line"><span class="comment"> *       pool.shutdown();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * class Handler implements Runnable &#123;</span></span><br><span class="line"><span class="comment"> *   private final Socket socket;</span></span><br><span class="line"><span class="comment"> *   Handler(Socket socket) &#123; this.socket = socket; &#125;</span></span><br><span class="line"><span class="comment"> *   public void run() &#123;</span></span><br><span class="line"><span class="comment"> *     // read and service request on socket</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following method shuts down an &#123;<span class="doctag">@code</span> ExecutorService&#125; in two phases,</span></span><br><span class="line"><span class="comment"> * first by calling &#123;<span class="doctag">@code</span> shutdown&#125; to reject incoming tasks, and then</span></span><br><span class="line"><span class="comment"> * calling &#123;<span class="doctag">@code</span> shutdownNow&#125;, if necessary, to cancel any lingering tasks:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * void shutdownAndAwaitTermination(ExecutorService pool) &#123;</span></span><br><span class="line"><span class="comment"> *   pool.shutdown(); // Disable new tasks from being submitted</span></span><br><span class="line"><span class="comment"> *   try &#123;</span></span><br><span class="line"><span class="comment"> *     // Wait a while for existing tasks to terminate</span></span><br><span class="line"><span class="comment"> *     if (!pool.awaitTermination(60, TimeUnit.SECONDS)) &#123;</span></span><br><span class="line"><span class="comment"> *       pool.shutdownNow(); // Cancel currently executing tasks</span></span><br><span class="line"><span class="comment"> *       // Wait a while for tasks to respond to being cancelled</span></span><br><span class="line"><span class="comment"> *       if (!pool.awaitTermination(60, TimeUnit.SECONDS))</span></span><br><span class="line"><span class="comment"> *           System.err.println(&quot;Pool did not terminate&quot;);</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125; catch (InterruptedException ie) &#123;</span></span><br><span class="line"><span class="comment"> *     // (Re-)Cancel if current thread also interrupted</span></span><br><span class="line"><span class="comment"> *     pool.shutdownNow();</span></span><br><span class="line"><span class="comment"> *     // Preserve interrupt status</span></span><br><span class="line"><span class="comment"> *     Thread.currentThread().interrupt();</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Memory consistency effects: Actions in a thread prior to the</span></span><br><span class="line"><span class="comment"> * submission of a &#123;<span class="doctag">@code</span> Runnable&#125; or &#123;<span class="doctag">@code</span> Callable&#125; task to an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ExecutorService&#125;</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * any actions taken by that task, which in turn &lt;i&gt;happen-before&lt;/i&gt; the</span></span><br><span class="line"><span class="comment"> * result is retrieved via &#123;<span class="doctag">@code</span> Future.get()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - 启动一个有秩序的shutdown</span></span><br><span class="line"><span class="comment">     * - 调用该方法时，之前提交的任务都被执行，但是不接收新任务；</span></span><br><span class="line"><span class="comment">     * - 如果已关闭，再次调用则没有任何影响</span></span><br><span class="line"><span class="comment">     * -</span></span><br><span class="line"><span class="comment">     * - 该方法不会等待已提交任务被执行完成，可以使用awaitTermination来实现。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment">     *         shutting down this ExecutorService may manipulate</span></span><br><span class="line"><span class="comment">     *         threads that the caller is not permitted to modify</span></span><br><span class="line"><span class="comment">     *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> (&quot;modifyThread&quot;)&#125;,</span></span><br><span class="line"><span class="comment">     *         or the security manager&#x27;s &#123;<span class="doctag">@code</span> checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     *         denies access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - 试图停止所有活动的正在执行的任务，停止等待中的任务处理，</span></span><br><span class="line"><span class="comment">     * - 返回等待执行任务列表（未执行的任务列表）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - 该方法不会等待活动的执行中的任务终止，可以使用awaitTermination处理。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - 处理尽量尝试终止活动中执行的任务，但是没有任何保障。</span></span><br><span class="line"><span class="comment">     * - 尤其是无法响应中断的任务，则永远无法终止</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list of tasks that never commenced execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment">     *         shutting down this ExecutorService may manipulate</span></span><br><span class="line"><span class="comment">     *         threads that the caller is not permitted to modify</span></span><br><span class="line"><span class="comment">     *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> (&quot;modifyThread&quot;)&#125;,</span></span><br><span class="line"><span class="comment">     *         or the security manager&#x27;s &#123;<span class="doctag">@code</span> checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     *         denies access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this executor has been shut down.</span></span><br><span class="line"><span class="comment">     * - 如果executor已经关闭则返回true</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this executor has been shut down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - 如果所有任务在shutdown后全部执行完成则返回true</span></span><br><span class="line"><span class="comment">     * - isTerminated 可能永远为true,除非调用了shutdown或shutdownNow</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if all tasks have completed following shut down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * -阻塞直到（任一）</span></span><br><span class="line"><span class="comment">     * -1.在shutdown 方法执行之后，所有任务完成执行</span></span><br><span class="line"><span class="comment">     * -2.时间超时</span></span><br><span class="line"><span class="comment">     * -3.当前线程interrupted</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this executor terminated and</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; if the timeout elapsed before termination</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - 提交一个有返回值的任务，执行并且返回一个Future对象，代表任务的执行结果</span></span><br><span class="line"><span class="comment">     * - future.get方法会返回成功完成任务的执行结果（阻塞效果）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - 如果想立刻阻塞等待任务的结果，可以参考以下代码：</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> result = exec.submit(aCallable).get();&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - Executors中提供了一组方法，用于对象的转换（闭包对象），</span></span><br><span class="line"><span class="comment">     * - 比如PrivilegedAction转成Callable形式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the task&#x27;s result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submits a Runnable task for execution and returns a Future</span></span><br><span class="line"><span class="comment">     * representing that task. The Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will</span></span><br><span class="line"><span class="comment">     * return the given result upon successful completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result the result to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submits a Runnable task for execution and returns a Future</span></span><br><span class="line"><span class="comment">     * representing that task. The Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will</span></span><br><span class="line"><span class="comment">     * return &#123;<span class="doctag">@code</span> null&#125; upon &lt;em&gt;successful&lt;/em&gt; completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - 批量提交任务，当所有任务都执行完成时返回Future列表，这些Future保持任务的状态和结果。</span></span><br><span class="line"><span class="comment">     * - 返回列表中每个Future的isDone都为true</span></span><br><span class="line"><span class="comment">     * -</span></span><br><span class="line"><span class="comment">     * - 任务会在正常运行结束或者抛出异常时完成终止</span></span><br><span class="line"><span class="comment">     * - 如果在操作过程中任务队列别修改，则返回返回undefined</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a list of Futures representing the tasks, in the same</span></span><br><span class="line"><span class="comment">     *         sequential order as produced by the iterator for the</span></span><br><span class="line"><span class="comment">     *         given task list, each of which has completed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting, in</span></span><br><span class="line"><span class="comment">     *         which case unfinished tasks are cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks or any of its elements are &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if any task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a list of Futures representing the tasks, in the same</span></span><br><span class="line"><span class="comment">     *         sequential order as produced by the iterator for the</span></span><br><span class="line"><span class="comment">     *         given task list. If the operation did not time out,</span></span><br><span class="line"><span class="comment">     *         each task will have completed. If it did time out, some</span></span><br><span class="line"><span class="comment">     *         of these tasks will not have completed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting, in</span></span><br><span class="line"><span class="comment">     *         which case unfinished tasks are cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks, any of its elements, or</span></span><br><span class="line"><span class="comment">     *         unit are &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if any task cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - 1.返回任一个已经成功完成任务的结果，也就是说没有抛出异常。</span></span><br><span class="line"><span class="comment">     * - 2.在正常或者异常返回时，未完成的任务将被取消。</span></span><br><span class="line"><span class="comment">     * - 3.在执行过程中如果任务列表被修改，则方法的返回结果为undefined</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks or any element task</span></span><br><span class="line"><span class="comment">     *         subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if tasks is empty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks, or unit, or any element</span></span><br><span class="line"><span class="comment">     *         task subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException if the given timeout elapses before</span></span><br><span class="line"><span class="comment">     *         any task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>Java线程池</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
        <tag>Executor</tag>
        <tag>ExecutorService</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之阻塞队列</title>
    <url>/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：<br>    当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。 </p>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/1589104874399.png" class>

</div>
<a id="more"></a>

<p>    当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。 </p>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/1589104894314.png" class>

</div>

<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/1589104912351.png" class>

</div>

<h2 id="阻塞队列的主要方法"><a href="#阻塞队列的主要方法" class="headerlink" title="阻塞队列的主要方法"></a>阻塞队列的主要方法</h2><style type="text/css">
.tg  {border-collapse:collapse;border-color:#aaa;border-spacing:0;}
.tg td{background-color:#fff;border-color:#aaa;border-style:solid;border-width:1px;color:#333;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#f38630;border-color:#aaa;border-style:solid;border-width:1px;color:#fff;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0pky">方法类型</th>
    <th class="tg-0pky">抛出异常</th>
    <th class="tg-0pky">特殊值</th>
    <th class="tg-0pky">阻塞</th>
    <th class="tg-0pky">超时</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">插入</td>
    <td class="tg-0pky">add(e)</td>
    <td class="tg-0pky">offer(e)</td>
    <td class="tg-0pky">put(e)</td>
    <td class="tg-0pky">offer(e,time,unit)</td>
  </tr>
  <tr>
    <td class="tg-0pky">移除</td>
    <td class="tg-0pky">remove()</td>
    <td class="tg-0pky">poll()</td>
    <td class="tg-0pky">take()</td>
    <td class="tg-0pky">poll(time,unit)</td>
  </tr>
  <tr>
    <td class="tg-0pky">检查</td>
    <td class="tg-0pky">element()</td>
    <td class="tg-0pky">peek()</td>
    <td class="tg-0pky">不可用</td>
    <td class="tg-0pky">不可用</td>
  </tr>
</tbody>
</table>

<ol>
<li>抛出异常：抛出一个异常； </li>
<li>特殊值：返回一个特殊值（null 或 false） </li>
<li>阻塞：在成功操作之前，一直阻塞线程 </li>
<li>超时：放弃前只在最大的时间内阻塞 </li>
</ol>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/1589104955872.png" class>

</div>


<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ol>
<li><p>public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。 </p>
</li>
<li><p>public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。  </p>
</li>
<li><p>public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要） </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue, waiting</span></span><br><span class="line"><span class="comment"> * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();<span class="comment">//如果队列满了，则线程阻塞等待</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败。</p>
</li>
</ol>
<h3 id="获取数据操作"><a href="#获取数据操作" class="headerlink" title="获取数据操作"></a>获取数据操作</h3><ol>
<li>poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数规定的时间,取不到时返回 null; </li>
<li>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。 </li>
<li>take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入。 </li>
<li>drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。  </li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> BlockingQueue&lt;Object&gt; bq = <span class="keyword">new</span> ArrayBlockingQueue&lt;Object&gt;(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="string">&quot;错误使用&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">					Object o = bq.poll();<span class="comment">//不等待直接返回数据</span></span><br><span class="line">					<span class="comment">// TODO</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="string">&quot;正确使用&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Object o = bq.take();<span class="comment">//等待数据</span></span><br><span class="line">						<span class="comment">// TODO</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="string">&quot;正确使用&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Object o = bq.poll(<span class="number">1</span>, TimeUnit.SECONDS);<span class="comment">//防止死等</span></span><br><span class="line">						<span class="comment">// TODO</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义阻塞队列"><a href="#自定义阻塞队列" class="headerlink" title="自定义阻塞队列"></a>自定义阻塞队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDefineBlockQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">BlockingQ1</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Object notEmpty = <span class="keyword">new</span> Object();</span><br><span class="line">		<span class="keyword">private</span> Queue&lt;Object&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 未取得锁就直接执行wait、notfiy、notifyAll会抛异常</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (notEmpty) &#123;</span><br><span class="line">				<span class="keyword">if</span> (linkedList.size() == <span class="number">0</span>) &#123;<span class="comment">// 没有数据需要等待</span></span><br><span class="line">					<span class="comment">/**</span></span><br><span class="line"><span class="comment">					 * 1.执行wait之前需要获得当前对象的锁 2.执行wait之后释放锁 3.被唤醒之前，需要先获得锁</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					notEmpty.wait();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> linkedList.poll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (notEmpty) &#123;</span><br><span class="line">				System.out.println(linkedList.size());</span><br><span class="line">				<span class="keyword">if</span> (linkedList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">/**</span></span><br><span class="line"><span class="comment">					 * 要执行notify和notifyAll操作，都必须先取得该对象的锁。</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					notEmpty.notifyAll();</span><br><span class="line">				&#125;</span><br><span class="line">				linkedList.add(o);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 分别需要对notEmpty和notFull加锁</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Theodore SUN</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">BlockingQ2</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Object notEmpty = <span class="keyword">new</span> Object();</span><br><span class="line">		<span class="keyword">private</span> Object notFull = <span class="keyword">new</span> Object();</span><br><span class="line">		<span class="keyword">private</span> Queue&lt;Object&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Object&gt;();</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> maxLength = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (notEmpty) &#123;</span><br><span class="line">				<span class="keyword">if</span> (linkedList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">					notEmpty.wait();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">synchronized</span> (notFull) &#123;</span><br><span class="line">					<span class="keyword">if</span> (linkedList.size() == maxLength) &#123;</span><br><span class="line">						notFull.notifyAll();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> linkedList.poll();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Object object)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (notEmpty) &#123;</span><br><span class="line">				<span class="keyword">if</span> (linkedList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">					notEmpty.notifyAll();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">synchronized</span> (notFull) &#123;</span><br><span class="line">					<span class="keyword">if</span> (linkedList.size() == maxLength) &#123;</span><br><span class="line">						notFull.wait();</span><br><span class="line">					&#125;</span><br><span class="line">					linkedList.add(object);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//未锁就直接执行await、signal、siganlAll会抛异常</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">BlockingQ3</span> </span>&#123;</span><br><span class="line">		<span class="comment">//一个锁创建多个condition</span></span><br><span class="line">		<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		<span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">		<span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line">		<span class="keyword">private</span> Queue&lt;Object&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Object&gt;();</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> maxLength = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (linkedList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">/**</span></span><br><span class="line"><span class="comment">					 * 要执行await操作，必须先取得该Condition的锁。</span></span><br><span class="line"><span class="comment">					 * 执行await操作之后，锁会释放。</span></span><br><span class="line"><span class="comment">					 * 被唤醒之前，需要先获得锁</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					notEmpty.await();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (linkedList.size() == maxLength) &#123;</span><br><span class="line">					notFull.signalAll();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> linkedList.poll();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Object object)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (linkedList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 要执行signal和signalAll操作，都必须先取得该对象的锁。</span></span><br><span class="line">					notEmpty.signalAll();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (linkedList.size() == maxLength) &#123;</span><br><span class="line">					notFull.await();</span><br><span class="line">				&#125;</span><br><span class="line">				linkedList.add(object);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		MyDefineBlockQueue a = <span class="keyword">new</span> MyDefineBlockQueue();</span><br><span class="line">		BlockingQ1 bq1 = a.n<span class="function">ew <span class="title">BlockingQ1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//		bq1.take();//没有数据会阻塞</span></span><br><span class="line">		bq1.offer(<span class="keyword">new</span> Object());</span><br><span class="line">		System.out.println(bq1.take());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java-中的阻塞队列"><a href="#Java-中的阻塞队列" class="headerlink" title="Java 中的阻塞队列"></a>Java 中的阻塞队列</h2><ol>
<li>   ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。 </li>
<li>   LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。 </li>
<li>   PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。 </li>
<li>   DelayQueue：使用优先级队列实现的无界阻塞队列。 </li>
<li>   SynchronousQueue：不存储元素的阻塞队列。 </li>
<li>   LinkedTransferQueue：由链表结构组成的无界阻塞队列。 </li>
<li>   LinkedBlockingDeque：由链表结构组成的双向阻塞队列 </li>
</ol>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/1589105003217.png" class>

</div>

<h3 id="ArrayBlockingQueue（公平、非公平）"><a href="#ArrayBlockingQueue（公平、非公平）" class="headerlink" title="ArrayBlockingQueue（公平、非公平）"></a>ArrayBlockingQueue（公平、非公平）</h3><p>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span>  ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="LinkedBlockingQueue（两个独立锁提高并发）"><a href="#LinkedBlockingQueue（两个独立锁提高并发）" class="headerlink" title="LinkedBlockingQueue（两个独立锁提高并发）"></a>LinkedBlockingQueue（两个独立锁提高并发）</h3><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。 </p>
<p>LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。 </p>
<h3 id="PriorityBlockingQueue（compareTo-排序实现优先）"><a href="#PriorityBlockingQueue（compareTo-排序实现优先）" class="headerlink" title="PriorityBlockingQueue（compareTo 排序实现优先）"></a>PriorityBlockingQueue（compareTo 排序实现优先）</h3><p>是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现 compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 </p>
<h3 id="DelayQueue（缓存失效、定时任务-）"><a href="#DelayQueue（缓存失效、定时任务-）" class="headerlink" title="DelayQueue（缓存失效、定时任务 ）"></a>DelayQueue（缓存失效、定时任务 ）</h3><p>是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景： </p>
<ol>
<li>   缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询<br>DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。 </li>
<li>   定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从<br>DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。 </li>
</ol>
<h3 id="SynchronousQueue（不存储数据、可用于传递数据）"><a href="#SynchronousQueue（不存储数据、可用于传递数据）" class="headerlink" title="SynchronousQueue（不存储数据、可用于传递数据）"></a>SynchronousQueue（不存储数据、可用于传递数据）</h3><p>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。<br>SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另 外 一 个 线 程 使 用 ， SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和<br>ArrayBlockingQueue。 </p>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，<br>LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。 </p>
<ol>
<li>   transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的 poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。 </li>
<li>   tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。<br>对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。 </li>
</ol>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。<br>双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast， peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。<br>在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。 </p>
<h2 id="Java线程阻塞的代价"><a href="#Java线程阻塞的代价" class="headerlink" title="Java线程阻塞的代价"></a>Java线程阻塞的代价</h2><p>java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。<br>    如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间；<br>    如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。<br>synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>阻塞队列</tag>
        <tag>ArrayBlockingQueue</tag>
        <tag>LinkedBlockingQueue</tag>
        <tag>PriorityBlockingQueue</tag>
        <tag>DelayQueue</tag>
        <tag>SynchronousQueue</tag>
        <tag>LinkedTransferQueue</tag>
        <tag>LinkedBlockingDeque</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之反射</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1587523711269.png" class title="反射知识点">

</div>

<a id="more"></a>

<h3 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h3><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。在Java中如果想获取到运行中对象的结构则需要引入反射的概念。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>在java中包括两种时期：编译期和运行期，对应的类型就是编译时类型和运行时类型。编译时类型由声明时的对象决定，运行时类型则由实际的对象类型决定（<strong>主要表现为行为，对于成员变量则编译时确认</strong>）。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中编译时类型为 Person，运行时类型为 Man。  </span></span><br><span class="line">Person p=<span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>
<p>由于编译时类型无法获取具体方法且程序运行过程中可能会接收外部传入的对象该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>反射API用来生成JVM中的类、接口或则对象的信息。  </p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>反射的核心类，可以获取类的属性，方法等信息。class的生成已经加载过程会在JVM章节中进行详细说明。</p>
<h5 id="RTTI（Run-Time-Type-Identification）运行时类型识别"><a href="#RTTI（Run-Time-Type-Identification）运行时类型识别" class="headerlink" title="RTTI（Run-Time Type Identification）运行时类型识别"></a>RTTI（Run-Time Type Identification）运行时类型识别</h5><p><font color="red">RTTI（Run-Time Type Identification）运行时类型识别</font>，其作用是在运行时识别一个对象的类型和类的信息，这里分两种：传统的”RRTI”,它假定我们在编译期已知道了所有类型(在没有反射机制创建和使用类对象时，一般都是编译期已确定其类型，如new对象时该类必须已定义好)，另外一种是反射机制，它允许我们在运行时发现和使用类型的信息。在Java中用来表示运行时类型信息的对应类就是Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中.</p>
<h5 id="Class的特点"><a href="#Class的特点" class="headerlink" title="Class的特点"></a>Class的特点</h5><ul>
<li>在java中万事万物都是对象的概念，使用Class类表示类的对象信息</li>
<li>通过关键字class标识的类，在内存中都会有一个与之对应的Class对象，用来描述具体的类型信息</li>
<li>Class类的构造函数是私有的，因此对应Class对象只能有JVM创建和加载</li>
<li>Class类的对象作用是运行时提供或获得某个对象的类型信息（反射的来源）</li>
<li>类加载器在类被第一次静态调用(比如一个静态方法，一个静态代码块或者new关键字调用构造器，注意contructors其实都是静态的)时会把那个对应的Class对象加载到内存中。</li>
</ul>
<h5 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h5><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1587536833908.png" class title="类与对象的关系">

</div>

<h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><p>Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</p>
<h5 id="class中获取field"><a href="#class中获取field" class="headerlink" title="class中获取field"></a>class中获取field</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field</td>
<td>getDeclaredField(String name)</td>
<td>获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td>
</tr>
<tr>
<td>Field[]</td>
<td>getDeclaredField()</td>
<td>获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td>
</tr>
<tr>
<td>Field</td>
<td>getField(String name)</td>
<td>获取指定name名称、具有public修饰的字段，包含继承字段</td>
</tr>
<tr>
<td>Field[]</td>
<td>getField()</td>
<td>获取修饰符为public的字段，包含继承字段</td>
</tr>
</tbody></table>
<h5 id="field中常用方法"><a href="#field中常用方法" class="headerlink" title="field中常用方法"></a>field中常用方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>set(Object obj, Object value)</td>
<td>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td>
</tr>
<tr>
<td>Object</td>
<td>get(Object obj)</td>
<td>返回指定对象上此 Field 表示的字段的值</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getType()</td>
<td>返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。</td>
</tr>
<tr>
<td>boolean</td>
<td>isEnumConstant()</td>
<td>如果此字段表示枚举类型的元素则返回 true；否则返回 false</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回一个描述此 Field（包括其一般类型）的字符串</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>返回此 Field 对象表示的字段的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getDeclaringClass()</td>
<td>返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td>
</tr>
<tr>
<td>void</td>
<td>setAccessible(boolean flag)</td>
<td>将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</td>
</tr>
</tbody></table>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</p>
<h5 id="class中的method方法"><a href="#class中的method方法" class="headerlink" title="class中的method方法"></a>class中的method方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Method</td>
<td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td>
</tr>
<tr>
<td>Method[]</td>
<td>getDeclaredMethod()</td>
<td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td>
</tr>
<tr>
<td>Method</td>
<td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td>
</tr>
<tr>
<td>Method[]</td>
<td>getMethods()</td>
<td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td>
</tr>
</tbody></table>
<h5 id="method常用的方法"><a href="#method常用的方法" class="headerlink" title="method常用的方法"></a>method常用的方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object</td>
<td>invoke(Object obj, Object… args)</td>
<td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getReturnType()</td>
<td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td>
</tr>
<tr>
<td>Type</td>
<td>getGenericReturnType()</td>
<td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td>
</tr>
<tr>
<td>Class&lt;?&gt;[]</td>
<td>getParameterTypes()</td>
<td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td>
</tr>
<tr>
<td>Type[]</td>
<td>getGenericParameterTypes()</td>
<td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td>
</tr>
<tr>
<td>boolean</td>
<td>isVarArgs()</td>
<td>判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回描述此 Method 的字符串，包括类型参数。</td>
</tr>
</tbody></table>
<h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><p>Java.lang.reflec 包中的类，表示类的构造方法。</p>
<h5 id="class中获取Constructor"><a href="#class中获取Constructor" class="headerlink" title="class中获取Constructor"></a>class中获取Constructor</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Class&lt;?&gt;</td>
<td>forName(String className)</td>
<td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td>
</tr>
<tr>
<td>Constructor<T></T></td>
<td>getConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>返回指定参数类型、具有public访问权限的构造函数对象</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[]</td>
<td>getConstructors()</td>
<td>返回所有具有public访问权限的构造函数的Constructor对象数组</td>
</tr>
<tr>
<td>Constructor<T></T></td>
<td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>返回指定参数类型、所有声明的（包括private）构造函数对象</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[]</td>
<td>getDeclaredConstructor()</td>
<td>返回所有声明的（包括private）构造函数对象</td>
</tr>
<tr>
<td>T</td>
<td>newInstance()</td>
<td>创建此 Class 对象所表示的类的一个新实例。</td>
</tr>
</tbody></table>
<h5 id="Constructor中的常用方法"><a href="#Constructor中的常用方法" class="headerlink" title="Constructor中的常用方法"></a>Constructor中的常用方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Class<T></T></td>
<td>getDeclaringClass()</td>
<td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td>
</tr>
<tr>
<td>Type[]</td>
<td>getGenericParameterTypes()</td>
<td>按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>以字符串形式返回此构造方法的名称。</td>
</tr>
<tr>
<td>Class&lt;?&gt;[]</td>
<td>getParameterTypes()</td>
<td>按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td>
</tr>
<tr>
<td>T</td>
<td>newInstance(Object… initargs)</td>
<td>使用此 Constructor对象表示的构造函数来创建新实例</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回描述此 Constructor 的字符串，其中包括类型参数。</td>
</tr>
</tbody></table>
<h4 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h4><p>参考《<a href="https://www.sunliaodong.cn/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/">JAVA注解</a>》</p>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><h5 id="class中的array"><a href="#class中的array" class="headerlink" title="class中的array"></a>class中的array</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Class&lt;?&gt;</td>
<td>getComponentType()</td>
<td>返回表示数组元素类型的 Class，即数组的类型</td>
</tr>
<tr>
<td>boolean</td>
<td>isArray()</td>
<td>判定此 Class 对象是否表示一个数组类。</td>
</tr>
</tbody></table>
<h5 id="array中常用的方法"><a href="#array中常用的方法" class="headerlink" title="array中常用的方法"></a>array中常用的方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Object</td>
<td>set(Object array, int index)</td>
<td>返回指定数组对象中索引组件的值。</td>
</tr>
<tr>
<td>static int</td>
<td>getLength(Object array)</td>
<td>以 int 形式返回指定数组对象的长度</td>
</tr>
<tr>
<td>static object</td>
<td>newInstance(Class&lt;?&gt; componentType, int… dimensions)</td>
<td>创建一个具有指定类型和维度的新数组。</td>
</tr>
<tr>
<td>static Object</td>
<td>newInstance(Class&lt;?&gt; componentType, int length)</td>
<td>创建一个具有指定的组件类型和长度的新数组。</td>
</tr>
<tr>
<td>static void</td>
<td>set(Object array, int index, Object value)</td>
<td>将指定数组对象中索引组件的值设置为指定的新值。</td>
</tr>
</tbody></table>
<h3 id="使用步骤：获取Class对象、调用对象方法"><a href="#使用步骤：获取Class对象、调用对象方法" class="headerlink" title="使用步骤：获取Class对象、调用对象方法"></a>使用步骤：获取Class对象、调用对象方法</h3><ol>
<li><p>获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。可以通过以下方式获取：</p>
<ul>
<li>调用对象的getClass()：(new Man()).getClass()</li>
<li>调用类的class属性：Man.class</li>
<li>使用Class.forName调用类的全路径（<strong>最安全，性能最好</strong>）：Class.forName(“com.sunld.Man”)</li>
</ul>
</li>
<li><p>调用 Class 类中的方法，既就是反射的使用阶段。</p>
</li>
<li><p>使用反射 API 来操作这些信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 获取 Man 类的 Class 对象</span></span><br><span class="line">         Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.sunld.Man&quot;</span>);</span><br><span class="line">         <span class="comment">// 获取 Man 类的所有方法信息</span></span><br><span class="line">         Method[] method = clazz.getDeclaredMethods();</span><br><span class="line">         <span class="keyword">for</span> (Method m : method) &#123;</span><br><span class="line">             System.out.println(m.toString());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 获取 Man 类的所有成员属性信息</span></span><br><span class="line">         Field[] field = clazz.getDeclaredFields();</span><br><span class="line">         <span class="keyword">for</span> (Field f : field) &#123;</span><br><span class="line">             System.out.println(f.toString());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 获取 Man 类的所有构造方法信息</span></span><br><span class="line">         Constructor[] constructor = clazz.getDeclaredConstructors();</span><br><span class="line">         <span class="keyword">for</span> (Constructor c : constructor) &#123;</span><br><span class="line">             System.out.println(c.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h3></li>
</ol>
<h4 id="Class对象的newInstance"><a href="#Class对象的newInstance" class="headerlink" title="Class对象的newInstance()"></a>Class对象的newInstance()</h4><p>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取 Man 类的 Class 对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.sunld.Man&quot;</span>);</span><br><span class="line"><span class="comment">//使用.newInstane 方法创建对象</span></span><br><span class="line">Man p=(Man) clazz.newInstance();</span><br></pre></td></tr></table></figure>
<h4 id="调用Constructor对象的newInstance"><a href="#调用Constructor对象的newInstance" class="headerlink" title="调用Constructor对象的newInstance()"></a>调用Constructor对象的newInstance()</h4><p>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz=Class.forName(<span class="string">&quot;com.sunld.Man&quot;</span>);  </span><br><span class="line"><span class="comment">//获取构造方法并创建对象</span></span><br><span class="line">Constructor c=clazz.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//创建对象并设置属性</span></span><br><span class="line">Man m=(Man) c.newInstance(<span class="string">&quot;男人&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h5 id="Java的安全模型"><a href="#Java的安全模型" class="headerlink" title="Java的安全模型"></a>Java的安全模型</h5><p>java运行在jvm中，不与外部直接联系，java的安全模型包括：字节码验证器、类加载器、安全管理器、访问控制器等一系列的组件。java通过反射可以处理private方法和属性，说明它绕过了访问控制器。它其实是Java本身为了某种目的而留下的类似于“后门”的东西，它的原理其实是关闭访问安全检查。</p>
<h5 id="Java中访问控制的实现"><a href="#Java中访问控制的实现" class="headerlink" title="Java中访问控制的实现"></a>Java中访问控制的实现</h5><p>Field、Method和Constructor类，它们都有一个共同的父类AccessibleObject 。AccessibleObject 有一个公共方法：void setAccessible(boolean flag)。正是这个方法，让我们可以改变动态的打开或者关闭访问安全检查，从而访问到原本是private的方法或域。另外，访问安全检查是一件比较耗时的操作，关闭它反射的性能也会有较大提升。</p>
<h5 id="Java中的作用域（访问控制）"><a href="#Java中的作用域（访问控制）" class="headerlink" title="Java中的作用域（访问控制）"></a>Java中的作用域（访问控制）</h5><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-mnhx{background-color:#fe0000;text-align:left;vertical-align:top}
.tg .tg-2pvn{background-color:#fcff2f;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-s7ni{background-color:#f8ff00;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax"></th>
    <th class="tg-0lax">public</th>
    <th class="tg-0lax">protected</th>
    <th class="tg-0lax">friendly</th>
    <th class="tg-0lax">private</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">在类中</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-0lax">可见</td>
  </tr>
  <tr>
    <td class="tg-0lax">同源文件下的不同类</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-s7ni">不可见</td>
  </tr>
  <tr>
    <td class="tg-0lax">同包的不同类</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-2pvn">不可见</td>
  </tr>
  <tr>
    <td class="tg-0lax">同包的子类</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-mnhx">不能继承</td>
  </tr>
  <tr>
    <td class="tg-0lax">不同包的不同类</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-2pvn">不可见</td>
    <td class="tg-2pvn">不可见</td>
    <td class="tg-2pvn">不可见</td>
  </tr>
  <tr>
    <td class="tg-0lax">不同包的子类</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-0lax">可见</td>
    <td class="tg-2pvn">不可见</td>
    <td class="tg-mnhx">不能继承</td>
  </tr>
</tbody>
</table>

<h3 id="ClassUtils"><a href="#ClassUtils" class="headerlink" title="ClassUtils"></a>ClassUtils</h3><p>在spring的源码中提供了Class反射使用到的常用封装，可以参考修改或者直接使用。</p>
<h3 id="自定义ClassUtils"><a href="#自定义ClassUtils" class="headerlink" title="自定义ClassUtils"></a>自定义ClassUtils</h3><p><a href="https://github.com/sld880311/Architect-Growth-Manual/tree/master/docs/book/source/ClassUtils.java">ClassUtils代码地址</a></p>
<h3 id="内省Introspector"><a href="#内省Introspector" class="headerlink" title="内省Introspector"></a>内省Introspector</h3><p>一种用于处理javabean的API，提高Java反射的效率</p>
<h4 id="内省Introspector类结构"><a href="#内省Introspector类结构" class="headerlink" title="内省Introspector类结构"></a>内省Introspector类结构</h4><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1589936907736.png" class title="内省Introspector类结构">

</div>

<ol>
<li>Introspector：获取JavaBean的BeanInfo</li>
<li>BeanInfo：通过getPropertyDescriptors 方法和 getMethodDescriptors 方法可以拿到 javaBean 的字段信息列表和 getter 和 setter 方法信息列表</li>
<li>PropertyDescriptors 可以根据字段直接获得该字段的 getter 和 setter 方法。</li>
<li>PropertyDescriptor类表示JavaBean类通过存储器导出一个属性。主要方法：<ul>
<li>getPropertyType()，获得属性的Class对象</li>
<li>getReadMethod()，获得用于读取属性值的方法；getWriteMethod()，获得用于写入属性值的方法;</li>
<li>hashCode()，获取对象的哈希值;</li>
<li>setReadMethod(Method readMethod)，设置用于读取属性值的方法;</li>
<li>setWriteMethod(Method writeMethod)，设置用于写入属性值的方法。</li>
</ul>
</li>
<li>MethodDescriptors 可以获得方法的元信息，比如方法名，参数个数，参数字段类型等。</li>
</ol>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIntrospector</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">findUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">findUser2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser2:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">findUser3</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser3:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">findUser4</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser4:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IntrospectionException </span>&#123;</span><br><span class="line">        TestIntrospector t = <span class="keyword">new</span> TestIntrospector();</span><br><span class="line">        User u = t.n<span class="function">ew <span class="title">User</span><span class="params">()</span></span>;</span><br><span class="line">        u.setAge(<span class="number">20</span>);</span><br><span class="line">        u.setUserName(<span class="string">&quot;dfafda&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取整个Bean的信息</span></span><br><span class="line">        <span class="comment">// 在Object类时候停止检索，可以选择在任意一个父类停止</span></span><br><span class="line">        BeanInfo beanInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取某个对象的BeanInfo信息，并且可以指定上限</span></span><br><span class="line">            beanInfo = Introspector.getBeanInfo(User.class, Object.class);</span><br><span class="line">            System.out.println(beanInfo);</span><br><span class="line">            System.out.println(<span class="string">&quot;所有属性描述：&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取所有的属性描述</span></span><br><span class="line">            PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor propertyDescriptor : pds) &#123;</span><br><span class="line">                System.out.println(propertyDescriptor.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有方法描述：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (MethodDescriptor methodDescriptor : beanInfo.getMethodDescriptors()) &#123;</span><br><span class="line">                System.out.println(methodDescriptor.getName());</span><br><span class="line">                <span class="keyword">if</span>(methodDescriptor.getName().startsWith(<span class="string">&quot;get&quot;</span>))&#123;</span><br><span class="line">                    Method method = methodDescriptor.getMethod();</span><br><span class="line">                    System.out.println(method.invoke(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 自定义</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String propertyName = <span class="string">&quot;userName&quot;</span>;</span><br><span class="line">            PropertyDescriptor namePd = <span class="keyword">new</span> PropertyDescriptor(propertyName, User.class);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;名字：&quot;</span> + namePd.getReadMethod().invoke(u));</span><br><span class="line">            namePd.getWriteMethod().invoke(u, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;名字：&quot;</span> + namePd.getReadMethod().invoke(u));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="org-springframework-beans-BeanUtils"><a href="#org-springframework-beans-BeanUtils" class="headerlink" title="org.springframework.beans.BeanUtils"></a>org.springframework.beans.BeanUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy the property values of the given source bean into the given target bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: The source and target classes do not have to match or even be derived</span></span><br><span class="line"><span class="comment"> * from each other, as long as the properties match. Any bean properties that the</span></span><br><span class="line"><span class="comment"> * source bean exposes but the target bean does not will silently be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the source bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target the target bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> editable the class (or interface) to restrict property setting to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ignoreProperties array of property names to ignore</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the copying failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanWrapper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target, <span class="meta">@Nullable</span> Class&lt;?&gt; editable,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> String... ignoreProperties)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(source, <span class="string">&quot;Source must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(target, <span class="string">&quot;Target must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取目标对象的class</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt; actualEditable = target.getClass();</span><br><span class="line">	<span class="keyword">if</span> (editable != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!editable.isInstance(target)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Target class [&quot;</span> + target.getClass().getName() +</span><br><span class="line">					<span class="string">&quot;] not assignable to Editable class [&quot;</span> + editable.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		actualEditable = editable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取目标对象的属性信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理忽略属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;String&gt; ignoreList = (ignoreProperties != <span class="keyword">null</span> ? Arrays.asList(ignoreProperties) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (PropertyDescriptor targetPd : targetPds) &#123;</span><br><span class="line">		Method writeMethod = targetPd.getWriteMethod();</span><br><span class="line">		<span class="keyword">if</span> (writeMethod != <span class="keyword">null</span> &amp;&amp; (ignoreList == <span class="keyword">null</span> || !ignoreList.contains(targetPd.getName()))) &#123;</span><br><span class="line">			PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</span><br><span class="line">			<span class="keyword">if</span> (sourcePd != <span class="keyword">null</span>) &#123;</span><br><span class="line">				Method readMethod = sourcePd.getReadMethod();</span><br><span class="line">				<span class="keyword">if</span> (readMethod != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						ClassUtils.isAssignable(writeMethod.getParameterTypes()[<span class="number">0</span>], readMethod.getReturnType())) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">							readMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						Object value = readMethod.invoke(source);</span><br><span class="line">						<span class="keyword">if</span> (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">							writeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						writeMethod.invoke(target, value);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(</span><br><span class="line">								<span class="string">&quot;Could not copy property &#x27;&quot;</span> + targetPd.getName() + <span class="string">&quot;&#x27; from source to target&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="instanceof和isInstance区别"><a href="#instanceof和isInstance区别" class="headerlink" title="instanceof和isInstance区别"></a>instanceof和isInstance区别</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0pky">用法</th>
    <th class="tg-0pky">功能</th>
    <th class="tg-0pky">对象本身</th>
    <th class="tg-0pky">父类/接口</th>
    <th class="tg-0pky">Object</th>
    <th class="tg-0lax">null</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">obj instanceof class</td>
    <td class="tg-0pky">判断对象是否是某个类型</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0lax">false</td>
  </tr>
  <tr>
    <td class="tg-0pky">class.isInstance(obj)</td>
    <td class="tg-0pky">判断对象是否可以转换为这个类</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0lax">false</td>
  </tr>
</tbody>
</table>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstanceClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestInstanceClass t = <span class="keyword">new</span> TestInstanceClass();</span><br><span class="line"></span><br><span class="line">        B b = t.n<span class="function">ew <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        A a = t.n<span class="function">ew <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">        A ba = t.n<span class="function">ew <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1------------&quot;</span>);</span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> B);<span class="comment">// true</span></span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> A);<span class="comment">// true</span></span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> Object);<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2------------&quot;</span>);</span><br><span class="line">        System.out.println(b.getClass().isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.getClass().isInstance(a));<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3------------&quot;</span>);</span><br><span class="line">        System.out.println(a.getClass().isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.getClass().isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.getClass().isInstance(<span class="keyword">null</span>));<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4------------&quot;</span>);</span><br><span class="line">        System.out.println(A.class.isInstance(a));<span class="comment">// true</span></span><br><span class="line">        System.out.println(A.class.isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(A.class.isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;5------------&quot;</span>);</span><br><span class="line">        System.out.println(B.class.isInstance(a));<span class="comment">// false</span></span><br><span class="line">        System.out.println(B.class.isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(B.class.isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;6------------&quot;</span>);</span><br><span class="line">        System.out.println(Object.class.isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(Object.class.isInstance(<span class="keyword">null</span>));<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/javazejian/article/details/70768369">深入理解Java类型信息(Class对象)与反射机制</a></li>
<li>《Java并发编程的艺术》</li>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://www.cnblogs.com/greatfish/p/6096038.html">Java中instanceof和isInstance区别详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之异常</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中任务或方法的运行，要不就是正常执行完成(包括虚拟机退出，比如<code>System.exit()</code>)，要不就是出现异常终止(<code>Throwable</code>)。本章节重点讲解在Java中对异常的处理。当程序出现异常之后，Java会抛出一个封装好的异常堆栈信息，并且终止当前的方法，异常处理机制会将代码执行交给异常处理器。整体结构如下图所示：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587714125412.png" class title="Java异常架构图">

</div>

<a id="more"></a>

<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* The &#123;<span class="meta">@code</span> Throwable&#125; <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">the</span> <span class="title">superclass</span> <span class="title">of</span> <span class="title">all</span> <span class="title">errors</span> <span class="title">and</span></span></span><br><span class="line"><span class="class">* <span class="title">exceptions</span> <span class="title">in</span> <span class="title">the</span> <span class="title">Java</span> <span class="title">language</span>. <span class="title">Only</span> <span class="title">objects</span> <span class="title">that</span> <span class="title">are</span> <span class="title">instances</span> <span class="title">of</span> <span class="title">this</span></span></span><br><span class="line"><span class="class">* <span class="title">class</span> (<span class="title">or</span> <span class="title">one</span> <span class="title">of</span> <span class="title">its</span> <span class="title">subclasses</span>) <span class="title">are</span> <span class="title">thrown</span> <span class="title">by</span> <span class="title">the</span> <span class="title">Java</span> <span class="title">Virtual</span> <span class="title">Machine</span> <span class="title">or</span></span></span><br><span class="line"><span class="class">* <span class="title">can</span> <span class="title">be</span> <span class="title">thrown</span> <span class="title">by</span> <span class="title">the</span> <span class="title">Java</span> </span>&#123;<span class="meta">@code</span> <span class="keyword">throw</span>&#125; statement. Similarly, only</span><br><span class="line">* <span class="keyword">this</span> <span class="class"><span class="keyword">class</span> <span class="title">or</span> <span class="title">one</span> <span class="title">of</span> <span class="title">its</span> <span class="title">subclasses</span> <span class="title">can</span> <span class="title">be</span> <span class="title">the</span> <span class="title">argument</span> <span class="title">type</span> <span class="title">in</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">* </span>&#123;<span class="meta">@code</span> <span class="keyword">catch</span>&#125; clause.</span><br></pre></td></tr></table></figure>
<p>在Java中<code>Throwable</code>是所有异常类的父类，只有该类的子类才能被用于Java异常处理。该类的唯一两个子类是<code>Error</code>和<code>Exception</code>。</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* An &#123;<span class="meta">@code</span> Error&#125; is a subclass of &#123;<span class="meta">@code</span> Throwable&#125;</span><br><span class="line">* that indicates serious problems that a reasonable application</span><br><span class="line">* should not <span class="keyword">try</span> to <span class="keyword">catch</span>. Most such errors are abnormal conditions.</span><br><span class="line">* The &#123;<span class="meta">@code</span> ThreadDeath&#125; error, though a <span class="string">&quot;normal&quot;</span> condition,</span><br><span class="line">* is also a subclass of &#123;<span class="meta">@code</span> Error&#125; because most applications</span><br><span class="line">* should not <span class="keyword">try</span> to <span class="keyword">catch</span> it.</span><br><span class="line">* &lt;p&gt;</span><br><span class="line">* A method is not required to declare in its &#123;<span class="meta">@code</span> <span class="keyword">throws</span>&#125;</span><br><span class="line">* clause any subclasses of &#123;<span class="meta">@code</span> Error&#125; that might be thrown</span><br><span class="line">* during the execution of the method but not caught, since these</span><br><span class="line">* errors are abnormal conditions that should never occur.</span><br><span class="line">*</span><br><span class="line">* That is, &#123;<span class="meta">@code</span> Error&#125; and its subclasses are regarded as unchecked</span><br><span class="line">* exceptions <span class="keyword">for</span> the purposes of compile-time checking of exceptions.</span><br></pre></td></tr></table></figure>
<p>Error在正常情况下不应该出现的异常（一般是JVM本身产生的异常，比如JVM运行错误、<code>NoClassDefFoundError</code>或<code>OutOfMemoryError</code>），而且不建议应用程序对其进行捕获。Error被定义为非检查异常。Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。  包括以下类：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587719292555.png" class title="Java Error直接之类">

</div>

<h3 id="Exception（RuntimeException、CheckedException）"><a href="#Exception（RuntimeException、CheckedException）" class="headerlink" title="Exception（RuntimeException、CheckedException）"></a>Exception（RuntimeException、CheckedException）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* &lt;p&gt;The <span class="class"><span class="keyword">class</span> </span>&#123;<span class="meta">@code</span> Exception&#125; and any subclasses that are not also</span><br><span class="line">* subclasses of &#123;<span class="meta">@link</span> RuntimeException&#125; are &lt;em&gt;checked</span><br><span class="line">* exceptions&lt;/em&gt;.  Checked exceptions need to be declared in a</span><br><span class="line">* method or constructor<span class="string">&#x27;s &#123;@code throws&#125; clause if they can be thrown</span></span><br><span class="line"><span class="string">* by the execution of the method or constructor and propagate outside</span></span><br><span class="line"><span class="string">* the method or constructor boundary.</span></span><br></pre></td></tr></table></figure>
<p><code>Exception</code>用于处理应用程序方面的异常定义和处理。分为<code>RuntimeException</code>和<code>CheckedException</code>(非<code>RuntimeException</code>)。检查类异常需要在方法或者构造器中明确的进行处理（throws）。</p>
<h4 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* &#123;<span class="meta">@code</span> RuntimeException&#125; is the superclass of those</span><br><span class="line">* exceptions that can be thrown during the normal operation of the</span><br><span class="line">* Java Virtual Machine.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt;&#123;<span class="meta">@code</span> RuntimeException&#125; and its subclasses are &lt;em&gt;unchecked</span><br><span class="line">* exceptions&lt;/em&gt;.  Unchecked exceptions do &lt;em&gt;not&lt;/em&gt; need to be</span><br><span class="line">* declared in a method or constructor<span class="string">&#x27;s &#123;@code throws&#125; clause if they</span></span><br><span class="line"><span class="string">* can be thrown by the execution of the method or constructor and</span></span><br><span class="line"><span class="string">* propagate outside the method or constructor boundary.</span></span><br></pre></td></tr></table></figure>
<p><code>RuntimeException</code>是在JVM的正常操作期间可以抛出异常的超类。该类都是未检查异常类，未检查异常不需要在方法或构造函数中进行throws，如果他们可以通过该方法或构造函数的执行被抛出和方法或构造边界之外传播。所以通常用不着捕获RuntimeException，但在自己的封装里，也许仍然要选择抛出一部分RuntimeException。常见的类包括：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587718395409.png" class title="RuntimeException直接之类">

</div>

<h4 id="CheckedException"><a href="#CheckedException" class="headerlink" title="CheckedException"></a>CheckedException</h4><p>Exception下除<code>RuntimeException</code>和<code>Error</code>之外的异常类都是<code>CheckedException</code>。它们都在java.lang库内部定义。Java编译器要求程序必须捕获或声明抛出这种异常。常用的类包括： I/O 错误导致的 IOException、SQLException。这类异常的表现形式一般为：</p>
<ol>
<li>试图在文件尾部读取数据  </li>
<li>试图打开一个错误格式的 URL  </li>
<li>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</li>
</ol>
<h4 id="CheckedException与RuntimeException的区别"><a href="#CheckedException与RuntimeException的区别" class="headerlink" title="CheckedException与RuntimeException的区别"></a>CheckedException与RuntimeException的区别</h4><ol>
<li>CheckedException需要显示的处理，throws；RuntimeException不需要。</li>
<li>RuntimeException运行期间的错误，一般都是代码bug；CheckedException编译期间的错误，一般是外部错误。Java 编译器会强制程序去捕获此类异常（ try catch）。</li>
</ol>
<h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><h3 id="抛出"><a href="#抛出" class="headerlink" title="抛出"></a>抛出</h3><p>当程序中出现异常时，如果不进行具体处理，可以使用<code>throw</code>、<code>throws</code> 、系统自动抛出三种方式进行异常抛出处理。</p>
<h4 id="throw与throws的区别"><a href="#throw与throws的区别" class="headerlink" title="throw与throws的区别"></a>throw与throws的区别</h4><ol>
<li>位置不同：throws在函数或构造器定义中，throw是函数或构造器内</li>
<li>功能不同：throws用于异常声明，让调用者知道可能出现的异常；throw抛出异常，业务处理终止，抛出到上层业务</li>
<li>含义不同：throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。  throw需要配合throws使用。</li>
<li>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li>
</ol>
<h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>如果程序中需要进行异常的特殊处理或者进行异常转换，则需要使用try、catch进行处理。</p>
<h3 id="处理的伪代码"><a href="#处理的伪代码" class="headerlink" title="处理的伪代码"></a>处理的伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionType e)&#123;</span><br><span class="line"> <span class="comment">//此违例类型的控制代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"> <span class="comment">//清除回收等工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先执行try中包含的代码块，如果遇到执行错误，程序掷出（throw）一特定类型的违例，你捕捉到此违例并转而执行catch中的违例控制代码。最后，无论程序是否产生违例都必须执行finally中的代码，其主要为一些变量清除、资源回收（1）等工作。</p>
<h2 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h2><ol>
<li>重写一个方法时，只能产生已在方法的基础类版本中定义的异常。</li>
<li>重写的方法可以抛出父类方法所抛出的异常或它的子类型</li>
<li>重写的方法可以不用抛出父类方法所抛出的异常</li>
<li>重写的方法不可以抛出异常如果父类方法没有抛出异常</li>
<li>对异常的限制并不适用于构建器。</li>
</ol>
<h2 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h2><p>掷”出一个异常后，异常控制系统会按当初编写的顺序搜索“最接近”的控制器。一旦找到相符的控制器，就认为异常已得到控制，不再进行更多的搜索工作。在异常和它的控制器之间，并不需要非常精确的匹配。一个衍生类对象可与基础类的一个异常控制器相配，<strong>即我们在写代码时，将子类写在前面</strong>。</p>
<h2 id="JVM中处理异常的原理"><a href="#JVM中处理异常的原理" class="headerlink" title="JVM中处理异常的原理"></a>JVM中处理异常的原理</h2><h3 id="异常的执行顺序"><a href="#异常的执行顺序" class="headerlink" title="异常的执行顺序"></a>异常的执行顺序</h3><p>1、new一个异常对象<br>2、终止当前的执行程序。<br>3、弹出异常对象的引用。<br>4、异常处理机制接管被终止的执行程序。<br>5、寻找一个恰当的地点（异常处理程序）继续执行程序。  </p>
<h3 id="异常处理的理论模型"><a href="#异常处理的理论模型" class="headerlink" title="异常处理的理论模型"></a>异常处理的理论模型</h3><ol>
<li><strong>终止模型</strong>：这种模型将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行，一旦异常抛出错误就意味着世界末日，意味着死亡，意味着GG</li>
<li><strong>恢复模型</strong>：异常处理程序发现了错误，并且修复了错误然后重新调用出问题的方法，并且认为第二次调用该方法会成功。通常可以将try块放入while循环中，不断执行方法，直到得到满意的结果。</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="异常信息构建：Throwable"><a href="#异常信息构建：Throwable" class="headerlink" title="异常信息构建：Throwable"></a>异常信息构建：Throwable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a new throwable with &#123;<span class="doctag">@code</span> null&#125; as its detail message.</span></span><br><span class="line"><span class="comment">* The cause is not initialized, and may subsequently be initialized by a</span></span><br><span class="line"><span class="comment">* call to &#123;<span class="doctag">@link</span> #initCause&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;The &#123;<span class="doctag">@link</span> #fillInStackTrace()&#125; method is called to initialize</span></span><br><span class="line"><span class="comment">* the stack trace data in the newly created throwable.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Throwable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 填充执行过程中的堆栈信息，</span></span><br><span class="line"><span class="comment">    * 此方法在Throwable对象中记录当前线程的栈帧的状态信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fillInStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="核心代码：fillInStackTrace"><a href="#核心代码：fillInStackTrace" class="headerlink" title="核心代码：fillInStackTrace"></a>核心代码：fillInStackTrace</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A shared value for an empty stack.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StackTraceElement[] UNASSIGNED_STACK = <span class="keyword">new</span> StackTraceElement[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The stack trace, as returned by &#123;<span class="doctag">@link</span> #getStackTrace()&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The field is initialized to a zero-length array.  A &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">* null&#125; value of this field indicates subsequent calls to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #setStackTrace(StackTraceElement[])&#125; and &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #fillInStackTrace()&#125; will be be no-ops.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> StackTraceElement[] stackTrace = UNASSIGNED_STACK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Fills in the execution stack trace. This method records within this</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> Throwable&#125; object information about the current state of</span></span><br><span class="line"><span class="comment">* the stack frames for the current thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the stack trace of this &#123;<span class="doctag">@code</span> Throwable&#125; &#123;<span class="doctag">@linkplain</span></span></span><br><span class="line"><span class="comment">* Throwable#Throwable(String, Throwable, boolean, boolean) is not</span></span><br><span class="line"><span class="comment">* writable&#125;, calling this method has no effect.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  a reference to this &#123;<span class="doctag">@code</span> Throwable&#125; instance.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>     java.lang.Throwable#printStackTrace()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackTrace != <span class="keyword">null</span> ||</span><br><span class="line">        backtrace != <span class="keyword">null</span> <span class="comment">/* Out of protocol state */</span> ) &#123;</span><br><span class="line">        fillInStackTrace(<span class="number">0</span>);</span><br><span class="line">        stackTrace = UNASSIGNED_STACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 底层本地方法获取当前线程的堆栈信息</span></span><br><span class="line"><span class="comment">* 2. 执行非常耗时。</span></span><br><span class="line"><span class="comment">* 3.如果只是关系异常的传播性质，而不关心异常的堆栈信息，可重写fillInStackTrace()方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> Throwable <span class="title">fillInStackTrace</span><span class="params">(<span class="keyword">int</span> dummy)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="StackTraceElement"><a href="#StackTraceElement" class="headerlink" title="StackTraceElement"></a>StackTraceElement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An element in a stack trace, as returned by &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Throwable#getStackTrace()&#125;.  Each element represents a single stack frame.</span></span><br><span class="line"><span class="comment"> * All stack frames except for the one at the top of the stack represent</span></span><br><span class="line"><span class="comment"> * a method invocation.  The frame at the top of the stack represents the</span></span><br><span class="line"><span class="comment"> * execution point at which the stack trace was generated.  Typically,</span></span><br><span class="line"><span class="comment"> * this is the point at which the throwable corresponding to the stack trace</span></span><br><span class="line"><span class="comment"> * was created.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Bloch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTraceElement</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Normally initialized by VM (public constructor added in 1.5)</span></span><br><span class="line">    <span class="keyword">private</span> String declaringClass;<span class="comment">// 方法的类名</span></span><br><span class="line">    <span class="keyword">private</span> String methodName; <span class="comment">//方法名</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;<span class="comment">//文件名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>    lineNumber;<span class="comment">// 调用的行数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a stack trace element representing the specified execution</span></span><br><span class="line"><span class="comment">     * point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> declaringClass the fully qualified name of the class containing</span></span><br><span class="line"><span class="comment">     *        the execution point represented by the stack trace element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName the name of the method containing the execution point</span></span><br><span class="line"><span class="comment">     *        represented by the stack trace element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName the name of the file containing the execution point</span></span><br><span class="line"><span class="comment">     *         represented by the stack trace element, or &#123;<span class="doctag">@code</span> null&#125; if</span></span><br><span class="line"><span class="comment">     *         this information is unavailable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lineNumber the line number of the source line containing the</span></span><br><span class="line"><span class="comment">     *         execution point represented by this stack trace element, or</span></span><br><span class="line"><span class="comment">     *         a negative number if this information is unavailable. A value</span></span><br><span class="line"><span class="comment">     *         of -2 indicates that the method containing the execution point</span></span><br><span class="line"><span class="comment">     *         is a native method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> declaringClass&#125; or</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> methodName&#125; is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackTraceElement</span><span class="params">(String declaringClass, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             String fileName, <span class="keyword">int</span> lineNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.declaringClass = Objects.requireNonNull(declaringClass, <span class="string">&quot;Declaring class is null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.methodName     = Objects.requireNonNull(methodName, <span class="string">&quot;Method name is null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.fileName       = fileName;</span><br><span class="line">        <span class="keyword">this</span>.lineNumber     = lineNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="违例的作用"><a href="#违例的作用" class="headerlink" title="违例的作用"></a>违例的作用</h3><p>1)监视程序中的异常情况<br>2)当异常情况发生时，将控制权交给你自己编写的违例控制代码  </p>
<h3 id="使用准则"><a href="#使用准则" class="headerlink" title="使用准则"></a>使用准则</h3><p>(1) 解决问题并再次调用造成违例的方法。<br>(2) 平息事态的发展，并在不重新尝试方法的前提下继续。<br>(3) 计算另一些结果，而不是希望方法产生的结果。<br>(4) 在当前环境中尽可能解决问题，以及将相同的违例重新“掷”出一个更高级的环境。<br>(5) 在当前环境中尽可能解决问题，以及将不同的违例重新“掷”出一个更高级的环境。<br>(6) 中止程序执行。<br>(7) 简化编码。若违例方案使事情变得更加复杂，那就会令人非常烦恼，不如不用。<br>(8) 使自己的库和程序变得更加安全。这既是一种“短期投资”（便于调试），也是一种“长期投资”（改善应用程序的健壮性）  </p>
<p><strong>异常的处理包括业务类处理（给于用户更好的友好提示）和bug类处理（链条式异常信息输出，方便运维人员或研发人员快速定位问题）。</strong></p>
<h3 id="异常相关的关键字"><a href="#异常相关的关键字" class="headerlink" title="异常相关的关键字"></a>异常相关的关键字</h3><p><code>try，catch，throw，throws，finally</code></p>
<h3 id="finally的使用总结"><a href="#finally的使用总结" class="headerlink" title="finally的使用总结"></a>finally的使用总结</h3><h4 id="finally不被执行的场景"><a href="#finally不被执行的场景" class="headerlink" title="finally不被执行的场景"></a>finally不被执行的场景</h4><ol>
<li>与try配套使用，所以只有try执行finally才会执行</li>
<li>如果try中执行System.exit(0);或jvm异常终止，则否finally不会被执行</li>
</ol>
<h4 id="finally语句在return语句执行之后return返回之前执行"><a href="#finally语句在return语句执行之后return返回之前执行" class="headerlink" title="finally语句在return语句执行之后return返回之前执行"></a>finally语句在return语句执行之后return返回之前执行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test1());<span class="comment">//4.输出100</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>; </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test11());<span class="comment">// 4.after return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">           <span class="keyword">return</span> test12();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//3</span></span><br><span class="line">       &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;return statement&quot;</span>);<span class="comment">//2</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;after return&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="finally块中的return语句会覆盖try块中的return返回"><a href="#finally块中的return语句会覆盖try块中的return返回" class="headerlink" title="finally块中的return语句会覆盖try块中的return返回"></a>finally块中的return语句会覆盖try块中的return返回</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test2());<span class="comment">//200</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这说明finally里的return直接返回了，就不管try中是否还有返回语句.</p>
<h4 id="finally语句中没有return语句覆盖返回值，返回值的变化"><a href="#finally语句中没有return语句覆盖返回值，返回值的变化" class="headerlink" title="finally语句中没有return语句覆盖返回值，返回值的变化"></a>finally语句中没有return语句覆盖返回值，返回值的变化</h4><p>用例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test3());<span class="comment">//4:100</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">            b = <span class="number">150</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest6</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(getMap().get(<span class="string">&quot;KEY&quot;</span>).toString());<span class="comment">//FINALLY</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;INIT&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;TRY&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;CATCH&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;FINALLY&quot;</span>);</span><br><span class="line">            map = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="try块里的return语句在异常的情况下不会被执行"><a href="#try块里的return语句在异常的情况下不会被执行" class="headerlink" title="try块里的return语句在异常的情况下不会被执行"></a>try块里的return语句在异常的情况下不会被执行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest5</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test4());<span class="comment">//5:204</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            b = b / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            b += <span class="number">15</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//4</span></span><br><span class="line">            &#125;</span><br><span class="line">            b += <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样"><a href="#当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样" class="headerlink" title="当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样"></a>当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest7</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test5());<span class="comment">//5:35</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            b = b /<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">15</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//4</span></span><br><span class="line">            &#125;</span><br><span class="line">            b += <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//return b;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>finally语句在return语句执行之后return返回之前执行</li>
<li>finally块中的return语句会覆盖try块中的return返回</li>
<li>如果finally语句中没有return语句,且覆盖了返回值，那么原来的返回值原始类型则不覆盖，对象类型则覆盖</li>
<li>try块里的return语句在异常的情况下不会被执行</li>
<li>当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。</li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h4 id="自定义异常的优点"><a href="#自定义异常的优点" class="headerlink" title="自定义异常的优点"></a>自定义异常的优点</h4><ol>
<li>统一了对外异常展示的方式。</li>
<li>方便框架统一处理<code>@ControllerAdvice</code></li>
<li>定义业务类异常</li>
<li>隐藏底层的异常，这样更安全，异常信息也更加的直观</li>
</ol>
<h4 id="自定义异常的注意事项"><a href="#自定义异常的注意事项" class="headerlink" title="自定义异常的注意事项"></a>自定义异常的注意事项</h4><ol>
<li>所有异常都必须是 Throwable 的子类。</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ol>
<h3 id="异常捕获的陷阱"><a href="#异常捕获的陷阱" class="headerlink" title="异常捕获的陷阱"></a>异常捕获的陷阱</h3><h4 id="正确关闭资源的方式"><a href="#正确关闭资源的方式" class="headerlink" title="正确关闭资源的方式"></a>正确关闭资源的方式</h4><p>对于物理资源（数据库连接、网络连接、磁盘文件），JVM是不会进行处理的，因为JVM属于Java内存管理的一部分，只负责回收堆内存中分配的空间。<br><strong>关闭资源：</strong></p>
<ol>
<li>必须要保证一定执行，一次要放在finally中完成</li>
<li>必须保证被关闭的资源不为空</li>
<li>保证资源之间的关闭操作互不影响</li>
</ol>
<h4 id="finally块的陷阱"><a href="#finally块的陷阱" class="headerlink" title="finally块的陷阱"></a>finally块的陷阱</h4><h5 id="finally块的执行规则"><a href="#finally块的执行规则" class="headerlink" title="finally块的执行规则"></a>finally块的执行规则</h5><ol>
<li><p>如果调用了System.exit(0);finally将不再执行，</p>
</li>
<li><p>当System.exit(0)被执行时，虚拟机在退出之前要完成两项工作：</p>
<ol>
<li>执行系统中注册的所有钩子</li>
<li>如果程序调用了System.runFinalizersOnExit(true);那么JVM会对所有未结束的对象调用Finalize</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h5 id="finally块和方法返回值"><a href="#finally块和方法返回值" class="headerlink" title="finally块和方法返回值"></a>finally块和方法返回值</h5></li>
</ol>
<p>当Java程序执行try、catch遇到return语句时，return语句会导致该方法会立即结束；系统执行return语句之后并不会立即结束该方法，而是去寻找异常处理过程中是否有finally，如果有则会执行finally代码块，在执行finally块时如果该块中没有return则会直接返回到try中的return，结束该方法，如果有则会直接返回finally中的数据，而不会调用try中的return。</p>
<h4 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a>catch的用法</h4><ol>
<li>catch的顺序: 先处理小异常在处理大异常</li>
<li>不要用catch代替流程控制</li>
<li>只能catch可能抛出的异常(减少大范围catch异常)</li>
<li>实际的修复<ol>
<li>如果程序知道如何修复这个异常，应该在catch中修复这个异常，修复之后可以再次调用这个方法；</li>
<li>如果程序不知道如何修复并且系统也没有进行任何修复，千万不要再次调用可能导致该异常的方法。（造成内存溢出），不要在finally块中调用可能引起异常的方法，可能会导致无限递归、内存溢出</li>
</ol>
</li>
</ol>
<h4 id="继承得到的异常"><a href="#继承得到的异常" class="headerlink" title="继承得到的异常"></a>继承得到的异常</h4><ol>
<li>子类重写父类方法时，不能抛出比父类方法类型更多、范围更大的异常</li>
<li>抛出的异常只能是父类异常中的交集，否则不能通过编译。</li>
</ol>
<h3 id="异常的处理流程"><a href="#异常的处理流程" class="headerlink" title="异常的处理流程"></a>异常的处理流程</h3><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587727204173.png" class title="异常处理流程">

</div>

<h3 id="异常拦截"><a href="#异常拦截" class="headerlink" title="异常拦截"></a>异常拦截</h3><p>系统的异常处理机制是衡量一个系统设计的关键因素，良好的异常处理机制能在系统出现异常时准确的找到问题的所在。spring aop对异常的处理有良好的支持。spring（spring全家桶中增加了很多异常统一处理的接口和AOP，比如<code>@ControllerAdvice</code>） 提供了一个接口 <code>ThrowsAdvice</code>，该接口里面没有任何方法，但是实现类里面必须的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以处理详细的异常信息</span></span><br><span class="line">afterThrowing(Method method, Object[] args, Object target, RuntimeException  throwable)</span><br><span class="line"><span class="comment">//方便快速记录发生的异常</span></span><br><span class="line">afterThrowing(RuntimeException  throwable)</span><br></pre></td></tr></table></figure>
<h3 id="ClassNotFoundException和NoClassDefFoundError的区别"><a href="#ClassNotFoundException和NoClassDefFoundError的区别" class="headerlink" title="ClassNotFoundException和NoClassDefFoundError的区别"></a>ClassNotFoundException和NoClassDefFoundError的区别</h3><p>NoClassDefFoundError是一个错误(Error)，而ClassNOtFoundException是一个异常，在Java中错误和异常是有区别的，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。</p>
<h4 id="ClassNotFoundException的产生原因"><a href="#ClassNotFoundException的产生原因" class="headerlink" title="ClassNotFoundException的产生原因"></a>ClassNotFoundException的产生原因</h4><ol>
<li>使用<code>Class.forName（ClassLoader.loadClass、ClassLOader.findSystemClass）</code>加载对象时，如果没有找到则会出现该异常</li>
<li>当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。</li>
<li>ClassNotFoundException发生在装入阶段。</li>
<li>加载时从外存储器找不到需要的class就出现ClassNotFoundException</li>
</ol>
<h4 id="NoClassDefFoundError产生的原因"><a href="#NoClassDefFoundError产生的原因" class="headerlink" title="NoClassDefFoundError产生的原因"></a>NoClassDefFoundError产生的原因</h4><ol>
<li>JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。</li>
<li>NoClassDefFoundError： 当目前执行的类已经编译，但是找不到它的定义时</li>
<li>连接时从内存找不到需要的class就出现NoClassDefFoundError</li>
</ol>
<h4 id="NoClassDefFoundError-解决的三种方法"><a href="#NoClassDefFoundError-解决的三种方法" class="headerlink" title="NoClassDefFoundError 解决的三种方法"></a>NoClassDefFoundError 解决的三种方法</h4><ol>
<li><p>Simple example of NoClassDefFoundError is class belongs to a jar and jar was not added into classpath or sometime jar’s name has been changed by someone like in my case one of my colleague has changed tibco.jar into tibco_v3.jar and by program is failing with java.lang.NoClassDefFoundError and I was wondering what’s wrong.<br>首先是类在运行的时候依赖于其它的一个jar包，但是该jar包没有加载到classpath中或者是该jar包的名字被其他人改了，就像我的一个例子tibo.jar改为了tibco_v3.jar……. </p>
</li>
<li><p>Class is not in Classpath, there is no sure shot way of knowing it but many a times you can just have a look to print System.getproperty(”java.classpath“)and it will print the classpath from there you can at least get an idea of your actual runtime classpath.<br>运行的类不在classpath中，这个问题没有一个确定的方法去知道，但是很多时候你可以通过System.getproperty(”java.classpath“)方法，该方法能让你至少可以领略到实际存在的运行期间的classpath。
 </p>
</li>
<li><p>Just try to run with explicitly -classpath option with the classpath you think will work and if its working then it’s sure short sign that some one is overriding java classpath.<br>试着通过-classpath命令明确指出你认为正确的classpath，如果能够正常执行的话就说明你使用的classpath是正确的，而系统中的classpath已经被修该过了。</p>
</li>
</ol>
<h4 id="类装载方式"><a href="#类装载方式" class="headerlink" title="类装载方式"></a>类装载方式</h4><h5 id="显示类装载"><a href="#显示类装载" class="headerlink" title="显示类装载"></a>显示类装载</h5><p>显式 类装入发生在使用以下方法调用装入的类的时候：</p>
<ul>
<li>cl.loadClass()（cl 是 java.lang.ClassLoader 的实例）</li>
<li>Class.forName()（启动的类装入器是当前类定义的类装入器）</li>
</ul>
<p>当调用其中一个方法的时候，指定的类（以类名为参数）由类装入器装入。如果类已经装入，那么只是返回一个引用；否则，装入器会通过委托模型装入类。</p>
<h5 id="隐式类装载"><a href="#隐式类装载" class="headerlink" title="隐式类装载"></a>隐式类装载</h5><p>隐式 类装入发生在由于引用、实例化或继承导致装入类的时候（不是通过显式方法调用）。在每种情况下，装入都是在幕后启动的，JVM 会解析必要的引用并装入类。与显式类装入一样，如果类已经装入了，那么只是返回一个引用；否则，装入器会通过委托模型装入类。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/jygqm/article/details/81364636">JAVA 异常详解</a></li>
<li><a href="https://www.cnblogs.com/hysum/p/7112011.html">JAVA基础——异常详解</a></li>
<li><a href="https://www.cnblogs.com/nwgdk/p/8862353.html">Java 异常基础详解(详细的使用方式，可参考)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/108423001">Java基础篇——异常详解</a></li>
<li><a href="https://blog.csdn.net/qq_31615049/article/details/80952216">Java异常实现及原理</a></li>
<li>《疯狂Java》</li>
<li><a href="https://www.toutiao.com/i6805046770897256974/">finally 到底是在 return 之前还是之后执行的？</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之集合概述</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>使用集合需要考虑几个关注点：</p>
<ol>
<li>线程安全性</li>
<li>是否有序</li>
<li>是否重复</li>
<li>关注查询还是关注写入</li>
<li>equals和hashCode方法的重写需要同步</li>
<li>使用接口返回集合数据<a id="more"></a>

</li>
</ol>
<h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589101774172.png" class title="Java集合知识图谱">

</div>

<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589870092003.png" class title="Java集合类图">

</div>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h3><ol>
<li>数组和集合都是Java中的容器</li>
<li>数组的长度是固定的，集合的长度是可变的</li>
<li>数组只能存储相同数据类型的数据，这里的数据类型可以是基本数据类型，也可以是引用类型</li>
<li>集合可以存储不同数据类型的对象的引用(不建议使用这种方式，需要使用泛型控制)，但不能存储基本数据类型</li>
</ol>
<h3 id="接口继承关系和实现"><a href="#接口继承关系和实现" class="headerlink" title="接口继承关系和实现"></a>接口继承关系和实现</h3><p>集合类存放于 <code>Java.util</code> 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。</p>
<ol>
<li>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。</li>
<li>Iterator：迭代器，可以通过迭代器遍历集合中的数据</li>
<li>Map：是映射表的基础接口</li>
</ol>
<p>通过类图可知得出以下结论：  </p>
<ol>
<li>Java集合的根接口是Collection，它又继承了迭代接口Iterable</li>
<li>List接口和Set接口继承了Collection接口</li>
<li>Map接口是独立的接口，并没有继承Collection接口</li>
<li>List接口常用的实现类有：ArrayList、LinkedList、Vector，有序集合</li>
<li>Set接口常用的实现类有：HashSet、LinkedHashSet、TreeSet，不重复集合</li>
<li>Map接口常用的实现类有：HashMap、HashTable、TreeMap</li>
<li>Queue(队列)接口及其子类，提供了基于队列的集合体系。</li>
</ol>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">接口</th>
    <th class="tg-0lax">集合类</th>
    <th class="tg-0lax">重复性</th>
    <th class="tg-0lax">有序性</th>
    <th class="tg-0lax">判断方法</th>
    <th class="tg-0lax">数据结构</th>
    <th class="tg-0lax">其他</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax" rowspan="2">Set</td>
    <td class="tg-0lax">HashSet</td>
    <td class="tg-0lax">否</td>
    <td class="tg-0lax">无序</td>
    <td class="tg-0lax">equals()、hashCode()</td>
    <td class="tg-0lax">Hash 表</td>
    <td class="tg-0lax">插入速度快</td>
  </tr>
  <tr>
    <td class="tg-0lax">LinkedHashSet</td>
    <td class="tg-0lax">否</td>
    <td class="tg-0lax">插入有序</td>
    <td class="tg-0lax">equals()、hashCode()</td>
    <td class="tg-0lax">Hash 表和双向链表</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">SortedSet、Set</td>
    <td class="tg-0lax">TreeSet</td>
    <td class="tg-0lax">否</td>
    <td class="tg-0lax">有序</td>
    <td class="tg-0lax">equals()、compareTo()</td>
    <td class="tg-0lax">&平衡树（Balanced tree）</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax" rowspan="3">List</td>
    <td class="tg-0lax">ArrayList</td>
    <td class="tg-0lax">是</td>
    <td class="tg-0lax">插入有序</td>
    <td class="tg-0lax">equals()</td>
    <td class="tg-0lax">数组</td>
    <td class="tg-0lax">
        动态链表<br>
        随机查询
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">LinkedList</td>
    <td class="tg-0lax">是</td>
    <td class="tg-0lax">插入有序</td>
    <td class="tg-0lax">equals()</td>
    <td class="tg-0lax">链表</td>
    <td class="tg-0lax">
        用于链表、队列、堆<br>
        中间写入、删除数据较快
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">Vector</td>
    <td class="tg-0lax">是</td>
    <td class="tg-0lax">插入有序</td>
    <td class="tg-0lax">equals()</td>
    <td class="tg-0lax">数组</td>
    <td class="tg-0lax">线程安全，效率低</td>
  </tr>
  <tr>
    <td class="tg-0lax" rowspan="3">Map</td>
    <td class="tg-0lax">HashMap</td>
    <td class="tg-0lax">key唯一</td>
    <td class="tg-0lax">无序</td>
    <td class="tg-0lax">equals()、hashCode()</td>
    <td class="tg-0lax">Hash 表</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">LinkedHashMap</td>
    <td class="tg-0lax">key唯一</td>
    <td class="tg-0lax">Key插入有序</td>
    <td class="tg-0lax">equals()、hashCode()</td>
    <td class="tg-0lax">Hash 表和双向链表</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">Hashtable</td>
    <td class="tg-0lax">key唯一</td>
    <td class="tg-0lax">无序</td>
    <td class="tg-0lax">equals()、hashCode()</td>
    <td class="tg-0lax">Hash 表</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">SortedMap</td>
    <td class="tg-0lax">TreeMap</td>
    <td class="tg-0lax">key唯一</td>
    <td class="tg-0lax">key有序</td>
    <td class="tg-0lax">equals()、compareTo()</td>
    <td class="tg-0lax">平衡树（Balanced tree）</td>
    <td class="tg-0lax"></td>
  </tr>
</tbody>
</table>

<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="Collection类图"><a href="#Collection类图" class="headerlink" title="Collection类图"></a>Collection类图</h3><div style="width:300px;length:400px;align=center;margin:0 auto;">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589875532865.png" class title="Collection类图">

</div>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589871965983.png" class title="List类图">

</div>

<p>List 是<strong>有序</strong>的 Collection。Java List常用的实现类：ArrayList、Vector 和LinkedList。<br>List集合包括List接口以及List接口的所有实现类。List集合具有以下特点：</p>
<ol>
<li>集合中的元素允许重复</li>
<li>集合中的元素是有顺序的，各元素插入的顺序就是各元素的顺序，可以通过索引获取数据</li>
<li>集合中的元素可以通过索引来访问或者设置</li>
<li>提供一个listIterator()方法，返回一个 ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历</li>
</ol>
<h3 id="ArrayList（数组）"><a href="#ArrayList（数组）" class="headerlink" title="ArrayList（数组）"></a>ArrayList（数组）</h3><ol>
<li>内部通过数组实现</li>
<li>元素支持快速随机访问</li>
<li>当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li>
<li>可以为null</li>
<li>size，isEmpty，get，set方法运行时间为常数</li>
<li>add时间复杂度O(n)</li>
<li>动态扩容，使用ensureCapacity方法来增加ArrayList的容量以提高插入效率</li>
</ol>
<h3 id="Vector（数组实现、线程同步）"><a href="#Vector（数组实现、线程同步）" class="headerlink" title="Vector（数组实现、线程同步）"></a>Vector（数组实现、线程同步）</h3><ol>
<li>内部通过数组实现</li>
<li>支持同步，效率慢</li>
<li>如果其他线程在变更链表，使用Iterator将抛出ConcurrentModificationException</li>
</ol>
<h3 id="LinkList（链表）"><a href="#LinkList（链表）" class="headerlink" title="LinkList（链表）"></a>LinkList（链表）</h3><ol>
<li>内部使用链表结构实现</li>
<li>适合数据的动态插入和删除</li>
<li>随机访问和遍历速度较慢</li>
<li>提供额外的get、remove、insert方法作用LinkList的头尾，可以当作堆栈、队列和双向队列使用</li>
<li>允许为null</li>
<li>安全化：List list = Collections.synchronizedList(new LinkedList(…));</li>
</ol>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><ol>
<li>Stack继承自Vector，实现一个后进先出的堆栈</li>
<li>基本的push和pop方法，还有peek方法得到栈顶的元素</li>
<li>empty方法测试堆栈是否为空</li>
<li>search方法检测一个元素在堆栈中的位置</li>
<li>Stack刚创建后是空栈</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ol>
<li>数据不重复（通过对象的hashCode值判断，可重复添加但是最终只有一个）</li>
<li>存储数据无序(存入和取出的顺序不一定相同)</li>
</ol>
<blockquote>
<p>请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题</p>
</blockquote>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589872549181.png" class title="Set类图">

</div>

<h3 id="HashSet（Hash-表）"><a href="#HashSet（Hash-表）" class="headerlink" title="HashSet（Hash 表）"></a>HashSet（Hash 表）</h3><ol>
<li>使用Hash表实现，并且存储的是哈希值</li>
<li>存储的数据顺序无序（不是按照写入顺序定义）</li>
<li>按照哈希值来存储或读取数据，哈希值是通过hashcode获取</li>
<li>判断相同：首先判断哈希值，然后执行equals方法，都通过才认为是同一条数据</li>
<li>哈希碰撞：（哈希值相同，equals不同），可以使用链表进行顺延</li>
<li>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。</li>
</ol>
<h3 id="TreeSet（二叉树）"><a href="#TreeSet（二叉树）" class="headerlink" title="TreeSet（二叉树）"></a>TreeSet（二叉树）</h3><ol>
<li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。</li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</li>
<li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</li>
</ol>
<h3 id="LinkHashSet（HashSet-LinkedHashMap）"><a href="#LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet（HashSet+LinkedHashMap）"></a>LinkHashSet（HashSet+LinkedHashMap）</h3><ol>
<li>通过HashSet+LinkedHashMap实现</li>
<li>使用LinkedHashMap 来保存所有元素</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589873440529.png" class title="Map类图">

</div>

<p>Map集合包括Map接口以及Map接口的所有实现类。Map集合具有以下特点：</p>
<ol>
<li>Map接口并没有继承Collection接口，提供的是key到value的映射</li>
<li>Map中不能包含相同的key</li>
</ol>
<h3 id="Hashmap与hashtable的区别"><a href="#Hashmap与hashtable的区别" class="headerlink" title="Hashmap与hashtable的区别"></a>Hashmap与hashtable的区别</h3><ol>
<li>HashMap 允许 key 和 value 为 null，Hashtable 不允许。</li>
<li>HashMap 的默认初始容量为 16，Hashtable 为 11。</li>
<li>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。</li>
<li>HashMap 是非线程安全的，Hashtable是线程安全的。</li>
<li>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</li>
<li>HashMap 去掉了 Hashtable 中的 contains 方法。</li>
<li>HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。</li>
</ol>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ol>
<li>HashMap 的底层是个 Node 数组（Node&lt;K,V&gt;[] table），在数组的具体索引位置，如果存在多个节点，则可能是以链表或红黑树的形式存在。</li>
<li>增加、删除、查找键值对时，定位到哈希桶数组的位置是很关键的一步，源码中是通过下面3个操作来完成这一步：1）拿到 key 的 hashCode 值；2）将 hashCode 的高位参与运算，重新计算 hash 值；3）将计算出来的 hash 值与 “table.length - 1” 进行 &amp; 运算。</li>
<li>HashMap 的默认初始容量（capacity）是 16，capacity 必须为 2 的幂次方；默认负载因子（load factor）是 0.75；实际能存放的节点个数（threshold，即触发扩容的阈值）= capacity * load factor。</li>
<li>HashMap 在触发扩容后，阈值会变为原来的 2 倍，并且会对所有节点进行重 hash 分布，重 hash 分布后节点的新分布位置只可能有两个：“原索引位置” 或 “原索引+oldCap位置”。例如 capacity 为16，索引位置 5 的节点扩容后，只可能分布在新表 “索引位置5” 和 “索引位置21（5+16）”。</li>
<li>导致 HashMap 扩容后，同一个索引位置的节点重 hash 最多分布在两个位置的根本原因是：1）table的长度始终为 2 的 n 次方；2）索引位置的计算方法为 “(table.length - 1) &amp; hash”。HashMap 扩容是一个比较耗时的操作，定义 HashMap 时尽量给个接近的初始容量值。</li>
<li>HashMap 有 threshold 属性和 loadFactor 属性，但是没有 capacity 属性。初始化时，如果传了初始化容量值，该值是存在 threshold 变量，并且 Node 数组是在第一次 put 时才会进行初始化，初始化时会将此时的 threshold 值作为新表的 capacity 值，然后用 capacity 和 loadFactor 计算新表的真正 threshold 值。</li>
<li>当同一个索引位置的节点在增加后达到 9 个时，并且此时数组的长度大于等于 64，则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。链表节点转红黑树节点的具体方法为源码中的 treeifyBin 方法。而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容。</li>
<li>当同一个索引位置的节点在移除后达到 6 个时，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点。红黑树节点转链表节点的具体方法为源码中的 untreeify 方法。</li>
<li>HashMap 在 JDK 1.8 之后不再有死循环的问题，JDK 1.8 之前存在死循环的根本原因是在扩容后同一索引位置的节点顺序会反掉。</li>
<li>HashMap 是非线程安全的，在并发场景下使用 ConcurrentHashMap 来代替。</li>
</ol>
<p>详细参考：<a href="https://www.sunliaodong.cn/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/">JAVA HashMap详解</a></p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="Segment-段"><a href="#Segment-段" class="headerlink" title="Segment 段"></a>Segment 段</h4><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一<br>些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。 </p>
<h4 id="线程安全（Segment-继承-ReentrantLock-加锁）"><a href="#线程安全（Segment-继承-ReentrantLock-加锁）" class="headerlink" title="线程安全（Segment 继承 ReentrantLock 加锁）"></a>线程安全（Segment 继承 ReentrantLock 加锁）</h4><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承<br>ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 </p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589102309296.png" class title="Java7 ConcurrentHashMap结构">

</div>

<h4 id="并行度（默认-16）"><a href="#并行度（默认-16）" class="headerlink" title="并行度（默认 16）"></a>并行度（默认 16）</h4><p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 </p>
<h4 id="Java8-实现-（引入了红黑树）"><a href="#Java8-实现-（引入了红黑树）" class="headerlink" title="Java8 实现 （引入了红黑树）"></a>Java8 实现 （引入了红黑树）</h4><p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。 </p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589102332640.png" class title="Java8 ConcurrentHashMap结构">

</div>

<h3 id="HashTable（线程安全）"><a href="#HashTable（线程安全）" class="headerlink" title="HashTable（线程安全）"></a>HashTable（线程安全）</h3><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p>
<h3 id="TreeMap（可排序）"><a href="#TreeMap（可排序）" class="headerlink" title="TreeMap（可排序）"></a>TreeMap（可排序）</h3><p>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的<br>Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。<br>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html</a> </p>
<h3 id="LinkHashMap（记录插入顺序）"><a href="#LinkHashMap（记录插入顺序）" class="headerlink" title="LinkHashMap（记录插入顺序）"></a>LinkHashMap（记录插入顺序）</h3><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。参考 1：<a href="http://www.importnew.com/28263.html">http://www.importnew.com/28263.html</a><br>参考 2：<a href="http://www.importnew.com/20386.html#comment-648123">http://www.importnew.com/20386.html#comment-648123</a> </p>
<h2 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h2><p>Iterator是获取集合中元素的过程，实际上帮助获取集合中的元素。<br>迭代器代替了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同：<br>迭代器允许调用方利用定义良好的语义在迭代期间从迭代器所指向的集合移除元素。<br>方法名称得到了改进。<br>Iterator 仅有一个子接口ListIterator，是列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。 ListIterator 没有当前元素；它的光标位置 始终位于调用 previous() 所返回的元素和调用 next() 所返回的元素之间。在长度为 n 的列表中，有 n+1 个有效的索引值，从 0 到 n（包含）。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="Comparable-接口"><a href="#Comparable-接口" class="headerlink" title="Comparable 接口"></a>Comparable 接口</h3><h3 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高效编程技巧</title>
    <url>/2021/02/04/Java%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="Java代码规范"><a href="#Java代码规范" class="headerlink" title="Java代码规范"></a>Java代码规范</h2><h3 id="命名规范（阿里规范）"><a href="#命名规范（阿里规范）" class="headerlink" title="命名规范（阿里规范）"></a>命名规范（阿里规范）</h3><ol>
<li><p>名称只能是有含义的英文，不能出现下划线或美元符号</p>
</li>
<li><p>方法名、参数名、成员变量、局部变量统一使用驼峰方式命名，形如lowerCamelCase</p>
</li>
<li><p>类名使用UpperCamelCase命名，DO/BO/DTO/VO/AO/PO/UID除外</p>
</li>
<li><p>常量或类变量都需要使用大写，并且中间使用下划线分割</p>
</li>
<li><p>抽象类必须以Abstract或Base开头，异常类，必须以Exception结果，测试类必须以待测试代码_Test</p>
</li>
<li><p>类型与中括号紧挨相连来表示数组,形如<code>int[] arrayDemo</code></p>
</li>
<li><p>成员变量不能以is开头</p>
</li>
<li><p>包使用小写定义，并且使用单数，中间使用英文句号分割，并且定义必须有意义和唯一性</p>
</li>
<li><p>子类与父类之间不要使用相同的成员变量命名</p>
</li>
<li><p>完全杜绝不规范的缩写，尽量使用完整的单词</p>
</li>
<li><p>在常量与变量命名时，表示类型的名称放在词尾</p>
</li>
<li><p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式</p>
</li>
<li><p>接口中不要定义变量，方式不需要增加任何修饰符，都必须有注释信息</p>
</li>
<li><p>接口与实现类的命名规范是<strong>Service/**ServiceImpl、</strong>DAO/**DAOImpl</p>
</li>
<li><p>枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开</p>
</li>
<li><p>各层命名规范：</p>
<ul>
<li>Service/DAO 层方法命名规约<ul>
<li>获取单个对象的方法用 get 做前缀。</li>
<li>获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。</li>
<li>获取统计值的方法用 count 做前缀。</li>
<li>插入的方法用 save/insert 做前缀。</li>
<li>删除的方法用 remove/delete 做前缀。</li>
<li>修改的方法用 update 做前缀。</li>
</ul>
</li>
<li>领域模型命名规约<ul>
<li>数据对象：xxxDO，xxx 即为数据表名。</li>
<li>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li>
<li>展示对象：xxxVO，xxx 一般为网页名称。</li>
<li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。<a id="more"></a>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>不允许任何魔法值（即未经预先定义的常量）直接出现在代码中，使用常量替换</p>
</li>
<li><p>定义类型为long或Long的属性时，需要用大写L结尾</p>
</li>
<li><p>常量定义要分类维护，一般分为：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量</p>
</li>
<li><p>如果变量值仅在一个固定范围内变化用 enum 类型来定义</p>
</li>
</ol>
<h2 id="高效能开发的原则"><a href="#高效能开发的原则" class="headerlink" title="高效能开发的原则"></a>高效能开发的原则</h2><h3 id="优化代码的注意事项"><a href="#优化代码的注意事项" class="headerlink" title="优化代码的注意事项"></a>优化代码的注意事项</h3><ol>
<li>除非必须优化，否则不要轻易改动</li>
<li>改动之后要进行仔细的测试</li>
<li>在各个JVM产品中不存在一劳永逸的成本模型</li>
</ol>
<h3 id="Java编码原则"><a href="#Java编码原则" class="headerlink" title="Java编码原则"></a>Java编码原则</h3><ol>
<li>注重设计、数据结构、算法选择</li>
<li>不要过分依赖编译器编译期的优化技术，正确理解Java运行期的实际效果</li>
<li>将对象的创建和使用降到最低：<ul>
<li>StringBuilder的使用</li>
<li>for循环中对象的索引使用</li>
<li>线程或连接的复用</li>
<li>合理设计对象的大小（在类加载过程会完成内存大小的计算）</li>
<li>合理设计继承关系（不多于3层）</li>
<li>构造函数尽可能短小精干</li>
<li>对象创建使用懒加载思想</li>
</ul>
</li>
<li>降低同步的影响范围<ul>
<li>是否需要使用同步控制或者线程安全的类</li>
<li>控制同步范围</li>
<li>合理使用锁变量，做到线程分离，提高并发度和吞吐量</li>
<li>减少锁的使用，避免出现死锁</li>
</ul>
</li>
<li>尽量在栈中完成业务处理</li>
<li>使用static、final、private函数促成inlining</li>
<li>实例变量初始化合适就好，比如单例模式</li>
<li>注意集合的使用<ul>
<li>选择合适的遍历方式</li>
<li>使用大小的控制</li>
<li>数据复制的选择</li>
<li>选择合适的集合类</li>
</ul>
</li>
<li>尽可能重用对象</li>
<li>增加缓存概念</li>
</ol>
<h2 id="集合遍历效率问题"><a href="#集合遍历效率问题" class="headerlink" title="集合遍历效率问题"></a>集合遍历效率问题</h2><h3 id="高效遍历MAP"><a href="#高效遍历MAP" class="headerlink" title="高效遍历MAP"></a>高效遍历MAP</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * keySet的for循环方式：</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetForGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetForGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetForGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	        String value = map.get(key);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetForGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * keySet的iterator迭代器方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetIteratorGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetIteratorGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetIteratorGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next();</span><br><span class="line">	        String value = map.get(iterator.next());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetIteratorGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * entrySet的for循环方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetForGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	        String key = entry.getKey();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetForGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetForGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	        String key = entry.getKey();</span><br><span class="line">	        String value = entry.getValue();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetForGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * entrySet的iterator迭代器方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetIteratorGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next().getKey();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetIteratorGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetIteratorGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next().getKey();</span><br><span class="line">	        String value = iterator.next().getValue();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetIteratorGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		    map.put(i + <span class="string">&quot;&quot;</span>, i + <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		MapTest.keySetForGetKey(map);</span><br><span class="line">		MapTest.keySetIteratorGetKey(map);</span><br><span class="line">		MapTest.entrySetForGetKey(map);</span><br><span class="line">		MapTest.entrySetIteratorGetKey(map);</span><br><span class="line">		</span><br><span class="line">		MapTest.keySetForGetKeyAndValue(map);</span><br><span class="line">		MapTest.keySetIteratorGetKeyAndValue(map);</span><br><span class="line">		MapTest.entrySetForGetKeyAndValue(map);</span><br><span class="line">		MapTest.entrySetIteratorGetKeyAndValue(map);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">keySetForGetKey运行时间<span class="number">96</span></span><br><span class="line">keySetIteratorGetKey运行时间<span class="number">107</span></span><br><span class="line">entrySetForGetKey运行时间<span class="number">112</span></span><br><span class="line">entrySetIteratorGetKey运行时间<span class="number">153</span></span><br><span class="line">keySetForGetKeyAndValue运行时间<span class="number">169</span></span><br><span class="line">keySetIteratorGetKeyAndValue运行时间<span class="number">283</span></span><br><span class="line">entrySetForGetKeyAndValue运行时间<span class="number">109</span></span><br><span class="line">entrySetIteratorGetKeyAndValue运行时间<span class="number">138</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：<br>entrySet的方式整体都是比keySet方式要高一些<br>单纯的获取key来说，两者的差别并不大，但是如果要获取value，还是entrySet的效率会更好，因为keySet需要从map中再次根据key获取value，而entrySet一次都全部获取出来<br>iterator的迭代器方式比foreach的效率高  </p>
</blockquote>
<h3 id="实现RandomAccess接口的集合使用for循环而不是foreach来遍历"><a href="#实现RandomAccess接口的集合使用for循环而不是foreach来遍历" class="headerlink" title="实现RandomAccess接口的集合使用for循环而不是foreach来遍历"></a>实现RandomAccess接口的集合使用for循环而不是foreach来遍历</h3><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其：色nu支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p>
<div align="center">

<img src="/2021/02/04/Java%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/1589105799147.png" class title="参考代码">

</div>

<p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p>
<h2 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h2><ol>
<li>尽量使用同步代码块替代同步方法，提高代码执行效率</li>
<li>尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</li>
</ol>
<h2 id="资源处理注意事项"><a href="#资源处理注意事项" class="headerlink" title="资源处理注意事项"></a>资源处理注意事项</h2><ol>
<li>及时关闭资源：使用资源一般都会建立流的连接，比如文件流，数据库连接等，在使用完成之后要及时关闭打开的连接，防止内存泄露。一般在finally中处理。</li>
<li>关闭多个资源时，需要分开执行，防止由于异常无法关闭所有的资源</li>
</ol>
<h2 id="垃圾信息处理"><a href="#垃圾信息处理" class="headerlink" title="垃圾信息处理"></a>垃圾信息处理</h2><ol>
<li>不要定义、创建不使用的对象，变量；</li>
<li>不要导入不需要的依赖包</li>
<li>公用的集合类中不使用的数据一定要及时remove掉</li>
<li>ThreadLocal中不使用的数据要及时处理掉，防止内存溢出</li>
<li>及时清除不再需要的会话（会话超时设置），防止出现内存不足或内存磁盘之间交互频繁，当会话不再需要时，应当及时调用HttpSession的invalidate方法清除会话。</li>
</ol>
<h2 id="尽量使用局部变量"><a href="#尽量使用局部变量" class="headerlink" title="尽量使用局部变量"></a>尽量使用局部变量</h2><ol>
<li>方法参数和临时临时变量都在栈中分配，速度快</li>
<li>类变量、实例变量存储在堆中速度较慢</li>
<li>栈中的变量随时方法的结束而结束，不需要额外的垃圾回收</li>
</ol>
<h2 id="提高效率，减少内存"><a href="#提高效率，减少内存" class="headerlink" title="提高效率，减少内存"></a>提高效率，减少内存</h2><ol>
<li>使用StringBuilder/StringBuffer替代String</li>
<li>循环内不要创建对象的引用：减少堆栈中的使用，避免出现栈内存溢出或出现栈越界。</li>
<li>尽量采用懒加载的策略，即在需要的时候才创建</li>
<li>尽量避免随意使用静态变量：当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的</li>
<li>尽量在合适的场合使用单例（减轻加载的负担、缩短加载的时间、提高加载的效率）<ul>
<li>控制资源的使用，通过线程同步来控制资源的并发访问</li>
<li>控制实例的产生，以达到节约资源的目的</li>
<li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
</li>
<li>使用数据库连接池和线程池：前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</li>
<li>使用带缓冲的输入输出流进行IO操作</li>
<li>乘法和除法使用移位操作</li>
<li>减少对变量的重复计算：对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。集合中大小的重复获取会消耗内存和时间。</li>
<li>当复制大量数据时，使用System.arraycopy命令</li>
<li>基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</li>
<li>程序运行过程中避免使用反射（根据实际情况定）：反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</li>
<li>顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个</li>
</ol>
<h2 id="关键字和方法的说明"><a href="#关键字和方法的说明" class="headerlink" title="关键字和方法的说明"></a>关键字和方法的说明</h2><h3 id="equals的正确使用"><a href="#equals的正确使用" class="headerlink" title="equals的正确使用"></a>equals的正确使用</h3><ol>
<li>重写equals后需要同时完成hashcode方法的重写</li>
<li>equals中初始代码比对的是对象地址</li>
<li>字符串比对相等时，字符串常量写在字符串变量前面，比如”abc”.equals(abc)</li>
</ol>
<h3 id="final的正确使用"><a href="#final的正确使用" class="headerlink" title="final的正确使用"></a>final的正确使用</h3><ol>
<li>如果类不能被派生，则必须定义为final（该类中的方法都是final的）</li>
<li>如果方法不能被重写，则必须定义为final</li>
<li>常量定义为static final，并且名称使用大写，多个字符使用下划线拼接，比如：USER_NAME</li>
<li>不要将数组声明为public static final（final只是表示引用不变，但是内容还是可以变）</li>
</ol>
<h3 id="方法参数要求"><a href="#方法参数要求" class="headerlink" title="方法参数要求"></a>方法参数要求</h3><p>在Java编程中，要尽量保证面向对象编程，并且达到高内聚，低耦合，实现动态扩展的特性。如果定义参数太多，会有以下缺点：</p>
<ol>
<li>违背面向对象编程</li>
<li>可扩展性低</li>
<li>方法调用出错概率大</li>
</ol>
<p>建议参数保证在3~4个之内，尽量使用有明确意义的对象传参（<strong>减少类似Map对象的使用</strong>）。</p>
<h3 id="不要对数组使用toString方法"><a href="#不要对数组使用toString方法" class="headerlink" title="不要对数组使用toString方法"></a>不要对数组使用toString方法</h3><ol>
<li>数组为空会出现空指针</li>
<li>打印的数据是地址信息，与预期不一致</li>
<li>对集合toString是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString方法。</li>
</ol>
<h2 id="异常使用注意事项"><a href="#异常使用注意事项" class="headerlink" title="异常使用注意事项"></a>异常使用注意事项</h2><ol>
<li>慎用异常：异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace的本地同步方法，fillInStackTrace方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</li>
<li>不要在循环中使用try…catch…，应该把其放在最外层，除非不得已</li>
</ol>
<h2 id="合理使用初始化长度"><a href="#合理使用初始化长度" class="headerlink" title="合理使用初始化长度"></a>合理使用初始化长度</h2><ol>
<li>集合：ArrayList、LinkedLlist等</li>
<li>字符串：StringBuilder、StringBuffer等</li>
<li>Map：HashMap等</li>
<li>Set：HashSet等</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol>
<li>不要对超出范围的基本数据类型做向下强制转型<ul>
<li>整型默认的数据类型是int，long需要在结尾增加<code>L</code></li>
<li>浮点型的默认类型是double，所以定义float的时候要写成<code>float f = 3.5f</code></li>
<li>long+int会自动转型为long</li>
</ul>
</li>
<li>基本类型（包装类）转String：<code>toString &gt; String.valueOf &gt; +</code>，可以通过源码得到原因：<ul>
<li>String.valueOf方法底层调用了Integer.toString方法，但是会在调用前做空判断</li>
<li>Integer.toString，直接调用了</li>
<li>i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString方法获取字符串</li>
</ul>
</li>
</ol>
<h2 id="日志规范"><a href="#日志规范" class="headerlink" title="日志规范"></a>日志规范</h2><ol>
<li>日志级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL，常用级别<strong>ERROR、WARN、INFO和DEBUG</strong></li>
<li>ERROR<ul>
<li>表示不能自己恢复的错误，需要立即关注和解决</li>
<li>比如：数据库连接错误、网络错误、未知系统错误</li>
<li>需要接入监控和报警系统 </li>
</ul>
</li>
<li>WARN<ul>
<li>表示可预知的错误，业务场景类错误</li>
<li>比如：参数验证、权限认证 </li>
</ul>
</li>
<li>INFO<ul>
<li>记录系统的基本运行过程和运行状态</li>
<li>包括：系统状态变化、业务流程的核心处理、关键动作、业务流状态的变化 </li>
</ul>
</li>
<li>DEBUG<ul>
<li>调试信息 </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux PageCache详解</title>
    <url>/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>应用程序要存储或访问数据时，只需读或者写”文件”的一维地址空间即可，而这个地址空间与存储设备上存储块之间的对应关系则由操作系统维护。说白了，文件就是基于内核态Page Cache的一层抽象。</p>
<a id="more"></a>

<h2 id="相关场景"><a href="#相关场景" class="headerlink" title="相关场景"></a>相关场景</h2><ol>
<li>服务器的 load 飙高；</li>
<li>服务器的 I/O 吞吐飙高；</li>
<li>业务响应时延出现大的毛刺；</li>
<li>业务平均访问时延明显增加。</li>
</ol>
<h2 id="什么是page-cache"><a href="#什么是page-cache" class="headerlink" title="什么是page cache"></a>什么是page cache</h2><div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1597721768372.png" class title="应用程序产生page cache的逻辑示意图">

</div>

<p><strong>page cache是内存管理的内存，属于内核不属于用户。</strong></p>
<h3 id="查看方式"><a href="#查看方式" class="headerlink" title="查看方式"></a>查看方式</h3><ol>
<li>/proc/meminfo</li>
<li>free命令</li>
<li>vmstat命令</li>
</ol>
<h3 id="page-cache指标说明"><a href="#page-cache指标说明" class="headerlink" title="page cache指标说明"></a>page cache指标说明</h3><p>通过/proc/meminfo查看内存信息如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MemTotal:        2046920 kB</span><br><span class="line">MemFree:          375284 kB</span><br><span class="line">MemAvailable:    1013780 kB</span><br><span class="line">Buffers:          142100 kB</span><br><span class="line">Cached:           668196 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">Active:           959184 kB</span><br><span class="line">Inactive:         279700 kB</span><br><span class="line">Active(anon):     491680 kB</span><br><span class="line">Inactive(anon):    46776 kB</span><br><span class="line">Active(file):     467504 kB</span><br><span class="line">Inactive(file):   232924 kB</span><br><span class="line">Unevictable:           0 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">SwapTotal:             0 kB</span><br><span class="line">SwapFree:              0 kB</span><br><span class="line">Dirty:                 0 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">AnonPages:        428608 kB</span><br><span class="line">Mapped:            37768 kB</span><br><span class="line">Shmem:            109868 kB</span><br><span class="line">Slab:             138120 kB</span><br><span class="line">SReclaimable:     126188 kB</span><br><span class="line">SUnreclaim:        11932 kB</span><br><span class="line">KernelStack:        2480 kB</span><br><span class="line">PageTables:         4572 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:      891364 kB</span><br><span class="line">Committed_AS:    1419192 kB</span><br><span class="line">VmallocTotal:   34359738367 kB</span><br><span class="line">VmallocUsed:        9136 kB</span><br><span class="line">VmallocChunk:   34359724540 kB</span><br><span class="line">HardwareCorrupted:     0 kB</span><br><span class="line">AnonHugePages:    169984 kB</span><br><span class="line">CmaTotal:              0 kB</span><br><span class="line">CmaFree:               0 kB</span><br><span class="line">HugePages_Total:     129</span><br><span class="line">HugePages_Free:      129</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br><span class="line">DirectMap4k:       53104 kB</span><br><span class="line">DirectMap2M:     2043904 kB</span><br><span class="line">DirectMap1G:           0 kB</span><br></pre></td></tr></table></figure>
<p>通过计算发现：</p>
<p><strong>Buffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached</strong></p>
<p>在 Page Cache 中，Active(file)+Inactive(file) 是 File-backed page（与文件对应的内存页），平时用的 mmap() 内存映射方式和 buffered I/O 来消耗的内存就属于这部分，这部分在真实的生产环境上也最容易产生问题。</p>
<h3 id="SwapCached说明-生产环境中不建议开启，防止IO引起性能抖动"><a href="#SwapCached说明-生产环境中不建议开启，防止IO引起性能抖动" class="headerlink" title="SwapCached说明(生产环境中不建议开启，防止IO引起性能抖动)"></a>SwapCached说明(生产环境中不建议开启，防止IO引起性能抖动)</h3><p>SwapCached 是在打开了 <strong>Swap</strong> 分区后，把 Inactive(anon)+Active(anon) 这两项里的匿名页给交换到磁盘（swap out），然后再读入到内存（swap in）后分配的内存。由于读入到内存后原来的 Swap File 还在，所以 SwapCached 也可以认为是 File-backed page，即属于 Page Cache。</p>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1597731780142.png" class title="1597731780142.png">

</div>

<h3 id="Shmem"><a href="#Shmem" class="headerlink" title="Shmem"></a>Shmem</h3><ol>
<li>Shmem 是指匿名共享映射这种方式分配的内存（free 命令中 shared 这一项）</li>
<li>进程使用mmap(MAP_ANON|MAP_SHARED)的方式申请内存</li>
<li>tmpfs： 磁盘的速度是远远低于内存的，有些应用程序为了提升性能，会避免将一些无需持续化存储的数据写入到磁盘，而是把这部分临时数据写入到内存中，然后定期或者在不需要这部分数据时，清理掉这部分内容来释放出内存。在这种需求下，就产生了一种特殊的 Shmem：tmpfs</li>
<li></li>
</ol>
<h3 id="frem命令的说明"><a href="#frem命令的说明" class="headerlink" title="frem命令的说明"></a>frem命令的说明</h3><p><strong>数据来源于/proc/meminfo</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -k</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        2046920      732896      377464      109860      936560     1016044</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>
<p>通过源码可知：<strong>buff/cache = Buffers + Cached + SReclaimable</strong></p>
<p><strong>SReclaimable 是指可以被回收的内核内存，包括 dentry 和 inode。</strong></p>
<h4 id="缓存的具体含义"><a href="#缓存的具体含义" class="headerlink" title="缓存的具体含义"></a>缓存的具体含义</h4><h5 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Buffers %lu</span><br><span class="line">    Relatively temporary storage <span class="keyword">for</span> raw disk blocks that shouldn<span class="string">&#x27;t get tremendously large (20MB or so).</span></span><br><span class="line"><span class="string">Cached %lu</span></span><br><span class="line"><span class="string">   In-memory cache for files read from the disk (the page cache).  Doesn&#x27;</span>t include SwapCached.</span><br><span class="line">SReclaimable %lu (since Linux 2.6.19)</span><br><span class="line">    Part of Slab, that might be reclaimed, such as caches.</span><br><span class="line">    </span><br><span class="line">SUnreclaim %lu (since Linux 2.6.19)</span><br><span class="line">    Part of Slab, that cannot be reclaimed on memory pressure.</span><br></pre></td></tr></table></figure>
<h5 id="具体解释"><a href="#具体解释" class="headerlink" title="具体解释"></a>具体解释</h5><ol>
<li>Buffers 是对原始磁盘块的临时存储，也就是用来<strong>缓存磁盘的数据</strong>，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等。</li>
<li>Cached 是从磁盘读取文件的页缓存，也就是用来<strong>缓存从文件读取的数据</strong>。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</li>
<li>SReclaimable 是 Slab 的一部分。Slab 包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。</li>
<li><strong>Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中</strong></li>
</ol>
<h3 id="PageCache数据结构"><a href="#PageCache数据结构" class="headerlink" title="PageCache数据结构"></a>PageCache数据结构</h3><ol>
<li>内存管理系统与Page Cache交互，负责维护每项 Page Cache 的分配和回收，同时在使用 memory map 方式访问时负责建立映射；</li>
<li>VFS 与Page Cache交互，负责 Page Cache 与用户空间的数据交换，即文件读写；</li>
<li>具体文件系统则一般只与 Buffer Cache 交互，它们负责在外围存储设备和 Buffer Cache 之间交换数据。</li>
<li>一个Page Cache包含多个Buffer Cache，一个Buffer Cache与一个磁盘块一一对应；假定了 Page 的大小是 4K，则文件的每个4K的数据块最多只能对应一个 Page Cache 项，它通过一个是 radix tree来管理文件块和page cache的映射关系，Radix tree 是一种搜索树，Linux 内核利用这个数据结构来通过文件内偏移快速定位 Cache 项。</li>
</ol>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598412861987.png" class title="1598412861987.png">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598412872367.png" class title="1598412872367.png">

</div>

<h2 id="为什么使用page-cache"><a href="#为什么使用page-cache" class="headerlink" title="为什么使用page cache"></a>为什么使用page cache</h2><p><strong>减少 I/O，提升应用的 I/O 速度</strong></p>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598412292674.png" class title="Linux 操作系统中文件 Cache 管理与内存管理以及文件系统的关系示意图">

</div>

<ol>
<li><strong>具体文件系统：</strong>，如 ext2/ext3、jfs、ntfs 等，负责在文件 Cache和存储设备之间交换数据</li>
<li><strong>虚拟文件系统VFS：</strong> 负责在应用程序和文件 Cache 之间通过 read/write 等接口交换数据</li>
<li><strong>内存管理系统：</strong> 负责文件 Cache 的分配和回收</li>
<li><strong>虚拟内存管理系统(VMM)：</strong> 则允许应用程序和文件 Cache 之间通过 memory map的方式交换数据</li>
<li><strong>在 Linux 系统中，文件 Cache 是内存管理系统、文件系统以及应用程序之间的一个联系枢纽</strong>。</li>
</ol>
<h2 id="page-cache的产生"><a href="#page-cache的产生" class="headerlink" title="page cache的产生"></a>page cache的产生</h2><h3 id="产生方式"><a href="#产生方式" class="headerlink" title="产生方式"></a>产生方式</h3><ol>
<li>Buffered I/O（标准 I/O）如：read/write/sendfile等；</li>
<li>Memory-Mapped I/O（存储映射 I/O）如：mmap；</li>
<li>sendfile和mmap都是零拷贝的实现方案。</li>
</ol>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1597749811737.png" class title="1597749811737.png">

</div>

<h3 id="产生方式的区别"><a href="#产生方式的区别" class="headerlink" title="产生方式的区别"></a>产生方式的区别</h3><ol>
<li>标准 I/O 是写的 (write(2)) 用户缓冲区 (Userpace Page 对应的内存)，然后再将用户缓冲区里的数据拷贝到内核缓冲区 (Pagecache Page 对应的内存)；如果是读的 (read(2)) 话则是先从内核缓冲区拷贝到用户缓冲区，再从用户缓冲区读数据，也就是 buffer 和文件内容不存在任何映射关系。</li>
<li>对于存储映射 I/O 而言，则是直接将 Pagecache Page 给映射到用户地址空间，用户直接读写 Pagecache Page 中内容。</li>
</ol>
<h3 id="常规文件读写"><a href="#常规文件读写" class="headerlink" title="常规文件读写"></a>常规文件读写</h3><p>FileChannel#read，FileChannel#write，共涉及四次上下文切换（内核态和用户态的切换，包括read调用，read返回，write调用，write返回）和四次数据拷贝。</p>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598421055864.png" class title="1598421055864.png">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598421062853.png" class title="1598421062853.png">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1597750033559.png" class title="1597750033559.png">

</div>

<h4 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/vmstat | egrep <span class="string">&quot;dirty|writeback&quot;</span></span><br><span class="line">nr_dirty 25</span><br><span class="line">nr_writeback 0</span><br><span class="line">nr_writeback_temp 0</span><br><span class="line">nr_dirty_threshold 94000</span><br><span class="line">nr_dirty_background_threshold 31333</span><br></pre></td></tr></table></figure>
<p>nr_dirty 表示当前系统中积压了多少脏页，nr_writeback 则表示有多少脏页正在回写到磁盘中，他们两个的单位都是 Page(4KB)。</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><ol>
<li>文件（page cache）直接映射到用户虚拟地址空间，内核态和用户态共享一片page cache，避免了一次数据拷贝</li>
<li>建立mmap之后，并不会立马加载数据到内存，只有真正使用数据时，才会引发缺页异常并加载数据到内存</li>
</ol>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598421396771.png" class title="1598421396771.png">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598421406978.png" class title="1598421406978.png">

</div>

<h4 id="memory-map具体步骤如下"><a href="#memory-map具体步骤如下" class="headerlink" title="memory map具体步骤如下"></a>memory map具体步骤如下</h4><ol>
<li>应用程序调用mmap（图中1），先到内核中</li>
<li>后调用do_mmap_pgoff（图中2），该函数从应用程序的地址空间中<strong>分配一段区域作为映射的内存地址</strong>，并使用一个VMA（vm_area_struct）结构代表该区域，</li>
<li>之后就返回到应用程序（图中3）</li>
<li>当应用程序访问mmap所返回的地址指针时（图中4），由于虚实映射尚未建立，会触发缺页中断（图中5）。之后系统会调用缺页中断处理函数（图中6），在缺页中断处理函数中，内核通过相应区域的VMA结构判断出该区域属于文件映射，于是调用具体文件系统的接口读入相应的Page Cache项（图中7、8、9），并填写相应的虚实映射表。</li>
<li>经过这些步骤之后，应用程序就可以正常访问相应的内存区域了。</li>
</ol>
<h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><ol>
<li>使用sendfile的方式避免了用户空间与内核空间的交互，复制次数减少到三次，内核态与用户态切换减少到两次。</li>
<li>在 Linux 内核 2.4 及后期版本中，针对套接字缓冲区描述符做了相应调整，DMA自带了收集功能，对于用户方面，用法还是一样。内部只把包含数据位置和长度信息的描述符追加到套接字缓冲区，DMA 引擎直接把数据从内核缓冲区传到协议引擎，从而消除了最后一次 CPU参与的拷贝动作。</li>
</ol>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598433791064.png" class title="1598433791064.png">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598433800506.png" class title="1598433800506.png">

</div>

<h3 id="顺序读写"><a href="#顺序读写" class="headerlink" title="顺序读写"></a>顺序读写</h3><h4 id="文件预读"><a href="#文件预读" class="headerlink" title="文件预读"></a>文件预读</h4><p>文件的预读机制，它是一种将磁盘块预读到page cache的机制,执行步骤如下：</p>
<ol>
<li>对于每个文件的<strong>第一个读请求</strong>，系统读入所请求的页面并读入紧随其后的少数几个页面(不少于一个页面，通常是三个页面)，这时的预读称为<strong>同步预读</strong>。</li>
<li>对于<strong>第二次读请求</strong>，如果所读页面不在Cache中，即不在前次预读的group中，则表明文件访问不是顺序访问，系统继续采用同步预读；如果所读页面在Cache中，则表明前次预读命中，操作系统把预读group扩大一倍，并让底层文件系统读入group中剩下尚不在Cache中的文件数据块，这时的预读称为<strong>异步预读</strong>。</li>
<li>无论第二次读请求是否命中，系统都要更新当前预读group的大小。</li>
<li>系统中定义了一个window，它包括前一次预读的group和本次预读的group。任何接下来的读请求都会处于两种情况之一：<ul>
<li>第一种情况是所请求的页面处于预读window中，这时继续进行异步预读并更新相应的window和group；</li>
<li>第二种情况是所请求的页面处于预读window之外，这时系统就要进行同步预读并重置相应的window和group。</li>
</ul>
</li>
</ol>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598434976482.png" class title="1598434976482.png">

</div>

<p>图中group指一次读入page cached的集合；window包括前一次预读的group和本次预读的group；浅灰色代表要用户想要查找的page cache，深灰色代表命中的page。</p>
<h4 id="顺序读写高效的原因"><a href="#顺序读写高效的原因" class="headerlink" title="顺序读写高效的原因"></a>顺序读写高效的原因</h4><div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598435243913.png" class title="1598435243913.png">

</div>

<p>以顺序读为例，当用户发起一个 fileChannel.read(4kb) 之后，实际发生了两件事</p>
<ol>
<li>操作系统从磁盘加载了 16kb 进入 PageCache，这被称为预读</li>
<li>操作通从 PageCache 拷贝 4kb 进入用户内存</li>
<li>当用户继续访问接下来的 [4kb,16kb] 的磁盘内容时，便是直接从 PageCache 去访问了</li>
</ol>
<h2 id="page-cache的消亡"><a href="#page-cache的消亡" class="headerlink" title="page cache的消亡"></a>page cache的消亡</h2><p>page cache的回收主要是针对free 命令中的 buff/cache 中的这些就是“活着”的 Page Cache。回收的过程如下图所示：</p>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1597750451415.png" class title="1597750451415.png">

</div>

<p>回收的方式主要是两种：直接回收和后台回收,具体的回收行为，可以使用以下命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sar -B 1</span><br><span class="line">Linux 3.10.0-1062.9.1.el7.x86_64 (instance-gctg007a) 	08/18/2020 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">07:34:59 PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff</span><br><span class="line">07:35:00 PM      0.00      0.00     66.00      0.00     58.00      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:01 PM      0.00     25.53   1893.62      0.00    608.51      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:02 PM      0.00      0.00    648.48      0.00    280.81      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:03 PM      0.00      0.00     17.00      0.00     19.00      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:04 PM      0.00      0.00   1096.04      0.00    295.05      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:05 PM      0.00      0.00     17.00      0.00     23.00      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:06 PM      0.00     52.00     17.00      0.00     19.00      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:07 PM      0.00      0.00     17.00      0.00     44.00      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:08 PM      0.00      0.00     18.00      0.00     19.00      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:09 PM      0.00      0.00     18.18      0.00     19.19      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:10 PM      0.00      0.00     17.00      0.00     19.00      0.00      0.00      0.00      0.00</span><br><span class="line">07:35:11 PM      0.00      0.00     17.00      0.00     19.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>
<ol>
<li>pgscank/s : kswapd(后台回收线程) 每秒扫描的 page 个数。</li>
<li>pgscand/s: Application 在内存申请过程中每秒直接扫描的 page 个数。</li>
<li>pgsteal/s: 扫描的 page 中每秒被回收的个数。</li>
<li>%vmeff: pgsteal/(pgscank+pgscand), 回收效率，越接近 100 说明系统越安全，越接近 0 说明系统内存压力越大。</li>
</ol>
<h3 id="sar-B与-proc-vmstat比对"><a href="#sar-B与-proc-vmstat比对" class="headerlink" title="sar -B与/proc/vmstat比对"></a>sar -B与/proc/vmstat比对</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#aaa;border-spacing:0;}
.tg td{background-color:#fff;border-color:#aaa;border-style:solid;border-width:1px;color:#333;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#f38630;border-color:#aaa;border-style:solid;border-width:1px;color:#fff;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-amwm">sar -B</th>
    <th class="tg-amwm">/proc/vmstat</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">pgscank</td>
    <td class="tg-0lax">pgscan_kswapd</td>
  </tr>
  <tr>
    <td class="tg-0lax">pgscand</td>
    <td class="tg-0lax">pgscan_direct</td>
  </tr>
  <tr>
    <td class="tg-0lax">pgsteal</td>
    <td class="tg-0lax">pgsteal_kswapd+pgsteal_direct</td>
  </tr>
</tbody>
</table>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="DMA（Direct-Memory-Access-直接存储器访问）"><a href="#DMA（Direct-Memory-Access-直接存储器访问）" class="headerlink" title="DMA（Direct Memory Access,直接存储器访问）"></a>DMA（Direct Memory Access,直接存储器访问）</h3><ol>
<li>DMA的出现就是为了解决批量数据的输入/输出问题。DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术</li>
<li>DMA控制器需要具备的功能：<ul>
<li>能向CPU发出系统保持信号，提出总线接管请求</li>
<li>当CPU同意接管请求之后，对总线的控制交给DMA</li>
<li><strong>能对存储器寻址及能修改地址指针，实现对内存的读写</strong></li>
<li>能决定本次DMA传送的字节数，判断DMA传送是否借宿</li>
<li>发送DMA结束信号，使CPU恢复正常工作状态</li>
</ul>
</li>
</ol>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598409974379.png" class title="1598409974379.png">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598409984707.png" class title="1598409984707.png">

</div>

<h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><h4 id="堆内存与堆外内存的关系"><a href="#堆内存与堆外内存的关系" class="headerlink" title="堆内存与堆外内存的关系"></a>堆内存与堆外内存的关系</h4><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax"></th>
    <th class="tg-0lax">堆内内存</th>
    <th class="tg-0lax">堆外内存</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">底层实现</td>
    <td class="tg-0lax">数组，JVM内存</td>
    <td class="tg-0lax">unsafe.allocateMemory(size)返回直接内存</td>
  </tr>
  <tr>
    <td class="tg-0lax">分配大小限制</td>
    <td class="tg-0lax">
    -Xms-Xmx，<br>
    数组大小，当前JVM free memory大于1.5G时，ByteBuffer.allocate(900M)会报错
    </td>
    <td class="tg-0lax">-XX:MaxDirectMemorySize参数从JVM层面限制，同时受到机器虚拟内存的限制</td>
  </tr>
  <tr>
    <td class="tg-0lax">垃圾回收</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">
    当前DirectByteBuffer不再被使用时，会触发内部cleaner的钩子
    <br>保险起见，可以考虑手动回收
    <br>((DirectBuffer)buffer).cleaner().clean()</td>
  </tr>
  <tr>
    <td class="tg-0lax">内存复制</td>
    <td class="tg-0lax">堆内内存---堆外内存---pageCache</td>
    <td class="tg-0lax">堆外内存--pageCache</td>
  </tr>
</tbody>
</table>

<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol>
<li>当需要申请大块的内存时，堆内内存会受到限制，只能分配堆外内存。</li>
<li>堆外内存适用于生命周期中等或较长的对象。(如果是生命周期较短的对象，在 YGC 的时候就被回收了，就不存在大内存且生命周期较长的对象在 FGC 对应用造成的性能影响)。</li>
<li>堆内内存刷盘的过程中，还需要复制一份到堆外内存，这部分内容可以在 FileChannel 的实现源码中看到细节<ul>
<li> 使用 HeapByteBuffer 读写都会经过 DirectByteBuffer，写入数据的流转方式其实是：HeapByteBuffer -&gt; DirectByteBuffer -&gt; PageCache -&gt; Disk，读取数据的流转方式正好相反。</li>
<li> 使用 HeapByteBuffer 读写会申请一块跟线程绑定的 DirectByteBuffer。这意味着，线程越多，临时 DirectByteBuffer 就越会占用越多的空间。</li>
</ul>
</li>
<li>堆外内存就是把内存对象分配在Java虚拟机堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</li>
<li>内存回收流程</li>
</ol>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598440617394.png" class title="1598440617394.png">

</div>

<h2 id="PageCache内存回收"><a href="#PageCache内存回收" class="headerlink" title="PageCache内存回收"></a>PageCache内存回收</h2><h3 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h3><p>在内存紧张的时候会触发内存回收，内存回收会尝试去回收reclaimable（可被回收）的内存。包括<strong>PageCache以及reclaimable kernel memory（比如slab）</strong>。</p>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598493313084.png" class title="1598493313084.png">

</div>

<h3 id="避免PageCache回收出现的性能问题"><a href="#避免PageCache回收出现的性能问题" class="headerlink" title="避免PageCache回收出现的性能问题"></a>避免PageCache回收出现的性能问题</h3><h4 id="memory-cgroup-protection"><a href="#memory-cgroup-protection" class="headerlink" title="memory cgroup protection"></a>memory cgroup protection</h4><div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1598493920439.png" class title="1598493920439.png">

</div>

<ol>
<li><strong>memory.max</strong>：memory cgroup 内的进程最多能够分配的内存，如果不设置的话，就默认不做内存大小的限制</li>
<li><strong>memory.high</strong>：当 memory cgroup 内进程的内存使用量超过了该值后就会立即被回收掉，目的是为了<strong>尽快的回收掉不活跃的 Page Cache</strong>。</li>
<li><strong>memory.low</strong>：用来保护重要数据的，当 memory cgroup 内进程的内存使用量低于了该值后，在内存紧张触发回收后就会先去回收不属于该 memory cgroup 的 Page Cache，等到其他的 Page Cache 都被回收掉后再来回收这些 Page Cache。</li>
<li><strong>memory.min</strong>：用来保护重要数据的，只不过与 memoy.low 有所不同的是，当 memory cgroup 内进程的内存使用量低于该值后，即使其他不在该 memory cgroup 内的 Page Cache 都被回收完了也不会去回收这些 Page Cache。</li>
<li><strong>总结：如果你想要保护你的 Page Cache 不被回收，你就可以考虑将你的业务进程放在一个 memory cgroup 中，然后设置 memory.{min,low} 来进行保护；与之相反，如果你想要尽快释放你的 Page Cache，那你可以考虑设置 memory.high 来及时的释放掉不活跃的 Page Cache。</strong></li>
</ol>
<h3 id="出现load过高的原因"><a href="#出现load过高的原因" class="headerlink" title="出现load过高的原因"></a>出现load过高的原因</h3><h4 id="直接内存回收引起"><a href="#直接内存回收引起" class="headerlink" title="直接内存回收引起"></a>直接内存回收引起</h4><h5 id="内存回收过程"><a href="#内存回收过程" class="headerlink" title="内存回收过程"></a>内存回收过程</h5><div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1602664770697.png" class title="1602664770697.png">

</div>

<p>后台回收原理：</p>
<div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1602664859410.png" class title="1602664859410.png">

</div>

<p>通过调整参数vm.min_free_kbytes来提高后台进程回收频率。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/vm/min_free_kbytes</span><br><span class="line">vi /etc/sysctl.conf vm.min_free_kbytes=524288 </span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p>通过调整内存水位，在一定程度上保障了应用的内存申请，但是同时也带来了一定的内存浪费，因为系统始终要保障有这么多的 free 内存，这就压缩了 Page Cache 的空间。调整的效果你可以通过 /proc/zoneinfo 来观察</p>
<h4 id="系统中脏页积压过多"><a href="#系统中脏页积压过多" class="headerlink" title="系统中脏页积压过多"></a>系统中脏页积压过多</h4><h5 id="内存申请过程"><a href="#内存申请过程" class="headerlink" title="内存申请过程"></a>内存申请过程</h5><div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1602665372291.png" class title="1602665372291.png">

</div>

<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>设置配置：/proc/vmstat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vm.dirty_background_bytes = 0</span><br><span class="line">vm.dirty_background_ratio = 10</span><br><span class="line">vm.dirty_bytes = 0</span><br><span class="line">vm.dirty_expire_centisecs = 3000</span><br><span class="line">vm.dirty_ratio = 20</span><br></pre></td></tr></table></figure>
<h4 id="系统numa策略配置不当"><a href="#系统numa策略配置不当" class="headerlink" title="系统numa策略配置不当"></a>系统numa策略配置不当</h4><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h3 id="OOM-KILL逻辑"><a href="#OOM-KILL逻辑" class="headerlink" title="OOM KILL逻辑"></a>OOM KILL逻辑</h3><div align="center">

<img src="/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/1602661306900.png" class title="1602661306900.png">

</div>

<p>可以调整oom_score_adj来防止进程被杀掉（不建议配置）</p>
<h3 id="如何观察内核内存泄漏"><a href="#如何观察内核内存泄漏" class="headerlink" title="如何观察内核内存泄漏"></a>如何观察内核内存泄漏</h3><ol>
<li>如果 /proc/meminfo 中内核内存（比如 VmallocUsed 和 SUnreclaim）太大，那很有可能发生了内核内存泄漏</li>
<li>周期性地观察 VmallocUsed 和 SUnreclaim 的变化，如果它们持续增长而不下降，也可能是发生了内核内存泄漏</li>
<li>通过 /proc/vmallocinfo 来看到该模块的内存使用情况</li>
<li>kmemleak 内核内存分析工具</li>
</ol>
<h3 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#aaa;border-spacing:0;}
.tg td{background-color:#fff;border-color:#aaa;border-style:solid;border-width:1px;color:#333;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#f38630;border-color:#aaa;border-style:solid;border-width:1px;color:#fff;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-1wig{font-weight:bold;text-align:left;vertical-align:top}
.tg .tg-7ivu{background-color:#fffc9e;font-weight:bold;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">/proc/meminfo</th>
    <th class="tg-1wig">含义以及排查思路</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-7ivu">Active(anon)</td>
    <td class="tg-0lax">在active anon lru的page，与下一项相互转换</td>
  </tr>
  <tr>
    <td class="tg-7ivu">Inactive(anon)</td>
    <td class="tg-0lax">在inactive anonlru的page，可以交换到swap分区，（active anno也是）但是不能回收<br>程序使用malloc()或mmap()匿名方式申请并且写后的内存。如果过大，排除思路：<br>1.使用top找出内存消耗最大的进程<br>2.使用pmap分析该进程<br>3.如果没有任何进程内存开销大，则重点排除tmpfs</td>
  </tr>
  <tr>
    <td class="tg-7ivu">Unevictable</td>
    <td class="tg-0lax">在系统内存紧张时不能被回收，主要组成：<br>1.ram disk或ramfs消耗的内存<br>2.以SHM_LOCK方式申请的Shmem<br>3.使用mlock()序列函数来管理的内存</td>
  </tr>
  <tr>
    <td class="tg-7ivu">Mlocked</td>
    <td class="tg-0lax">属于Unevictable的一种，重点排除mlock()方式包含的内存</td>
  </tr>
  <tr>
    <td class="tg-7ivu">AnonPages</td>
    <td class="tg-0lax">AnonPages！=Active（anon）+Inactive（anon）<br>因为shmem（包括tmpfs）虽然属于active（anon）或Inactive（anon），但是他们有自己的内存文件，所以不属于AnonPages<br>active anon和Inactive anon表示不可回收但是可以被交换到swap分区的内存<br>AnonPages没有对应文件的内存<br>排除malloc()方式申请的内存或mmap（PROT_WRITE,MAP_ANON|MAP_PRIVATE）方式申请的内存</td>
  </tr>
  <tr>
    <td class="tg-7ivu">Mapped</td>
    <td class="tg-0lax">使用mmap（2）申请，没有被unmap的内存；unmap包含主动调用unmap（2）以及内核内存回收时的unmap<br>排查mmap（）申请的内存</td>
  </tr>
  <tr>
    <td class="tg-7ivu">Shmem</td>
    <td class="tg-0lax">共享内存，特别注意tmpfs，排查思路<br>1. 使用top找出shr最大的进程<br>2.使用pmap分析该进程<br>3.如果没有任何进程消耗shr内存，则重点排查tmpfs</td>
  </tr>
  <tr>
    <td class="tg-7ivu">Slab</td>
    <td class="tg-0lax">分为可被回收（SReclaimable）和不可以被回收（SUnreclaim），其中不可被回收的slab如果发生泄漏，<br>比如kmalloc申请的内存没有释放，排查思路<br>1.使用slaptop分析slab最大的数据<br>2.排查驱动程序以kmalloc(）方式申请的内存</td>
  </tr>
  <tr>
    <td class="tg-7ivu">VmallocUsed</td>
    <td class="tg-0lax">通过vmalloc分配的内核内存，可以使用/proc/vmallocinfo，来判断哪些驱动程序以vmalloc方式申请的内存较多<br>可以尝试卸载驱动，释放内存</td>
  </tr>
</tbody>
</table>

<ol>
<li>应用程序可以通过 malloc() 和 free() 在用户态申请和释放内存，与之对应，可以通过 kmalloc()/kfree() 以及 vmalloc()/vfree() 在内核态申请和释放内存</li>
<li>vmalloc 申请的内存会体现在 VmallocUsed 这一项中，即已使用的 Vmalloc 区大小；而 kmalloc 申请的内存则是体现在 Slab 这一项中，它又分为两部分，其中 SReclaimable 是指在内存紧张的时候可以被回收的内存，而 SUnreclaim 则是不可以被回收只能主动释放的内存。</li>
</ol>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="清理缓存buffer-cache"><a href="#清理缓存buffer-cache" class="headerlink" title="清理缓存buffer/cache"></a>清理缓存buffer/cache</h3><h4 id="运行sync将dirty的内容写回硬盘"><a href="#运行sync将dirty的内容写回硬盘" class="headerlink" title="运行sync将dirty的内容写回硬盘"></a>运行sync将dirty的内容写回硬盘</h4><h4 id="通过修改proc系统的drop-caches清理free的cache"><a href="#通过修改proc系统的drop-caches清理free的cache" class="headerlink" title="通过修改proc系统的drop_caches清理free的cache"></a>通过修改proc系统的drop_caches清理free的cache</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">说明</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches:表示清除pagecache。 </span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches:表示清除回收slab分配器中的对象（包括目录项缓存和inode缓存）。slab分配器是内核中管理内存的一种机制，其中很多缓存数据实现都是用的pagecache。 </span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches:表示清除pagecache和slab分配器中的缓存对象。</span><br></pre></td></tr></table></figure>
<p>可以通过<code>/proc/vmstat</code>文件判断是否执行过drop_caches：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># cat /proc/vmstat | grep drop</span></span><br><span class="line">drop_pagecache 0</span><br><span class="line">drop_slab 0</span><br></pre></td></tr></table></figure>
<h4 id="可以调用crond定时任务：每10分钟执行一次"><a href="#可以调用crond定时任务：每10分钟执行一次" class="headerlink" title="可以调用crond定时任务：每10分钟执行一次"></a>可以调用crond定时任务：每10分钟执行一次</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*/10 * * * * sync;<span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches;  </span><br></pre></td></tr></table></figure>
<h3 id="重要配置参数"><a href="#重要配置参数" class="headerlink" title="重要配置参数"></a>重要配置参数</h3><h4 id="proc-sys-vm-dirty-ratio（同步刷盘）"><a href="#proc-sys-vm-dirty-ratio（同步刷盘）" class="headerlink" title="/proc/sys/vm/dirty_ratio（同步刷盘）"></a>/proc/sys/vm/dirty_ratio（同步刷盘）</h4><p>这个参数控制文件系统的文件系统写缓冲区的大小，单位是百分比，表示系统内存的百分比，<strong>表示当写缓冲使用到系统内存多少的时候，开始向磁盘写出数据</strong>。增大之会使用更多系统内存用于磁盘写缓冲，也可以极大提高系统的写性能。但是，当你需要持续、恒定的写入场合时，应该降低其数值，一般启动上缺省是 10。设1加速程序速度</p>
<h4 id="proc-sys-vm-dirty-background-ratio（异步刷盘）"><a href="#proc-sys-vm-dirty-background-ratio（异步刷盘）" class="headerlink" title="/proc/sys/vm/dirty_background_ratio（异步刷盘）"></a>/proc/sys/vm/dirty_background_ratio（异步刷盘）</h4><p>这个参数控制文件系统的pdflush进程，在何时刷新磁盘。单位是百分比，<strong>表示系统内存的百分比，意思是当写缓冲使用到系统内存多少的时 候，pdflush开始向磁盘写出数据</strong>。增大之会使用更多系统内存用于磁盘写缓冲，也可以极大提高系统的写性能。但是，当你需要持续、恒定的写入场合时， 应该降低其数值，一般启动上缺省是 5</p>
<h4 id="proc-sys-vm-dirty-writeback-centisecs"><a href="#proc-sys-vm-dirty-writeback-centisecs" class="headerlink" title="/proc/sys/vm/dirty_writeback_centisecs"></a>/proc/sys/vm/dirty_writeback_centisecs</h4><p>这个参数控制内核的脏数据刷新进程pdflush的运行间隔。单位是 1/100 秒。缺省数值是500，也就是 5 秒。如果你的系统是持续地写入动作，那么实际上还是降低这个数值比较好，这样可以把尖峰的写操作削平成多次写操</p>
<h4 id="proc-sys-vm-dirty-expire-centisecs"><a href="#proc-sys-vm-dirty-expire-centisecs" class="headerlink" title="/proc/sys/vm/dirty_expire_centisecs"></a>/proc/sys/vm/dirty_expire_centisecs</h4><p>这个参数声明Linux内核写缓冲区里面的数据多“旧”了之后，pdflush进程就开始考虑写到磁盘中去。单位是 1/100秒。缺省是 30000，也就是 30 秒的数据就算旧了，将会刷新磁盘。对于特别重载的写操作来说，这个值适当缩小也是好的，但也不能缩小太多，因为缩小太多也会导致IO提高太快。建议设置为 1500，也就是15秒算旧。 </p>
<h4 id="proc-sys-vm-drop-caches"><a href="#proc-sys-vm-drop-caches" class="headerlink" title="/proc/sys/vm/drop_caches"></a>/proc/sys/vm/drop_caches</h4><p>释放已经使用的cache</p>
<h4 id="proc-sys-vm-page-cluster"><a href="#proc-sys-vm-page-cluster" class="headerlink" title="/proc/sys/vm/page_cluster"></a>/proc/sys/vm/page_cluster</h4><p>该文件表示在写一次到swap区的时候写入的页面数量，0表示1页，1表示2页，2表示4页。</p>
<h4 id="proc-sys-vm-swapiness"><a href="#proc-sys-vm-swapiness" class="headerlink" title="/proc/sys/vm/swapiness"></a>/proc/sys/vm/swapiness</h4><p>该文件表示系统进行交换行为的程度，数值（0-100）越高，越可能发生磁盘交换。</p>
<h4 id="proc-sys-vm-vfs-cache-pressure"><a href="#proc-sys-vm-vfs-cache-pressure" class="headerlink" title="/proc/sys/vm/vfs_cache_pressure"></a>/proc/sys/vm/vfs_cache_pressure</h4><p>该文件表示内核回收用于directory和inode cache内存的倾向</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.kernel.org/doc/Documentation/filesystems/proc.rst">proc帮助手册</a></li>
<li><a href="linux-performance-analysis-tools.md">常用性能分析工具</a></li>
<li><a href="https://blog.csdn.net/a1240466196/article/details/106456200">NIO进阶篇：Page Cache、零拷贝、顺序读写、堆外内存</a></li>
<li><a href="https://www.imooc.com/article/301624">面试官：RocketMQ 如何基于mmap+page cache实现磁盘文件的高性能读写？</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_448574810101k1va.html">文件系统缓存dirty_ratio与dirty_background_ratio两个参数区别</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/42364591">PageCache系列之五 统一缓存之PageCache</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>PageCache</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令之netstat/ss</title>
    <url>/2021/02/05/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bnetstat-ss/</url>
    <content><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。<br>在Linux下，如果连接数比较大，可以使用效率更高的ss来替代netstat。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r         netstat &#123;-V|--version|-h|--<span class="built_in">help</span>&#125;</span><br><span class="line">       netstat [-vWnNcaeol] [&lt;Socket&gt; ...]</span><br><span class="line">       netstat &#123; [-vWeenNac] -I[&lt;Iface&gt;] | [-veenNac] -i | [-cnNe] -M | -s [-6tuw] &#125; [delay]</span><br><span class="line"></span><br><span class="line">        -r, --route              display routing table</span><br><span class="line">        -I, --interfaces=&lt;Iface&gt; display interface table <span class="keyword">for</span> &lt;Iface&gt;</span><br><span class="line">        -i, --interfaces         display interface table</span><br><span class="line">        -g, --groups             display multicast group memberships</span><br><span class="line">        -s, --statistics         display networking statistics (like SNMP)</span><br><span class="line">        -M, --masquerade         display masqueraded connections</span><br><span class="line"></span><br><span class="line">        -v, --verbose            be verbose</span><br><span class="line">        -W, --wide               don<span class="string">&#x27;t truncate IP addresses</span></span><br><span class="line"><span class="string">        -n, --numeric            don&#x27;</span>t resolve names</span><br><span class="line">        --numeric-hosts          don<span class="string">&#x27;t resolve host names</span></span><br><span class="line"><span class="string">        --numeric-ports          don&#x27;</span>t resolve port names</span><br><span class="line">        --numeric-users          don<span class="string">&#x27;t resolve user names</span></span><br><span class="line"><span class="string">        -N, --symbolic           resolve hardware names</span></span><br><span class="line"><span class="string">        -e, --extend             display other/more information</span></span><br><span class="line"><span class="string">        -p, --programs           display PID/Program name for sockets</span></span><br><span class="line"><span class="string">        -o, --timers             display timers</span></span><br><span class="line"><span class="string">        -c, --continuous         continuous listing</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        -l, --listening          display listening server sockets</span></span><br><span class="line"><span class="string">        -a, --all                display all sockets (default: connected)</span></span><br><span class="line"><span class="string">        -F, --fib                display Forwarding Information Base (default)</span></span><br><span class="line"><span class="string">        -C, --cache              display routing cache instead of FIB</span></span><br><span class="line"><span class="string">        -Z, --context            display SELinux security context for sockets</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;Socket&gt;=&#123;-t|--tcp&#125; &#123;-u|--udp&#125; &#123;-U|--udplite&#125; &#123;-S|--sctp&#125; &#123;-w|--raw&#125;</span></span><br><span class="line"><span class="string">           &#123;-x|--unix&#125; --ax25 --ipx --netrom</span></span><br><span class="line"><span class="string">  &lt;AF&gt;=Use &#x27;</span>-6|-4<span class="string">&#x27; or &#x27;</span>-A &lt;af&gt;<span class="string">&#x27; or &#x27;</span>--&lt;af&gt;<span class="string">&#x27;; default: inet</span></span><br><span class="line"><span class="string">  List of possible address families (which support routing):</span></span><br><span class="line"><span class="string">    inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25) </span></span><br><span class="line"><span class="string">    netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP) </span></span><br><span class="line"><span class="string">    x25 (CCITT X.25) </span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 instance-gctg007a:ssh   ip152.ip-66-70-13:35204 ESTABLISHED</span><br><span class="line">tcp        0      0 instance-gctg007a:42940 100.64.253.36:tdp-suite ESTABLISHED</span><br><span class="line">tcp        0      0 instance-gctg007a:53248 100.64.253.:radius-acct ESTABLISHED</span><br><span class="line">tcp        0      0 instance-gctg007a:52486 100.64.253.41:http      ESTABLISHED</span><br><span class="line">tcp        0      0 instance-gctg007a:ssh   58.56.96.27:59100       ESTABLISHED</span><br><span class="line">tcp        0      0 instance-gctg007a:52504 100.64.253.41:http      ESTABLISHED</span><br><span class="line">tcp6       0      0 localhost:781           localhost:44440         TIME_WAIT  </span><br><span class="line">tcp6       0      0 localhost:781           localhost:44446         TIME_WAIT  </span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    128926   /var/run/chrony/chronyd.sock</span><br><span class="line">unix  2      [ ]         DGRAM                    13279    /run/systemd/shutdownd</span><br><span class="line">unix  3      [ ]         DGRAM                    7391     /run/systemd/notify</span><br><span class="line">unix  2      [ ]         DGRAM                    7393     /run/systemd/cgroups-agent</span><br><span class="line">unix  6      [ ]         DGRAM                    7405     /run/systemd/journal/socket</span><br><span class="line">unix  14     [ ]         DGRAM                    7407     /dev/<span class="built_in">log</span></span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     243842   /run/systemd/journal/stdout</span><br></pre></td></tr></table></figure>
<h3 id="有源TCP连接"><a href="#有源TCP连接" class="headerlink" title="有源TCP连接"></a>有源TCP连接</h3><p>Active Internet connections，称为有源TCP连接，其中”Recv-Q”和”Send-Q”指的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。</p>
<h3 id="有源Unix域套接口"><a href="#有源Unix域套接口" class="headerlink" title="有源Unix域套接口"></a>有源Unix域套接口</h3><p>Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。</p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul>
<li>Proto显示连接使用的协议</li>
<li>RefCnt表示连接到本套接口上的进程号</li>
<li>Types显示套接口的类型</li>
<li>State显示套接口当前的状态</li>
<li>Path表示连接到套接口的其它进程使用的路径名</li>
</ul>
<h3 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h3><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;border-color:#bbb;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#bbb;color:#594F4F;background-color:#E0FFEB;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#bbb;color:#493F3F;background-color:#9DE0AD;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1">CLOSED</th>
    <th class="tg-0lax">初始（无连接）状态</th>
  </tr>
  <tr>
    <td class="tg-cly1">LISTEN</td>
    <td class="tg-0lax">侦听状态，等待远程机器的连接请求</td>
  </tr>
  <tr>
    <td class="tg-cly1">SYN_SEND</td>
    <td class="tg-0lax">在TCP三次握手期间，主动连接端发送了SYN包后，进入SYN_SEND状态，等待对方的ACK包</td>
  </tr>
  <tr>
    <td class="tg-cly1">SYN_RECV</td>
    <td class="tg-0lax">在TCP三次握手期间，主动连接端收到SYN包后，进入SYN_RECV状态</td>
  </tr>
  <tr>
    <td class="tg-cly1">ESTABLISHED</td>
    <td class="tg-0lax">完成TCP三次握手后，主动连接端进入ESTABLISHED状态。此时，TCP连接已经建立，可以进行通信</td>
  </tr>
  <tr>
    <td class="tg-cly1">FIN_WAIT_1</td>
    <td class="tg-0lax">在TCP四次挥手时，主动关闭端发送FIN包后，进入FIN_WAIT_1状态</td>
  </tr>
  <tr>
    <td class="tg-cly1">FIN_WAIT_2</td>
    <td class="tg-0lax">在TCP四次挥手时，主动关闭端收到ACK包后，进入FIN_WAIT_2状态</td>
  </tr>
  <tr>
    <td class="tg-cly1">TIME_WAIT</td>
    <td class="tg-0lax">在TCP四次挥手时，主动关闭端发送了ACK包之后，进入TIME_WAIT状态，等待最多MSL时间，让被动关闭端收到ACK包</td>
  </tr>
  <tr>
    <td class="tg-cly1">CLOSING</td>
    <td class="tg-0lax">在TCP四次挥手期间，主动关闭端发送了FIN包后，没有收到对应的ACK包，却收到对方的FIN包，此时，进入CLOSING状态</td>
  </tr>
  <tr>
    <td class="tg-cly1">CLOSE_WAIT</td>
    <td class="tg-0lax">在TCP四次挥手期间，被动关闭端收到FIN包后，进入CLOSE_WAIT状态</td>
  </tr>
  <tr>
    <td class="tg-0lax">LAST_ACK</td>
    <td class="tg-0lax">在TCP四次挥手时，被动关闭端发送FIN包后，进入LAST_ACK状态，等待对方的ACK包</td>
  </tr>
</table>

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;border-color:#bbb;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#bbb;color:#594F4F;background-color:#E0FFEB;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#bbb;color:#493F3F;background-color:#9DE0AD;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1">主动连接端可能的状态有</th>
    <th class="tg-0lax">CLOSED        SYN_SEND        ESTABLISHED</th>
  </tr>
  <tr>
    <td class="tg-cly1">主动关闭端可能的状态有</td>
    <td class="tg-0lax">FIN_WAIT_1    FIN_WAIT_2      TIME_WAIT</td>
  </tr>
  <tr>
    <td class="tg-cly1">被动连接端可能的状态有</td>
    <td class="tg-0lax">LISTEN        SYN_RECV        ESTABLISHED</td>
  </tr>
  <tr>
    <td class="tg-cly1">被动关闭端可能的状态有</td>
    <td class="tg-0lax">CLOSE_WAIT    LAST_ACK        CLOSED</td>
  </tr>
</table>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="显示网卡列表"><a href="#显示网卡列表" class="headerlink" title="显示网卡列表"></a>显示网卡列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat -i</span></span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">docker0          1500        0      0      0 0             0      0      0      0 BMU</span><br><span class="line">eth0             1500 24097762      0      0 0      24283960      0      0      0 BMRU</span><br><span class="line">lo              65536  5213562      0      0 0       5213562      0      0      0 LRU</span><br></pre></td></tr></table></figure>
<h3 id="显示组播信息"><a href="#显示组播信息" class="headerlink" title="显示组播信息"></a>显示组播信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat -g</span></span><br><span class="line">IPv6/IPv4 Group Memberships</span><br><span class="line">Interface       RefCnt Group</span><br><span class="line">--------------- ------ ---------------------</span><br><span class="line">lo              1      all-systems.mcast.net</span><br><span class="line">eth0            1      all-systems.mcast.net</span><br><span class="line">docker0         1      all-systems.mcast.net</span><br><span class="line">lo              1      ff02::1</span><br><span class="line">lo              1      ff01::1</span><br><span class="line">eth0            1      ff02::202</span><br><span class="line">eth0            1      ff02::1:ff55:3dea</span><br><span class="line">eth0            1      ff02::1</span><br><span class="line">eth0            1      ff01::1</span><br><span class="line">docker0         1      ff02::1</span><br><span class="line">docker0         1      ff01::1</span><br></pre></td></tr></table></figure>
<h3 id="显示网络统计"><a href="#显示网络统计" class="headerlink" title="显示网络统计"></a>显示网络统计</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat -s | more 4</span></span><br><span class="line">Ip:</span><br><span class="line">    29005184 total packets received</span><br><span class="line">    0 forwarded</span><br><span class="line">    18 with unknown protocol</span><br><span class="line">    0 incoming packets discarded</span><br><span class="line">    29005160 incoming packets delivered</span><br><span class="line">    29191565 requests sent out</span><br></pre></td></tr></table></figure>
<h3 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat -lntup</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      1162/mysqld         </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2099/sshd           </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      2055/master         </span><br><span class="line">tcp6       0      0 :::781                  :::*                    LISTEN      2145/./bcm-agent    </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      2099/sshd           </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      2055/master         </span><br><span class="line">udp        0      0 0.0.0.0:68              0.0.0.0:*                           1580/dhclient       </span><br><span class="line">udp        0      0 0.0.0.0:111             0.0.0.0:*                           1/systemd           </span><br><span class="line">udp        0      0 127.0.0.1:323           0.0.0.0:*                           13421/chronyd       </span><br><span class="line">udp        0      0 0.0.0.0:827             0.0.0.0:*                           13372/rpcbind       </span><br><span class="line">udp6       0      0 :::111                  :::*                                1/systemd           </span><br><span class="line">udp6       0      0 ::1:323                 :::*                                13421/chronyd       </span><br><span class="line">udp6       0      0 :::827                  :::*                                13372/rpcbind</span><br></pre></td></tr></table></figure>
<h3 id="显示关于以太网的统计数据"><a href="#显示关于以太网的统计数据" class="headerlink" title="显示关于以太网的统计数据"></a>显示关于以太网的统计数据</h3><p>用于显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。这个选项可以用来统计一些基本的网络流量）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat -e</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode     </span><br><span class="line">tcp        0      0 instance-gctg007a:52948 100.64.253.41:http      ESTABLISHED root       41318395  </span><br><span class="line">tcp        0      0 localhost:44890         localhost:781           ESTABLISHED root       41318388  </span><br><span class="line">tcp        0      0 instance-gctg007a:42940 100.64.253.36:tdp-suite ESTABLISHED root       41007269  </span><br><span class="line">tcp        0      0 instance-gctg007a:53248 100.64.253.:radius-acct ESTABLISHED root       41007268  </span><br><span class="line">tcp        0      0 instance-gctg007a:ssh   188.131.142.109:51650   ESTABLISHED root       41318433  </span><br><span class="line">tcp        0      0 instance-gctg007a:ssh   58.56.96.27:59100       ESTABLISHED root       41305929  </span><br><span class="line">tcp        0      0 instance-gctg007a:50304 100.64.253.42:http      ESTABLISHED root       41318403  </span><br><span class="line">tcp6       0      0 localhost:781           localhost:44886         TIME_WAIT   root       0         </span><br><span class="line">tcp6       0      0 localhost:781           localhost:44890         ESTABLISHED root       41318389  </span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    128926   /var/run/chrony/chronyd.sock</span><br><span class="line">unix  2      [ ]         DGRAM                    13279    /run/systemd/shutdownd</span><br><span class="line">unix  3      [ ]         DGRAM                    7391     /run/systemd/notify</span><br><span class="line">unix  2      [ ]         DGRAM                    7393     /run/systemd/cgroups-agent</span><br><span class="line">unix  6      [ ]         DGRAM                    7405     /run/systemd/journal/socket</span><br><span class="line">unix  15     [ ]         DGRAM                    7407     /dev/<span class="built_in">log</span></span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     243842   /run/systemd/journal/stdout</span><br></pre></td></tr></table></figure>
<h3 id="显示路由信息"><a href="#显示路由信息" class="headerlink" title="显示路由信息"></a>显示路由信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat -r</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">default         gateway         0.0.0.0         UG        0 0          0 eth0</span><br><span class="line">169.254.169.254 192.168.16.2    255.255.255.255 UGH       0 0          0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U         0 0          0 docker0</span><br><span class="line">192.168.16.0    0.0.0.0         255.255.240.0   U         0 0          0 eth0</span><br></pre></td></tr></table></figure>
<h3 id="统计机器中网络连接各个状态个数"><a href="#统计机器中网络连接各个状态个数" class="headerlink" title="统计机器中网络连接各个状态个数"></a>统计机器中网络连接各个状态个数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat -an | awk &#x27;/^tcp/ &#123;++S[$NF]&#125;  END &#123;for (a in S) print a,S[a]&#125; &#x27;</span></span><br><span class="line">LISTEN 8</span><br><span class="line">SYN_RECV 2</span><br><span class="line">ESTABLISHED 5</span><br><span class="line">TIME_WAIT 2</span><br></pre></td></tr></table></figure>
<h3 id="查看连接某服务端口最多的的IP地址"><a href="#查看连接某服务端口最多的的IP地址" class="headerlink" title="查看连接某服务端口最多的的IP地址"></a>查看连接某服务端口最多的的IP地址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat -ant|grep &quot;127.*&quot;|awk &#x27;&#123;print $5&#125;&#x27;|awk -F: &#x27;&#123;print $1&#125;&#x27;|sort -nr|uniq -c</span></span><br><span class="line">      4 127.0.0.1</span><br><span class="line">      1 0.0.0.0</span><br></pre></td></tr></table></figure>
<h3 id="找出程序运行的端口"><a href="#找出程序运行的端口" class="headerlink" title="找出程序运行的端口"></a>找出程序运行的端口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat -ap | grep ssh</span></span><br><span class="line">tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN      2099/sshd           </span><br><span class="line">tcp        0      0 instance-gctg007a:ssh   58.56.96.27:59100       ESTABLISHED 14074/sshd: root@pt </span><br><span class="line">tcp        0      0 instance-gctg007a:ssh   67.205.138.198:42924    ESTABLISHED 14679/sshd: root [p </span><br><span class="line">tcp       23      0 instance-gctg007a:ssh   193-93-12-122.sol:41056 ESTABLISHED 14678/sshd: [accept </span><br><span class="line">tcp6       0      0 [::]:ssh                [::]:*                  LISTEN      2099/sshd           </span><br><span class="line">unix  2      [ ]         DGRAM                    41319468 14678/sshd: [accept  </span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     41319497 14680/sshd: root [n  </span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     41319498 14679/sshd: root [p  </span><br><span class="line">unix  2      [ ]         DGRAM                    41319513 14679/sshd: root [p  </span><br><span class="line">unix  2      [ ]         DGRAM                    41306028 14074/sshd: root@pt  </span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     20226    2099/sshd </span><br></pre></td></tr></table></figure>
<h3 id="在-netstat-输出中显示-TCP连接信息"><a href="#在-netstat-输出中显示-TCP连接信息" class="headerlink" title="在 netstat 输出中显示 TCP连接信息"></a>在 netstat 输出中显示 TCP连接信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@instance-gctg007a ~]<span class="comment"># netstat -pt</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 instance-gctg007a:53010 100.64.253.41:http      ESTABLISHED 2145/./bcm-agent    </span><br><span class="line">tcp        0      0 instance-gctg007a:42940 100.64.253.36:tdp-suite ESTABLISHED 20485/hosteye       </span><br><span class="line">tcp        0      0 instance-gctg007a:53248 100.64.253.:radius-acct ESTABLISHED 20485/hosteye       </span><br><span class="line">tcp        0      0 instance-gctg007a:53008 100.64.253.41:http      ESTABLISHED 2145/./bcm-agent    </span><br><span class="line">tcp        0      0 instance-gctg007a:ssh   58.56.96.27:59100       ESTABLISHED 14074/sshd: root@pt </span><br><span class="line">tcp6       0      0 localhost:781           localhost:44944         TIME_WAIT   -                   </span><br><span class="line">tcp6       0      0 localhost:781           localhost:44948         TIME_WAIT   -  </span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h3><p>ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。<br>ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。原因如下：</p>
<ol>
<li>当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。当服务器维持的连接达到上万个的时候，使用netstat等于浪费 生命，而用ss才是节省时间。</li>
<li>而ss快的秘诀在于它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢（但仍然比 netstat要快）。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/ftl1012/p/netstat.html">Linux netstat命令详解</a></li>
<li><a href="https://www.cnblogs.com/kevingrace/p/6211509.html">SS命令和Netstat命令比较</a></li>
<li><a href="https://www.cnblogs.com/dadonggg/p/8778318.html">解决TIME_WAIT过多造成的问题</a></li>
<li><a href="https://www.cnblogs.com/bakari/p/10515977.html">一文掌握 Linux 性能分析之网络篇</a></li>
<li><a href="https://www.cnblogs.com/Security-Darren/p/4700387.html">Linux系统排查4——网络篇</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>性能分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>netstat</tag>
        <tag>ss</tag>
        <tag>网络分析</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL之数据类型与Schema</title>
    <url>/2021/02/08/MYSQL%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8ESchema/</url>
    <content><![CDATA[<h2 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h2><ol>
<li>更小的通常更好</li>
<li>简单就好</li>
<li>尽量避免使用NULL</li>
</ol>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>在mysql中的数值类型主要包括：整数和实数。</p>
<ol>
<li>在mysql中可以指定整数类型的宽度，但是该宽度只是用来显示可展示的长度，不能作为限制类型的实际长度</li>
<li>mysql中支持精确类型的实数和非精确类型的实数，需要根据实际场景进行选择，也可以根据业务场景转换成BIGINT进行存储<br>具体类型如下表所示：<a id="more"></a>

</li>
</ol>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 800px">
<colgroup>
<col style="width: 106px">
<col style="width: 134px">
<col style="width: 261px">
<col style="width: 215px">
<col style="width: 84px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"> 类型 </th>
    <th class="tg-0lax"> 大小 </th>
    <th class="tg-0lax"> 范围（有符号） </th>
    <th class="tg-0lax"> 范围（无符号） </th>
    <th class="tg-0lax"> 用途 </th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"> TINYINT </td>
    <td class="tg-0lax"> 1 byte </td>
    <td class="tg-0lax"> (-128，127) </td>
    <td class="tg-0lax"> (0，255) </td>
    <td class="tg-0lax"> 小整数值 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> SMALLINT </td>
    <td class="tg-0lax"> 2 bytes </td>
    <td class="tg-0lax"> (-32 768，32 767) </td>
    <td class="tg-0lax"> (0，65 535) </td>
    <td class="tg-0lax"> 大整数值 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> MEDIUMINT </td>
    <td class="tg-0lax"> 3  bytes </td>
    <td class="tg-0lax"> (-8 388 608，8 388 607) </td>
    <td class="tg-0lax"> (0，16 777 215) </td>
    <td class="tg-0lax"> 大整数值 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> INT或INTEGER </td>
    <td class="tg-0lax"> 4  bytes </td>
    <td class="tg-0lax"> (-2 147 483 648，2 147 483 647) </td>
    <td class="tg-0lax"> (0，4 294 967 295) </td>
    <td class="tg-0lax"> 大整数值 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> BIGINT </td>
    <td class="tg-0lax"> 8  bytes </td>
    <td class="tg-0lax"> (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) </td>
    <td class="tg-0lax"> (0，18 446 744 073 709 551 615) </td>
    <td class="tg-0lax"> 极大整数值 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> FLOAT </td>
    <td class="tg-0lax"> 4  bytes </td>
    <td class="tg-0lax"> (-3.402 823 466 E+38，-1.175 494 351 E-38)，<br>0，<br>(1.175 494 351 E-38，3.402 823 466 351 E+38)  </td>
    <td class="tg-0lax"> 0，<br>(1.175 494 351 E-38，3.402 823 466 E+38) </td>
    <td class="tg-0lax"> 单精度<br>浮点数值 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> DOUBLE </td>
    <td class="tg-0lax"> 8  bytes </td>
    <td class="tg-0lax"> (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，<br>0，<br>(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) </td>
    <td class="tg-0lax"> 0，<br>(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) </td>
    <td class="tg-0lax"> 双精度<br>浮点数值 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> DECIMAL </td>
    <td class="tg-0lax"> 对DECIMAL(M,D) ，如果M&gt;D，M+2<br>否则为D+2 </td>
    <td class="tg-0lax"> 依赖于M和D的值 </td>
    <td class="tg-0lax"> 依赖于M和D的值 </td>
    <td class="tg-0lax"> 小数值 </td>
  </tr>
</tbody>
</table>

<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax"> 类型 </th>
    <th class="tg-0lax"> 大小 </th>
    <th class="tg-0lax"> 用途 </th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"> CHAR </td>
    <td class="tg-0lax"> 0-255 bytes </td>
    <td class="tg-0lax"> 定长字符串 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> VARCHAR </td>
    <td class="tg-0lax"> 0-65535 bytes </td>
    <td class="tg-0lax"> 变长字符串 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> TINYBLOB </td>
    <td class="tg-0lax"> 0-255 bytes </td>
    <td class="tg-0lax"> 不超过 255 个字符的二进制字符串 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> TINYTEXT </td>
    <td class="tg-0lax"> 0-255 bytes </td>
    <td class="tg-0lax"> 短文本字符串 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> BLOB </td>
    <td class="tg-0lax"> 0-65 535 bytes </td>
    <td class="tg-0lax"> 二进制形式的长文本数据 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> TEXT </td>
    <td class="tg-0lax"> 0-65 535 bytes </td>
    <td class="tg-0lax"> 长文本数据 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> MEDIUMBLOB </td>
    <td class="tg-0lax"> 0-16 777 215 bytes </td>
    <td class="tg-0lax"> 二进制形式的中等长度文本数据 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> MEDIUMTEXT </td>
    <td class="tg-0lax"> 0-16 777 215 bytes </td>
    <td class="tg-0lax"> 中等长度文本数据 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> LONGBLOB </td>
    <td class="tg-0lax"> 0-4 294 967 295 bytes </td>
    <td class="tg-0lax"> 二进制形式的极大文本数据 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> LONGTEXT </td>
    <td class="tg-0lax"> 0-4 294 967 295 bytes </td>
    <td class="tg-0lax"> 极大文本数据 </td>
  </tr>
</tbody>
</table>

<h4 id="varchar"><a href="#varchar" class="headerlink" title="varchar"></a>varchar</h4><ol>
<li>可变长字符串，通常比定长类型节省空间。但是如果使用ROW_FORMAT=FIXED创建表则每一行都会使用定长存储</li>
<li>需要1(&lt;&gt;=255)或2(超过255)个额外的字节记录字符串长度</li>
<li>InnoDB在varchar空间变化时会使用分裂页的方式处理数据，从而会产生碎片</li>
<li>使用场景：字符串列的最大长度比平均长度大很多，列的更新很少</li>
</ol>
<h4 id="char"><a href="#char" class="headerlink" title="char"></a>char</h4><ol>
<li>定长</li>
<li>不易产生碎片</li>
<li>自动删除右侧的空格</li>
<li>适合存储MD5这种定长的数据</li>
</ol>
<h4 id="枚举类型enum"><a href="#枚举类型enum" class="headerlink" title="枚举类型enum"></a>枚举类型enum</h4><ol>
<li>把一些不重复的字符串存储成一个预定义的集合</li>
<li>在存储枚举类型时，数据库会根据数据进行压缩到一个或两个字节中</li>
<li>mysql内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“整数-字符串”映射关系的查找表</li>
<li>缺点：字符串固定，只能通过alter table进行修改；在不同类型之间关联会出现性能下降（由于有转换的过程）</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符，根据不同的编码方式，占用的字节数不同</li>
<li>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</li>
<li>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串，存储字节码。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值；binary使用\0进行填充而不是空格，并且检索时也不会去掉填充值</li>
<li>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</li>
<li>有4种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</li>
<li>BLOB与TEXT不同的是BLOB存储二进制数据，没有排序规则或字符集；TEXT存储的是字符串，存在字符集和排序规则，注意：排序的时候只是针对每个列的最前max_sort_length字节进行处理，可以配置max_sort_length的大小或者使用order by substring(column,length)进行设置，在实际开发中尽量避免BLOB和TEXT的使用</li>
</ol>
<h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 784px">
<colgroup>
<col style="width: 99px">
<col style="width: 62px">
<col style="width: 301px">
<col style="width: 182px">
<col style="width: 140px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"> 类型 </th>
    <th class="tg-0lax"> 大小<br>( bytes) </th>
    <th class="tg-0lax"> 范围 </th>
    <th class="tg-0lax"> 格式 </th>
    <th class="tg-0lax"> 用途 </th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"> DATE </td>
    <td class="tg-0lax"> 3 </td>
    <td class="tg-0lax"> 1000-01-01/9999-12-31 </td>
    <td class="tg-0lax"> YYYY-MM-DD </td>
    <td class="tg-0lax"> 日期值 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> TIME </td>
    <td class="tg-0lax"> 3 </td>
    <td class="tg-0lax"> '-838:59:59'/'838:59:59' </td>
    <td class="tg-0lax"> HH:MM:SS </td>
    <td class="tg-0lax"> 时间值或持续时间 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> YEAR </td>
    <td class="tg-0lax"> 1 </td>
    <td class="tg-0lax"> 1901/2155 </td>
    <td class="tg-0lax"> YYYY </td>
    <td class="tg-0lax"> 年份值 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> DATETIME </td>
    <td class="tg-0lax"> 8 </td>
    <td class="tg-0lax"> 1000-01-01 00:00:00/9999-12-31 23:59:59 </td>
    <td class="tg-0lax"> YYYY-MM-DD HH:MM:SS </td>
    <td class="tg-0lax"> 混合日期和时间值 </td>
  </tr>
  <tr>
    <td class="tg-0lax"> TIMESTAMP </td>
    <td class="tg-0lax"> 4 </td>
    <td class="tg-0lax"> <br>1970-01-01 00:00:00/2038<br>结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 </td>
    <td class="tg-0lax"> YYYYMMDD HHMMSS </td>
    <td class="tg-0lax"> 混合日期和时间值，时间戳 </td>
  </tr>
</tbody>
</table>

<ol>
<li>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</li>
<li>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</li>
<li>TIMESTAMP类型有专有的自动更新特性</li>
<li>建议尽量使用TIMESTAMP</li>
<li>mysql支持的时间最小粒度为s，可以使用BIGINT或DOUBLE替换，或者使用mariadb数据库</li>
</ol>
<h2 id="ID选择（主键的处理）"><a href="#ID选择（主键的处理）" class="headerlink" title="ID选择（主键的处理）"></a>ID选择（主键的处理）</h2><ol>
<li>在选择ID列的类型时，不经要考虑存储类型，还需要考虑mysql对这种类型的计算和比较的方式。</li>
<li>确定之后需要在关联表中都是用同样的类型和长度，防止出现性能问题或位置错误</li>
<li>根据实际的业务场景选择最小的数据类型</li>
</ol>
<h3 id="类型选择技巧"><a href="#类型选择技巧" class="headerlink" title="类型选择技巧"></a>类型选择技巧</h3><ol>
<li>整数类型：最好的选择，并且支持自增长</li>
<li>enum和set类型：尽量避免使用该类型</li>
<li>字符串类型<ul>
<li>相对于整数类型，则不建议选择，不仅会浪费空间，而且会影响查询性能（MYISAM默认会对字符串进行压缩）</li>
<li>特别注意随机字符串，比如MD5()、SHA1()或UUID()，会任意分布到很大的空间中，影响insert和select性能<ul>
<li> 插入式索引的位置不定，会导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片</li>
<li> 查询会由于相邻数据分布到不同的磁盘和内存中导致数据加载过慢</li>
<li> 随时值会导致缓存的不可用，热数据的丢失，查询效果变差</li>
</ul>
</li>
<li> UUID可以去掉-或者使用unhex函数转换成数字存储在BINARY(16)中，在使用时通过HEX进行转换；相对于SHA1具有一定的顺序性</li>
</ul>
</li>
</ol>
<h2 id="Schema设计中的陷阱"><a href="#Schema设计中的陷阱" class="headerlink" title="Schema设计中的陷阱"></a>Schema设计中的陷阱</h2><ol>
<li>太多的列：MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。</li>
<li>太多的关联：单个查询最好在12个以内做关联，mysql最大限制为61个</li>
<li>全能的枚举：避免多读使用枚举</li>
<li>变相的枚举：可以使用枚举代替集合列</li>
<li>非此发明的NULL：在实际业务场景中如果需要使用NULL，就去使用，不要使用其他变量进行替换，比如使用-1表示null</li>
</ol>
<h2 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="第一范式-1st-NF-－列都是不可再分"><a href="#第一范式-1st-NF-－列都是不可再分" class="headerlink" title="第一范式(1st NF －列都是不可再分)"></a>第一范式(1st NF －列都是不可再分)</h4><p>第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF） </p>
<div align="center">

<img src="/2021/02/08/MYSQL%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8ESchema/1589106620753.png" class>

</div>

<h4 id="第二范式-2nd-NF－每个表只描述一件事情"><a href="#第二范式-2nd-NF－每个表只描述一件事情" class="headerlink" title="第二范式(2nd NF－每个表只描述一件事情)"></a>第二范式(2nd NF－每个表只描述一件事情)</h4><p>首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一件事情。 </p>
<div align="center">

<img src="/2021/02/08/MYSQL%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8ESchema/1589106645458.png" class>

</div>

<h4 id="第三范式-3rd-NF－-不存在对非主键列的传递依赖"><a href="#第三范式-3rd-NF－-不存在对非主键列的传递依赖" class="headerlink" title="第三范式(3rd NF－ 不存在对非主键列的传递依赖)"></a>第三范式(3rd NF－ 不存在对非主键列的传递依赖)</h4><p>第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号。 </p>
<div align="center">

<img src="/2021/02/08/MYSQL%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8ESchema/1589106668000.png" class>

</div>

<h3 id="范式优缺点"><a href="#范式优缺点" class="headerlink" title="范式优缺点"></a>范式优缺点</h3><ol>
<li>更新相对较快</li>
<li>修改的数据相对较少</li>
<li>表通常会更小，所在可以缓存到内存中，执行操作相对较快</li>
<li>很少有冗余的数据，所以很少会用到distinct或group by语句</li>
<li>缺点是需要做关联操作，影响查询效率</li>
</ol>
<h3 id="反范式优缺点"><a href="#反范式优缺点" class="headerlink" title="反范式优缺点"></a>反范式优缺点</h3><ol>
<li>可以避免多表关联，避免过多的随机IO</li>
<li>可以更加有效的使用索引策略</li>
</ol>
<h2 id="缓存表和汇总表（常用于报表数据存储）"><a href="#缓存表和汇总表（常用于报表数据存储）" class="headerlink" title="缓存表和汇总表（常用于报表数据存储）"></a>缓存表和汇总表（常用于报表数据存储）</h2><h2 id="加快alter-table操作的速度"><a href="#加快alter-table操作的速度" class="headerlink" title="加快alter table操作的速度"></a>加快alter table操作的速度</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MySQL执行大部分修改表的结构操作的方法是用新的结构创建一个空表，从旧表中查询出所有数据然后进行写入，之后删除表。（<strong>性能低下</strong>）</p>
<h3 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h3><ol>
<li>使用slave节点的数据进行处理，然后进行切换使用</li>
<li>影子拷贝，然后进行重命名和删除</li>
</ol>
<h3 id="不重建表的场景"><a href="#不重建表的场景" class="headerlink" title="不重建表的场景"></a>不重建表的场景</h3><p>该表或删除一个列的默认值。</p>
<ol>
<li>慢：alter table <strong>* modify column *</strong> tinyint(3) not null default 5;</li>
<li>快（直接修改.frm文件不涉及表数据）：alter table <strong>* alter column *</strong> set default 5;</li>
</ol>
<h3 id="只修改-frm文件"><a href="#只修改-frm文件" class="headerlink" title="只修改.frm文件"></a>只修改.frm文件</h3><h4 id="可能不需要重建表的场景"><a href="#可能不需要重建表的场景" class="headerlink" title="可能不需要重建表的场景"></a>可能不需要重建表的场景</h4><ol>
<li>移除（不是添加）一个列的auto_increment属性</li>
<li>增加、移除、或更改enum和set常量。如果移除的是已经有行数据用到其值的常量，查询将返回一个空字符串</li>
</ol>
<h4 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h4><p>为目的表创建一个新的frm文件，然后替换掉已经存在的对应文件</p>
<ol>
<li>创建相同结构的空表，然后按照要求修改对应的表信息</li>
<li>执行flush tables with read lock，关闭所有正在使用的表，并且禁止任何表被打开</li>
<li>更换frm文件</li>
<li>执行unlock tables</li>
</ol>
<h4 id="快速创建MyISAM索引"><a href="#快速创建MyISAM索引" class="headerlink" title="快速创建MyISAM索引"></a>快速创建MyISAM索引</h4><ol>
<li>提供载入数据的效率：先禁用索引，载入数据然后启用索引，对非唯一索引有效</li>
<li>使用alter table处理（有风险）<ul>
<li> 用需要的表结构创建新表，不包括索引</li>
<li> 载入数据到表中，构建.myd文件</li>
<li> 按照需要的结构创建另外一个空表，包含索引。自会创建需要的frm和myi文件</li>
<li> 获取读锁并刷新表</li>
<li> 重命名第二张表的frm和myi文件，让mysql认为是第一张表的文件</li>
<li> 释放读锁</li>
<li> 使用repair table来重建表的索引。该操作会通过排序来构建所有索引，包括唯一索引</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之日志-慢查询日志</title>
    <url>/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li>记录执行时间超过指定时间（long_query_time，默认10s）的查询语句（包括dml和ddl等）</li>
<li>慢查询日志默认不启动</li>
<li>慢查询日志支持将日志写入文件或数据库表中</li>
<li>优点：可以有效的跟踪 执行时间过长 或者 没有使用索引的查询语句（包括select 语句，update语句，delete语句，以及insert语句）</li>
<li>缺点：存在性能损耗，不建议默认开启</li>
<li>慢查询日志只包含成功执行过的查询语句<a id="more"></a>

</li>
</ol>
<h3 id="官方说明"><a href="#官方说明" class="headerlink" title="官方说明"></a>官方说明</h3><p>The slow query log consists of SQL statements that took more than long_query_time seconds to execute and required at least min_examined_row_limit rows to be examined. The minimum and default values of long_query_time are 0 and 10, respectively. The value can be specified to a resolution of microseconds. For logging to a file, times are written including the microseconds part. For logging to tables, only integer times are written; the microseconds part is ignored.  </p>
<p>By default, administrative statements are not logged, nor are queries that do not use indexes for lookups. This behavior can be changed usinglog_slow_admin_statements and log_queries_not_using_indexes, as described later.  </p>
<h2 id="慢查询日志相关参数"><a href="#慢查询日志相关参数" class="headerlink" title="慢查询日志相关参数"></a>慢查询日志相关参数</h2><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;属性&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;说明&nbsp;&nbsp;&nbsp;</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;slow_query_log&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;是否开启慢查询日志，1表示开启，0表示关闭。&nbsp;&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;log-slow-queries&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log&nbsp;&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;slow-query-log-file&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log&nbsp;&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;long_query_time&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;慢查询阈值，当查询时间多于设定的阈值时，记录日志&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;log_queries_not_using_indexes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;未使用索引的查询也被记录到慢查询日志中（可选项）&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;log_output&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">
        日志存储方式。<br>
        log_output='FILE'表示将日志存入文件，默认值是'FILE'。<br>
        log_output='TABLE'表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。<br>
        MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output='FILE,TABLE'。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。<br>
    </td>
  </tr>
</tbody>
</table>

<h2 id="查看慢查询日志"><a href="#查看慢查询日志" class="headerlink" title="查看慢查询日志"></a>查看慢查询日志</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> log_slow_admin_statements <span class="operator">|</span> OFF            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_slow_slave_statements <span class="operator">|</span> OFF            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_launch_time          <span class="operator">|</span> <span class="number">2</span>              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log            <span class="operator">|</span> <span class="keyword">ON</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log_file       <span class="operator">|</span> SUNLD<span class="operator">-</span>slow.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+----------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="启动和设置慢查询日志"><a href="#启动和设置慢查询日志" class="headerlink" title="启动和设置慢查询日志"></a>启动和设置慢查询日志</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>通过配置文件my.cnf中的log-slow-queries选项可以开启慢查询日志；形式如下：</p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/1589444455739.png" class title="慢查询日志路径">

</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改配置文件my.cnf</span><br><span class="line">slow_query_log &#x3D;1</span><br><span class="line">slow_query_log_file&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql-slow-query-new.log</span><br></pre></td></tr></table></figure>
<p>文件定义说明：log-slow-queries [=  DIR/[filename] ]  </p>
<p>其中，DIR参数指定慢查询日志的存储路径；filename参数指定日志的文件名，生成日志文件的完成名称为filename-slow.log。如果不指定存储路径，慢查询日志默认存储到mysql数据库的数据文件下，如果不指定文件名，默认文件名为hostname-slow.log。</p>
<h3 id="直接设置属性（通过登录mysql服务器直接定义）"><a href="#直接设置属性（通过登录mysql服务器直接定义）" class="headerlink" title="直接设置属性（通过登录mysql服务器直接定义）"></a>直接设置属性（通过登录mysql服务器直接定义）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> global slow_query_log=0;</span><br><span class="line"><span class="built_in">set</span> global slow_query_log=1;</span><br><span class="line"><span class="built_in">set</span> global slow_query_log_file=<span class="string">&#x27;/var/lib/mysql/mysql-slow-query-new.log&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="超时配置"><a href="#超时配置" class="headerlink" title="超时配置"></a>超时配置</h3><p>一般都是通过long_query_time选项来设置这个时间值，时间以秒为单位，可以精确到微秒（可以精确到小数点后6位(微秒)）。如果查询时间超过了这个时间值（默认为10秒），这个查询语句将被记录到慢查询日志中。查看服务器默认时间值方式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>注意：其中这个慢查询时间并不是只表示语句自身执行超过10秒还包含由于其他资源被征用造成阻塞的查询执行时间或其他原因等都被记录到慢查询中。所以这个慢查的时长表示从查询开始到查询结束中间包含可能的任何原因所经历的所有时间。  </li>
<li>从MySQL 5.1开始，long_query_time开始以微秒记录SQL语句运行时间，之前仅用秒为单位记录。如果记录到表里面，只会记录整数部分，不会记录微秒部分。  </li>
<li>注意：使用命令 set global long_query_time=4修改后，需要重新连接或新开一个会话才能看到修改值。你用show variables like ‘long_query_time’查看是当前会话的变量值，你也可以不用重新连接会话，而是用show global variables like ‘long_query_time’;  </li>
</ol>
</blockquote>
<h3 id="log-quries-not-using-indexes"><a href="#log-quries-not-using-indexes" class="headerlink" title="log_quries_not_using_indexes"></a>log_quries_not_using_indexes</h3><p>系统变量log-queries-not-using-indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。如果调优的话，建议开启这个选项。另外，开启了这个参数，其实使用full index scan的sql也会被记录到慢查询日志。  </p>
<p>This option does not necessarily mean that no index is used. For example, a query that uses a full index scan uses an index but would be logged because the index would not limit the number of rows.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> @<span class="variable">@global</span>.log_queries_not_using_indexes<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_queries_not_using_indexes&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> log_queries_not_using_indexes <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br></pre></td></tr></table></figure>
<h3 id="log-slow-admin-statements"><a href="#log-slow-admin-statements" class="headerlink" title="log_slow_admin_statements"></a>log_slow_admin_statements</h3><p>系统变量log_slow_admin_statements表示是否将慢管理语句例如ANALYZE TABLE和ALTER TABLE等记入慢查询日志。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_slow_admin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> log_slow_admin_statements <span class="operator">|</span> OFF   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="log-slow-slave-statements"><a href="#log-slow-slave-statements" class="headerlink" title="log_slow_slave_statements"></a>log_slow_slave_statements</h3><p>By default, a replication slave does not write replicated queries to the slow query log. To change this, use the log_slow_slave_statements system variable.  </p>
<p>When the slow query log is enabled, this variable enables logging for queries that have taken more than long_query_time seconds to execute on the slave. This variable was added in MySQL 5.7.1. Setting this variable has no immediate effect. The state of the variable applies on all subsequent START SLAVE statements.  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_slow_slave%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> log_slow_slave_statements <span class="operator">|</span> OFF   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="参数–log-short-format"><a href="#参数–log-short-format" class="headerlink" title="参数–log-short-format"></a>参数–log-short-format</h3><p>The server writes less information to the slow query log if you use the –log-short-format option.  </p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;Command-Line Format&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;--log-short-format&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Permitted Values&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Type&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Default&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;FALSE&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<h3 id="查询有多少条慢查询记录"><a href="#查询有多少条慢查询记录" class="headerlink" title="查询有多少条慢查询记录"></a>查询有多少条慢查询记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;%slow_queries%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Slow_queries  <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="日志记录方式"><a href="#日志记录方式" class="headerlink" title="日志记录方式"></a>日志记录方式</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_output%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> log_output    <span class="operator">|</span> FILE  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line">#设置存储方式</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output<span class="operator">=</span><span class="string">&#x27;TABLE&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="分析慢查询日志"><a href="#分析慢查询日志" class="headerlink" title="分析慢查询日志"></a>分析慢查询日志</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">system</span> more <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow<span class="operator">-</span>query.log</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/1589444635250.png" class title="慢查询日志分析">

</div>

<h3 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h3><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>log_output参数可以设置慢查询日志的输出形式。默认为FILE,可以设置为TABLE;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> mysql.slow_log;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+---------------------+------+-----+----------------------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Field          <span class="operator">|</span> Type                <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>              <span class="operator">|</span> Extra                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+---------------------+------+-----+----------------------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> start_time     <span class="operator">|</span> <span class="type">timestamp</span>(<span class="number">6</span>)        <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">6</span>) <span class="operator">|</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">6</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> user_host      <span class="operator">|</span> mediumtext          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_time     <span class="operator">|</span> <span class="type">time</span>(<span class="number">6</span>)             <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> lock_time      <span class="operator">|</span> <span class="type">time</span>(<span class="number">6</span>)             <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> rows_sent      <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)             <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> rows_examined  <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)             <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> db             <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">512</span>)        <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> last_insert_id <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)             <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> insert_id      <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)             <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> server_id      <span class="operator">|</span> <span class="type">int</span>(<span class="number">10</span>) unsigned    <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_text       <span class="operator">|</span> mediumblob          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> thread_id      <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+---------------------+------+-----+----------------------+--------------------------------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>lock_time表示该SQL执行时被锁阻塞的时间。<br>rows_send表示执行SQL后返回的内容行数。<br>rows_examined表示该SQL执行时实际扫描的记录条数。  </p>
<h4 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldumpslow --<span class="built_in">help</span></span><br><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line">Parse and summarize the MySQL slow query <span class="built_in">log</span>. Options are</span><br><span class="line">  --verbose    verbose</span><br><span class="line">  --debug      debug</span><br><span class="line">  --<span class="built_in">help</span>       write this text to standard output</span><br><span class="line">  -v           verbose</span><br><span class="line">  -d           debug</span><br><span class="line">  -s ORDER     what to sort by (al, at, ar, c, l, r, t), <span class="string">&#x27;at&#x27;</span> is default</span><br><span class="line">                al: average lock time 平均锁定时间</span><br><span class="line">                ar: average rows sent 平均返回记录</span><br><span class="line">                at: average query time 平均查询时间</span><br><span class="line">                 c: count 访问次数</span><br><span class="line">                 l: lock time 锁定时间</span><br><span class="line">                 r: rows sent 返回记录</span><br><span class="line">                 t: query time  查询时间</span><br><span class="line">  -r           reverse the sort order (largest last instead of first)</span><br><span class="line">  -t NUM       just show the top n queries</span><br><span class="line">  -a           don<span class="string">&#x27;t abstract all numbers to N and strings to &#x27;</span>S<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  -n NUM       abstract numbers with at least n digits within names</span></span><br><span class="line"><span class="string">  -g PATTERN   grep: only consider stmts that include this string</span></span><br><span class="line"><span class="string">  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),</span></span><br><span class="line"><span class="string">               default is &#x27;</span>*<span class="string">&#x27;, i.e. match all</span></span><br><span class="line"><span class="string">  -i NAME      name of server instance (if using mysql.server startup script)</span></span><br><span class="line"><span class="string">  -l           don&#x27;</span>t subtract lock time from total time</span><br></pre></td></tr></table></figure>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#返回访问次数最多的20条SQL语句</span></span><br><span class="line">mysqldumpslow -s c -t 20 mysql-slow-query.log</span><br><span class="line"><span class="comment">#返回return记录数最多的20条SQL语句</span></span><br><span class="line">mysqldumpslow -s r -t 20 mysql-slow-query.log</span><br><span class="line"><span class="comment">#返回含有like的SQL语句</span></span><br><span class="line">mysqldumpslow -g <span class="string">&#x27;like&#x27;</span> -t 20 mysql-slow-query.log</span><br><span class="line">explain sql statements</span><br><span class="line">show profile <span class="keyword">for</span> query num 需要开启profiling</span><br><span class="line"><span class="comment">#得到返回记录集最多的10个SQL。</span></span><br><span class="line">mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log</span><br><span class="line"><span class="comment">#得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log</span><br><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句。</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log</span><br><span class="line"><span class="comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。</span></span><br><span class="line">mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/ggxxkkll/article/details/7616739">数据库日志文件– undo log 、redo log、 undo/redo log</a></li>
<li><a href="https://blog.csdn.net/leonpenn/article/details/72778901">InnoDB事务日志（redo log 和 undo log）详解</a></li>
<li><a href="https://www.iteye.com/blog/dinglin-907123">MySQL源码学习：ib_logfile、bin-log与主从同步</a></li>
<li><a href="https://blog.csdn.net/hackerwin7/article/details/39896173">Mysql日志抽取与解析</a></li>
<li><a href="https://blog.csdn.net/u010440155/article/details/54914353">mysql data文件夹下的ibdata1 文件作用</a></li>
<li><a href="https://blog.csdn.net/donghaixiaolongwang/article/details/60961603">mysql——innodb事务日志详解</a></li>
<li><a href="https://blog.csdn.net/mydriverc2/article/details/50629599">inlog，redo log，undo log区别</a></li>
<li><a href="http://www.itwendao.com/article/detail/450198.html">高性能MySQL学习笔记（3） — InnoDB事务日志（redo log 和 undo log）详解</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>慢查询日志</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之日志-Binlog日志</title>
    <url>/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="记录信息"><a href="#记录信息" class="headerlink" title="记录信息"></a>记录信息</h2><ol>
<li>二进制日志记录 MySQL 数据库中所有与更新相关的操作，即二进制日志记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。常用于恢复数据库和主从复制。</li>
<li>二进制日志主要记录数据库的变化情况，因此可以用作主从库的同步。内容主要包括数据库所有的更新操作，use语句、insert语句、delete语句、update语句、create语句、alter语句、drop语句。用一句更简洁易懂的话概括就是：所有涉及数据变动的操作，都要记录进二进制日志中。</li>
</ol>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>只要重启了服务, binlog二进制日志就会自己滚动一个新的, 或者使用flush logs 手动滚动日志</li>
<li>记录的信息 主要是记录修改数据或有可能引起数据改变的MySql语句, 记录时间,操作时长,等等信息</li>
<li>日志格式: 基于(语句, row, mixed) 默认mixed</li>
<li>每一个二进制日志叫做一个Binary log event(二进制日志事件), 每一个二进制日志事件都有自己的元数据(meta data)信息, 时间,操作时长….</li>
<li>每个二进制日志的上限是1G<a id="more"></a>

</li>
</ol>
<h2 id="查看binlog状态"><a href="#查看binlog状态" class="headerlink" title="查看binlog状态"></a>查看binlog状态</h2><p><code>show variables like &#39;log_bin%&#39;;</code></p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589445692540.png" class>

</div>

<p>开启之后：  </p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589445717921.png" class>

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589445725547.png" class>

</div>

<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0lax">参数</th>
    <th class="tg-0lax">说明</th>
  </tr>
  <tr>
    <td class="tg-0lax">sql_log_bin ={ON|OFF}</td>
    <td class="tg-0lax">用于控制会话级别二进制日志功能的开启或关闭。默认为ON，表示启用记录功能。用户可以在会话级别修改此变量的值，但其必须具有SUPER权限。</td>
  </tr>
  <tr>
    <td class="tg-0lax">binlog_cache_size =32768</td>
    <td class="tg-0lax">默认值32768 Binlog Cache用于在打开了二进制日志（binlog）记录功能的环境，是MySQL 用来提高binlog的记录效率而设计的一个用于短时间内临时缓存binlog数据的内存区域。一般来说，如果我们的数据库中没有什么大事务，写入也不是特别频繁，2MB～4MB是一个合适的选择。但是如果我们的数据库大事务较多，写入量比较大，可与适当调高binlog_cache_size。同时，我们可以通过binlog_cache_use 以及 binlog_cache_disk_use来分析设置的binlog_cache_size是否足够，是否有大量的binlog_cache由于内存大小不够而使用临时文件（binlog_cache_disk_use）来缓存了。</td>
  </tr>
  <tr>
    <td class="tg-0lax">binlog_stmt_cache_size= 32768</td>
    <td class="tg-0lax">当非事务语句使用二进制日志缓存，但是超出binlog_stmt_cache_size时，使用一个临时文件来存放这些语句。</td>
  </tr>
  <tr>
    <td class="tg-0lax">log_bin = mysql-bin</td>
    <td class="tg-0lax">指定binlog的位置，默认在数据目录下。</td>
  </tr>
  <tr>
    <td class="tg-0lax">binlog-format= {ROW|STATEMENT|MIXED}</td>
    <td class="tg-0lax">指定二进制日志的类型，默认为MIXED（row）。如果设定了二进制日志的格式，却没有启用二进制日志，则MySQL启动时会产生警告日志信息并记录于错误日志中</td>
  </tr>
  <tr>
    <td class="tg-0lax">sync_binlog = 10</td>
    <td class="tg-0lax">设定多久同步一次二进制日志至磁盘文件中，0表示不同步，任何正数值都表示对二进制每多少次写操作之后同步一次。当autocommit的值为1时，每条语句的执行都会引起二进制日志同步，否则，每个事务的提交会引起二进制日志同步</td>
  </tr>
  <tr>
    <td class="tg-0lax">max_binlog_cache_size= {4096 .. 18446744073709547520}</td>
    <td class="tg-0lax">二进制日志缓存空间大小，5.5.9及以后的版本仅应用于事务缓存，其上限由max_binlog_stmt_cache_size决定。</td>
  </tr>
  <tr>
    <td class="tg-0lax">max_binlog_stmt_cache_size= {4096 .. 18446744073709547520}</td>
    <td class="tg-0lax">二进制日志缓存空间大小，5.5.9及以后的版本仅应用于事务缓存</td>
  </tr>
  <tr>
    <td class="tg-0lax">expire_log_days ={0..99}</td>
    <td class="tg-0lax">设定二进制日志的过期天数，超出此天数的二进制日志文件将被自动删除。默认为0，表示不启用过期自动删除功能。如果启用此功能，自动删除工作通常发生在MySQL启动时或FLUSH日志时。</td>
  </tr>
  <tr>
    <td class="tg-0lax">log_slave_updates</td>
    <td class="tg-0lax">logslvaeupdates 用于主从复制</td>
  </tr>
</table>

<h3 id="开启二进制日志"><a href="#开启二进制日志" class="headerlink" title="开启二进制日志"></a>开启二进制日志</h3><ol>
<li>其一、log_bin可以直接定义为文件路径，也可以为ON|OFF。</li>
<li>其二、通过编辑my.cnf中的log-bin选项可以开启二进制日志；形式如下：my.cnf文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log<span class="operator">-</span>bin [<span class="operator">=</span>DIR \ [filename]]</span><br></pre></td></tr></table></figure>
<p>其中，DIR参数指定二进制文件的存储路径；filename参数指定二级制文件的文件名，其形式为filename.number，number的形式为000001、000002等。每次重启mysql服务或运行mysql&gt; flush logs;都会生成一个新的二进制日志文件，这些日志文件的number会不断地递增。除了生成上述的文件外还会生成一个名为filename.index的文件。这个文件中存储所有二进制日志文件的清单又称为二进制文件的索引。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log-bin</span>=<span class="string">&quot;filename-bin&quot;</span></span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589446006763.png" class>

</div>

<blockquote>
<p>注意：如果说我们向某个表的某个字段插入一个数据而这个数据为当前时间(日期时间型)；过段时间将此二进制文件应用到另一台服务器上数据就会变动从而导致数据的不一致性所以说对于这种非确定性的数据使用默认的语句定义并不是可靠的；</p>
</blockquote>
<h3 id="配置二进制文件大小"><a href="#配置二进制文件大小" class="headerlink" title="配置二进制文件大小"></a>配置二进制文件大小</h3><p>设定二进制日志文件上限，单位为字节，最小值为4K，最大值为1G，默认为1G。某事务所产生的日志信息只能写入一个二进制日志文件，因此，实际上的二进制日志文件可能大于这个指定的上限。作用范围为全局级别，可用于配置文件，属动态变量。<br><code>max_binlog_size=&#123;4096 .. 1073741824&#125; ;</code><br>查看文件<br><code>show binary logs;</code>  </p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589446113339.png" class>

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589446120636.png" class>

</div>

<p>查看主节点的日志  </p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589446146171.png" class>

</div>

<p>文件路径一般在mysql的目录下，如下图所示：  </p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589446172227.png" class>

</div>

<h2 id="查看当前正在使用的二进制文件"><a href="#查看当前正在使用的二进制文件" class="headerlink" title="查看当前正在使用的二进制文件"></a>查看当前正在使用的二进制文件</h2><p><code>show master status;</code></p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589446441990.png" class>

</div>

<blockquote>
<p>小扩展：二进制日志的记录位置：通常为上一个事件执行结束时间的位置，每一个日志文件本身也有自己的元数据所以说对于当前版本的mysql来说二进制的开始位置通常为107；</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> flushlogs;</span><br><span class="line">Query OK, <span class="number">0</span> rowsaffected (<span class="number">0.23</span> sec)</span><br><span class="line">注意：flush logs一般只会滚动中继日志和二进制日志。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master status;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+</span></span><br><span class="line"><span class="operator">|</span> File             <span class="operator">|</span> Position <span class="operator">|</span> Binlog_Do_DB <span class="operator">|</span>Binlog_Ignore_DB <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000011</span><span class="operator">|</span>      <span class="number">107</span> <span class="operator">|</span>              <span class="operator">|</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span>sec)</span><br></pre></td></tr></table></figure>
<h2 id="二进制日志滚动"><a href="#二进制日志滚动" class="headerlink" title="二进制日志滚动"></a>二进制日志滚动</h2><p>当 MySQL 服务进程启动、当前二进制日志文件的大小已经超过上限时、执行 FLUSH LOG 时，MySQL 会创建一个新的二进制日志文件。新的编号大1的日志用于记录最新的日志，而原日志名字不会被改变。<br>手动滚动命令：flush logs;  </p>
<h2 id="定义二进制格式日志"><a href="#定义二进制格式日志" class="headerlink" title="定义二进制格式日志"></a>定义二进制格式日志</h2><p>binlog_format= Mixed|Statement|Row  </p>
<ol>
<li>语句(statement)：默认的记录格式；</li>
<li>行(row)：定义的并非数据本身而是这一行的数据是什么；需要解码</li>
<li>混合模式(mixed)：交替使用行和语句、由mysql服务器自行判断。</li>
</ol>
<p>其中基于行的定义格式数据量会大一些但是可以保证数据的精确性  </p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;border-color:#bbb;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#bbb;color:#594F4F;background-color:#E0FFEB;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#bbb;color:#493F3F;background-color:#9DE0AD;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1">模式</th>
    <th class="tg-cly1">说明</th>
    <th class="tg-0lax">优点</th>
    <th class="tg-0lax">缺点</th>
  </tr>
  <tr>
    <td class="tg-cly1">STATEMENT模式（SBR）</td>
    <td class="tg-cly1">
        基于SQL语句的复制(statement-based replication, SBR)<br>
        每一条会修改数据的sql语句会记录到binlog中。
    </td>
    <td class="tg-0lax">
        不需要记录每一条sql语句和每一行的数据变化，减少了binlog日志量，节约IO，提高性能。<br>
        binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况。<br>
        binlog可以用于实时的还原，而不仅仅用于复制；主从版本可以不一样，从服务器版本可以比主服务器版本高
    </td>
    <td class="tg-0lax">
        在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)<br>
        不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候。<br>
        调用具有不确定因素的 UDF 时复制也可能出问题<br>
        INSERT ... SELECT 会产生比 RBR 更多的行级锁<br>
        使用以下函数的语句也无法被复制：<br>
        * LOAD_FILE()<br>
        * UUID()<br>
        * USER()<br>
        * FOUND_ROWS()<br>
        * SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)<br>
        复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁<br>
        对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句<br>
        对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响<br>
        存储函数(不是存储过程)在被调用的同时也会执行一次 NOW() 函数，这个可以说是坏事也可能是好事<br>
        确定了的 UDF 也需要在从服务器上执行<br>
        数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错<br>
        执行复杂语句如果出错的话，会消耗更多资源
    </td>
  </tr>
  <tr>
    <td class="tg-cly1">ROW模式（RBR）</td>
    <td class="tg-cly1">基于行的复制(row-based replication, RBR)</td>
    <td class="tg-0lax">
        不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。<br>
        任何情况都可以被复制，这对复制来说是最安全可靠的<br>
        和其他大多数数据库系统的复制技术一样<br>
        多数情况下，从服务器上的表如果有主键的话，复制就会快了很多<br>
        复制以下几种语句时的行锁更少：<br>
        * INSERT ... SELECT<br>
        * 包含 AUTO_INCREMENT 字段的 INSERT<br>
        * 没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句<br>
        执行 INSERT，UPDATE，DELETE 语句时锁更少<br>
        从服务器上采用多线程来执行复制成为可能
    </td>
    <td class="tg-0lax">
        会产生大量的日志（binlog 大了很多），尤其是alter table的时候会让日志暴涨。<br>
        复杂的回滚时 binlog 中会包含大量的数据<br>
        主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题<br>
        UDF 产生的大 BLOB 值会导致复制变慢<br>
        无法从 binlog 中看到都复制了写什么语句<br>
        当在非事务表上执行一段堆积的SQL语句时，最好采用 SBR 模式，否则很容易导致主从服务器的数据不一致情况发生<br>
        另外，针对系统库 mysql 里面的表发生变化时的处理规则如下：<br>
        如果是采用 INSERT，UPDATE，DELETE 直接操作表的情况，则日志格式根据 binlog_format 的设定而记录<br>
        如果是采用 GRANT，REVOKE，SET PASSWORD 等管理语句来做的话，那么无论如何都采用 SBR 模式记录<br>
        注：采用 RBR 模式后，能解决很多原先出现的主键重复问题。
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">MIXED模式（MBR）</td>
    <td class="tg-0lax" colspan="3">
        混合模式复制(mixed-based replication, MBR)<br>
        一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。<br>
        对于执行的SQL语句中包含now()这样的时间函数，会在日志中产生对应的unix_timestamp()*1000的时间字符串，slave在完成同步时，取用的是sqlEvent发生的时间来保证数据的准确性。另外对于一些功能性函数slave能完成相应的数据同步，而对于上面指定的一些类似于UDF函数，导致Slave无法知晓的情况，则会采用ROW格式存储这些Binlog，以保证产生的Binlog可以供Slave完成数据同步。
    </td>
  </tr>
</table>

<h2 id="二进制日志的有效天数"><a href="#二进制日志的有效天数" class="headerlink" title="二进制日志的有效天数"></a>二进制日志的有效天数</h2><p><code>expire_logs_days = 5</code></p>
<h2 id="实时将缓存中数据同步到硬盘"><a href="#实时将缓存中数据同步到硬盘" class="headerlink" title="实时将缓存中数据同步到硬盘"></a>实时将缓存中数据同步到硬盘</h2><p>sync_binlog：sync_binlog 的默认值是0，像操作系统刷其他文件的机制一样，MySQL不会同步到磁盘中去而是依赖操作系统来刷新binary log。 当sync_binlog =N (N&gt;0) ，MySQL 在每写 N次 二进制日志binary log时，会使用fdatasync()函数将它的写二进制日志binary log同步到磁盘中去。（如果启用了autocommit，那么每一个语句statement就会有一次写操作；否则每个事务对应一个写操作）在MySQL中系统默认的设置是sync_binlog=0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在binlog_cache中的所有binlog信息都会被丢失。而当设置为“1”的时候，是最安全但是性能损耗最大的设置。因为当设置为1的时候，即使系统Crash，也最多丢失binlog_cache中未完成的一个事务，对实际数据没有任何实质性影响。从以往经验和相关测试来看，对于高并发事务的系统来说，“sync_binlog”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。</p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1587543929052.png" class>

</div>

<h2 id="数据备份与恢复"><a href="#数据备份与恢复" class="headerlink" title="数据备份与恢复"></a>数据备份与恢复</h2><h3 id="导出此数据库的信息"><a href="#导出此数据库的信息" class="headerlink" title="导出此数据库的信息"></a>导出此数据库的信息</h3><p><code>mysqlbinlog mysql-bin.000017 &gt; /tmp/a.sql</code></p>
<h3 id="导入此数据库的信息"><a href="#导入此数据库的信息" class="headerlink" title="导入此数据库的信息"></a>导入此数据库的信息</h3><p><code>mysql &lt; a.sql</code></p>
<h3 id="Mysqlbinlog"><a href="#Mysqlbinlog" class="headerlink" title="Mysqlbinlog"></a>Mysqlbinlog</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line"><span class="operator">-</span>s                          以精简的方式显示日志内容</span><br><span class="line"><span class="operator">-</span>v                          以详细的方式显示日志内容</span><br><span class="line"><span class="operator">-</span>d<span class="operator">=</span>数据库名                  只显示指定数据库的日志内容</span><br><span class="line"><span class="operator">-</span>o<span class="operator">=</span>n                        忽略日志中前n行MySQL命令</span><br><span class="line"><span class="operator">-</span>r<span class="operator">=</span>file                    将指定内容写入指定文件</span><br><span class="line"><span class="comment">--start-datetime           显示指定时间范围内的日志内容</span></span><br><span class="line"><span class="comment">--stop-datetime</span></span><br><span class="line"><span class="comment">--start-position        显示指定位置间隔内的日志内容</span></span><br><span class="line"><span class="comment">--stop-position</span></span><br></pre></td></tr></table></figure>
<p>mysqlbinlog mysql-bin.<strong>**</strong><br>–start-datetime=#<br>–stop-datetime=#<br>–start-position=#<br>–stop-position=#<br>还可以使用-u,-p,-h 去读取其他主机上的二进制日志  </p>
<h4 id="通过时间恢复方法如下"><a href="#通过时间恢复方法如下" class="headerlink" title="通过时间恢复方法如下"></a>通过时间恢复方法如下</h4><p>mysqlbinlog mysql-bin.000017–stop-date=”恢复截至时间”|mysql -uroot -proot</p>
<h4 id="通过操作点恢复"><a href="#通过操作点恢复" class="headerlink" title="通过操作点恢复"></a>通过操作点恢复</h4><p>mysqlbinlog –stop-position=”450” mysql-bin.000017  | mysql -u root –p</p>
<h2 id="清除二进制日志"><a href="#清除二进制日志" class="headerlink" title="清除二进制日志"></a>清除二进制日志</h2><p>二进制日志会记录大量的信息（其中包含一些无用的信息）。如果很长时间不清理二进制日志，将会浪费很多的磁盘空间。但是，删除之后可能导致数据库崩溃时无法进行恢复，所以若要删除二进制日志首先将其和数据库备份一份，其中也只能删除备份前的二进制日志，新产生的日志信息不可删(可以做即时点还原)。也不可在关闭mysql服务器之后直接删除因为这样可能会给数据库带来错误的。若非要删除二进制日志需要做如下操作：导出备份数据库和二进制日志文件进行压缩归档存储。</p>
<h3 id="清除所有日志（不存在主从复制关系）"><a href="#清除所有日志（不存在主从复制关系）" class="headerlink" title="清除所有日志（不存在主从复制关系）"></a>清除所有日志（不存在主从复制关系）</h3><p>使用RESET MASTER语句可以删除所有的二进制日志。<br><code>RESET MASTER;</code></p>
<blockquote>
<p>解析：首先不建议在生产环境下使用此操作；删除所有的二进制日志后，Mysql将会重新创建新的二进制日志。新二进制日志的编号从000001开始。</p>
</blockquote>
<h3 id="根据文件或时间点来删除二进制日志"><a href="#根据文件或时间点来删除二进制日志" class="headerlink" title="根据文件或时间点来删除二进制日志"></a>根据文件或时间点来删除二进制日志</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; PURGE &#123; BINARY | MASTER &#125; LOGS &#123;TO <span class="string">&#x27;log_name&#x27;</span> | BEFORE datetime_expr &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中TO’log_name’表示把这个文件之前的其他文件都删除掉，也可使用BEFORE datetime_expr指定把哪个时间之前的二进制文件删除了。</p>
</blockquote>
<h4 id="清除指定日志之前的所有日志"><a href="#清除指定日志之前的所有日志" class="headerlink" title="清除指定日志之前的所有日志"></a>清除指定日志之前的所有日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PURGE MASTER LOGS TO <span class="string">&#x27;mysql-bin.000352&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="清除某一时间点前的所有日志"><a href="#清除某一时间点前的所有日志" class="headerlink" title="清除某一时间点前的所有日志"></a>清除某一时间点前的所有日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PURGE MASTER LOGS BEFORE <span class="string">&#x27;2015-01-01 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="清除-n-天前的所有日志"><a href="#清除-n-天前的所有日志" class="headerlink" title="清除 n 天前的所有日志"></a>清除 n 天前的所有日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PURGE MASTER LOGS BEFORE CURRENT_DATE - INTERVAL 10 DAY;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于二进制日志的重要性,请仅在确定不再需要将要被删除的二进制文件，或者在已经对二进制日志文件进行归档备份，或者已经进行数据库备份的情况下，才进行删除操作，且不要使用 rm 命令删除。</p>
</blockquote>
<h3 id="清除二进制日志的最佳实践"><a href="#清除二进制日志的最佳实践" class="headerlink" title="清除二进制日志的最佳实践"></a>清除二进制日志的最佳实践</h3><p>清除之前必须将日志文件备份，备份完毕后再次确认，如果确实可以删除则使用以上命令进行删除<br>假设binglog备份文件已经备份到日志服务器中，当前本地的数据库日志已经确保无误可以删除</p>
<h4 id="备份二进制文件"><a href="#备份二进制文件" class="headerlink" title="备份二进制文件"></a>备份二进制文件</h4><p><code>cp mysql-bin.0000* /tmp/</code></p>
<h4 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h4><p><code>mysqldump-u root -p&#39;123456&#39; -A &gt; /tmp/bak.sql</code></p>
<h4 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h4><p><code>tail -5 mysql-bin.index</code>  </p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589447636628.png" class>

</div>

<h4 id="删除某个日志之前的日志"><a href="#删除某个日志之前的日志" class="headerlink" title="删除某个日志之前的日志"></a>删除某个日志之前的日志</h4><p><code>purge binary logs to &#39;mysql-bin.****&#39;;</code></p>
<h4 id="删除某一事件之前的信息"><a href="#删除某一事件之前的信息" class="headerlink" title="删除某一事件之前的信息"></a>删除某一事件之前的信息</h4><p><code>cat  mysql-bin.index</code></p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589447690099.png" class>

</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt;show binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.****&#x27;</span> <span class="built_in">limit</span> 10;</span><br></pre></td></tr></table></figure>
<h2 id="查看日志详细"><a href="#查看日志详细" class="headerlink" title="查看日志详细"></a>查看日志详细</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SHOW BINLOG EVENTS [IN ‘log_name’] [FROM pos] [LIMIT [offset,]row_count]</span><br><span class="line">show binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.000354&#x27;</span>;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589447791140.png" class>

</div>

<p>每个语句执行结束后都会向日志记录的，因此如果数据量非常庞大的话会影响性能下降的从哪个位置开始查询  </p>
<p><code>show binlog events in &#39;mysql-bin.000354&#39; from 192 limit 2;</code></p>
<h3 id="使用mysqlbinlog命令行"><a href="#使用mysqlbinlog命令行" class="headerlink" title="使用mysqlbinlog命令行"></a>使用mysqlbinlog命令行</h3><p>mysqlbinlog直接在命令行直接去操作二进制文件<br>建议对日志操作之前先将其flush logs 滚动一次再对其进行编辑  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -v mysql-bin.000001</span><br></pre></td></tr></table></figure>
<h3 id="查看二进制日志内容信息"><a href="#查看二进制日志内容信息" class="headerlink" title="查看二进制日志内容信息"></a>查看二进制日志内容信息</h3><p><code>mysqlbinlog mysql-bin.000354  |more</code></p>
<h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589447902810.png" class>

</div>

<h4 id="初始化版本信息"><a href="#初始化版本信息" class="headerlink" title="初始化版本信息"></a>初始化版本信息</h4><p>用户通过mysql服务器进行通告<br>at 4 表示结束的位置  </p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589448003068.png" class>

</div>

<h4 id="开始位置123"><a href="#开始位置123" class="headerlink" title="开始位置123"></a>开始位置123</h4><p>at 123 #开始处，表明了上一个时间结束的时候开始  </p>
<div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589448106534.png" class>

</div>

<h4 id="境预设再下面就是sql语句了"><a href="#境预设再下面就是sql语句了" class="headerlink" title="境预设再下面就是sql语句了"></a>境预设再下面就是sql语句了</h4><div align="center">

<img src="/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-Binlog%E6%97%A5%E5%BF%97/1589448250858.png" class>

</div>

<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><h5 id="mysqlbinlog-查看binlog时报错unknown-variable-‘default-character-set-utf8’"><a href="#mysqlbinlog-查看binlog时报错unknown-variable-‘default-character-set-utf8’" class="headerlink" title="mysqlbinlog 查看binlog时报错unknown variable ‘default-character-set=utf8’"></a>mysqlbinlog 查看binlog时报错unknown variable ‘default-character-set=utf8’</h5><p>原因是mysqlbinlog这个工具无法识别binlog中的配置中的default-character-set=utf8这个指令。<br>两个方法可以解决这个问题</p>
<ol>
<li>一是在MySQL的配置/etc/my.cnf中将default-character-set=utf8 修改为 character-set-server = utf8，但是这需要重启MySQL服务，如果你的MySQL服务正在忙，那这样的代价会比较大。</li>
<li>二是用mysqlbinlog –no-defaults mysql-bin.000004 命令打开</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="mysql二进制日志处理事务与非事务性语句的区别"><a href="#mysql二进制日志处理事务与非事务性语句的区别" class="headerlink" title="mysql二进制日志处理事务与非事务性语句的区别"></a>mysql二进制日志处理事务与非事务性语句的区别</h3><p>在事务性语句执行过程中，服务器将会进行额外的处理，在服务器执行时多个事务是并行执行的，为了把他们的记录在一起，需要引入事务缓存的概念。在事务完成被提交的时候一同刷新到二进制日志。对于非事务性语句的处理。遵循以下3条规则：</p>
<ol>
<li>如果非事务性语句被标记为事务性，那么将被写入事务缓冲。</li>
<li>如果没有标记为事务性语句，而且事务缓存中没有，那么直接写入二进制日志。</li>
<li>如果没有标记为事务性的，但是事务缓存中有，那么写入事务缓冲。<br>注意如果在一个事务中有非事务性语句，那么将会利用规则2，优先将该影响非事务表语句直接写入二进制日志。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/ggxxkkll/article/details/7616739">数据库日志文件– undo log 、redo log、 undo/redo log</a></li>
<li><a href="https://blog.csdn.net/leonpenn/article/details/72778901">InnoDB事务日志（redo log 和 undo log）详解</a></li>
<li><a href="https://www.iteye.com/blog/dinglin-907123">MySQL源码学习：ib_logfile、bin-log与主从同步</a></li>
<li><a href="https://blog.csdn.net/hackerwin7/article/details/39896173">Mysql日志抽取与解析</a></li>
<li><a href="https://blog.csdn.net/u010440155/article/details/54914353">mysql data文件夹下的ibdata1 文件作用</a></li>
<li><a href="https://blog.csdn.net/donghaixiaolongwang/article/details/60961603">mysql——innodb事务日志详解</a></li>
<li><a href="https://blog.csdn.net/mydriverc2/article/details/50629599">inlog，redo log，undo log区别</a></li>
<li><a href="http://www.itwendao.com/article/detail/450198.html">高性能MySQL学习笔记（3） — InnoDB事务日志（redo log 和 undo log）详解</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>二进制日志</tag>
        <tag>Binlog日志</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之日志-概述</title>
    <url>/2021/02/05/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>日志是mysql数据库的重要组成部分。日志文件中记录着mysql数据库运行期间发生的变化；也就是说用来记录mysql数据库的客户端连接状况、SQL语句的执行情况和错误信息等。当数据库遭到意外的损坏时，可以通过日志查看文件出错的原因，并且可以通过日志文件进行数据恢复。  </p>
<p>默认情况下，所有日志创建于mysqld数据目录中。通过刷新日志，你可以强制 mysqld来关闭和重新打开日志文件（或者在某些情况下切换到一个新的日志）。当你执行一个FLUSH LOGS语句或执行mysqladmin flush-logs或mysqladmin refresh时，出现日志刷新  </p>
<p>mysql日志分类：错误日志、查询日志、慢查询日志、事务日志、二进制日志；  </p>
<p>官网：<a href="https://dev.mysql.com/doc/refman/5.7/en/server-logs.html">https://dev.mysql.com/doc/refman/5.7/en/server-logs.html</a></p>
<a id="more"></a>

<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>用–log-error[=file_name]选项来指定mysqld保存错误日志文件的位置。如果没有给定file_name值，mysqld使用错误日志名 host_name.err并在数据目录中写入日志文件。如果你执行FLUSH LOGS，错误日志用-old重新命名后缀并且mysqld创建一个新的空日志文件。(如果未给出–log-error选项，则不会重新命名）。<br>如果不指定–log-error，或者(在Windows中)如果你使用–console选项，错误被写入标准错误输出stderr。通常标准输出为你的终端。</p>
<h3 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h3><p>用–log[=file_name]或-l [file_name]选项启动它。如果没有给定file_name的值，默认名是host_name.log。</p>
<h3 id="慢速查询日志"><a href="#慢速查询日志" class="headerlink" title="慢速查询日志"></a>慢速查询日志</h3><p>用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件.如果没有给出file_name值，默认未主机名，后缀为 -slow.log。如果给出了文件名，但不是绝对路径名，文件则写入数据目录。或者没有使用缩影的语句。</p>
<h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><p>用–log-update[=file_name]选项启动,不推荐使用</p>
<h3 id="mysql日志缓存"><a href="#mysql日志缓存" class="headerlink" title="mysql日志缓存"></a>mysql日志缓存</h3><p>一个高速、稳定、可靠的系统，缓存在其中必定起着至关重要的作用。MySQL日志处理也使用了缓存机制。MySQL日志最初存放在MySQL服务器的内存中，若超过指定的存储容量，内存中的日志则写（或者刷新flush）到外存中，以数据库表或者以文件的方式永远的保存在硬盘中。</p>
<h2 id="日志相关配置参数"><a href="#日志相关配置参数" class="headerlink" title="日志相关配置参数"></a>日志相关配置参数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span>  variables <span class="keyword">like</span> <span class="string">&#x27;%log%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                           <span class="operator">|</span> <span class="keyword">Value</span>                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> back_log                                <span class="operator">|</span> <span class="number">450</span>                                      <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 默认启动的时候二进制的大小</span><br><span class="line"># 默认值<span class="number">32768</span> Binlog Cache用于在打开了二进制日志（binlog）记录功能的环境，</span><br><span class="line"># 是MySQL用来提高binlog的记录效率而设计的一个用于短时间内临时缓存binlog数据的内存区域。</span><br><span class="line"># 一般来说，如果我们的数据库中没有什么大事务，写入也不是特别频繁，<span class="number">2</span>MB～<span class="number">4</span>MB是一个合适的选择</span><br><span class="line"># 但是如果我们的数据库大事务较多，写入量比较大，可与适当调高binlog_cache_size。</span><br><span class="line"># 同时，我们可以通过binlog_cache_use以及 binlog_cache_disk_use来分析设置的</span><br><span class="line"># binlog_cache_size是否足够，是否有大量的</span><br><span class="line"># binlog_cache由于内存大小不够而使用临时文件（binlog_cache_disk_use）来缓存了</span><br><span class="line"><span class="operator">|</span> binlog_cache_size                       <span class="operator">|</span> <span class="number">32768</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> binlog_checksum                         <span class="operator">|</span> CRC32                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog_direct_non_transactional_updates <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog_error_action                     <span class="operator">|</span> ABORT_SERVER                             <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 指定二进制日志的类型，默认为MIXED。如果设定了二进制日志的格式，却没有启用二进制日志，</span><br><span class="line"># 则MySQL启动时会产生警告日志信息并记录于错误日志中。</span><br><span class="line"><span class="operator">|</span> binlog_format                           <span class="operator">|</span> <span class="type">ROW</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> binlog_group_commit_sync_delay          <span class="operator">|</span> <span class="number">0</span>                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog_group_commit_sync_no_delay_count <span class="operator">|</span> <span class="number">0</span>                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog_gtid_simple_recovery             <span class="operator">|</span> <span class="keyword">ON</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog_max_flush_queue_time             <span class="operator">|</span> <span class="number">0</span>                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog_order_commits                    <span class="operator">|</span> <span class="keyword">ON</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog_row_image                        <span class="operator">|</span> <span class="keyword">FULL</span>                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> binlog_rows_query_log_events            <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 当非事务语句使用二进制日志缓存，但是超出binlog_stmt_cache_size时，</span><br><span class="line"># 使用一个临时文件来存放这些语句。基于语句格式的二进制日志缓存的大小</span><br><span class="line"><span class="operator">|</span> binlog_stmt_cache_size                  <span class="operator">|</span> <span class="number">32768</span></span><br><span class="line"></span><br><span class="line"># 设定二进制日志的过期天数，超出此天数的二进制日志文件将被自动删除。</span><br><span class="line"># 默认为<span class="number">0</span>，表示不启用过期自动删除功能。如果启用此功能，</span><br><span class="line">#自动删除工作通常发生在MySQL启动时或FLUSH日志时。建议别设置,还是自己手动purge最好</span><br><span class="line"><span class="operator">|</span> expire_logs_days                        <span class="operator">|</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 定义查询日志是否开启</span><br><span class="line"><span class="operator">|</span> general_log                             <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"># 定义查询日志的文件地址名称</span><br><span class="line"><span class="operator">|</span> general_log_file                        <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>incloudos.log             <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> innodb_api_enable_binlog                <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_flush_log_at_timeout             <span class="operator">|</span> <span class="number">1</span>                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_flush_log_at_trx_commit          <span class="operator">|</span> <span class="number">1</span>                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_locks_unsafe_for_binlog          <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 定义内存空间的大小，万一都写在buffer里面，如果进程崩溃，也会丢失事物，</span><br><span class="line"># 因此避免这种情况，一旦事物提交了，那么需要立即同步到磁盘中，而不是间断同步</span><br><span class="line"><span class="operator">|</span> innodb_log_buffer_size                  <span class="operator">|</span> <span class="number">16777216</span></span><br><span class="line"><span class="operator">|</span> innodb_log_checksums                    <span class="operator">|</span> <span class="keyword">ON</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_log_compressed_pages             <span class="operator">|</span> <span class="keyword">ON</span>                                       <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 每个日志的单位大小为<span class="number">5</span>MB，如果有些大数据的话，则需要将其调大，</span><br><span class="line"># 否则恢复起来会比较慢，但是太大了也会导致恢复比较慢</span><br><span class="line"><span class="operator">|</span> innodb_log_file_size                    <span class="operator">|</span> <span class="number">50331648</span></span><br><span class="line"># 设置了日志文件组中重做日志（redo）日志的数量</span><br><span class="line"><span class="operator">|</span> innodb_log_files_in_group               <span class="operator">|</span> <span class="number">2</span>                                        <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 定义事物日志组的位置，一般来讲会有<span class="number">2</span>个日志，一个写满后会重建文件（达到轮询功能，写满后会同</span><br><span class="line"># 步到磁盘并将其清空）一般来讲，日志文件大小是固定的，凡是mysql已启动日志空间会在磁盘上立即</span><br><span class="line"># 分配，因为他们的主要功能是将随机IO转为顺序IO ，默认大小是每个文件为<span class="number">5</span>MB，</span><br><span class="line"># 明确说明事物日志的路径保存在.<span class="operator">/</span> 表示在当前路径下</span><br><span class="line"><span class="operator">|</span> innodb_log_group_home_dir               <span class="operator">|</span> .<span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> innodb_log_write_ahead_size             <span class="operator">|</span> <span class="number">8192</span>                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_max_undo_log_size                <span class="operator">|</span> <span class="number">1073741824</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_online_alter_log_max_size        <span class="operator">|</span> <span class="number">134217728</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_log_truncate                <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"># 设置回滚日志的回滚段大小，默认为<span class="number">128</span>k</span><br><span class="line"><span class="operator">|</span> innodb_undo_logs                        <span class="operator">|</span> <span class="number">128</span>                                      <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 设置回滚日志存放的目录。</span><br><span class="line"><span class="operator">|</span> innodb_undo_directory    <span class="operator">|</span> .<span class="operator">/</span>         <span class="operator">|</span></span><br><span class="line"># 设置了回滚日志由多少个回滚日志文件组成，默认为<span class="number">0.</span></span><br><span class="line"># Warning 特别注意：安装MySQL后需要在my.cnf中设置回滚日志的参数，</span><br><span class="line"># 如果创建数据库以后再设置回滚日志的参数，MySQL就会报错，并且回滚日志建好后，就不能再次修改或者增加。</span><br><span class="line"><span class="operator">|</span> innodb_undo_tablespaces  <span class="operator">|</span> <span class="number">0</span>          <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="keyword">on</span><span class="operator">|</span>文件路径 是否启用二进制日志,<span class="keyword">on</span>表示开启,文件路径表示指定自定义日志路径,</span><br><span class="line"># 默认路径在datadir指定的路径下</span><br><span class="line"><span class="operator">|</span> log_bin                                 <span class="operator">|</span> OFF<span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> log_bin_basename                        <span class="operator">|</span>                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                           <span class="operator">|</span>                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators         <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events               <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_builtin_as_identified_by_password   <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"># 定义错误日志</span><br><span class="line"><span class="operator">|</span> log_error                               <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysqld<span class="operator">-</span>error.log          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_error_verbosity                     <span class="operator">|</span> <span class="number">3</span>                                        <span class="operator">|</span></span><br><span class="line"># 日志的输出的位置，对慢查询和普通查询有效</span><br><span class="line"><span class="operator">|</span> log_output                              <span class="operator">|</span> FILE                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_queries_not_using_indexes           <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_slave_updates                       <span class="operator">|</span> <span class="keyword">ON</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_slow_admin_statements               <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_slow_slave_statements               <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_statements_unsafe_for_binlog        <span class="operator">|</span> <span class="keyword">ON</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_syslog                              <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_syslog_facility                     <span class="operator">|</span> daemon                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_syslog_include_pid                  <span class="operator">|</span> <span class="keyword">ON</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_syslog_tag                          <span class="operator">|</span>                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_throttle_queries_not_using_indexes  <span class="operator">|</span> <span class="number">0</span>                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_timestamps                          <span class="operator">|</span> UTC                                      <span class="operator">|</span></span><br><span class="line"># 是否把警告信息写入错误日志中</span><br><span class="line"><span class="operator">|</span> log_warnings                            <span class="operator">|</span> <span class="number">2</span>                                        <span class="operator">|</span></span><br><span class="line"># 二进定日志缓存空间大小，<span class="number">5.5</span><span class="number">.9</span>及以后的版本仅应用于事务缓存，</span><br><span class="line"># 其上限由max_binlog_stmt_cache_size决定。最大二进制缓存大小</span><br><span class="line"><span class="operator">|</span> max_binlog_cache_size                   <span class="operator">|</span> <span class="number">1844674407370954752</span>                      <span class="operator">|</span></span><br><span class="line"># 最大二进制日志大小,默认<span class="number">1</span>G,当达到这个值以后会自动滚动的</span><br><span class="line"><span class="operator">|</span> max_binlog_size                         <span class="operator">|</span> <span class="number">1073741824</span></span><br><span class="line"># 二进定日志缓存空间大小，<span class="number">5.5</span><span class="number">.9</span>及以后的版本仅应用于事务缓存</span><br><span class="line"># 最大基于语句二进制缓存大小</span><br><span class="line"><span class="operator">|</span> max_binlog_stmt_cache_size              <span class="operator">|</span> <span class="number">18446744073709547520</span></span><br><span class="line"># 最大中继日志大小</span><br><span class="line"><span class="operator">|</span> max_relay_log_size                      <span class="operator">|</span> <span class="number">0</span>                                        <span class="operator">|</span></span><br><span class="line"># 中继日志</span><br><span class="line"><span class="operator">|</span> relay_log                               <span class="operator">|</span>                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> relay_log_basename                      <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>incloudos<span class="operator">-</span>relay<span class="operator">-</span>bin       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> relay_log_index                         <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>incloudos<span class="operator">-</span>relay<span class="operator">-</span>bin.index <span class="operator">|</span></span><br><span class="line"># 中继日志存放的文件 </span><br><span class="line"><span class="operator">|</span> relay_log_info_file                     <span class="operator">|</span> relay<span class="operator">-</span>log.info                           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> relay_log_info_repository               <span class="operator">|</span> FILE                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> relay_log_purge                         <span class="operator">|</span> <span class="keyword">ON</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> relay_log_recovery                      <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> relay_log_space_limit                   <span class="operator">|</span> <span class="number">0</span>                                        <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 定义慢查询日志的</span><br><span class="line"><span class="operator">|</span> slow_query_log                          <span class="operator">|</span> <span class="keyword">ON</span>                                       <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 输出方式为file（文件）时定义慢查询日志的位置</span><br><span class="line"><span class="operator">|</span> slow_query_log_file                     <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow<span class="operator">-</span>query.log      <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"># 用于控制会话级别二进制日志功能的开启或关闭。默认为<span class="keyword">ON</span>，表示启用记录功能。</span><br><span class="line"># 用户可以在会话级别修改此变量的值，但其必须具有SUPER权限。</span><br><span class="line"><span class="operator">|</span> sql_log_bin                             <span class="operator">|</span> <span class="keyword">ON</span></span><br><span class="line"><span class="operator">|</span> sql_log_off                             <span class="operator">|</span> OFF                                      <span class="operator">|</span></span><br><span class="line"># 设定多久同步一次二进制日志至磁盘文件中，<span class="number">0</span>表示不同步，任何正数值都表示对二进制每多少次写操</span><br><span class="line"># 作之后同步一次。当autocommit的值为<span class="number">1</span>时，每条语句的执行都会引起二进制日志同步，</span><br><span class="line"># 否则，每个事务的提交会引起二进制日志同步</span><br><span class="line"><span class="operator">|</span> sync_binlog                             <span class="operator">|</span> <span class="number">1</span></span><br><span class="line"><span class="operator">|</span> sync_relay_log                          <span class="operator">|</span> <span class="number">10000</span>                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sync_relay_log_info                     <span class="operator">|</span> <span class="number">10000</span>                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------+------------------------------------------+</span></span><br><span class="line"><span class="number">72</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="配置文件my-cnf参考"><a href="#配置文件my-cnf参考" class="headerlink" title="配置文件my.cnf参考"></a>配置文件my.cnf参考</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Example MySQL config file <span class="keyword">for</span> medium systems.</span><br><span class="line">#</span><br><span class="line"># This <span class="keyword">is</span> <span class="keyword">for</span> a <span class="keyword">system</span> <span class="keyword">with</span> little memory (<span class="number">32</span>M <span class="operator">-</span> <span class="number">64</span>M) <span class="keyword">where</span> MySQL plays</span><br><span class="line"># an important part, <span class="keyword">or</span> systems up <span class="keyword">to</span> <span class="number">128</span>M <span class="keyword">where</span> MySQL <span class="keyword">is</span> used together <span class="keyword">with</span></span><br><span class="line"># other programs (such <span class="keyword">as</span> a web server)</span><br><span class="line">#</span><br><span class="line"># You can <span class="keyword">copy</span> this file <span class="keyword">to</span></span><br><span class="line"># <span class="operator">/</span>etc<span class="operator">/</span>my.cnf <span class="keyword">to</span> <span class="keyword">set</span> <span class="keyword">global</span> options,</span><br><span class="line"># mysql<span class="operator">-</span>data<span class="operator">-</span>dir<span class="operator">/</span>my.cnf <span class="keyword">to</span> <span class="keyword">set</span> server<span class="operator">-</span><span class="keyword">specific</span> options (<span class="keyword">in</span> this</span><br><span class="line"># installation this directory <span class="keyword">is</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql) <span class="keyword">or</span></span><br><span class="line"># <span class="operator">~</span><span class="operator">/</span>.my.cnf <span class="keyword">to</span> <span class="keyword">set</span> <span class="keyword">user</span><span class="operator">-</span><span class="keyword">specific</span> options.</span><br><span class="line">#</span><br><span class="line"># <span class="keyword">In</span> this file, you can use <span class="keyword">all</span> long options that a program supports.</span><br><span class="line"># If you want <span class="keyword">to</span> know which options a program supports, run the program</span><br><span class="line"># <span class="keyword">with</span> the &quot;--help&quot; option.</span><br><span class="line"></span><br><span class="line"># The following options will be passed <span class="keyword">to</span> <span class="keyword">all</span> MySQL clients</span><br><span class="line">[client]</span><br><span class="line">port                <span class="operator">=</span> <span class="number">3306</span></span><br><span class="line">socket                <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql.sock</span><br><span class="line"><span class="keyword">default</span><span class="operator">-</span><span class="type">character</span><span class="operator">-</span><span class="keyword">set</span> <span class="operator">=</span> utf8</span><br><span class="line"></span><br><span class="line"># Here follows entries <span class="keyword">for</span> <span class="keyword">some</span> <span class="keyword">specific</span> programs</span><br><span class="line"></span><br><span class="line"># The MySQL server</span><br><span class="line">[mysqld]</span><br><span class="line">event_scheduler<span class="operator">=</span><span class="keyword">ON</span></span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>name<span class="operator">-</span>resolve</span><br><span class="line">port                <span class="operator">=</span> <span class="number">3306</span></span><br><span class="line"># explicit_defaults_for_timestamp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">socket                <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql.sock</span><br><span class="line"><span class="keyword">default</span><span class="operator">-</span>storage<span class="operator">-</span>engine <span class="operator">=</span> INNODB</span><br><span class="line"></span><br><span class="line">sql_mode<span class="operator">=</span><span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;</span></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span><span class="operator">&gt;</span> interactive_timeout针对交互式连接，wait_timeout针对非交互式连接。</span><br><span class="line"># 所谓的交互式连接，即在mysql_real_connect()函数中使用了CLIENT_INTERACTIVE选项。</span><br><span class="line"># 说得直白一点，通过mysql客户端连接数据库是交互式连接，通过jdbc连接数据库是非交互式连接。</span><br><span class="line"></span><br><span class="line">#<span class="number">1.</span> 控制连接最大空闲时长是wait_timeout参数。</span><br><span class="line">#<span class="number">2.</span> 对于非交互式连接，类似于jdbc连接，wait_timeout的值继承自服务器端全局变量wait_timeout。</span><br><span class="line">#   对于交互式连接，类似于mysql客户单连接，wait_timeout的值继承自服务器端全局变量interactive_timeout。</span><br><span class="line">#<span class="number">3.</span> 判断一个连接的空闲时间，可通过<span class="keyword">show</span> processlist输出中Sleep状态的时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wait_timeout<span class="operator">=</span><span class="number">1800</span></span><br><span class="line">interactive_timeout<span class="operator">=</span><span class="number">1800</span></span><br><span class="line"></span><br><span class="line">#数据文件单独存放</span><br><span class="line">innodb_file_per_table</span><br><span class="line">max_connections <span class="operator">=</span> <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"># 这个是定义mysql服务器端和客户端在一次传送数据包的过程当中数据包的大小</span><br><span class="line"># 定义过大，<span class="number">8092</span>，有可能服务器端太忙，来不及接收，或者网络太差，会容易造成丢包</span><br><span class="line"># 定义过小，会因为客户端可能无法快速接收服务器端发过来的包，一般推荐是<span class="number">4096</span></span><br><span class="line"># 用来控制其通信缓冲区的最大长度。</span><br><span class="line">max_allowed_packet <span class="operator">=</span> <span class="number">4</span>M</span><br><span class="line"></span><br><span class="line">sort_buffer_size <span class="operator">=</span> <span class="number">512</span>K</span><br><span class="line">net_buffer_length <span class="operator">=</span> <span class="number">8</span>K</span><br><span class="line">read_buffer_size <span class="operator">=</span> <span class="number">256</span>K</span><br><span class="line">read_rnd_buffer_size <span class="operator">=</span> <span class="number">512</span>K</span><br><span class="line">character_set_server<span class="operator">=</span>utf8</span><br><span class="line">thread_cache_size<span class="operator">=</span><span class="number">300</span></span><br><span class="line">tmp_table_size<span class="operator">=</span><span class="number">500</span>M</span><br><span class="line">max_heap_table_size<span class="operator">=</span><span class="number">300</span>M</span><br><span class="line"></span><br><span class="line">#<span class="keyword">open</span> slow query</span><br><span class="line">slow<span class="operator">-</span>query<span class="operator">-</span>log<span class="operator">=</span><span class="number">1</span></span><br><span class="line">slow<span class="operator">-</span>query<span class="operator">-</span>log<span class="operator">-</span>file<span class="operator">=</span><span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow<span class="operator">-</span>query.log</span><br><span class="line">#<span class="keyword">set</span> slow <span class="type">time</span> <span class="keyword">to</span> <span class="number">1</span> <span class="keyword">second</span></span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">log<span class="operator">-</span>error<span class="operator">=</span><span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysqld<span class="operator">-</span>error.log</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span><span class="operator">-</span>infile<span class="operator">=</span><span class="number">0</span></span><br><span class="line"></span><br><span class="line"># <span class="type">binary</span> logging <span class="keyword">is</span> required <span class="keyword">for</span> replication</span><br><span class="line">####log<span class="operator">-</span>bin<span class="operator">=</span>mysql<span class="operator">-</span>bin</span><br><span class="line"></span><br><span class="line">#master <span class="operator">-</span> slave syncronized setting</span><br><span class="line">log_slave_updates<span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"># required <span class="keyword">unique</span> id <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span><span class="operator">^</span><span class="number">32</span> <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"># defaults <span class="keyword">to</span> <span class="number">1</span> if master<span class="operator">-</span>host <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">set</span></span><br><span class="line"># but will <span class="keyword">not</span> <span class="keyword">function</span> <span class="keyword">as</span> a master if omitted</span><br><span class="line">server<span class="operator">-</span>id        <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># Replication Slave (comment <span class="keyword">out</span> master section <span class="keyword">to</span> use this)</span><br><span class="line">#</span><br><span class="line"># <span class="keyword">To</span> configure this host <span class="keyword">as</span> a replication slave, you can choose <span class="keyword">between</span></span><br><span class="line"># two methods :</span><br><span class="line">#</span><br><span class="line"># <span class="number">1</span>) Use the CHANGE MASTER <span class="keyword">TO</span> command (fully described <span class="keyword">in</span> our manual) <span class="operator">-</span></span><br><span class="line">#    the syntax <span class="keyword">is</span>:</span><br><span class="line">#</span><br><span class="line">#    CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="operator">&lt;</span>host<span class="operator">&gt;</span>, MASTER_PORT<span class="operator">=</span><span class="operator">&lt;</span>port<span class="operator">&gt;</span>,</span><br><span class="line">#    MASTER_USER<span class="operator">=</span><span class="operator">&lt;</span><span class="keyword">user</span><span class="operator">&gt;</span>, MASTER_PASSWORD<span class="operator">=</span><span class="operator">&lt;</span>password<span class="operator">&gt;</span> ;</span><br><span class="line">#</span><br><span class="line">#    <span class="keyword">where</span> you replace <span class="operator">&lt;</span>host<span class="operator">&gt;</span>, <span class="operator">&lt;</span><span class="keyword">user</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>password<span class="operator">&gt;</span> <span class="keyword">by</span> quoted strings <span class="keyword">and</span></span><br><span class="line">#    <span class="operator">&lt;</span>port<span class="operator">&gt;</span> <span class="keyword">by</span> the master<span class="string">&#x27;s port number (3306 by default).</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">#    Example:</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">#    CHANGE MASTER TO MASTER_HOST=&#x27;</span><span class="number">125.564</span><span class="number">.12</span><span class="number">.1</span><span class="string">&#x27;, MASTER_PORT=3306,</span></span><br><span class="line"><span class="string">#    MASTER_USER=&#x27;</span>joe<span class="string">&#x27;, MASTER_PASSWORD=&#x27;</span>secret<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># OR</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># 2) Set the variables below. However, in case you choose this method, then</span></span><br><span class="line"><span class="string">#    start replication for the first time (even unsuccessfully, for example</span></span><br><span class="line"><span class="string">#    if you mistyped the password in master-password and the slave fails to</span></span><br><span class="line"><span class="string">#    connect), the slave will create a master.info file, and any later</span></span><br><span class="line"><span class="string">#    change in this file to the variables&#x27;</span> <span class="keyword">values</span> below will be ignored <span class="keyword">and</span></span><br><span class="line">#    overridden <span class="keyword">by</span> the content <span class="keyword">of</span> the master.info file, unless you shutdown</span><br><span class="line">#    the slave server, <span class="keyword">delete</span> master.info <span class="keyword">and</span> restart the slaver server.</span><br><span class="line">#    <span class="keyword">For</span> that reason, you may want <span class="keyword">to</span> leave the lines below untouched</span><br><span class="line">#    (commented) <span class="keyword">and</span> instead use CHANGE MASTER <span class="keyword">TO</span> (see above)</span><br><span class="line">#</span><br><span class="line"># required <span class="keyword">unique</span> id <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">2</span><span class="operator">^</span><span class="number">32</span> <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"># (<span class="keyword">and</span> different <span class="keyword">from</span> the master)</span><br><span class="line"># defaults <span class="keyword">to</span> <span class="number">2</span> if master<span class="operator">-</span>host <span class="keyword">is</span> <span class="keyword">set</span></span><br><span class="line"># but will <span class="keyword">not</span> <span class="keyword">function</span> <span class="keyword">as</span> a slave if omitted</span><br><span class="line">#server<span class="operator">-</span>id       <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">#</span><br><span class="line"># The replication master <span class="keyword">for</span> this slave <span class="operator">-</span> required</span><br><span class="line">#master<span class="operator">-</span>host     <span class="operator">=</span>   <span class="operator">&lt;</span>hostname<span class="operator">&gt;</span></span><br><span class="line">#</span><br><span class="line"># The username the slave will use <span class="keyword">for</span> authentication <span class="keyword">when</span> connecting</span><br><span class="line"># <span class="keyword">to</span> the master <span class="operator">-</span> required</span><br><span class="line">#master<span class="operator">-</span><span class="keyword">user</span>     <span class="operator">=</span>   <span class="operator">&lt;</span>username<span class="operator">&gt;</span></span><br><span class="line">#</span><br><span class="line"># The password the slave will authenticate <span class="keyword">with</span> <span class="keyword">when</span> connecting <span class="keyword">to</span></span><br><span class="line"># the master <span class="operator">-</span> required</span><br><span class="line">#master<span class="operator">-</span>password <span class="operator">=</span>   <span class="operator">&lt;</span>password<span class="operator">&gt;</span></span><br><span class="line">#</span><br><span class="line"># The port the master <span class="keyword">is</span> listening on.</span><br><span class="line"># optional <span class="operator">-</span> defaults <span class="keyword">to</span> <span class="number">3306</span></span><br><span class="line">#master<span class="operator">-</span>port     <span class="operator">=</span>  <span class="operator">&lt;</span>port<span class="operator">&gt;</span></span><br><span class="line">#</span><br><span class="line"># <span class="type">binary</span> logging <span class="operator">-</span> <span class="keyword">not</span> required <span class="keyword">for</span> slaves, but recommended</span><br><span class="line">#log<span class="operator">-</span>bin<span class="operator">=</span>mysql<span class="operator">-</span>bin</span><br><span class="line"></span><br><span class="line"># Point the following paths <span class="keyword">to</span> different dedicated disks</span><br><span class="line">#tmpdir                <span class="operator">=</span> <span class="operator">/</span>tmp<span class="operator">/</span>                </span><br><span class="line">#log<span class="operator">-</span><span class="keyword">update</span>         <span class="operator">=</span> <span class="operator">/</span>path<span class="operator">-</span><span class="keyword">to</span><span class="operator">-</span>dedicated<span class="operator">-</span>directory<span class="operator">/</span>hostname</span><br><span class="line"></span><br><span class="line"># Uncomment the following if you <span class="keyword">are</span> <span class="keyword">using</span> BDB tables</span><br><span class="line">#bdb_cache_size <span class="operator">=</span> <span class="number">4</span>M</span><br><span class="line">#bdb_max_lock <span class="operator">=</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"># Uncomment the following if you <span class="keyword">are</span> <span class="keyword">using</span> InnoDB tables</span><br><span class="line">#innodb_data_home_dir <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span></span><br><span class="line">#innodb_data_file_path <span class="operator">=</span> ibdata1:<span class="number">10</span>M:autoextend</span><br><span class="line">#innodb_log_group_home_dir <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span></span><br><span class="line">#innodb_log_arch_dir <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span></span><br><span class="line"># You can <span class="keyword">set</span> .._buffer_pool_size up <span class="keyword">to</span> <span class="number">50</span> <span class="operator">-</span> <span class="number">80</span> <span class="operator">%</span></span><br><span class="line"># <span class="keyword">of</span> RAM but beware <span class="keyword">of</span> setting memory usage too high</span><br><span class="line">#innodb_buffer_pool_size <span class="operator">=</span> <span class="number">16</span>M</span><br><span class="line">#innodb_additional_mem_pool_size <span class="operator">=</span> <span class="number">2</span>M</span><br><span class="line"># <span class="keyword">Set</span> .._log_file_size <span class="keyword">to</span> <span class="number">25</span> <span class="operator">%</span> <span class="keyword">of</span> buffer pool size</span><br><span class="line">#innodb_log_file_size <span class="operator">=</span> <span class="number">5</span>M</span><br><span class="line">#innodb_log_buffer_size <span class="operator">=</span> <span class="number">8</span>M</span><br><span class="line">#innodb_flush_log_at_trx_commit <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">#innodb_lock_wait_timeout <span class="operator">=</span> <span class="number">50</span></span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">max_allowed_packet <span class="operator">=</span> <span class="number">16</span>M</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"><span class="keyword">no</span><span class="operator">-</span>auto<span class="operator">-</span>rehash</span><br><span class="line"># Remove the next comment <span class="type">character</span> if you <span class="keyword">are</span> <span class="keyword">not</span> familiar <span class="keyword">with</span> <span class="keyword">SQL</span></span><br><span class="line">#safe<span class="operator">-</span>updates</span><br><span class="line"></span><br><span class="line">#[isamchk]</span><br><span class="line">#key_buffer <span class="operator">=</span> <span class="number">20</span>M</span><br><span class="line">#sort_buffer_size <span class="operator">=</span> <span class="number">20</span>M</span><br><span class="line">#read_buffer <span class="operator">=</span> <span class="number">2</span>M</span><br><span class="line">#write_buffer <span class="operator">=</span> <span class="number">2</span>M</span><br><span class="line"></span><br><span class="line">#[myisamchk]</span><br><span class="line">#key_buffer <span class="operator">=</span> <span class="number">20</span>M</span><br><span class="line">#sort_buffer_size <span class="operator">=</span> <span class="number">20</span>M</span><br><span class="line">#read_buffer <span class="operator">=</span> <span class="number">2</span>M</span><br><span class="line">#write_buffer <span class="operator">=</span> <span class="number">2</span>M</span><br><span class="line"></span><br><span class="line">[mysqlhotcopy]</span><br><span class="line">interactive<span class="operator">-</span>timeout</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/ggxxkkll/article/details/7616739">数据库日志文件– undo log 、redo log、 undo/redo log</a></li>
<li><a href="https://blog.csdn.net/leonpenn/article/details/72778901">InnoDB事务日志（redo log 和 undo log）详解</a></li>
<li><a href="https://www.iteye.com/blog/dinglin-907123">MySQL源码学习：ib_logfile、bin-log与主从同步</a></li>
<li><a href="https://blog.csdn.net/hackerwin7/article/details/39896173">Mysql日志抽取与解析</a></li>
<li><a href="https://blog.csdn.net/u010440155/article/details/54914353">mysql data文件夹下的ibdata1 文件作用</a></li>
<li><a href="https://blog.csdn.net/donghaixiaolongwang/article/details/60961603">mysql——innodb事务日志详解</a></li>
<li><a href="https://blog.csdn.net/mydriverc2/article/details/50629599">inlog，redo log，undo log区别</a></li>
<li><a href="http://www.itwendao.com/article/detail/450198.html">高性能MySQL学习笔记（3） — InnoDB事务日志（redo log 和 undo log）详解</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之账户管理</title>
    <url>/2021/02/04/MySQL%E4%B9%8B%E8%B4%A6%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="Mysql账户体系"><a href="#Mysql账户体系" class="headerlink" title="Mysql账户体系"></a>Mysql账户体系</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mysql           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> columns_priv              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> db                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> procs_priv                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> proxies_priv              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tables_priv               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">user</span>                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">31</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>根据账户所具有的权限的不同，MySQL的账户可以分为以下几种：</p>
<h3 id="服务实例级账号"><a href="#服务实例级账号" class="headerlink" title="服务实例级账号"></a>服务实例级账号</h3><p>如果某用户如root,拥有服务实例级分配的权限，那么该账号就可以删除所有的数据库、连同这些库中的表。</p>
<h3 id="数据库级别账号-db"><a href="#数据库级别账号-db" class="headerlink" title="数据库级别账号-db"></a>数据库级别账号-db</h3><ol>
<li>该账号可以在具有权限的数据库中执行增删改查的所有操作（如果分配了这些权限）。</li>
<li>db表列出数据库，而用户有权限访问它们。在这里指定的权限适用于一个数据库中的<strong>所有表</strong>。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> db;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+---------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field                 <span class="operator">|</span> Type          <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+---------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Host                  <span class="operator">|</span> <span class="type">char</span>(<span class="number">60</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>         <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Db                    <span class="operator">|</span> <span class="type">char</span>(<span class="number">64</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>         <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">User</span>                  <span class="operator">|</span> <span class="type">char</span>(<span class="number">32</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>         <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Select_priv           <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Insert_priv           <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Update_priv           <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Delete_priv           <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Create_priv           <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Drop_priv             <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Grant_priv            <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> References_priv       <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Index_priv            <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Alter_priv            <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Create_tmp_table_priv <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Lock_tables_priv      <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Create_view_priv      <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Show_view_priv        <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Create_routine_priv   <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Alter_routine_priv    <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Execute_priv          <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Event_priv            <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Trigger_priv          <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+---------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">22</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">7.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                 Host: <span class="operator">%</span></span><br><span class="line">                   Db: sunld_db</span><br><span class="line">                 <span class="keyword">User</span>: account_sunld_db</span><br><span class="line">          Select_priv: Y</span><br><span class="line">          Insert_priv: Y</span><br><span class="line">          Update_priv: Y</span><br><span class="line">          Delete_priv: Y</span><br><span class="line">          Create_priv: Y</span><br><span class="line">            Drop_priv: Y</span><br><span class="line">           Grant_priv: Y</span><br><span class="line">      References_priv: Y</span><br><span class="line">           Index_priv: Y</span><br><span class="line">           Alter_priv: Y</span><br><span class="line">Create_tmp_table_priv: Y</span><br><span class="line">     Lock_tables_priv: Y</span><br><span class="line">     Create_view_priv: Y</span><br><span class="line">       Show_view_priv: Y</span><br><span class="line">  Create_routine_priv: Y</span><br><span class="line">   Alter_routine_priv: Y</span><br><span class="line">         Execute_priv: Y</span><br><span class="line">           Event_priv: Y</span><br><span class="line">         Trigger_priv: Y</span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="数据表级别账号-tables-priv"><a href="#数据表级别账号-tables-priv" class="headerlink" title="数据表级别账号-tables_priv"></a>数据表级别账号-tables_priv</h3><ol>
<li>该账号可以在具有权限的表上执行增删改查等所有操作（如果分配了这些权限）。</li>
<li>tables_priv表指定表级权限，在这里指定的一个权限适用于一个表的<strong>所有列</strong>。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> tables_priv;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-----------------------------------------------------------------------------------------------------------------------------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Field       <span class="operator">|</span> Type                                                                                                                              <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>           <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-----------------------------------------------------------------------------------------------------------------------------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Host        <span class="operator">|</span> <span class="type">char</span>(<span class="number">60</span>)                                                                                                                          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Db          <span class="operator">|</span> <span class="type">char</span>(<span class="number">64</span>)                                                                                                                          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">User</span>        <span class="operator">|</span> <span class="type">char</span>(<span class="number">32</span>)                                                                                                                          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Table_name  <span class="operator">|</span> <span class="type">char</span>(<span class="number">64</span>)                                                                                                                          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Grantor     <span class="operator">|</span> <span class="type">char</span>(<span class="number">93</span>)                                                                                                                          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> MUL <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="type">Timestamp</span>   <span class="operator">|</span> <span class="type">timestamp</span>                                                                                                                         <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Table_priv  <span class="operator">|</span> <span class="keyword">set</span>(<span class="string">&#x27;Select&#x27;</span>,<span class="string">&#x27;Insert&#x27;</span>,<span class="string">&#x27;Update&#x27;</span>,<span class="string">&#x27;Delete&#x27;</span>,<span class="string">&#x27;Create&#x27;</span>,<span class="string">&#x27;Drop&#x27;</span>,<span class="string">&#x27;Grant&#x27;</span>,<span class="string">&#x27;References&#x27;</span>,<span class="string">&#x27;Index&#x27;</span>,<span class="string">&#x27;Alter&#x27;</span>,<span class="string">&#x27;Create View&#x27;</span>,<span class="string">&#x27;Show view&#x27;</span>,<span class="string">&#x27;Trigger&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Column_priv <span class="operator">|</span> <span class="keyword">set</span>(<span class="string">&#x27;Select&#x27;</span>,<span class="string">&#x27;Insert&#x27;</span>,<span class="string">&#x27;Update&#x27;</span>,<span class="string">&#x27;References&#x27;</span>)                                                                                      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-----------------------------------------------------------------------------------------------------------------------------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">4.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">       Host: <span class="operator">%</span></span><br><span class="line">         Db: sunld_db</span><br><span class="line">       <span class="keyword">User</span>: account_sunld_table</span><br><span class="line"> Table_name: tb_a</span><br><span class="line">    Grantor: root<span class="variable">@localhost</span></span><br><span class="line">  <span class="type">Timestamp</span>: <span class="number">0000</span><span class="number">-00</span><span class="number">-00</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"> Table_priv: <span class="keyword">Select</span>,<span class="keyword">Insert</span>,<span class="keyword">Update</span>,<span class="keyword">Delete</span>,<span class="keyword">Create</span>,<span class="keyword">Drop</span>,<span class="keyword">References</span>,Index,<span class="keyword">Alter</span>,<span class="keyword">Create</span> <span class="keyword">View</span>,<span class="keyword">Show</span> <span class="keyword">view</span>,<span class="keyword">Trigger</span></span><br><span class="line">Column_priv:</span><br></pre></td></tr></table></figure>
<h3 id="字段级别的权限-columns-priv"><a href="#字段级别的权限-columns-priv" class="headerlink" title="字段级别的权限-columns_priv"></a>字段级别的权限-columns_priv</h3><ol>
<li>该账号可以对某些表中具有权限的字段进行操作（取决于所分配的权限）。</li>
<li>columns_priv表指定列级权限。这里指定的权限适用于一个表的特定列。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> columns_priv;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+----------------------------------------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Field       <span class="operator">|</span> Type                                         <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>           <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+----------------------------------------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Host        <span class="operator">|</span> <span class="type">char</span>(<span class="number">60</span>)                                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Db          <span class="operator">|</span> <span class="type">char</span>(<span class="number">64</span>)                                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">User</span>        <span class="operator">|</span> <span class="type">char</span>(<span class="number">32</span>)                                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Table_name  <span class="operator">|</span> <span class="type">char</span>(<span class="number">64</span>)                                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Column_name <span class="operator">|</span> <span class="type">char</span>(<span class="number">64</span>)                                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="type">Timestamp</span>   <span class="operator">|</span> <span class="type">timestamp</span>                                    <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Column_priv <span class="operator">|</span> <span class="keyword">set</span>(<span class="string">&#x27;Select&#x27;</span>,<span class="string">&#x27;Insert&#x27;</span>,<span class="string">&#x27;Update&#x27;</span>,<span class="string">&#x27;References&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+----------------------------------------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="存储程序级别的账号"><a href="#存储程序级别的账号" class="headerlink" title="存储程序级别的账号"></a>存储程序级别的账号</h3><p>该账号可以对存储程序进行增删改查的操作（取决于所分配的权限）</p>
<h3 id="user表"><a href="#user表" class="headerlink" title="user表"></a>user表</h3><p>user表列出可以连接服务器的用户及其口令，并且它指定他们有哪种全局（超级用户）权限。在user表启用的任何权限均是全局权限，并适用于所有数据库。例如，如果你启用了DELETE权限，在这里列出的用户可以从任何表中删除记录，所以在你这样做之前要认真考虑。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-----------------------------------+------+-----+-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field                  <span class="operator">|</span> Type                              <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>               <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-----------------------------------+------+-----+-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Host                   <span class="operator">|</span> <span class="type">char</span>(<span class="number">60</span>)                          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">User</span>                   <span class="operator">|</span> <span class="type">char</span>(<span class="number">32</span>)                          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Select_priv            <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Insert_priv            <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Update_priv            <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Delete_priv            <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Create_priv            <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Drop_priv              <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Reload_priv            <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Shutdown_priv          <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Process_priv           <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> File_priv              <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Grant_priv             <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> References_priv        <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Index_priv             <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Alter_priv             <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Show_db_priv           <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Super_priv             <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Create_tmp_table_priv  <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Lock_tables_priv       <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Execute_priv           <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Repl_slave_priv        <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Repl_client_priv       <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Create_view_priv       <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Show_view_priv         <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Create_routine_priv    <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Alter_routine_priv     <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Create_user_priv       <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Event_priv             <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Trigger_priv           <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Create_tablespace_priv <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ssl_type               <span class="operator">|</span> enum(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;ANY&#x27;</span>,<span class="string">&#x27;X509&#x27;</span>,<span class="string">&#x27;SPECIFIED&#x27;</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span>                       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ssl_cipher             <span class="operator">|</span> <span class="type">blob</span>                              <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> x509_issuer            <span class="operator">|</span> <span class="type">blob</span>                              <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> x509_subject           <span class="operator">|</span> <span class="type">blob</span>                              <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> max_questions          <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>) unsigned                  <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="number">0</span>                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> max_updates            <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>) unsigned                  <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="number">0</span>                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> max_connections        <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>) unsigned                  <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="number">0</span>                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> max_user_connections   <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>) unsigned                  <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="number">0</span>                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> plugin                 <span class="operator">|</span> <span class="type">char</span>(<span class="number">64</span>)                          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> mysql_native_password <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> authentication_string  <span class="operator">|</span> text                              <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> password_expired       <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> password_last_changed  <span class="operator">|</span> <span class="type">timestamp</span>                         <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> password_lifetime      <span class="operator">|</span> <span class="type">smallint</span>(<span class="number">5</span>) unsigned              <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> account_locked         <span class="operator">|</span> enum(<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>)                     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> N                     <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-----------------------------------+------+-----+-----------------------+-------+</span></span><br><span class="line"><span class="number">45</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">12.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                  Host: <span class="operator">%</span></span><br><span class="line">                  <span class="keyword">User</span>: account_sunld_db_2</span><br><span class="line">           Select_priv: N</span><br><span class="line">           Insert_priv: N</span><br><span class="line">           Update_priv: N</span><br><span class="line">           Delete_priv: N</span><br><span class="line">           Create_priv: N</span><br><span class="line">             Drop_priv: N</span><br><span class="line">           Reload_priv: N</span><br><span class="line">         Shutdown_priv: N</span><br><span class="line">          Process_priv: N</span><br><span class="line">             File_priv: N</span><br><span class="line">            Grant_priv: N</span><br><span class="line">       References_priv: N</span><br><span class="line">            Index_priv: N</span><br><span class="line">            Alter_priv: N</span><br><span class="line">          Show_db_priv: N</span><br><span class="line">            Super_priv: N</span><br><span class="line"> Create_tmp_table_priv: N</span><br><span class="line">      Lock_tables_priv: N</span><br><span class="line">          Execute_priv: N</span><br><span class="line">       Repl_slave_priv: N</span><br><span class="line">      Repl_client_priv: N</span><br><span class="line">      Create_view_priv: N</span><br><span class="line">        Show_view_priv: N</span><br><span class="line">   Create_routine_priv: N</span><br><span class="line">    Alter_routine_priv: N</span><br><span class="line">      Create_user_priv: N</span><br><span class="line">            Event_priv: N</span><br><span class="line">          Trigger_priv: N</span><br><span class="line">Create_tablespace_priv: N</span><br><span class="line">              ssl_type: </span><br><span class="line">            ssl_cipher: </span><br><span class="line">           x509_issuer: </span><br><span class="line">          x509_subject: </span><br><span class="line">         max_questions: <span class="number">0</span></span><br><span class="line">           max_updates: <span class="number">0</span></span><br><span class="line">       max_connections: <span class="number">0</span></span><br><span class="line">  max_user_connections: <span class="number">0</span></span><br><span class="line">                plugin: mysql_native_password</span><br><span class="line"> authentication_string: <span class="operator">*</span><span class="number">6</span>BB4837EB74329105EE4568DDA7DC67ED2CA2AD9</span><br><span class="line">      password_expired: N</span><br><span class="line"> password_last_changed: <span class="number">2017</span><span class="number">-12</span><span class="number">-30</span> <span class="number">12</span>:<span class="number">33</span>:<span class="number">32</span></span><br><span class="line">     password_lifetime: <span class="keyword">NULL</span></span><br><span class="line">        account_locked: N</span><br></pre></td></tr></table></figure>
<h2 id="配置权限"><a href="#配置权限" class="headerlink" title="配置权限"></a>配置权限</h2><h3 id="grant-命令语法格式"><a href="#grant-命令语法格式" class="headerlink" title="grant 命令语法格式"></a>grant 命令语法格式</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限名称[字段列表] <span class="keyword">on</span> [数据库资源类型]数据库资源 <span class="keyword">to</span> MySQL账户<span class="number">1</span>,[MySQL账户<span class="number">2</span>] [<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br><span class="line"></span><br><span class="line">#增删改数据库数据权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">insert</span>, <span class="keyword">update</span>, <span class="keyword">delete</span> <span class="keyword">on</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">#创建、修改、删除 MySQL 数据表结构权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> ,<span class="keyword">alter</span>  ,<span class="keyword">drop</span>   <span class="keyword">on</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">#操作 MySQL 外键权限。</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">references</span> <span class="keyword">on</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">#操作 MySQL 临时表权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> temporary tables <span class="keyword">on</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">#操作 MySQL 索引权限</span><br><span class="line"><span class="keyword">grant</span> index <span class="keyword">on</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">#操作 MySQL 视图、查看视图源代码 权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">view</span> <span class="keyword">on</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">show</span>   <span class="keyword">view</span> <span class="keyword">on</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">#操作 MySQL 存储过程、函数 权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> routine <span class="keyword">on</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>; <span class="comment">-- now, can show procedure status</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">alter</span>  routine <span class="keyword">on</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>; <span class="comment">-- now, you can drop a procedure</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">execute</span>        <span class="keyword">on</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>;</span><br><span class="line">#普通 DBA 管理某个 MySQL 数据库的权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> db<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="keyword">to</span></span><br><span class="line">其中，关键字 “privileges” 可以省略。</span><br><span class="line">#高级 DBA 管理 MySQL 中所有数据库的权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span></span><br></pre></td></tr></table></figure>
<h3 id="创建服务实例级账号"><a href="#创建服务实例级账号" class="headerlink" title="创建服务实例级账号"></a>创建服务实例级账号</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建账号sunld_all，拥有所有数据库权限，并且具有<span class="keyword">grant</span>权限，</span><br><span class="line"># 可以创建其他拥有服务实例权限的其他用户。</span><br><span class="line"># 查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_all;</span><br><span class="line">ERROR <span class="number">1141</span> (<span class="number">42000</span>): There <span class="keyword">is</span> <span class="keyword">no</span> such <span class="keyword">grant</span> defined <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;account_sunld_all&#x27;</span> <span class="keyword">on</span> host <span class="string">&#x27;%&#x27;</span></span><br><span class="line"># 创建</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;account_sunld_all&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"># 查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_all;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> account_sunld_all@<span class="operator">%</span>                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_all&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="创建数据库实例账号"><a href="#创建数据库实例账号" class="headerlink" title="创建数据库实例账号"></a>创建数据库实例账号</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建账号sunld_db,拥有sunlddb数据库的所有权限，可以对该库中的表进行所有操作。</span><br><span class="line">#查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_db;</span><br><span class="line">ERROR <span class="number">1141</span> (<span class="number">42000</span>): There <span class="keyword">is</span> <span class="keyword">no</span> such <span class="keyword">grant</span> defined <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;account_sunld_db&#x27;</span> <span class="keyword">on</span> host <span class="string">&#x27;%&#x27;</span></span><br><span class="line">#创建</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> sunld_db.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;account_sunld_db&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line">#查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_db;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> account_sunld_db@<span class="operator">%</span>                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_db&#x27;</span>@<span class="string">&#x27;%&#x27;</span>                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> `sunld_db`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_db&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="创建数据表级别的账号"><a href="#创建数据表级别的账号" class="headerlink" title="创建数据表级别的账号"></a>创建数据表级别的账号</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建账号sunld_table，对sunlddb数据中的tb_a表拥有所有权限</span><br><span class="line">#查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_table;</span><br><span class="line">ERROR <span class="number">1141</span> (<span class="number">42000</span>): There <span class="keyword">is</span> <span class="keyword">no</span> such <span class="keyword">grant</span> defined <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;account_sunld_table&#x27;</span> <span class="keyword">on</span> host <span class="string">&#x27;%&#x27;</span></span><br><span class="line">#创建</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="keyword">table</span> sunld_db.tb_a <span class="keyword">to</span> <span class="string">&#x27;account_sunld_table&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">#查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_table;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> account_sunld_table@<span class="operator">%</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_table&#x27;</span>@<span class="string">&#x27;%&#x27;</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> `sunld_db`.`tb_a` <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_table&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#这里在给一个用户授权多张表时，可以多次执行以上语句。例如：</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>(user_id,username) <span class="keyword">on</span> smp.users <span class="keyword">to</span> mo_user@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123345&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> smp.mo_sms <span class="keyword">to</span> mo_user@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123345&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="作用在表中的列上"><a href="#作用在表中的列上" class="headerlink" title="作用在表中的列上"></a>作用在表中的列上</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>(id, se, rank) <span class="keyword">on</span> testdb.apache_log <span class="keyword">to</span> dba<span class="variable">@localhost</span>;</span><br></pre></td></tr></table></figure>
<h3 id="作用在存储过程、函数上"><a href="#作用在存储过程、函数上" class="headerlink" title="作用在存储过程、函数上"></a>作用在存储过程、函数上</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">execute</span> <span class="keyword">on</span> <span class="keyword">procedure</span> testdb.pr_add <span class="keyword">to</span> <span class="string">&#x27;dba&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">execute</span> <span class="keyword">on</span> <span class="keyword">function</span> testdb.fn_add <span class="keyword">to</span> <span class="string">&#x27;dba&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br></pre></td></tr></table></figure>
<p>字段设置冗余复杂，则每次MySQL在进行SQL执行的时候回进行同样复杂的权限判断，造成效率降低性能下降，同时也会存在安全隐患。因此简单、易管理的、高可用的权限才是可取的。</p>
<h3 id="权限的增删改查"><a href="#权限的增删改查" class="headerlink" title="权限的增删改查"></a>权限的增删改查</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_db_1;</span><br><span class="line">ERROR <span class="number">1141</span> (<span class="number">42000</span>): There <span class="keyword">is</span> <span class="keyword">no</span> such <span class="keyword">grant</span> defined <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;account_sunld_db_1&#x27;</span> <span class="keyword">on</span> host <span class="string">&#x27;%&#x27;</span></span><br><span class="line">#比如原本的权限为：</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">insert</span> <span class="keyword">on</span> sunld_db.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;account_sunld_db_1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line">#查询</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_db_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> account_sunld_db_1@<span class="operator">%</span>                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_db_1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> `sunld_db`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_db_1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">#想要增加<span class="keyword">update</span>, <span class="keyword">delete</span>,<span class="keyword">alter</span> 权限可以如下操作：</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">update</span>,<span class="keyword">delete</span>,<span class="keyword">alter</span> <span class="keyword">on</span> sunld_db.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;account_sunld_db_1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line">#然后使用</span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_db_1;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_db_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> account_sunld_db_1@<span class="operator">%</span>                                                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_db_1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>                                                            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span>, <span class="keyword">ALTER</span> <span class="keyword">ON</span> `sunld_db`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_db_1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">#删除权限<span class="keyword">insert</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">insert</span> <span class="keyword">on</span> sunld_db.<span class="operator">*</span> <span class="keyword">from</span>  <span class="string">&#x27;account_sunld_db_1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">查看</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> account_sunld_db_1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> account_sunld_db_1@<span class="operator">%</span>                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_db_1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>                                                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span>, <span class="keyword">ALTER</span> <span class="keyword">ON</span> `sunld_db`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;account_sunld_db_1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>用户管理也无非是增加用户、删除用户、密码修改和授权之类的。</p>
<h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><p>查询数据库mysql下的表user;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">user</span>                       <span class="operator">|</span> host      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> account_sunld_all          <span class="operator">|</span> <span class="operator">%</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> account_sunld_db           <span class="operator">|</span> <span class="operator">%</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> account_sunld_db_1         <span class="operator">|</span> <span class="operator">%</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> account_sunld_table        <span class="operator">|</span> <span class="operator">%</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> inspurCloudDB              <span class="operator">|</span> <span class="operator">%</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> inspurCloudCheckDBDiskSize <span class="operator">|</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> inspurCloudDB              <span class="operator">|</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> root                       <span class="operator">|</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> inspurCloudDB              <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql.sys                  <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> root                       <span class="operator">|</span> localhost <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-----------+</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="增加用户"><a href="#增加用户" class="headerlink" title="增加用户"></a>增加用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;USER_NAME&#x27;</span>@<span class="string">&#x27;HOST&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;PASSOWRD&#x27;</span>;</span><br><span class="line">#例子</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;account_sunld_db_2&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="设置用户密码"><a href="#设置用户密码" class="headerlink" title="设置用户密码"></a>设置用户密码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> password<span class="operator">=</span>password(<span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>其实这个命令不仅能够设置当前用户的密码，也可以设置其他用户的密码，这个命令的完整格式是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> password [<span class="keyword">for</span> <span class="keyword">USER</span>] <span class="operator">=</span> passowrd(<span class="string">&#x27;新密码&#x27;</span>);</span><br><span class="line">#例子</span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> account_sunld_db_2<span class="operator">=</span>password(<span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="在安装validate-password插件之后会出现如下信息"><a href="#在安装validate-password插件之后会出现如下信息" class="headerlink" title="在安装validate_password插件之后会出现如下信息"></a>在安装validate_password插件之后会出现如下信息</h4><p>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;validate_password%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                        <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> validate_password_check_user_name    <span class="operator">|</span> OFF    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> validate_password_dictionary_file    <span class="operator">|</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> validate_password_length             <span class="operator">|</span> <span class="number">8</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> validate_password_mixed_case_count   <span class="operator">|</span> <span class="number">1</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> validate_password_number_count       <span class="operator">|</span> <span class="number">1</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> validate_password_policy             <span class="operator">|</span> MEDIUM <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> validate_password_special_char_count <span class="operator">|</span> <span class="number">1</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+--------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>validate_password_policy有以下取值：  </p>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;Policy&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;Tests Performed&nbsp;&nbsp;&nbsp;</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;0 or LOW&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Length&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;1 or MEDIUM&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Length;&nbsp;&nbsp;&nbsp;numeric, lowercase/uppercase, and special characters&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;2 or STRONG&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Length;&nbsp;&nbsp;&nbsp;numeric, lowercase/uppercase, and special characters; dictionary file&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> validate_password_length<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> password<span class="operator">=</span>password(<span class="string">&#x27;123456a?&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> USER_NAME；</span><br><span class="line">#例子</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> account_sunld_db_2;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="MySQL-grant、revoke-用户权限注意事项"><a href="#MySQL-grant、revoke-用户权限注意事项" class="headerlink" title="MySQL grant、revoke 用户权限注意事项"></a>MySQL grant、revoke 用户权限注意事项</h4><ol>
<li>grant, revoke 用户权限后，该用户只有重新连接 MySQL 数据库，权限才能生效。</li>
<li>如果想让授权的用户，也可以将这些权限 grant 给其他用户，需要选项 “grant option“,grant select on testdb.* to ‘dba’@’localhost’ with grant option;这个特性一般用不到。实际中，数据库权限最好由 DBA 来统一管理。</li>
</ol>
<h4 id="符号"><a href="#符号" class="headerlink" title="@符号"></a>@符号</h4><p>当不加@选项时，效果与加@’%’是一样的，’%’从名义上包括任何主机，（%必须加上引号，不然与@放在一起可能不会被辨认出。）不过有些时候（有些版本）’%’不包括localhost，要单独对@’localhost’进行赋值。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/fslnet/p/3143344.html">mysql 用户管理和权限设置</a></li>
<li><a href="https://www.cnblogs.com/hcbin/archive/2010/04/23/1718379.html">MySQL- MySQL的Grant命令</a></li>
<li><a href="https://www.cnblogs.com/jifeng/archive/2011/03/06/1972183.html">mysql 数据库授权(给某个用户授权某个数据库)</a></li>
<li><a href="https://www.cnblogs.com/ivictor/p/5142809.html">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</a></li>
<li><a href="https://www.cnblogs.com/roverliang/p/6444512.html">MySQL账户管理</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>账户管理</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之配置文件</title>
    <url>/2021/02/04/MySQL%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>下面是72GB内存生产环境中my.cnf配置文件，读者可以作为一个优化参考：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">############################缓存配置整体说明############################################</span><br><span class="line">## global_buffers 在内存中缓存从数据文件中检索出来的数据块，可以大大提高查询和更新数据的性能</span><br><span class="line">## 计算公式： Innodb_buffer_pool_size <span class="operator">+</span></span><br><span class="line">##           Innodb_additional_mem_pool_size <span class="operator">+</span></span><br><span class="line">##           Innodb_log_buffer_size <span class="operator">+</span></span><br><span class="line">##           key_buffer_size <span class="operator">+</span></span><br><span class="line">##           query_cache_size</span><br><span class="line">##</span><br><span class="line">##</span><br><span class="line">## per_thread_buffers 线程独享内存大小</span><br><span class="line">## 计算公式（ </span><br><span class="line">##             read_buffer_size <span class="operator">+</span></span><br><span class="line">##             read_rnd_buffer_size <span class="operator">+</span></span><br><span class="line">##             sort_buffer_size <span class="operator">+</span></span><br><span class="line">##             thread_stack <span class="operator">+</span></span><br><span class="line">##             join_buffer_size <span class="operator">+</span></span><br><span class="line">##             binlog_cache_size ）<span class="operator">*</span> max_connections</span><br><span class="line"></span><br><span class="line">## 注意：global_buffers <span class="operator">+</span> per_thread_buffers不能大于实际物理内存，</span><br><span class="line">## 否者并发量大时会造成内存溢出、系统死机 ！</span><br><span class="line">############################缓存配置整体说明############################################</span><br><span class="line"># MySQL configuration <span class="keyword">for</span> <span class="number">72</span>G memory</span><br><span class="line">#定义客户端连接信息，端口号、socket 存放位置</span><br><span class="line">[client]</span><br><span class="line">port    <span class="operator">=</span> <span class="number">3306</span></span><br><span class="line">socket  <span class="operator">=</span> <span class="operator">/</span>tmp<span class="operator">/</span>mysql.sock</span><br><span class="line"></span><br><span class="line"># The MySQL server</span><br><span class="line">#########Basic##################</span><br><span class="line"># Mysql 基本信息，端口号、socket、安装目录、数据存放目录、临时目录</span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># Mysql Server 唯一标识，用来做主同同步（ 主从时开启 ）</span><br><span class="line">server<span class="operator">-</span>id<span class="operator">=</span> <span class="number">22</span></span><br><span class="line">port     <span class="operator">=</span> <span class="number">3306</span></span><br><span class="line"><span class="keyword">user</span>     <span class="operator">=</span> mysql</span><br><span class="line">basedir  <span class="operator">=</span> <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>mysql</span><br><span class="line">datadir  <span class="operator">=</span> <span class="operator">/</span>mysqlData<span class="operator">/</span>data</span><br><span class="line">tmpdir   <span class="operator">=</span> <span class="operator">/</span>mysqlData<span class="operator">/</span>tmp</span><br><span class="line">socket   <span class="operator">=</span> <span class="operator">/</span>tmp<span class="operator">/</span>mysql.sock</span><br><span class="line"></span><br><span class="line"># 避免Mysql外部锁定，减少出错几率、增强稳定性</span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span><span class="keyword">external</span><span class="operator">-</span>locking</span><br><span class="line"></span><br><span class="line"># 禁止 Mysql对外部连接进行DNS解析，加快连接速度。开启后所有远程连接主机只能使用IP的方式</span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>name<span class="operator">-</span>resolve</span><br><span class="line"></span><br><span class="line">lower_case_table_names <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 禁止 <span class="keyword">SQL</span> 读取本地文件</span><br><span class="line"><span class="keyword">local</span><span class="operator">-</span>infile <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 默认存储引擎</span><br><span class="line"><span class="keyword">default</span><span class="operator">-</span>storage<span class="operator">-</span>engine <span class="operator">=</span> INNODB</span><br><span class="line"></span><br><span class="line"># 默认字符集 utf8</span><br><span class="line"><span class="type">character</span><span class="operator">-</span><span class="keyword">set</span><span class="operator">-</span>server <span class="operator">=</span> utf8</span><br><span class="line"></span><br><span class="line"># wait_timeout默认是<span class="number">8</span>小时，也就是说一个connection空闲超过<span class="number">8</span>个小时，Mysql将自动断开该connection</span><br><span class="line"># 如果并发很高，默认设置会导致最大连接被占满，出现 &quot;too many connections&quot; 错误</span><br><span class="line"># 如果这个值很低，可能会导致出现 &quot;ERROR 2006 (HY000) MySQL server has gone away&quot; 的错误，</span><br><span class="line">#     出现这个错误还有可能是max_allowed_packet设置过小</span><br><span class="line"></span><br><span class="line"># 数据库连接池如果没有配置正确，会导致连接失效，wait_timeout与interactive_timeout要同时设置</span><br><span class="line"># 数据库连接池中需要配置的存活时间小于数据库中的时间，或者通过定期检查链接的状态</span><br><span class="line"></span><br><span class="line"># 服务器关闭非交互连接之前等待活动的秒数（Mysql处理完一条连接后所等待释放的时间）。</span><br><span class="line">wait_timeout <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"># 服务器关闭交互式连接前等待活动的秒数。</span><br><span class="line">interactive_timeout <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"># mysql客户端在尝试与mysql服务器建立连接时，</span><br><span class="line"># mysql服务器返回错误握手协议前等待客户端数据包的最大时限。默认<span class="number">10</span>秒。</span><br><span class="line">connect_timeout <span class="operator">=</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"># 在MYSQL暂时停止响应新请求之前，短时间内的多少个请求可以被存在堆栈中</span><br><span class="line"># Mysql 连接请求队列存放数，当某一时刻客户端连接请求过多，</span><br><span class="line">#       造成 Mysql Server 无法为其建立连接时存放的数量，</span><br><span class="line">#  最大 <span class="number">65535</span>（ 增大时需同时调整 OS 级别的网络监听队列限制 ），默认<span class="number">50</span></span><br><span class="line">back_log <span class="operator">=</span> <span class="number">500</span></span><br><span class="line"></span><br><span class="line">myisam_recover</span><br><span class="line">event_scheduler <span class="operator">=</span> <span class="keyword">ON</span></span><br><span class="line"></span><br><span class="line">#########general_log，一般不开启##</span><br><span class="line"></span><br><span class="line"># 开启查询日志，一般选择不开启，因为查询日志记录很详细，会增大磁盘 IO 开销，影响性能</span><br><span class="line"># general_log <span class="operator">=</span> <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"># 查询日志存放位置及文件名</span><br><span class="line"># general_log_file <span class="operator">=</span> <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>mysql<span class="operator">/</span>data<span class="operator">/</span>mysql.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#########binlog##################</span><br><span class="line"># 开启 binlog ( 二进制 ) 日志，主要用来做增量备份跟主从同步</span><br><span class="line">log<span class="operator">-</span>bin <span class="operator">=</span> <span class="operator">/</span>mysqlLog<span class="operator">/</span>logs<span class="operator">/</span>mysql<span class="operator">-</span>bin</span><br><span class="line"></span><br><span class="line"># Mysql binlog 的日志格式，Statement、<span class="type">ROW</span> 跟 Mixed（ 混合模式 ）</span><br><span class="line">binlog_format <span class="operator">=</span> <span class="type">row</span></span><br><span class="line"></span><br><span class="line">max_binlog_size <span class="operator">=</span> <span class="number">28</span>M</span><br><span class="line"></span><br><span class="line"># 二进制日志缓冲大小，此参数是为每 Session 单独分配的</span><br><span class="line"># 当一个线程开始一个事务时，Mysql就会为此Session分配一个binlog cache，</span><br><span class="line"># 当这个事务提交时，binlog cache 中的数据被写入 binlog 文件</span><br><span class="line"># 通过 <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;binlog_cache%&#x27;</span>; 查看使用 binlog cache 的次数及使用磁盘的次数</span><br><span class="line">binlog_cache_size <span class="operator">=</span> <span class="number">2</span>M</span><br><span class="line"></span><br><span class="line"># 重要参数，不仅影响到 binlog 对 Mysql 所带来的性能损耗，还影响到 Mysql 中数据的完整性。</span><br><span class="line"># <span class="number">0</span>：代表事务提交后，Mysql 不做 fsync 之类的磁盘同步指令刷新 binlog_cache 中的信息到磁盘</span><br><span class="line">#    而让 Filesystem 自行决定什么时候同步，或者 cache 满了之后才同步磁盘。</span><br><span class="line">#</span><br><span class="line"># n：代表进行 n 次事务提交后，Mysql 将进行一次 fsync 之类的磁盘同步指令来将</span><br><span class="line">#</span><br><span class="line">#    binlog_cache 中的数据强制写入磁盘。</span><br><span class="line"># 默认<span class="number">0</span> ，即不做任何强制性的磁盘刷新指令，性能最好，但是风险也最大。</span><br><span class="line">#         当系统崩溃时 binlog_cache 中的所有 binlog 信息都会丢失。</span><br><span class="line">#</span><br><span class="line"># <span class="number">1</span>，是最安全但是性能损耗最大。当系统崩溃时，</span><br><span class="line">#    最多丢失 binlog_cache 中未完成的一个事务，对实际数据没有实质性的影响。</span><br><span class="line">sync_binlog <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 保留<span class="number">5</span>天的binlog日志，系统重启、执行 flush logs或binlog日志文件大小达到上限时删除 binlog日志</span><br><span class="line">expire<span class="operator">-</span>logs<span class="operator">-</span>days <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">#########replication#############</span><br><span class="line"># mysql从复制连结等待读取数据的最大时限，默认<span class="number">3600</span>秒。</span><br><span class="line">slave<span class="operator">-</span>net<span class="operator">-</span>timeout                  <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">rpl_semi_sync_master_enabled       <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">rpl_semi_sync_master_wait_no_slave <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">rpl_semi_sync_master_timeout       <span class="operator">=</span> <span class="number">1000</span></span><br><span class="line">rpl_semi_sync_slave_enabled        <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>slave<span class="operator">-</span><span class="keyword">start</span></span><br><span class="line">log_slave_updates                  <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">relay_log_recovery                 <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">#########slow log#############</span><br><span class="line"></span><br><span class="line"># 开启慢查询日志，开启后将会记录执行时间超过 long_query_time 参数值的 <span class="keyword">SQL</span> 语句</span><br><span class="line">#（ 一般临时开启即可 ）</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 定义慢查询日志存放位置</span><br><span class="line">slow_query_log_file <span class="operator">=</span> <span class="operator">/</span>mysqlLog<span class="operator">/</span>logs<span class="operator">/</span>mysql.slow</span><br><span class="line"></span><br><span class="line"># 定义执行时间超过多少秒为慢查询，默认 <span class="number">10</span>s</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">#########error log#############</span><br><span class="line"># 错误日志位置跟文件名</span><br><span class="line">log<span class="operator">-</span>error  <span class="operator">=</span> <span class="operator">/</span>mysqlLog<span class="operator">/</span>logs<span class="operator">/</span>error.log</span><br><span class="line"></span><br><span class="line"># 如果此参数不开启，error_log 中会有警告信息</span><br><span class="line">explicit_defaults_for_timestamp <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#######per_thread_buffers############</span><br><span class="line"></span><br><span class="line"># 查看最大连接数：<span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%max_connections%&#x27;</span>;</span><br><span class="line"># 修改最大连接数：<span class="keyword">set</span> <span class="keyword">GLOBAL</span> max_connections <span class="operator">=</span> <span class="number">200</span>;（重启后失效）或则直接修改配置文件</span><br><span class="line"># 默认<span class="number">100</span>，最大值<span class="number">16384</span></span><br><span class="line"># 使用命令<span class="keyword">show</span> processlist; 可以查询相关（root所有，其他账号只显示自己相关的）的连接信息，</span><br><span class="line">#   显示<span class="number">100</span>条，使用<span class="keyword">show</span> <span class="keyword">full</span> processlist; 可列出所有</span><br><span class="line">#</span><br><span class="line"># Mysql 最大连接数，直接影响 Mysql 应用的并发处理能力</span><br><span class="line"># <span class="number">500</span><span class="operator">~</span><span class="number">1000</span> 是个比较合适的值，注意每建立的连接都会占用一定的内存空间，直到连接被关闭才释放内存</span><br><span class="line">max_connections<span class="operator">=</span><span class="number">1024</span></span><br><span class="line"></span><br><span class="line">max_user_connections<span class="operator">=</span><span class="number">1000</span></span><br><span class="line"></span><br><span class="line"># 最大连接失败次数，跟性能没有太大关系，主要跟安全方面有关</span><br><span class="line"># 设置每个主机的连接请求异常中断的最大次数，当超过该次数，MYSQL服务器将禁止host的连接请求，</span><br><span class="line"># 直到mysql服务器重启或通过flush hosts命令清空此host的相关信息，默认<span class="number">100</span></span><br><span class="line">max_connect_errors<span class="operator">=</span><span class="number">10000</span></span><br><span class="line"></span><br><span class="line"># 用来缓存 MyISAM 存储引擎的索引（ 默认 <span class="number">8</span>M ，如果使用 Innodb 存储引擎，此值设为 <span class="number">64</span>M 或更小 ）</span><br><span class="line"># 计算公式：key_reads <span class="operator">/</span> key_read_requests <span class="operator">*</span> <span class="number">100</span><span class="operator">%</span> 的值小于 <span class="number">0.1</span><span class="operator">%</span></span><br><span class="line"># 增加它可以得到更好的索引处理性能</span><br><span class="line">key_buffer_size <span class="operator">=</span> <span class="number">64</span>M</span><br><span class="line"></span><br><span class="line"># 网络传输中一次消息量的最大值，默认 <span class="number">4</span>M ，必须设为 <span class="number">1024</span> 的整倍数</span><br><span class="line">max_allowed_packet <span class="operator">=</span> <span class="number">128</span>M</span><br><span class="line"></span><br><span class="line"># 指示表调整缓冲区大小。</span><br><span class="line"># table_cache 参数设置表高速缓存的数目。每个连接进来，都会至少打开一个表缓存。</span><br><span class="line"># 因此， table_cache 的大小应与 max_connections 的设置有关。</span><br><span class="line"># 例如，对于 <span class="number">200</span> 个并行运行的连接，应该让表的缓存至少有 <span class="number">200</span> × N ，这里 N 是应用可以执行的查询的一个联接中表的最大数量。</span><br><span class="line"># 此外，还需要为临时表和文件保留一些额外的文件描述符。</span><br><span class="line"># 当 Mysql 访问一个表时，如果该表在缓存中已经被打开，则可以直接访问缓存；</span><br><span class="line"># 如果还没有被缓存，但是在 Mysql 表缓冲区中还有空间，那么这个表就被打开并放入表缓冲区；</span><br><span class="line"># 如果表缓存满了，则会按照一定的规则将当前未用的表释放，或者临时扩大表缓存来存放，使用表缓存的好处是可以更快速地访问表中的内容。</span><br><span class="line"># 执行 flush tables 会清空缓存的内容。</span><br><span class="line"># 一般来说，可以通过查看数据库运行峰值时间的状态值 Open_tables 和 Opened_tables ，判断是否需要增加 table_cache 的值</span><br><span class="line">#（其中 open_tables 是当前打开的表的数量， Opened_tables 则是已经打开的表的数量）</span><br><span class="line"># 即如果open_tables接近table_cache的时候，并且Opened_tables这个值在逐步增加，那就要考虑增加这个值的大小了。</span><br><span class="line"># 还有就是Table_locks_waited比较高的时候，也需要增加table_cache。</span><br><span class="line">table_cache <span class="operator">=</span> <span class="number">3096</span></span><br><span class="line"></span><br><span class="line"># 打开文件描述符的缓存个数，防止系统频繁打开、关闭描述符而浪费资源（ 对性能有影响，默认 <span class="number">2000</span> ）</span><br><span class="line">table_open_cache <span class="operator">=</span> <span class="number">6144</span></span><br><span class="line"></span><br><span class="line">table_definition_cache <span class="operator">=</span> <span class="number">4096</span></span><br><span class="line"></span><br><span class="line"># 系统中对数据进行排序时使用的 buffer ，如果系统中排序比较大，且内存充足、并发不大时，可以适当增大此值（ 默认 <span class="number">256</span>K ，此参数为每线程分配独立的 buffer ）</span><br><span class="line"># Sort_Buffer_Size 是一个connection级参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。</span><br><span class="line"># Sort_Buffer_Size 并不是越大越好，由于是connection级的参数，过大的设置<span class="operator">+</span>高并发可能会耗尽系统内存资源。例如：<span class="number">500</span>个连接将会消耗 <span class="number">500</span><span class="operator">*</span>sort_buffer_size(<span class="number">8</span>M)<span class="operator">=</span><span class="number">4</span>G内存</span><br><span class="line"># Sort_Buffer_Size 超过<span class="number">2</span>KB的时候，就会使用mmap() 而不是 malloc() 来进行内存分配，导致效率降低。</span><br><span class="line"># 技术导读 http:<span class="operator">/</span><span class="operator">/</span>blog.webshuo.com<span class="operator">/</span><span class="number">2011</span><span class="operator">/</span><span class="number">02</span><span class="operator">/</span><span class="number">16</span><span class="operator">/</span>mysql<span class="operator">-</span>sort_buffer_size<span class="operator">/</span></span><br><span class="line"># dev<span class="operator">-</span>doc: http:<span class="operator">/</span><span class="operator">/</span>dev.mysql.com<span class="operator">/</span>doc<span class="operator">/</span>refman<span class="operator">/</span><span class="number">5.5</span><span class="operator">/</span>en<span class="operator">/</span>server<span class="operator">-</span>parameters.html</span><br><span class="line"># explain <span class="keyword">select</span><span class="operator">*</span><span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">order</span> limit；出现filesort</span><br><span class="line"># 属重点优化参数</span><br><span class="line"></span><br><span class="line">sort_buffer_size <span class="operator">=</span> <span class="number">512</span>K</span><br><span class="line"></span><br><span class="line"># Mysql 读入缓冲区大小，对表进行顺序扫描的请求将分配一个读入缓冲区，，MySql会为它分配一段内存缓冲区。</span><br><span class="line"># Mysql 会为其分配一段内存缓冲区（ 默认 <span class="number">128</span>K ，此参数为每线程分配 ）</span><br><span class="line"># read_buffer_size变量控制这一缓冲区的大小。如果对表的顺序扫描请求非常频繁，</span><br><span class="line"># 并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。</span><br><span class="line"># 和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</span><br><span class="line"></span><br><span class="line">read_buffer_size <span class="operator">=</span> <span class="number">512</span>K</span><br><span class="line"></span><br><span class="line"># Mysql 随机 Query 缓冲区大小，当按任意顺序读取行时，将分配一个随机读取缓冲区。如进行排序查询时，Mysql 会首先扫描该缓冲，避免磁盘搜索，提高查询速度（ 默认 <span class="number">256</span>K ，该缓冲也是为每线程分配 ）</span><br><span class="line">read_rnd_buffer_size <span class="operator">=</span> <span class="number">512</span>k</span><br><span class="line"></span><br><span class="line"># <span class="keyword">join</span> 为 <span class="keyword">ALL</span>、index、rang 或 index_merge 时使用的 buffer（ 默认 <span class="number">256</span>K ，每 Thread 都会建立自己独立的 buffer ）</span><br><span class="line">join_buffer_size <span class="operator">=</span> <span class="number">512</span>K</span><br><span class="line"></span><br><span class="line"># 临时表大小，默认大小是 <span class="number">32</span>M</span><br><span class="line"># 如果一张临时表超出该大小，MySQL产生一个 The <span class="keyword">table</span> tbl_name <span class="keyword">is</span> <span class="keyword">full</span> 形式的错误，</span><br><span class="line"># 如果你做很多高级 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 查询，增加 tmp_table_size 值。如果超过该值，则会将临时表写入磁盘。</span><br><span class="line">tmp_table_size <span class="operator">=</span> <span class="number">64</span>M</span><br><span class="line">max_heap_table_size <span class="operator">=</span> <span class="number">64</span>M</span><br><span class="line"></span><br><span class="line"># 是否启用 query_cache ，<span class="number">0</span> 为不使用（ 若要关闭 query_cache 时，需同时将 query_cache_size 、query_cache_limit 设为 <span class="number">0</span> ）</span><br><span class="line">query_cache_type<span class="operator">=</span><span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 工作原理：一个<span class="keyword">SELECT</span>查询在DB中工作后，DB会把该语句缓存下来，当同样的一个<span class="keyword">SQL</span>再次来到DB里调用时，</span><br><span class="line"># DB在该表没发生变化的情况下把结果从缓存中返回给Client。</span><br><span class="line"># 这里有一个关建点，就是DB在利用Query_cache工作时，要求该语句涉及的表在这段时间内没有发生变更。</span><br><span class="line"># 如果该表在发生变更时，Query_cache里的数据又怎么处理呢？首先要把Query_cache和该表相关的语句全部置为失效，然后在写入更新。</span><br><span class="line"># 如果Query_cache非常大，该表的查询结构又比较多，查询语句失效也慢，一个更新或是<span class="keyword">Insert</span>就会很慢，这样看到的就是<span class="keyword">Update</span>或是<span class="keyword">Insert</span>怎么这么慢了。</span><br><span class="line"># 所以在数据库写入量或是更新量也比较大的系统，该参数不适合分配过大。而且在高并发，写入量大的系统，建议把该功能禁掉。</span><br><span class="line"># 重点优化参数（主库 增删改<span class="operator">-</span>MyISAM）</span><br><span class="line"># 查询缓冲大小，当重复查询时会直接从该缓冲中获取，但是当所查询表有改变时，缓冲的查询将失效（ 频繁写入、更新、高并发的环境下建议关闭此缓冲 ）</span><br><span class="line"></span><br><span class="line">query_cache_size <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 单个查询所能够使用的缓冲区大小，缺省为<span class="number">1</span>M</span><br><span class="line">query_cache_limit <span class="operator">=</span> <span class="number">1</span>M</span><br><span class="line"></span><br><span class="line"># 使用全文索引最小长度</span><br><span class="line">ft_min_word_len <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 默认是<span class="number">4</span>KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费</span><br><span class="line"># 查询缓存碎片率 <span class="operator">=</span> Qcache_free_blocks <span class="operator">/</span> Qcache_total_blocks <span class="operator">*</span> <span class="number">100</span><span class="operator">%</span></span><br><span class="line"># 如果查询缓存碎片率超过<span class="number">20</span><span class="operator">%</span>，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。</span><br><span class="line"># 查询缓存利用率 <span class="operator">=</span> (query_cache_size – Qcache_free_memory) <span class="operator">/</span> query_cache_size <span class="operator">*</span> <span class="number">100</span><span class="operator">%</span></span><br><span class="line"># 查询缓存利用率在<span class="number">25</span><span class="operator">%</span>以下的话说明query_cache_size设置的过大，可适当减小;</span><br><span class="line"># 查询缓存利用率在<span class="number">80</span><span class="operator">%</span>以上而且Qcache_lowmem_prunes <span class="operator">&gt;</span> <span class="number">50</span>的话说明query_cache_size可能有点小，要不就是碎片太多。</span><br><span class="line"># 查询缓存命中率 <span class="operator">=</span> (Qcache_hits – Qcache_inserts) <span class="operator">/</span> Qcache_hits <span class="operator">*</span> <span class="number">100</span><span class="operator">%</span></span><br><span class="line">query_cache_min_res_unit <span class="operator">=</span> <span class="number">2</span>k</span><br><span class="line"></span><br><span class="line"># 批量插入数据缓存大小，可以有效提高插入效率，默认为<span class="number">8</span>M</span><br><span class="line">bulk_insert_buffer_size <span class="operator">=</span> <span class="number">32</span>M</span><br><span class="line"></span><br><span class="line">## Thread Cache 池中存放的连接线程数（ 此池中的线程不是启动服务时就创建的，而是随着连接线程的创建和使用，逐渐将用完的线程存入其中，达到此值后将不再缓存连接线程 ）</span><br><span class="line">## 缓存命中率计算公式：Thread_Cache_Hit <span class="operator">=</span> ( Connections <span class="operator">-</span> Thread_created ) <span class="operator">/</span> Connections <span class="operator">*</span> <span class="number">100</span><span class="operator">%</span></span><br><span class="line">## 系统运行一段时间后，Thread Cache 命中率应该保持在 <span class="number">90</span><span class="operator">%</span> 以上</span><br><span class="line"># 服务器线程缓存这个值表示可以重新利用保存在缓存中线程的数量,</span><br><span class="line"># 当断开连接时如果缓存中还有空间,那么客户端的线程将被放到缓存中,如果线程重新被请求，那么请求将从缓存中读取,</span><br><span class="line"># 如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，增加这个值可以改善系统性能.</span><br><span class="line"># 通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。</span><br><span class="line"># 设置规则如下：<span class="number">1</span>GB 内存配置为<span class="number">8</span>，<span class="number">2</span>GB配置为<span class="number">16</span>，<span class="number">3</span>GB配置为<span class="number">32</span>，<span class="number">4</span>GB或更高内存，可配置更大。</span><br><span class="line">thread_cache_size <span class="operator">=</span> <span class="number">64</span></span><br><span class="line"></span><br><span class="line"># 设置thread_concurrency的值的正确与否, 对mysql的性能影响很大, </span><br><span class="line"># 在多个cpu(或多核)的情况下，错误设置了thread_concurrency的值, 会导致mysql不能充分利用多cpu(或多核), 出现同一时刻只能一个cpu(或核)在工作的情况。</span><br><span class="line"># thread_concurrency应设为CPU核数的<span class="number">2</span>倍. 比如有一个双核的CPU, 那么thread_concurrency的应该为<span class="number">4</span>; <span class="number">2</span>个双核的cpu, thread_concurrency的值应为<span class="number">8</span></span><br><span class="line"># 属重点优化参数</span><br><span class="line">thread_concurrency <span class="operator">=</span> <span class="number">32</span></span><br><span class="line"></span><br><span class="line"># 每线程的堆栈大小，默认值足够大，可满足普通操作。可设置范围为<span class="number">128</span>K至<span class="number">4</span>GB，默认为<span class="number">192</span>KB。</span><br><span class="line">thread_stack <span class="operator">=</span> <span class="number">256</span>K</span><br><span class="line">######### InnoDB #############</span><br><span class="line">innodb_data_home_dir <span class="operator">=</span> <span class="operator">/</span>mysqlData<span class="operator">/</span>data</span><br><span class="line">innodb_log_group_home_dir <span class="operator">=</span> <span class="operator">/</span>mysqlLog<span class="operator">/</span>logs</span><br><span class="line"></span><br><span class="line"># 指定一个大小为 <span class="number">2</span>G 的、可扩展的 ibdata1 数据文件</span><br><span class="line">innodb_data_file_path <span class="operator">=</span> ibdata1:<span class="number">2</span>G:autoextend</span><br><span class="line"></span><br><span class="line"># Innodb 存储引擎核心参数，用于缓存 Innodb 表的索引、数据（ 默认 <span class="number">128</span>M ，单独使用 Innodb 存储引擎且单一 Mysql 服务时建议设为物理内存的 <span class="number">70</span><span class="operator">%</span> <span class="operator">-</span> <span class="number">80</span> <span class="operator">%</span> ）</span><br><span class="line"># 可以通过 <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_%&#x27;</span>; 来获取 innodb buffer pool 的实时状态信息</span><br><span class="line">## Innodb_buffer_pool_pages_total 总共的 pages（ Innodb 存储引擎中所有数据存放最小物理单位 page ，每个 page 默认为 <span class="number">16</span>KB ）</span><br><span class="line">## Innodb_buffer_pool_pages_free  空闲的 pages</span><br><span class="line">## Innodb_buffer_pool_pages_data  有数据的 pages</span><br><span class="line">## Innodb_buffer_pool_read_requests  总共的 read 请求次数</span><br><span class="line">## Innodb_buffer_pool_reads  读取物理磁盘读取数据的次数，即：在 buffer pool 中没有找到</span><br><span class="line">## Innodb_buffer_pool_wait_free  因 buffer 空间不足而产生的 wait_free</span><br><span class="line">## Innodb_buffer_pool_read_ahead_rnd  记录进行随机读的时候产生的预读次数</span><br><span class="line">## Innodb_buffer_pool_read_ahead_seq  记录连续读的时候产生的预读次数</span><br><span class="line">## Innodb_buffer_pool_size  使用率 <span class="operator">=</span> innodb_buffer_pool_pages_data <span class="operator">/</span> innodb_buffer_pool_pages_total <span class="operator">*</span> <span class="number">100</span><span class="operator">%</span></span><br><span class="line">## Innodb_buffer_pool_read  命中率 <span class="operator">=</span> （ innodb_buffer_pool_read_requests <span class="operator">-</span> innodb_buffer_pool_reads ）<span class="operator">/</span> innodb_buffer_pool_read_requests <span class="operator">*</span> <span class="number">100</span><span class="operator">%</span></span><br><span class="line"></span><br><span class="line">innodb_buffer_pool_size <span class="operator">=</span> <span class="number">50</span>G</span><br><span class="line"></span><br><span class="line">innodb_buffer_pool_instances <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"># 使用系统自带的内存分配器，替代 innodb_additional_mem_pool_size 参数</span><br><span class="line"># innodb_use_sys_malloc <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 这个参数用来设置 InnoDB 存储的数据目录信息和其它内部数据结构的内存池大小，类似于Oracle的library cache。这不是一个强制参数，可以被突破。</span><br><span class="line">innodb_additional_mem_pool_size <span class="operator">=</span> <span class="number">16</span>M</span><br><span class="line"></span><br><span class="line"># 此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间，Redo log文件</span><br><span class="line">innodb_log_file_size <span class="operator">=</span> <span class="number">1024</span>M</span><br><span class="line"></span><br><span class="line"># 事务日志所使用的缓冲区。Innodb 在写事务日志时，为了提高写 Log 的 IO 性能，先将信息写入 Innodb Log Buffer 中，当满足 Innodb_flush_log_trx_commit 参数或日志缓冲区写满时，再将日志同步到磁盘中。</span><br><span class="line"># 默认 <span class="number">8</span>M ，一般设为 <span class="number">16</span><span class="operator">~</span><span class="number">64</span>M 即可，可以通过 <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_log%&#x27;</span>; 查看状态</span><br><span class="line">innodb_log_buffer_size <span class="operator">=</span> <span class="number">64</span>M</span><br><span class="line"># 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为<span class="number">3</span>M</span><br><span class="line">innodb_log_files_in_group <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># Innodb 事务日志刷新方式，</span><br><span class="line"># <span class="number">0</span> 为每隔一秒 log thread 会将 log buffer 中的数据写入到文件，并通知文件系统进行文件同步 flush 操作，极端情况下会丢失一秒的数据</span><br><span class="line"># <span class="number">1</span> 为每次事务结束都会触发 log thread 将 log buffer 中的数据写入文件并通知文件系统同步文件，数据最安全、不会丢失任何已经提交的数据</span><br><span class="line"># <span class="number">2</span> 为每次事务结束后 log thread 会将数据写入事务日志</span><br><span class="line"># 但只是调用了文件系统的文件写入操作，并没有同步到物理磁盘，因为文件系统都是有缓存机制的，各文件系统的缓存刷新机制不同</span><br><span class="line"># 当设为 <span class="number">1</span> 时是最为安全的，但性能也是最差的。</span><br><span class="line"># <span class="number">0</span> 为每秒同步一次，性能相对高一些。</span><br><span class="line"># 设为 <span class="number">2</span> 性能是最好的，但故障后丢失数据也最多（ OS 跟主机硬件、供电足够安全可以选择，或对数据少量丢失可以接受 ）。</span><br><span class="line">innodb</span><br><span class="line">innodb_flush_log_at_trx_commit <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">#InnoDB 有其内置的死锁检测机制，LOCK TABLES语句锁定设置，能导致未完成的事务回滚。</span><br><span class="line">#如果使用其他事务引擎处理锁，就会导致内置检测失效，需要通过配置对应参数解决</span><br><span class="line">#InnoDB事务在被回滚之前可以设置一个等待锁的超时秒数，默认为<span class="number">50</span>s，</span><br><span class="line">#表示事务等待获取资源等待的最长时间，超过这个时间还未分配到资源则会返回应用失败，回滚数据</span><br><span class="line">#通过以下方式可以动态设置</span><br><span class="line">#<span class="keyword">set</span> innodb_lock_wait_timeout<span class="operator">=</span><span class="number">100</span>;   <span class="comment">---------session</span></span><br><span class="line">#<span class="keyword">set</span> <span class="keyword">global</span> innodb_lock_wait_timeout<span class="operator">=</span><span class="number">100</span>;   <span class="comment">---------global</span></span><br><span class="line">#注意<span class="keyword">global</span>的修改对当前线程是不生效的，只有建立新的连接才生效。</span><br><span class="line">innodb_lock_wait_timeout <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">innodb_sync_spin_loops <span class="operator">=</span> <span class="number">40</span></span><br><span class="line">innodb_max_dirty_pages_pct <span class="operator">=</span> <span class="number">90</span></span><br><span class="line">innodb_support_xa <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># Innodb 线程并发数，<span class="number">0</span> 为不限制，默认 <span class="number">0</span></span><br><span class="line"># 服务器有几个CPU就设置为几，建议用默认设置，一般为<span class="number">8.</span></span><br><span class="line">innodb_thread_concurrency <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">innodb_thread_sleep_delay <span class="operator">=</span> <span class="number">500</span></span><br><span class="line"></span><br><span class="line"># 文件IO的线程数，一般为 <span class="number">4</span>，但是在 Windows 下，可以设置得较大。</span><br><span class="line">innodb_file_io_threads    <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">innodb_concurrency_tickets <span class="operator">=</span> <span class="number">1000</span></span><br><span class="line">log_bin_trust_function_creators <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">innodb_flush_method <span class="operator">=</span> O_DIRECT</span><br><span class="line"></span><br><span class="line"># <span class="number">0</span>:关闭独享表空间，使用共享表空间</span><br><span class="line">innodb_file_per_table</span><br><span class="line"></span><br><span class="line"># Innodb 使用后台线程处理数据页上的 IO 请求，根据 CPU 核数修改，默认 <span class="number">4</span></span><br><span class="line">innodb_read_io_threads <span class="operator">=</span> <span class="number">16</span></span><br><span class="line">innodb_write_io_threads <span class="operator">=</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line">innodb_io_capacity <span class="operator">=</span> <span class="number">2000</span></span><br><span class="line">innodb_file_format <span class="operator">=</span> Barracuda</span><br><span class="line">innodb_purge_threads<span class="operator">=</span><span class="number">1</span></span><br><span class="line">innodb_purge_batch_size <span class="operator">=</span> <span class="number">32</span></span><br><span class="line">innodb_old_blocks_pct<span class="operator">=</span><span class="number">75</span></span><br><span class="line">innodb_change_buffering<span class="operator">=</span><span class="keyword">all</span></span><br><span class="line"></span><br><span class="line"># 事务隔离级别，为了有效保证并发读取数据的正确性（ 默认 Repeatables Read 即：可重复读 ）</span><br><span class="line"># Innodb 有四种隔离级别：Read Uncommitted（ 未提交读 ）、Read Committed（ 已提交读 ）、</span><br><span class="line"># Repeatable Read（ 可重复读 ）、Serializable（ 可序列化 ）</span><br><span class="line"></span><br><span class="line">transaction_isolation <span class="operator">=</span> READ<span class="operator">-</span>COMMITTED</span><br><span class="line"></span><br><span class="line">####快速预热 Buffer_pool 缓冲池##########################</span><br><span class="line"># 当机器正常重启后，热数据还保留在内存中，避免瞬间连接数爆满导致机器死机</span><br><span class="line">#  关闭数据库时把热数据 dump 到本地磁盘。</span><br><span class="line">innodb_buffer_pool_dump_at_shutdown <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 采用手工方式把热数据 dump 到本地磁盘。</span><br><span class="line">innodb_buffer_pool_dump_now <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 启动时把热数据加载到内存。</span><br><span class="line">innodb_buffer_pool_load_at_startup <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 采用手工方式把热数据加载到内存。</span><br><span class="line">innodb_buffer_pool_load_now <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line"># 在使用mysqldump备份数据时，服务器发送和接受的最大包长度</span><br><span class="line">#使用 mysqldump 工具备份数据库时，当某张表过大时备份会报错，需要增大该值（ 增大到大于表大小的值 ）</span><br><span class="line"># 查看备份文件大小</span><br><span class="line">max_allowed_packet <span class="operator">=</span> <span class="number">128</span>M</span><br><span class="line"></span><br><span class="line"># MyISAM表发生变化时重新排序所需的缓冲</span><br><span class="line">myisam_sort_buffer_size <span class="operator">=</span> <span class="number">128</span>M </span><br><span class="line"></span><br><span class="line"># MySQL重建索引时所允许的最大临时文件的大小 (当 REPAIR, <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 或者 LOAD DATA INFILE).</span><br><span class="line"># 如果文件大小比此值更大,索引会通过键值缓冲创建(更慢)</span><br><span class="line">myisam_max_sort_file_size <span class="operator">=</span> <span class="number">10</span>G</span><br><span class="line"></span><br><span class="line">myisam_max_extra_sort_file_size <span class="operator">=</span> <span class="number">10</span>G</span><br><span class="line"></span><br><span class="line"># 如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们.</span><br><span class="line"># 这对于拥有多个CPU以及大量内存情况的用户,是一个很好的选择.</span><br><span class="line">myisam_repair_threads <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 自动检查和修复没有适当关闭的 MyISAM 表</span><br><span class="line">myisam_recover   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"><span class="keyword">no</span><span class="operator">-</span>auto<span class="operator">-</span>rehash</span><br><span class="line"></span><br><span class="line">[myisamchk]</span><br><span class="line">key_buffer_size <span class="operator">=</span> <span class="number">64</span>M</span><br><span class="line">sort_buffer_size <span class="operator">=</span> <span class="number">256</span>k</span><br><span class="line">read_buffer <span class="operator">=</span> <span class="number">2</span>M</span><br><span class="line">write_buffer <span class="operator">=</span> <span class="number">2</span>M</span><br><span class="line"></span><br><span class="line">[mysqlhotcopy]</span><br><span class="line">interactive<span class="operator">-</span>timeout</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line"><span class="keyword">open</span><span class="operator">-</span>files<span class="operator">-</span>limit <span class="operator">=</span> <span class="number">28192</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之高可用</title>
    <url>/2021/02/04/MySQL%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="互为主从复制"><a href="#互为主从复制" class="headerlink" title="互为主从复制"></a>互为主从复制</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在一些高可用的环境中，mysql的主从不能满足现实中的一些实际需求。比如，一些流量大的网站数据库访问有了瓶颈，需要负载均衡的时候就用两个或者多个的mysql服务器，而这些mysql服务器的数据库数据必须要保持一致，那么就会用到主主复制。  </p>
<p>mysql主从架构中其实就一个主在工作，而从就相当于一个备份机器，从通过日志监测的方式来备份主库上的数据而保证主库的数据安全。在这种架构中如果从上的数据做了改变，主数据是不会用任何变化的。因为mysql主从架构主要是mysql从监控mysql主的日志变化来实现同步，相反的在这个架构中主并没有监控从的日志变化。所以，mysql从数据反生变化，主也就没有什么变化了。  </p>
<p>通过上述描述，可以看到如果想实现主主复制，无非就是在mysql主从架构上让mysql主实现监测从的日志变化，从而实现两台机器相互同步。  </p>
<a id="more"></a>

<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ol>
<li>H1：192.168.209.132 root/123456a?</li>
<li>H2：192.168.209.137 root/123456a?</li>
</ol>
<h3 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h3><ol>
<li>第一、server-id，主server-id小于从server-id（必须不一样）</li>
<li>第二、主数据库，建立一个能复制的帐号并授权。</li>
<li>第三、从服务器开启复制功能就OK了。</li>
</ol>
<h3 id="修改配置文件my-cnf"><a href="#修改配置文件my-cnf" class="headerlink" title="修改配置文件my.cnf"></a>修改配置文件my.cnf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log-bin&#x3D;mysql-bin：这个选项基本默认都是开着的，如果没有打开，可以手动打开。</span><br><span class="line">log-slave-updates&#x3D;1：这个选项特别的重要它是为了让slave也能充当master，同时也为了更好的服务于 m-m + s 的环境，保证slave挂在任何一台master上都会接收到另一个master的写入信息。当然不局限于这个架构，级联复制的架构同样也需要log-slave-updates的支持。</span><br><span class="line">server-id &#x3D; 1：这个ID为服务器ID如果配置一样会出现冲突，而不能复制</span><br><span class="line">binlog-ignore-db &#x3D; mysql,information_schema       #忽略写入binlog日志的库</span><br><span class="line">auto-increment-increment &#x3D; 2             #字段变化增量值</span><br><span class="line">auto-increment-offset &#x3D; 1              #初始字段ID为1</span><br><span class="line">slave-skip-errors &#x3D; all                       #忽略所有复制产生的错误</span><br></pre></td></tr></table></figure>
<p>配置完成之后，使用命令<code>service mysqld restart</code>，完成重启，重启效果如下：  </p>
<h4 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h4><div align="center">

<img src="/2021/02/04/MySQL%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8/1590058835864.png" class>

<img src="/2021/02/04/MySQL%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8/1590058843893.png" class>

</div>

<h4 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h4><div align="center">

<img src="/2021/02/04/MySQL%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8/1590058864954.png" class>

<img src="/2021/02/04/MySQL%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8/1590058870961.png" class>

</div>

<h3 id="设置主从bin-log和读写位置"><a href="#设置主从bin-log和读写位置" class="headerlink" title="设置主从bin-log和读写位置"></a>设置主从bin-log和读写位置</h3><h4 id="查看master信息"><a href="#查看master信息" class="headerlink" title="查看master信息"></a>查看master信息</h4><h5 id="H1-1"><a href="#H1-1" class="headerlink" title="H1"></a>H1</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master status;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> File             <span class="operator">|</span> Position <span class="operator">|</span> Binlog_Do_DB <span class="operator">|</span> Binlog_Ignore_DB         <span class="operator">|</span> Executed_Gtid_Set <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>      <span class="number">154</span> <span class="operator">|</span>              <span class="operator">|</span> mysql,information_schema <span class="operator">|</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<h5 id="H2-1"><a href="#H2-1" class="headerlink" title="H2"></a>H2</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master status;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> File             <span class="operator">|</span> Position <span class="operator">|</span> Binlog_Do_DB <span class="operator">|</span> Binlog_Ignore_DB         <span class="operator">|</span> Executed_Gtid_Set <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>      <span class="number">154</span> <span class="operator">|</span>              <span class="operator">|</span> mysql,information_schema <span class="operator">|</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h4 id="设置读写位置"><a href="#设置读写位置" class="headerlink" title="设置读写位置"></a>设置读写位置</h4><h5 id="H1：设置H2的信息"><a href="#H1：设置H2的信息" class="headerlink" title="H1：设置H2的信息"></a>H1：设置H2的信息</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;sunld_backup&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED  <span class="keyword">BY</span> <span class="string">&#x27;123456a?&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> flush  privileges;</span><br><span class="line">mysql<span class="operator">&gt;</span> change  master <span class="keyword">to</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  master_host<span class="operator">=</span><span class="string">&#x27;192.168.209.137&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  master_user<span class="operator">=</span><span class="string">&#x27;sunld_backup&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  master_password<span class="operator">=</span><span class="string">&#x27;123456a?&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  master_log_pos<span class="operator">=</span><span class="number">154</span>;  #对端状态显示的值</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">start</span>  slave;         #启动同步</span><br></pre></td></tr></table></figure>
<h5 id="置H1的信息"><a href="#置H1的信息" class="headerlink" title="置H1的信息"></a>置H1的信息</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">GRANT</span>  REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;sunld_backup&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED  <span class="keyword">BY</span> <span class="string">&#x27;123456a?&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> flush  privileges;</span><br><span class="line">mysql<span class="operator">&gt;</span> change  master <span class="keyword">to</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  master_host<span class="operator">=</span><span class="string">&#x27;192.168.209.132&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  master_user<span class="operator">=</span><span class="string">&#x27;sunld_backup&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  master_password<span class="operator">=</span><span class="string">&#x27;123456a?&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>  master_log_pos<span class="operator">=</span><span class="number">154</span>;  #对端状态显示的值</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">start</span>  slave;         #启动同步</span><br></pre></td></tr></table></figure>
<h4 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h4><p>可以看到</p>
<ol>
<li>Slave_IO_Running: Yes</li>
<li>Slave_SQL_Running: Yes</li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h4><h5 id="H1数据库信息"><a href="#H1数据库信息" class="headerlink" title="H1数据库信息"></a>H1数据库信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mysql -uroot -p123456a? -h192.168.209.132 -e &#x27;show databases;&#x27;</span></span><br><span class="line">mysql: [Warning] Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<h5 id="H2数据库信息"><a href="#H2数据库信息" class="headerlink" title="H2数据库信息"></a>H2数据库信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mysql -uroot -p123456a? -h192.168.209.137 -e &#x27;show databases;&#x27;</span></span><br><span class="line">mysql: [Warning] Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<h4 id="H1创建数据库，在H2中是否显示"><a href="#H1创建数据库，在H2中是否显示" class="headerlink" title="H1创建数据库，在H2中是否显示"></a>H1创建数据库，在H2中是否显示</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mysql -uroot -p123456a? -h192.168.209.132 -e &#x27;create database h1;&#x27;</span></span><br><span class="line">mysql: [Warning] Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line">[root@localhost ~]<span class="comment"># mysql -uroot -p123456a? -h192.168.209.137 -e &#x27;show databases;&#x27;</span></span><br><span class="line">mysql: [Warning] Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| h1                 |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<h4 id="H2创建数据库，在H1中是否显示"><a href="#H2创建数据库，在H1中是否显示" class="headerlink" title="H2创建数据库，在H1中是否显示"></a>H2创建数据库，在H1中是否显示</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mysql -uroot -p123456a? -h192.168.209.137 -e &#x27;create database h2;&#x27;</span></span><br><span class="line">mysql: [Warning] Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line">[root@localhost ~]<span class="comment"># mysql -uroot -p123456a? -h192.168.209.132 -e &#x27;show databases;&#x27;</span></span><br><span class="line">mysql: [Warning] Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| h1                 |</span><br><span class="line">| h2                 |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<h2 id="Keepalived-Mysql主主"><a href="#Keepalived-Mysql主主" class="headerlink" title="Keepalived+Mysql主主"></a>Keepalived+Mysql主主</h2><p><strong>mysql主主参考上一章节。</strong>  </p>
<p>使用keepalived可以实现热备，mysql之间的自动切换。  </p>
<h3 id="安装keepalived注意：-关闭selinux策略-setenforce-0"><a href="#安装keepalived注意：-关闭selinux策略-setenforce-0" class="headerlink" title="安装keepalived注意：(关闭selinux策略 setenforce 0)"></a>安装keepalived注意：(关闭selinux策略 setenforce 0)</h3><h4 id="离线或在线现在安装包"><a href="#离线或在线现在安装包" class="headerlink" title="离线或在线现在安装包"></a>离线或在线现在安装包</h4><ol>
<li>下载最新版本：1.4.0</li>
<li>离线下载（使用该方式完成）：官方现在地址：<a href="http://www.keepalived.org/download.html">http://www.keepalived.org/download.html</a></li>
<li>在线下载安装包：wget <a href="http://www.keepalived.org/software/keepalived-1.4.0.tar.gz">http://www.keepalived.org/software/keepalived-1.4.0.tar.gz</a></li>
<li>在线安装：yum install keepalived -y</li>
</ol>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar -zxvf keepalived-1.4.0.tar.gz</span><br><span class="line"><span class="comment">#删除安装包</span></span><br><span class="line">rm -rf keepalived-1.4.0.tar.gz</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line"><span class="built_in">cd</span> /app/keepalived-1.4.0/</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/keepalived</span><br><span class="line"><span class="comment">#出现如下错误：</span></span><br><span class="line">checking <span class="keyword">for</span> a BSD-compatible install... /usr/bin/install -c</span><br><span class="line">checking whether build environment is sane... yes</span><br><span class="line">checking <span class="keyword">for</span> a thread-safe mkdir -p... /usr/bin/mkdir -p</span><br><span class="line">checking <span class="keyword">for</span> gawk... gawk</span><br><span class="line">checking whether make sets $(MAKE)... yes</span><br><span class="line">checking whether make supports nested variables... yes</span><br><span class="line">checking whether make supports nested variables... (cached) yes</span><br><span class="line">checking <span class="keyword">for</span> pkg-config... /usr/bin/pkg-config</span><br><span class="line">checking pkg-config is at least version 0.9.0... yes</span><br><span class="line">checking <span class="keyword">for</span> gcc... no</span><br><span class="line">checking <span class="keyword">for</span> cc... no</span><br><span class="line">checking <span class="keyword">for</span> cl.exe... no</span><br><span class="line">configure: error: <span class="keyword">in</span> `/app/keepalived-1.4.0<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">configure: error: no acceptable C compiler found in $PATH</span></span><br><span class="line"><span class="string">#安装编译依赖包</span></span><br><span class="line"><span class="string">yum -y install gcc</span></span><br><span class="line"><span class="string">#Openssl错误</span></span><br><span class="line"><span class="string">configure: error: </span></span><br><span class="line"><span class="string">  !!! OpenSSL is not properly installed on your system. !!!</span></span><br><span class="line"><span class="string">  !!! Can not include OpenSSL headers files.            !!!</span></span><br><span class="line"><span class="string">#安装openssl</span></span><br><span class="line"><span class="string">yum -y install openssl-devel </span></span><br><span class="line"><span class="string">#最终编译</span></span><br><span class="line"><span class="string">make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<h4 id="将keepalived配置成系统服务"><a href="#将keepalived配置成系统服务" class="headerlink" title="将keepalived配置成系统服务"></a>将keepalived配置成系统服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -r /usr/<span class="built_in">local</span>/keepalived/etc/keepalived /etc/init.d/</span><br><span class="line">cp -r  /usr/<span class="built_in">local</span>/keepalived/etc/sysconfig/keepalived /etc/sysconfig/</span><br><span class="line">mkdir /etc/keepalived/</span><br><span class="line">cp /usr/<span class="built_in">local</span>/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/</span><br><span class="line">cp /usr/<span class="built_in">local</span>/keepalived/sbin/keepalived /usr/sbin/</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><h4 id="keepalived-conf"><a href="#keepalived-conf" class="headerlink" title="keepalived.conf"></a>keepalived.conf</h4><p>vi /etc/keepalived/keepalived.conf  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   #设置报警通知邮件地址，可以设置多个</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   #设置邮件的发送地址</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   #设置smtp server的地址,该地址必须是存在的</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   #设置连接smtp server的超时时间</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   #运行Keepalived服务器的标识，发邮件时显示在邮件标题中的信息，可以设置为主机名 </span><br><span class="line">   router_id MYSQL_HA      #标识，双主相同</span><br><span class="line">&#125;</span><br><span class="line">#检测脚本</span><br><span class="line">vrrp_script check_run &#123;</span><br><span class="line">	script &quot;&#x2F;etc&#x2F;keepalived&#x2F;bin&#x2F;mysql_check.sh&quot;</span><br><span class="line">	interval 10</span><br><span class="line">&#125;</span><br><span class="line">#定义VRRP实例,实例名自定义</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    #指定Keepalived的角色，MASTER主机 BACKUP备份</span><br><span class="line">    state BACKUP           #两台都设置BACKUP</span><br><span class="line">    #指定HA监测的接口</span><br><span class="line">    interface ens33       #实际网卡</span><br><span class="line">        #虚拟路由标识，这个标识是一个数字(1-255)，在一个VRRP实例中主备服务器ID必须一样</span><br><span class="line">    virtual_router_id 51   #主备相同</span><br><span class="line">        #优先级，数字越大优先级越高，在一个实例中主服务器优先级要高于备服务器</span><br><span class="line">    priority 100           #优先级，backup设置90</span><br><span class="line">    #设置主备之间同步检查的时间间隔单位秒</span><br><span class="line">    advert_int 1</span><br><span class="line">    #设置不抢占模式</span><br><span class="line">    nopreempt              #不主动抢占资源，只在master这台优先级高的设置，backup不设置（防止频繁切换）</span><br><span class="line">        #设置验证类型和密码</span><br><span class="line">    authentication &#123;</span><br><span class="line">        #验证类型有两种&#123;PASS|HA&#125;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        #设置验证密码，在一个实例中主备密码保持一样</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">	    check_run          #执行上述检查mysql状态脚本</span><br><span class="line">    &#125;</span><br><span class="line">    #定义虚拟IP地址,可以有多个，每行一个</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.209.138</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.209.138 3306 &#123;</span><br><span class="line">    delay_loop 2</span><br><span class="line">    #lb_algo rr            #LVS算法，用不到，我们就关闭了</span><br><span class="line">    #lb_kind NAT           #LVS模式，如果不关闭，备用服务器不能通过VIP连接主MySQL</span><br><span class="line">    #nat_mask 255.255.255.0</span><br><span class="line">    persistence_timeout 50 #同一IP的连接50秒内被分配到同一台真实服务器</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.209.132 3306 &#123; #检测本地mysql，backup也要写检测本地mysql</span><br><span class="line">        weight 3</span><br><span class="line">	    notify_down &#x2F;etc&#x2F;keepalived&#x2F;bin&#x2F;mysql_down.sh #当mysql服down时，执行此脚本，杀死keepalived，启动其他服务</span><br><span class="line">	    TCP_CHECK &#123;</span><br><span class="line">            connect_timeout 3      #连接超时</span><br><span class="line">            nb_get_retry 3         #重试次数</span><br><span class="line">            delay_before_retry 3   #重试间隔时间</span><br><span class="line">            connect_port 3306</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mysql-check-sh"><a href="#mysql-check-sh" class="headerlink" title="mysql_check.sh"></a>mysql_check.sh</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /etc/keepalived/bin</span><br><span class="line">vim /etc/keepalived/bin/mysql_check.sh</span><br><span class="line">chmod a+x /etc/keepalived/bin/mysql_check.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#This scripts is check for Mysql Slave status</span></span><br><span class="line">Mysqlbin=/usr/bin/mysql</span><br><span class="line">user=root</span><br><span class="line">pw=<span class="string">&#x27;123456a?&#x27;</span></span><br><span class="line">port=3306</span><br><span class="line">host=127.0.0.1</span><br><span class="line"><span class="comment">#最大延时</span></span><br><span class="line">sbm=120</span><br><span class="line"></span><br><span class="line"><span class="comment">#Check for $Mysqlbin</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="variable">$Mysqlbin</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&#x27;Mysqlbin not found,check the variable Mysqlbin&#x27;</span></span><br><span class="line">        pkill keepalived</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Get Mysql Slave Status</span></span><br><span class="line">IOThread=`<span class="variable">$Mysqlbin</span> -h <span class="variable">$host</span> -P <span class="variable">$port</span> -u<span class="variable">$user</span> -p<span class="variable">$pw</span> -e <span class="string">&#x27;show slave status\G&#x27;</span>  2&gt;/dev/null|grep <span class="string">&#x27;Slave_IO_Running:&#x27;</span>|awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span>`</span><br><span class="line">SQLThread=`<span class="variable">$Mysqlbin</span> -h <span class="variable">$host</span> -P <span class="variable">$port</span> -u<span class="variable">$user</span> -p<span class="variable">$pw</span> -e <span class="string">&#x27;show slave status\G&#x27;</span> 2&gt;/dev/null|grep <span class="string">&#x27;Slave_SQL_Running:&#x27;</span>|awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span>`</span><br><span class="line">SBM=`<span class="variable">$Mysqlbin</span> -h <span class="variable">$host</span> -P <span class="variable">$port</span> -u<span class="variable">$user</span> -p<span class="variable">$pw</span> -e <span class="string">&#x27;show slave status\G&#x27;</span> 2&gt;/dev/null|grep <span class="string">&#x27;Seconds_Behind_Master:&#x27;</span>|awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">#Check if the mysql run</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$IOThread</span>&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">        pkill keepalived</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Check if the thread run </span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$IOThread</span>&quot;</span> == <span class="string">&quot;No&quot;</span> || <span class="string">&quot;<span class="variable">$SQLThread</span>&quot;</span> == <span class="string">&quot;No&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">        pkill keepalived</span><br><span class="line">        <span class="keyword">elif</span> [[ <span class="variable">$SBM</span> -ge <span class="variable">$sbm</span> ]];<span class="keyword">then</span></span><br><span class="line">                pkill keepalived</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h4 id="mysql-down-sh"><a href="#mysql-down-sh" class="headerlink" title="mysql_down.sh"></a>mysql_down.sh</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/keepalived/bin/mysql_down.sh</span><br><span class="line">chmod a+x /etc/keepalived/bin/mysql_down.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">pkill keepalived</span><br><span class="line">/sbin/ifdown ens33 &amp;&amp; /sbin/ifup ens33 <span class="comment">#ens33按照实际网卡名填写</span></span><br></pre></td></tr></table></figure>
<h4 id="启动keepalived"><a href="#启动keepalived" class="headerlink" title="启动keepalived"></a>启动keepalived</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service keepalived start</span><br></pre></td></tr></table></figure>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><h4 id="在H1和H2中配置远程连接"><a href="#在H1和H2中配置远程连接" class="headerlink" title="在H1和H2中配置远程连接"></a>在H1和H2中配置远程连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span><span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456a?&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure>
<h4 id="通过vip链接-可以通过客户端连接"><a href="#通过vip链接-可以通过客户端连接" class="headerlink" title="通过vip链接(可以通过客户端连接)"></a>通过vip链接(可以通过客户端连接)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop keepalived]<span class="comment"># mysql -uroot -p123456a? -h 192.168.209.138 </span></span><br><span class="line">mysql: [Warning] Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 55</span><br><span class="line">Server version: 5.7.20-log MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>
<h4 id="测试切换"><a href="#测试切换" class="headerlink" title="测试切换"></a>测试切换</h4><ol>
<li>通过Mysql客户端通过VIP连接，看是否连接成功。</li>
<li>停止master这台mysql服务，是否能正常切换过去，可通过ip addr命令来查看VIP在哪台服务器上。</li>
<li>可通过查看/var/log/messges日志，看出主备切换过程</li>
<li>master服务器故障恢复后，是否主动抢占资源，成为活动服务器。</li>
</ol>
<h5 id="H1132、H2137正常启动"><a href="#H1132、H2137正常启动" class="headerlink" title="H1132、H2137正常启动"></a>H1132、H2137正常启动</h5><h6 id="H1-IP"><a href="#H1-IP" class="headerlink" title="H1 IP"></a>H1 IP</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop etc]<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:c2:a2:df brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.209.132/24 brd 192.168.209.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 192.168.209.138/32 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::ffc6:3a33:ea90:cc5f/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h6 id="H2-IP"><a href="#H2-IP" class="headerlink" title="H2 IP"></a>H2 IP</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost etc]<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:4c:51:01 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.209.137/24 brd 192.168.209.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::cfc:5056:d04a:340d/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h5 id="关闭H1：service-mysqld-stop，ip自动切换"><a href="#关闭H1：service-mysqld-stop，ip自动切换" class="headerlink" title="关闭H1：service mysqld stop，ip自动切换"></a>关闭H1：service mysqld stop，ip自动切换</h5><h6 id="H1-IP-1"><a href="#H1-IP-1" class="headerlink" title="H1 IP"></a>H1 IP</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop etc]<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:c2:a2:df brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.209.132/24 brd 192.168.209.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::ffc6:3a33:ea90:cc5f/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h6 id="H2-IP-1"><a href="#H2-IP-1" class="headerlink" title="H2 IP"></a>H2 IP</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost etc]<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:4c:51:01 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.209.137/24 brd 192.168.209.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 192.168.209.138/32 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::cfc:5056:d04a:340d/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h5 id="重启H1：service-mysqld-start，IP不切换（减少资源浪费）"><a href="#重启H1：service-mysqld-start，IP不切换（减少资源浪费）" class="headerlink" title="重启H1：service mysqld start，IP不切换（减少资源浪费）"></a>重启H1：service mysqld start，IP不切换（减少资源浪费）</h5><h6 id="H1-IP-2"><a href="#H1-IP-2" class="headerlink" title="H1 IP"></a>H1 IP</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop etc]<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:c2:a2:df brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.209.132/24 brd 192.168.209.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::ffc6:3a33:ea90:cc5f/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h6 id="H2-IP-2"><a href="#H2-IP-2" class="headerlink" title="H2 IP"></a>H2 IP</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost etc]<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:4c:51:01 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.209.137/24 brd 192.168.209.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 192.168.209.138/32 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::cfc:5056:d04a:340d/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h5 id="关闭H2：service-mysqld-stop，IP切换"><a href="#关闭H2：service-mysqld-stop，IP切换" class="headerlink" title="关闭H2：service mysqld stop，IP切换"></a>关闭H2：service mysqld stop，IP切换</h5><h6 id="H1-IP-3"><a href="#H1-IP-3" class="headerlink" title="H1 IP"></a>H1 IP</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop keepalived]<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:c2:a2:df brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.209.132/24 brd 192.168.209.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 192.168.209.138/32 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::ffc6:3a33:ea90:cc5f/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h6 id="H2-IP-3"><a href="#H2-IP-3" class="headerlink" title="H2 IP"></a>H2 IP</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost etc]<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:4c:51:01 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.209.137/24 brd 192.168.209.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::cfc:5056:d04a:340d/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="log-slave-updates说明"><a href="#log-slave-updates说明" class="headerlink" title="log-slave-updates说明"></a>log-slave-updates说明</h3><p>当从库log_slave_updates参数没有开启时，从库的binlog不会记录来源于主库的操作记录。只有开启log_slave_updates，从库binlog才会记录主库同步的操作日志。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_slave%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name     <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> log_slave_updates <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>M01和M02为主主复制，M01和R01为主从复制；在测试的过程中发现了以下问题：</p>
<ol>
<li>M01和M02的主主复制是没有问题的（从M01写入数据能同步到M02，从M02写入数据能够同步到M01);</li>
<li>主从同步的时候，当从M01写入的时候，数据可以写入到R01；</li>
<li>当从M02写入的时候，数据就不能写入到R01；</li>
</ol>
<p>问题的原因：log_slave_updates参数的状态为NO  </p>
<h4 id="官方说明"><a href="#官方说明" class="headerlink" title="官方说明"></a>官方说明</h4><p>Normally, a slave does not log to its own binary log any updates that are received from a master server. This option tells the slave to log the updates performed by its SQL thread to its own binary log. For this option to have any effect, the slave must also be started with the –log-bin option to enable binary logging. Prior to MySQL 5.5, the server would not start when using the –log-slave-updates option without also starting the server with the –log-bin option, and would fail with an error; in MySQL 5.5, only a warning is generated. (Bug #44663) –log-slave-updates is used when you want to chain replication servers. For example, you might want to set up replication servers using this arrangement:<br>A -&gt; B -&gt; C<br>Here, A serves as the master for the slave B, and B serves as the master for the slave C. For this to work, B must be both a master and a slave. You must start both A and B with –log-bin to enable binary logging, and B with the –log-slave-updates option so that updates received from A are logged by B to its binary log.  </p>
<p>a) M01同步从M02同步数据过来的时候，log_slave_updates参数用来控制M01是否把所有的操作写入到binary log，默认的情况下mysql是关闭的;<br>b) R01数据的更新需要通过读取到M01的binary log才能进行更新，这个时候M01是没有写binary log的，所以当数据从M02写入的时候，R01也就没有更新了。。  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.51cto.com/duyunlong/1306841">Linux下的MYSQL主主复制</a></li>
<li><a href="https://blog.51cto.com/lizhenliang/1362313">MySQL高可用性之Keepalived+Mysql（双主热备）</a></li>
<li><a href="https://blog.csdn.net/HzSunshine/article/details/67059532">Mysql+Keepalived双主互备高可用详细配置</a></li>
<li><a href="https://blog.51cto.com/duyunlong/1310405">Linux下keepalived+mysql实现高可用</a></li>
<li><a href="https://www.cnblogs.com/Aiapple/p/5794901.html">mysql高可用架构</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper系统化学习</title>
    <url>/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>开源分布式协调框架</li>
<li>为分布式应用提供一致性服务，作为整个大数据体系的管理员，包括服务发现、分布式锁、分布式领导选举、配置管理等</li>
<li>Zookeeper = 文件系统（类似于Linux文件系统的树形结构） + 监听通知机制<a id="more"></a>

</li>
</ol>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610767149963.png" class title="文件系统">

</div>

<ol>
<li>每个znode存放数据的上线为1M</li>
<li>能够自由的增减、删除znode</li>
<li>znode中可以存放数据</li>
<li>节点以绝对路径表示，不存在相对路径，且路径最后不能以 / 结尾（根节点除外）</li>
<li>ZooKeeper保证读和写都是原子操作，且每次读写操作都是对数据的完整读取或完整写入，并不提供对数据进行部分读取或者写入的操作。</li>
</ol>
<h4 id="znode"><a href="#znode" class="headerlink" title="znode"></a>znode</h4><h5 id="znode分类"><a href="#znode分类" class="headerlink" title="znode分类"></a>znode分类</h5><ol>
<li><strong>持久化目录节点PERSISTENT</strong>：客户端与zookeeper断开连接后，该节点依旧存在。</li>
<li><strong>持久化顺序编号目录节点PERSISTENT_SEQUENTIAL</strong>：客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。</li>
<li><strong>临时目录节点 EPHEMERAL</strong>：客户端与zookeeper断开连接后，该节点被删除。</li>
<li><strong>临时顺序编号目录节点 EPHEMERAL_SEQUENTIAL</strong>：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。</li>
</ol>
<h5 id="znode客户端操作"><a href="#znode客户端操作" class="headerlink" title="znode客户端操作"></a>znode客户端操作</h5><div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610767796309.png" class title="znode客户端操作">

</div>

<h5 id="znode状态信息"><a href="#znode状态信息" class="headerlink" title="znode状态信息"></a>znode状态信息</h5><div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610767865744.png" class title="znode状态信息">

</div>

<h5 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h5><ol>
<li><strong>dataVersion</strong> ：数据版本号，每次对节点进行set操作，dataVersion的值都会增加1（即使设置的是相同的数据）。</li>
<li><strong>cversion</strong> ：子节点的版本号。当znode的子节点有变化时，cversion 的值就会增加1。</li>
<li><strong>aclVersion</strong> ：ACL的版本号，ACL（Access Control List，访问控制）</li>
</ol>
<div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610768088118.png" class title="版本号管理">

</div>

<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>对于zk来说，每次的变化都会产生一个唯一的事务id，zxid（ZooKeeper Transaction Id）。通过zxid，可以确定更新操作的先后顺序。例如，如果zxid1小于zxid2，说明zxid1操作先于zxid2发生。 需要指出的是，zxid对于整个zk都是唯一的，即使操作的是不同的znode。</p>
<ol>
<li><strong>cZxid</strong> :Znode创建的事务id。</li>
<li><strong>mZxid</strong> :Znode被修改的事务id，即每次对znode的修改都会更新mZxid。</li>
</ol>
<div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610768235767.png" class title="事务">

</div>

<h5 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h5><ol>
<li>身份认证<div align="center">

</div></li>
</ol>
<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610768336326.png" class title="身份认证">

 
2. 权限操作
<div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610768364549.png" class title="权限操作">

</div>

<h3 id="监听通知机制（watcher）"><a href="#监听通知机制（watcher）" class="headerlink" title="监听通知机制（watcher）"></a>监听通知机制（watcher）</h3><ol>
<li>基于zookeeper上创建的节点，可以进行监听事件的绑定（节点数据变更、节点删除、子节点状态变更）</li>
<li>基于事件机制，实现分布式锁和集群管理功能</li>
</ol>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><blockquote>
<p>当数据发生变化的时候， Zookeeper 会产生一个 Watcher 事件，并且会发送到客户端。但是客户端只会收到一次通知。如果后续这个节点再次发生变化，那么之前设置 Watcher 的客户端不会再次收到消息。（Watcher 是一次性的操作）。可以通过循环监听去达到永久监听效果。</p>
</blockquote>
<h4 id="监听流程"><a href="#监听流程" class="headerlink" title="监听流程"></a>监听流程</h4><ol>
<li>客户端注册 Watcher，注册 watcher 有 3 种方式，getData、exists、getChildren。</li>
<li>服务器处理 Watcher 。</li>
<li>客户端回调 Watcher 客户端。</li>
</ol>
<div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610768831271.png" class title="监听流程">

</div>

<ol>
<li>创建main()线程</li>
<li>在main线程中创建Zookeeper客户端，这时就会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）。</li>
<li>通过connect线程将注册的监听事件发送给Zookeeper。</li>
<li>在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中。</li>
<li>Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程。</li>
<li>listener线程内部调用了process()方法。</li>
</ol>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>集群</strong>：Zookeeper是一个领导者（Leader），多个跟随者（Follower）组成的集群。</li>
<li><strong>高可用性</strong>：集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。</li>
<li><strong>全局数据一致</strong>：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。</li>
<li><strong>更新请求顺序进行</strong>：来自同一个Client的更新请求按其发送顺序依次执行。</li>
<li><strong>数据更新原子性</strong>：一次数据更新要么成功，要么失败。</li>
<li><strong>实时性</strong>：在一定时间范围内，Client能读到最新数据。</li>
<li>从设计模式角度来看，zk是一个基于观察者设计模式的框架，它负责管理跟存储大家都关心的数据，然后接受观察者的注册，数据反生变化zk会通知在zk上注册的观察者做出反应。</li>
<li>Zookeeper是一个分布式协调系统，满足CP性，跟SpringCloud中的Eureka满足AP不一样。</li>
</ol>
<blockquote>
<p>分布式协调系统：Leader会同步数据到follower，用户请求可通过follower得到数据，这样不会出现单点故障，并且只要同步时间无限短，那这就是个好的 分布式协调系统。CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p>
</blockquote>
<h3 id="Zookeeper角色"><a href="#Zookeeper角色" class="headerlink" title="Zookeeper角色"></a>Zookeeper角色</h3><p>Zookeeper 集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种</p>
<div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1589095424742.png" class title="角色">

</div>

<h4 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h4><ol>
<li>一个Zookeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护与各 Follwer及Observer间的心跳。 </li>
<li>所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。只要有超过半数节点（不包括 observeer 节点）写入成功，该写请求就会被提交（类 2PC 协议）。 </li>
</ol>
<h4 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h4><ol>
<li>一个 Zookeeper 集群可能同时存在多个 Follower，它会响应 Leader 的心跳， </li>
<li>Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理，并且负责在 Leader 处理写请求时对请求进行投票。 </li>
</ol>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>角色与 Follower 类似，但是无投票权。Zookeeper 需保证高可用和强一致性，为了支持更多的客户端，需要增加更多 Server；Server 增多，投票阶段延迟增大，影响性能；引入 Observer， Observer 不参与投票； Observers 接受客户端的连接，并将写请求转发给 leader 节点； 加入更多 Observer 节点，提高伸缩性，同时不影响吞吐率。 </p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="数据发布-订阅"><a href="#数据发布-订阅" class="headerlink" title="数据发布/订阅"></a>数据发布/订阅</h3><p>当某些数据由几个机器共享，且这些信息经常变化数据量还小的时候，这些数据就适合存储到ZK中。</p>
<ol>
<li><strong>数据存储</strong>：将数据存储到 Zookeeper 上的一个数据节点。</li>
<li><strong>数据获取</strong>：应用在启动初始化节点从 Zookeeper 数据节点读取数据，并在该节点上注册一个数据变更 Watcher</li>
<li><strong>数据变更</strong>：当变更数据时会更新 Zookeeper 对应节点数据，Zookeeper会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即可。</li>
</ol>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ol>
<li><strong>保持独占</strong>：在zk中有<strong>一个唯一的临时节点</strong>，只有拿到节点的才可以操作数据，没拿到的线程就需要等待。缺点：可能引发羊群效应，第一个用完后瞬间有999个同时并发的线程向zk请求获得锁。</li>
<li><strong>控制时序</strong>：主要是避免了羊群效应，临时节点已经预先存在，所有想要获得锁的线程在它下面创建临时顺序编号目录节点，编号最小的获得锁，用完删除，后面的依次排队获取。</li>
</ol>
<div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610778219171.png" class title="分布式锁">

</div>

<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610778458637.png" class title="负载均衡">

</div>

<ol>
<li>多个服务注册</li>
<li>客户端获取中间件地址集合</li>
<li>从集合中随机选一个服务执行任务</li>
</ol>
<h4 id="ZooKeeper负载均衡和Nginx负载均衡区别"><a href="#ZooKeeper负载均衡和Nginx负载均衡区别" class="headerlink" title="ZooKeeper负载均衡和Nginx负载均衡区别"></a>ZooKeeper负载均衡和Nginx负载均衡区别</h4><blockquote>
<p>ZooKeeper不存在单点问题，zab机制保证单点故障可重新选举一个leader只负责服务的注册与发现，不负责转发，减少一次数据交换（消费方与服务方直接通信），需要自己实现相应的负载均衡算法。<br>Nginx存在单点问题，单点负载高数据量大,需要通过 KeepAlived + LVS 备机实现高可用。每次负载，都充当一次中间人转发角色，增加网络负载量（消费方与服务方间接通信），自带负载均衡算法</p>
</blockquote>
<h3 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h3><div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610778627481.png" class title="命名服务">

</div>

<p>命名服务是指<strong>通过指定的名字来获取资源或者服务的地址</strong>，利用 zk 创建一个全局唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p>
<h3 id="分布式协调-通知"><a href="#分布式协调-通知" class="headerlink" title="分布式协调/通知"></a>分布式协调/通知</h3><ol>
<li>对于系统调度来说，用户更改zk某个节点的value， ZooKeeper会将这些变化发送给注册了这个节点的 watcher 的所有客户端，进行通知。</li>
<li>对于执行情况汇报来说，每个工作进程都在目录下创建一个携带工作进度的临时节点，那么汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。</li>
</ol>
<h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610778799129.png" class title="集群管理">

</div>

<ol>
<li><p>动态上下线：</p>
<blockquote>
<p>比如在zookeeper服务器端有一个znode叫 /Configuration，那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1 创建 /Configuration/Server1，server2创建**/Configuration /Server1**，然后Server1和Server2都watch /Configuration 这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知到该节点进行watch的客户端。</p>
</blockquote>
</li>
<li><p>Leader选举：</p>
</li>
</ol>
<blockquote>
<p>利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /Master 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选举了。<br>动态Master选举。这就要用到 EPHEMERAL_SEQUENTIAL类型节点的特性了，这样每个节点会自动被编号。允许所有请求都能够创建成功，但是得有个创建顺序，每次选取序列号最小的那个机器作为Master 。</p>
</blockquote>
<h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><ol>
<li><strong>LOOKING：寻 找 Leader 状态</strong>。当服务器处于该状态时会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</li>
<li><strong>FOLLOWING：跟随者状态</strong>。处理客户端的非事务请求，转发事务请求给 Leader 服务器，参与事务请求 Proposal(提议) 的投票，参与 Leader 选举投票。</li>
<li><strong>LEADING：领导者状态</strong>。事务请求的唯一调度和处理者，保证集群事务处理的顺序性，集群内部个服务器的调度者(管理follower,数据同步)。</li>
<li><strong>OBSERVING：观察者状态</strong>。3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力，处理客户端的非事务请求，转发事务请求给 Leader 服务器，不参与任何形式的投票。</li>
</ol>
<h3 id="服务器ID"><a href="#服务器ID" class="headerlink" title="服务器ID"></a>服务器ID</h3><p><strong>Server id</strong>，一般在搭建ZK集群时会在myid文件中给每个节点搞个唯一编号，<strong>编号越大在Leader选择算法中的权重越大</strong>，比如初始化启动时就是根据服务器ID进行比较。</p>
<h3 id="ZXID"><a href="#ZXID" class="headerlink" title="ZXID"></a>ZXID</h3><div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610779475884.png" class title="zxid">

</div>

<p>采用<strong>全局递增的事务 Id</strong> 来标识，所有 proposal(提议)在被提出的时候加上了ZooKeeper Transaction Id ，zxid是<strong>64位</strong>的Long类型，这是保证事务的顺序一致性的关键。<strong>zxid中高32位表示纪元epoch，低32位表示事务标识xid</strong>。</p>
<ol>
<li>每个leader都会具有<strong>不同的epoch值</strong>，表示一个纪元/朝代，用来标识 leader 周期。每个新的选举开启时都会生成一个新的epoch，新的leader产生的话epoch会自增，会将该值更新到所有的zkServer的zxid和epoch，</li>
<li>xid是一个依次递增的事务编号。数值越大说明数据越新，所有 proposal（提议）在被提出的时候加上了zxid，然后会依据数据库的两阶段过程，<strong>首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行</strong>。</li>
</ol>
<h3 id="启动时选举"><a href="#启动时选举" class="headerlink" title="启动时选举"></a>启动时选举</h3><div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610768994211.png" class title="启动时选举">

</div>

<ol>
<li>服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，<strong>服务器1状态保持为LOOKING</strong>。</li>
<li>服务器2启动，再发起一次选举。服务器1和2分别投自己一票，此时服务器1发现服务器2的id比自己大，更改选票投给服务器2。此时服务器1票数0票，服务器2票数2票，不够半数以上（3票），选举无法完成。服务器1，2状态保持LOOKING。</li>
<li>服务器3启动，发起一次选举。与上面过程一样，服务器1和2先投自己一票，然后因为服务器3id最大，两者更改选票投给为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数（3票），<strong>服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</strong></li>
<li>服务器4启动，发起一次选举。此时服务器1、2、3已经不是LOOKING状态，不会更改选票信息，交换选票信息结果。服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，服务器4并更改状态为FOLLOWING。</li>
<li>服务器5启动，发起一次选举同4一样投票给3，此时服务器3一共5票，服务器5为0票。服务器5并更改状态为FOLLOWING；</li>
<li>最终Leader是服务器3，状态为LEADING。其余服务器是Follower，状态为FOLLOWING。</li>
</ol>
<h3 id="运行时选举"><a href="#运行时选举" class="headerlink" title="运行时选举"></a>运行时选举</h3><p>运行时候如果Master节点崩溃了会走恢复模式，新Leader选出前会暂停对外服务，大致可以分为四个阶段 <strong>选举、发现、同步、广播</strong>。</p>
<div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610780044797.png" class title="运行时选举">

</div>

<ol>
<li>每个Server会发出一个投票，第一次都是投自己，其中投票信息 = (myid，ZXID)</li>
<li>收集来自各个服务器的投票</li>
<li>处理投票并重新投票，处理逻辑：优先比较ZXID，然后比较myid。</li>
<li>统计投票，只要超过半数的机器接收到同样的投票信息，就可以确定leader，注意epoch的增加跟同步。</li>
<li>改变服务器状态Looking变为Following或Leading。</li>
<li>当 Follower 链接上 Leader 之后，Leader 服务器会根据自己服务器上最后被提交的 ZXID 和 Follower 上的 ZXID 进行比对，比对结果要么回滚，要么和 Leader 同步，保证集群中各个节点的事务一致。</li>
<li>集群恢复到广播模式，开始接受客户端的写请求。</li>
</ol>
<h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p>有了过半机制，并且有且只能一个leader</p>
<h2 id="一致性协议-ZAB"><a href="#一致性协议-ZAB" class="headerlink" title="一致性协议-ZAB"></a>一致性协议-ZAB</h2><h3 id="zab简介"><a href="#zab简介" class="headerlink" title="zab简介"></a>zab简介</h3><p>ZAB (Zookeeper Atomic Broadcast <strong>原子广播协议</strong>) 协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的一致性协议。基于该协议，ZooKeeper 实现了一种<strong>主从模式的系统架构来保持集群中各个副本之间的数据一致性</strong>。</p>
<ol>
<li>原子广播模式：把数据更新到所有的follower。</li>
<li>崩溃恢复模式：Leader发生崩溃时，如何恢复。</li>
</ol>
<h3 id="原子广播模式（同步）"><a href="#原子广播模式（同步）" class="headerlink" title="原子广播模式（同步）"></a>原子广播模式（同步）</h3><p><strong>保证事务的顺序一致性</strong>。</p>
<div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610781102376.png" class title="事务一致性">

</div>

<ol>
<li>leader从客户端收到一个写请求后生成一个新的事务并为这个事务生成一个唯一的ZXID，</li>
<li>leader将带有 zxid 的消息作为一个提案(proposal)分发给所有 FIFO队列。</li>
<li>FIFO队列取出队头proposal给follower节点。</li>
<li>当 follower 接收到 proposal，<strong>先将 proposal 写到硬盘，写硬盘成功后再向 leader 回一个 ACK。</strong></li>
<li>FIFO队列把ACK返回给Leader。</li>
<li>当leader收到超过一半以上的follower的ack消息，leader会进行commit请求，然后再给FIFO发送commit请求。</li>
<li>当follower收到commit请求时，会判断该事务的ZXID是不是比历史队列中的任何事务的ZXID都小，如果是则提交，如果不是则等待比它更小的事务的commit(保证顺序性)</li>
</ol>
<h3 id="恢复模式（选主）"><a href="#恢复模式（选主）" class="headerlink" title="恢复模式（选主）"></a>恢复模式（选主）</h3><p>当 Leader 崩溃会进入崩溃恢复模式。</p>
<ol>
<li>ZAB 协议确保执行那些已经在 Leader 提交的事务最终会被所有服务器提交。</li>
<li>ZAB 协议确保丢弃那些只在 Leader 提出/复制，但没有提交的事务。</li>
</ol>
<h3 id="zab特性"><a href="#zab特性" class="headerlink" title="zab特性"></a>zab特性</h3><ol>
<li><strong>一致性保证：可靠提交(Reliable delivery)</strong> ，如果一个事务 A 被一个server提交(committed)了，那么它最终一定会被所有的server提交</li>
<li>**全局有序(Total order)**：假设有A、B两个事务，有一台server先执行A再执行B，那么可以保证所有server上A始终都被在B之前执行</li>
<li>**因果有序(Causal order)**：如果发送者在事务A提交之后再发送B,那么B必将在A之后执行</li>
<li><strong>高可用性</strong>：只要大多数（法定数量）节点启动，系统就行正常运行</li>
<li><strong>可恢复性</strong>：当节点下线后重启，它必须保证能恢复到当前正在执行的事务</li>
</ol>
<h3 id="ZAB-协议4阶段"><a href="#ZAB-协议4阶段" class="headerlink" title="ZAB 协议4阶段"></a>ZAB 协议4阶段</h3><h4 id="Leader-election（选举阶段-选出准Leader）"><a href="#Leader-election（选举阶段-选出准Leader）" class="headerlink" title="Leader election（选举阶段-选出准Leader）"></a>Leader election（选举阶段-选出准Leader）</h4><p>节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 广播阶段（broadcast） 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。 </p>
<h4 id="Discovery（发现阶段-接受提议、生成epoch、接受epoch）"><a href="#Discovery（发现阶段-接受提议、生成epoch、接受epoch）" class="headerlink" title="Discovery（发现阶段-接受提议、生成epoch、接受epoch）"></a>Discovery（发现阶段-接受提议、生成epoch、接受epoch）</h4><p>在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且准 leader 生成新的 epoch，让 followers 接受，更新它们的 accepted Epoch ，一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入重新选举阶段。 </p>
<h4 id="Synchronization（同步阶段-同步follower副本）"><a href="#Synchronization（同步阶段-同步follower副本）" class="headerlink" title="Synchronization（同步阶段-同步follower副本）"></a>Synchronization（同步阶段-同步follower副本）</h4><p>主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。只有当 大多数节点都同步完成，准 leader 才会成为真正的 leader。<br>follower 只会接收 zxid 比自己的 lastZxid 大的提议。 </p>
<h4 id="Broadcast（广播阶段-leader消息广播）"><a href="#Broadcast（广播阶段-leader消息广播）" class="headerlink" title="Broadcast（广播阶段-leader消息广播）"></a>Broadcast（广播阶段-leader消息广播）</h4><p>到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。 </p>
<h3 id="ZAB-和-Paxos-对比"><a href="#ZAB-和-Paxos-对比" class="headerlink" title="ZAB 和 Paxos 对比"></a>ZAB 和 Paxos 对比</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><blockquote>
<p>两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行.Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交.ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader周期，Paxos 中名字为 Ballot</p>
</blockquote>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><blockquote>
<p>ZAB 用来构建高可用的<strong>分布式数据主备系统</strong>（Zookeeper），Paxos 是用来构建分<strong>布式一致性状态机</strong>系统。</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol>
<li>集群中机器的数量并不是越多越好，一个写操作需要半数以上的节点ack，所以集群节点数越多，整个集群可以抗挂点的节点数越多(越可靠)，但是吞吐量越差。集群的数量必须为奇数。</li>
<li>zk是基于内存进行读写操作的，有时候会进行消息广播，因此不建议在节点存取容量比较大的数据。</li>
<li>dataDir目录、dataLogDir两个目录会随着时间推移变得庞大，容易造成硬盘满了。建议自己编写或使用自带的脚本保留最新的n个文件。</li>
<li>默认最大连接数 默认为60，配置maxClientCnxns参数，配置单个客户端机器创建的最大连接数。</li>
</ol>
<h3 id="部署模式"><a href="#部署模式" class="headerlink" title="部署模式"></a>部署模式</h3><ol>
<li>单机部署：一台机器上运行。</li>
<li>集群部署：多台机器运行。</li>
<li>伪集群部署：一台机器启动多个 Zookeeper 实例运行。</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><div align="center">

<img src="/2021/02/05/Zookeeper%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0/1610781922501.png" class title="常用命令">

</div>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://yq.aliyun.com/articles/38098?spm=5176.100239.blogcont38274.9.Bx5zlv">Zookeeper笔记（一）初识Zookeeper</a> </li>
<li><a href="https://blog.csdn.net/xuxiuning/article/details/51218941">Zookeeper原理架构</a> </li>
<li><a href="https://www.iteye.com/blog/cailin-2014486">zookeeper原理（转）</a>  </li>
<li><a href="https://www.cnblogs.com/felixzh/p/5869212.html">Zookeeper的功能以及工作原理</a> </li>
<li><a href="https://blog.csdn.net/yzllz001/article/details/68946323">zookeeper在Dubbo中的作用</a>  </li>
<li><a href="https://blog.csdn.net/daiqinge/article/details/51282874">zookeeper和dubbo的关系</a> </li>
<li><a href="https://blog.csdn.net/yinwenjie/article/details/47685077">hadoop系列：zookeeper（3）——zookeeper核心原理（事件）</a> </li>
<li><a href="https://www.toutiao.com/i6917882262764012043">万字详解 Zookeeper 的五个核心知识点</a></li>
</ol>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论</title>
    <url>/2021/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><h3 id="Consistency（一致性）"><a href="#Consistency（一致性）" class="headerlink" title="Consistency（一致性）"></a>Consistency（一致性）</h3><ol>
<li>在分布式系统中的所有数据备份，在同一时刻是否同样的值</li>
<li>所有节点访问同一份最新的数据副本</li>
<li>强调数据的正确性，对于客户端而言，每次都能读取到最新写入的数据</li>
</ol>
<h3 id="Availability（可用性）"><a href="#Availability（可用性）" class="headerlink" title="Availability（可用性）"></a>Availability（可用性）</h3><ol>
<li>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li>强调服务可用，但是不保证数据正确</li>
</ol>
<h3 id="Partition-tolerance（分区容错性）"><a href="#Partition-tolerance（分区容错性）" class="headerlink" title="Partition tolerance（分区容错性）"></a>Partition tolerance（分区容错性）</h3><ol>
<li>以实际效果而言，分区相当于对<strong>通信</strong>的时限要求</li>
<li>系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li>
<li>强调的是集群对分区故障的容错能力</li>
</ol>
<h3 id="可用性和分区容错性的区别"><a href="#可用性和分区容错性的区别" class="headerlink" title="可用性和分区容错性的区别"></a>可用性和分区容错性的区别</h3><ol>
<li>可用性：节点出现故障时，系统可用</li>
<li>分区容错性：网络出现问题时，系统可用</li>
</ol>
<a id="more"></a>

<h3 id="CAP的关系"><a href="#CAP的关系" class="headerlink" title="CAP的关系"></a>CAP的关系</h3><div align="center">

<img src="/2021/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/1602761037948.png" class title="CAP的关系">

</div>

<ol>
<li><strong>CA 模型</strong>，不存在；舍弃P则舍弃分布式系统，如：在单机版MySQL中，如果要考虑主备或集群部署时，它必须考虑 P</li>
<li><strong>CP 模型</strong>，舍弃可用性，一定会读取最新的数据。一旦因为消息丢失、延迟过高发生了网络分区，就影响用户的体验和业务的可用性</li>
<li><strong>AP 模型</strong>，舍弃一致性，实现了服务的高可用。用户访问系统的时候，都能得到响应数据，不会出现响应错误，但会读到旧数据</li>
</ol>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>如果网络故障经常出现一般选择AP原则，如果对一致性要求比较高则选择CP；</p>
<ol>
<li>AP：redis、rocketmq、分布式事务-最大努力尝试、Eureka、Cassandra、DynamoDB。</li>
<li>CP：分布式事务-2pc、基于Raft的强一致性系统（Etcd，Consul 和 Hbase）</li>
</ol>
<h2 id="ACID（追求一致性）"><a href="#ACID（追求一致性）" class="headerlink" title="ACID（追求一致性）"></a>ACID（追求一致性）</h2><h3 id="两阶段提交协议（2PC）"><a href="#两阶段提交协议（2PC）" class="headerlink" title="两阶段提交协议（2PC）"></a>两阶段提交协议（2PC）</h3><h4 id="定义（分布式事务一致性协议：Protocol）"><a href="#定义（分布式事务一致性协议：Protocol）" class="headerlink" title="定义（分布式事务一致性协议：Protocol）"></a>定义（分布式事务一致性协议：Protocol）</h4><p>分布式系统下，一种通过两阶段协商来保障事务一致性的算法</p>
<h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>为了保持事务的 ACID 特性，需要引入<strong>协调者</strong>来统一掌控所有节点(<strong>参与者</strong>)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)</p>
<div align="center">

<img src="/2021/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/1589107881967.png" class title="两阶段提交算法">

</div>

<h5 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h5><p><strong>在一个参与者投票要求提交事务之前，它必须保证能够执行提交协议中它自己那一部分，即使参与者出现故障或者中途被替换掉</strong></p>
<ol>
<li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复（发送Prepare消息）</li>
<li>各参与者执行事务操作，要么直接返回失败(如权限验证失败)，要么在本地执行事务，<strong>写本地的redo和undo日志，但不提交</strong></li>
<li>参与者执行成功返回yes，否则no</li>
</ol>
<h5 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h5><p><strong>事务的每个参与者执行最终统一的决定，提交事务或者放弃事务</strong></p>
<h6 id="提交阶段（提交）"><a href="#提交阶段（提交）" class="headerlink" title="提交阶段（提交）"></a>提交阶段（提交）</h6><ol>
<li>协调者向所有参与者发出正式提交事务的请求（即 commit 请求）</li>
<li>参与者执行 commit 请求，并释放整个事务期间占用的资源</li>
<li>各参与者向协调者反馈 ack(应答)完成的消息</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交</li>
</ol>
<h6 id="提交阶段（回滚）"><a href="#提交阶段（回滚）" class="headerlink" title="提交阶段（回滚）"></a>提交阶段（回滚）</h6><ol>
<li>协调者向所有参与者发出回滚请求（即 rollback 请求）。</li>
<li>参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>性能问题</strong>：所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li><strong>可靠性问题</strong>：协调者单点故障，参与者将一直处于锁定状态</li>
<li><strong>数据一致性问题</strong>：在阶段 2 中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。</li>
<li><strong>脑裂问题</strong>：在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，导致只有一部分参与者接受到了 commit 请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。 </li>
<li><strong>二阶段无法解决的问题（数据状态不确定）</strong>：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li>
<li>实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）。</p>
<h3 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h3><p>二阶段提交（2PC）的改进版本，3PC最关键要解决的就是<strong>协调者和参与者同时挂掉的问题</strong>，所以3PC把2PC的准备阶段再次一分为二，这样三阶段提交</p>
<div align="center">

<img src="/2021/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/1589107914787.png" class title="三阶段提交">

</div>

<h4 id="改进点（对比2PC）"><a href="#改进点（对比2PC）" class="headerlink" title="改进点（对比2PC）"></a>改进点（对比2PC）</h4><ol>
<li>同时在协调者和参与者中都引入<strong>超时机制</strong></li>
<li>在第一阶段和第二阶段中插入一个准备阶段；保证了在最后提交阶段之前各参与节点的状态是一致的。3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有 <strong>CanCommit、PreCommit、DoCommit</strong> 三个阶段。 </li>
</ol>
<h4 id="阶段一CanCommit-阶段"><a href="#阶段一CanCommit-阶段" class="headerlink" title="阶段一CanCommit 阶段"></a>阶段一CanCommit 阶段</h4><ol>
<li>协调者向所有参与者发出包含事务内容的 <strong>canCommit</strong> 请求，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入<strong>预备状态</strong>，否则反馈 no。</li>
</ol>
<h4 id="阶段二PreCommit-阶段"><a href="#阶段二PreCommit-阶段" class="headerlink" title="阶段二PreCommit 阶段"></a>阶段二PreCommit 阶段</h4><h5 id="yes，协调者预执行事务"><a href="#yes，协调者预执行事务" class="headerlink" title="yes，协调者预执行事务"></a>yes，协调者预执行事务</h5><ol>
<li>协调者向所有参与者发出 <strong>preCommit</strong> 请求，进入准备阶段。</li>
<li>参与者收到 preCommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>
<li>各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令。</li>
</ol>
<h5 id="存在no或超时"><a href="#存在no或超时" class="headerlink" title="存在no或超时"></a>存在no或超时</h5><ol>
<li>协调者向所有参与者发出 abort 请求。</li>
<li>无论收到协调者发出的 abort 请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。</li>
</ol>
<h4 id="阶段三doCommit-阶段"><a href="#阶段三doCommit-阶段" class="headerlink" title="阶段三doCommit 阶段"></a>阶段三doCommit 阶段</h4><h5 id="ack-响应，执行真正的事务提交"><a href="#ack-响应，执行真正的事务提交" class="headerlink" title="ack 响应，执行真正的事务提交"></a>ack 响应，执行真正的事务提交</h5><ol>
<li>如果协调者处于工作状态，则向所有参与者发出 <strong>do Commit</strong> 请求。</li>
<li>参与者收到 do Commit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调者反馈 ack 完成的消息。</li>
<li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交</li>
</ol>
<h5 id="存在no或超时-1"><a href="#存在no或超时-1" class="headerlink" title="存在no或超时"></a>存在no或超时</h5><ol>
<li>如果协调者处于工作状态，向所有参与者发出 rollback 请求。</li>
<li>参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>各参与者向协调组反馈 ack 完成的消息。</li>
<li>协调组收到所有参与者反馈的 ack 消息后，即完成事务回滚。</li>
</ol>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题。阶段3中协调者出现问题时，参与者会继续提交事务。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 do commite 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</p>
<h3 id="TCC-型事务（Try-Confirm-Cancel）"><a href="#TCC-型事务（Try-Confirm-Cancel）" class="headerlink" title="TCC 型事务（Try/Confirm/Cancel）"></a>TCC 型事务（Try/Confirm/Cancel）</h3><ol>
<li>针对每个操作都要注册一个与其对应的确认操作和补偿操作（也就是撤销操作）</li>
<li>业务层面的协议（TCC操作在业务层实现），一种编程模型</li>
<li>为了实现一致性，确认操作和补偿操作必须是等幂的</li>
</ol>
<div align="center">

<img src="/2021/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/1589107951384.png" class title="TCC型事务">

</div>

<p>WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，服务器 B 参与事务，服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行顺利，则事务 B 也提交，整个事务就算完成。但是如果事务 B 执行失败，事务 B 本身回滚，这时事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢复到未执行前事务 A 的状态。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是提高了 long-running 事务的可用性。 </p>
<h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ol>
<li>需要实现确认和补偿逻辑</li>
<li>需要支持幂等</li>
</ol>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><ol>
<li>Try 阶段主要是对业务系统做检测及资源预留：<ul>
<li>完成所有业务检查( 一致性 )</li>
<li>预留必须业务资源( 准隔离性 )</li>
<li>Try 尝试执行业务。</li>
</ul>
</li>
<li>Confirm 阶段主要是对业务系统做确认提交，默认Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ol>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>性能提升</strong>：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</li>
<li><strong>数据最终一致性</strong>：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li>
<li><strong>可靠性</strong>：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li>
</ol>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p>
<p>1.1.2    异步确保型<br>1、    通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响。 </p>
<div align="center">



</div>

<p>1.1.1    最大努力通知型（多次尝试）<br>1、    这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由 MQ Server 投递到消费者之后, 允许在达到最大重试次数之后正常结束事务。</p>
<p>1.2    本地消息表（消息队列）<br>其核心思想是将分布式事务拆分成本地事务进行处理。<br>方案通过在消费者额外新建事务消息表，消费者处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，提供者基于消息中间件消费事务消息表中的事务。</p>
<div align="center">



</div>

<p>1.1.1    条件<br>服务消费者需要创建一张消息表，用来记录消息状态。<br>服务消费者和提供者需要支持幂等。<br>需要补偿逻辑。<br>每个节点上起定时线程，检查未处理完成或发出失败的消息，重新发出消息，即重试机制和幂等性机制。<br>1.1.2    处理流程</p>
<ol>
<li>服务消费者把业务数据和消息一同提交，发起事务。</li>
<li>消息经过MQ发送到服务提供方，服务消费者等待处理结果。</li>
<li>服务提供方接收消息，完成业务逻辑并通知消费者已处理的消息。<br>容错处理情况如下：<br>当步骤1处理出错，事务回滚，相当于什么都没有发生。<br>当步骤2、3处理出错，由于消息保存在消费者表中，可以重新发送到MQ进行重试。<br>如果步骤3处理出错，且是业务上的失败，服务提供者发送消息通知消费者事务失败，且此时变为消费者发起回滚事务进行回滚逻辑。<br>优点：从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。<br>缺点：与具体的业务场景绑定，耦合性强，不可公用。消息数据与业务数据同库，占用业务系统资源。业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。</li>
<li>2    MQ事务消息（最终一致性）<br>支持事务消息的MQ，其支持事务消息的方式采用类似于二阶段提交。<br>基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。<div align="center">

</div></li>
</ol>




<p>1.1.1    条件<br>a) 需要补偿逻辑<br>b) 业务处理逻辑需要幂等<br>1.1.2    处理流程<br>c) 消费者向MQ发送half消息。<br>d) MQ Server将消息持久化后，向发送方ack确认消息发送成功。<br>e) 消费者开始执行事务逻辑。<br>f) 消费者根据本地事务执行结果向MQ Server提交二次确认或者回滚。<br>g) MQ Server收到commit状态则将half消息标记可投递状态。<br>h) 服务提供者收到该消息，执行本地业务逻辑。返回处理结果。<br>优点：<br>消息数据独立存储，降低业务系统与消息系统之间的耦合。<br>吞吐量优于本地消息表方案。<br>缺点：<br>一次消息发送需要两次网络请求(half消息 + commit/rollback)。<br>需要实现消息回查接口。<br>1.2    Sagas事务模型（最终一致性）<br>Saga模式是一种分布式异步事务，一种最终一致性事务，是一种柔性事务，有两种不同的方式来实现saga事务，最流行的两种方式是：<br>1.2.1    事件/编排Choreography：没有中央协调器（没有单点风险）时，每个服务产生并聆听其他服务的事件，并决定是否应采取行动。<br>该实现第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件，当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。</p>
<div align="center">



</div>

<p>1.1.1.1    处理流程<br>订单服务保存新订单，将状态设置为pengding挂起状态，并发布名为ORDER_CREATED_EVENT的事件。<br>支付服务监听ORDER_CREATED_EVENT，并公布事件BILLED_ORDER_EVENT。<br>库存服务监听BILLED_ORDER_EVENT，更新库存，并发布ORDER_PREPARED_EVENT。<br>货运服务监听ORDER_PREPARED_EVENT，然后交付产品。最后，它发布ORDER_DELIVERED_EVENT。<br>最后，订单服务侦听ORDER_DELIVERED_EVENT并设置订单的状态为concluded完成。<br>假设库存服务在事务过程中失败了。进行回滚：<br>库存服务产生PRODUCT_OUT_OF_STOCK_EVENT<br>订购服务和支付服务会监听到上面库存服务的这一事件：<br>①支付服务会退款给客户。<br>②订单服务将订单状态设置为失败。<br>优点：事件/编排是实现Saga模式的自然方式; 它很简单，容易理解，不需要太多的努力来构建，所有参与者都是松散耦合的，因为他们彼此之间没有直接的耦合。如果您的事务涉及2至4个步骤，则可能是非常合适的。<br>1.1.2    命令/协调orchestrator：中央协调器负责集中处理事件的决策和业务逻辑排序。<br>saga协调器orchestrator以命令/回复的方式与每项服务进行通信，告诉他们应该执行哪些操作。</p>
<div align="center">



</div>

<p>订单服务保存pending状态，并要求订单Saga协调器（简称OSO）开始启动订单事务。<br>OSO向收款服务发送执行收款命令，收款服务回复Payment Executed消息。<br>OSO向库存服务发送准备订单命令，库存服务将回复OrderPrepared消息。<br>OSO向货运服务发送订单发货命令，货运服务将回复Order Delivered消息。<br>OSO订单Saga协调器必须事先知道执行“创建订单”事务所需的流程(通过读取BPM业务流程XML配置获得)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。当你有一个中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。<br>优点：<br>避免服务之间的循环依赖关系，因为saga协调器会调用saga参与者，但参与者不会调用协调器。<br>集中分布式事务的编排。<br>只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。<br>在添加新步骤时，事务复杂性保持线性，回滚更容易管理。<br>如果在第一笔交易还没有执行完，想改变有第二笔事务的目标对象，则可以轻松地将其暂停在协调器上，直到第一笔交易结束。</p>
<h2 id="BASE理论（追求可用性）"><a href="#BASE理论（追求可用性）" class="headerlink" title="BASE理论（追求可用性）"></a>BASE理论（追求可用性）</h2><p>BASE 理论是 CAP 理论中的 AP 的延伸，是对互联网大规模分布式系统的实践总结，强调可用性。核心思想就是：<strong>我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性</strong>。</p>
<h3 id="Basically-Available（基本可用）"><a href="#Basically-Available（基本可用）" class="headerlink" title="Basically Available（基本可用）"></a>Basically Available（基本可用）</h3><p>基本可用四板斧</p>
<ol>
<li>流量削峰：分时间段时间分业务场景处理</li>
<li>延迟响应：队列等待</li>
<li>体验降级：降低用户体验</li>
<li>过载保护：排队执行、超时保护</li>
</ol>
<h3 id="Soft-state（软状态）"><a href="#Soft-state（软状态）" class="headerlink" title="Soft state（软状态）"></a>Soft state（软状态）</h3><h3 id="Eventually-consistent（最终一致性）"><a href="#Eventually-consistent（最终一致性）" class="headerlink" title="Eventually consistent（最终一致性）"></a>Eventually consistent（最终一致性）</h3><p>系统中所有的数据副本在经过一段时间的同步后，最终能够达到一个一致的状态。</p>
<h4 id="实现依据"><a href="#实现依据" class="headerlink" title="实现依据"></a>实现依据</h4><ol>
<li>以最新写入的数据为准，比如 AP 模型的 KV 存储采用的就是这种方式；</li>
<li>以第一次写入的数据为准，如果你不希望存储的数据被更改，可以以它为准。</li>
</ol>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol>
<li><strong>读时修复</strong>：在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。</li>
<li><strong>写时修复</strong>：在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>
<li><strong>异步修复</strong>：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.toutiao.com/i6716373012393755148">大厂二面：CAP原则为什么只能满足其中两项？而不能同时满足</a></li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>cap</tag>
        <tag>base</tag>
        <tag>acid</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM加载机制</title>
    <url>/2021/02/05/JVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java虚拟机把描述类的数据从class文件加载到内存，并且对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程称为<strong>Java虚拟机的类加载机制</strong>，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的，JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，这五部分是在程序<strong>运行期间</strong>完成；还有使用和卸载，共七个阶段，参考下图所示：</p>
<div align="center">

<img src="/2021/02/05/JVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1588727499000.png" class title="JVM加载机制">

</div>
<a id="more"></a>

<h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><ol>
<li><strong>创建类的实例</strong>：new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。具体场景：<ul>
<li>使用new关键字实例化对象的时候</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li><strong>反射</strong>：使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li><strong>初始化子类</strong>：当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li><strong>主类</strong>：当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li><strong>JDK 7新加入的动态语言支持</strong>：，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<blockquote>
<p>说明</p>
<blockquote>
<p>对于静态字段，只有直接定义这个字段的类才会被初始化<br>接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。  </p>
</blockquote>
</blockquote>
<h2 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h2><p>类加载（Class Loading）的第一个阶段，在<code>加载</code>过程中主要完成以下操作：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流，比如<code>java.lang.String</code>，二进制字节流的形式可以是：<ul>
<li> ZIP中获取：jar、ear、war</li>
<li> 网络获取：Web Applet</li>
<li> 动态代理：*<em>java.lang.reflect.Proxy中的ProxyGenerator.generateProxyClass()来为特定接口生成形式为“</em>$Proxy”的代理类的二进制字节流**</li>
<li> JSP编译后的class文件</li>
<li> 加密后的class文件，然后使用时解密</li>
</ul>
</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存<strong>堆</strong>中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="数组的加载"><a href="#数组的加载" class="headerlink" title="数组的加载"></a>数组的加载</h3><ol>
<li>数组本身不通过类加载创建，由java虚拟机直接在内存中动态构建。</li>
<li>数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载</li>
</ol>
<p>如果一个数组类（比如：C）的<strong>组件类型</strong>（Component Type，指的是数组去掉一个维度的类型）是：</p>
<ol>
<li><strong>引用类型</strong>，就会使用类加载器来递归完成组件类型的加载。<strong>数组C将被标识在加载该组件类型的类加载器的类名称空间上</strong>；</li>
<li>非引用类型（例如int[]数组的组件类型为int），<strong>Java虚拟机将会把数组C标记为与引导类加载器关联</strong>。</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是<strong>确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求</strong>，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。主要完成以下四个阶段的校验的工作：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证</strong>。</p>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>基于二进制流，判断字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，解析完成之后可以正确的保存到方法区中，包括但不限于：</p>
<ol>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主、次版本号</li>
<li>常量池中非法常量类型检查（检查常量tag标志）</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
</ol>
<h3 id="元数据验证（语法验证）"><a href="#元数据验证（语法验证）" class="headerlink" title="元数据验证（语法验证）"></a>元数据验证（语法验证）</h3><p>元数据验证主要完成字节码描述信息的<strong>语义分析（面向元数据信息中的数据类型）</strong>，符合《Java语言规范》的要求，主要完成以下信息：</p>
<ol>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载）</li>
</ol>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>通过<strong>数据流分析和控制流分析</strong>，确定程序语义是合法的、符合逻辑的。面向<strong>类的方法体【Class文件中的Code属性】</strong> 进行校验分析，具体如下：</p>
<ol>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作（入栈的类型与出栈后的使用类型一致）</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换总是有效的（合法的类型转换）</li>
</ol>
<h4 id="StackMapTable"><a href="#StackMapTable" class="headerlink" title="StackMapTable"></a>StackMapTable</h4><p>为了提高字节码验证阶段的时间，JDK6之后在javac编译期阶段的方法体code中增加了一个<code>StackMapTable</code>的新属性，这项属性描述了<strong>方法体所有的基本块</strong>（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。StackMapTable属性也存在错误或被篡改的可能，所以是否有可能在恶意篡改了Code属性的同时，也生成相应的StackMapTable属性来骗过虚拟机的类型校验。</p>
<blockquote>
<p>扩展知识  </p>
<blockquote>
<p>使用<code>-XX：-UseSplitVerifier</code>关闭该优化，或使用<code>-XX：+FailOverToOldVerifier</code>要求在类型校验失败的时候退回到旧的类型推导方式进行校验。<br>JDK 7之后，尽管虚拟机中仍然保留着类型推导验证器的代码，但是对于主版本号大于50（对应JDK 6）的Class文件，使用类型检查来完成数据流分析校验则是唯一的选择，不允许再退回到原来的类型推导的校验方式。  </p>
</blockquote>
</blockquote>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>发生在虚拟机将符号引用转化为直接引用时（<strong>解析阶段</strong>），<strong>符号引用验证可以看作是对类自身以外【常量池中的各种符号引用】的各类信息进行匹配性校验，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</strong> 具体如下：</p>
<ol>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的可访问性（private、protected、public、&lt;package&gt;）是否可被当前类访问。</li>
</ol>
<p>符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>该阶段是正式为<strong>类变量（static修饰）分配内存并且完成初始化赋值的阶段（即在方法区分配内存空间）</strong>。</p>
<blockquote>
<p>关于方法区的特殊说明</p>
<blockquote>
<p>JDK 7及之前，HotSpot使用永久代来实现方法区<br>JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中  </p>
</blockquote>
</blockquote>
<h3 id="初始值的概念"><a href="#初始值的概念" class="headerlink" title="初始值的概念"></a>初始值的概念</h3><p>该阶段主要完成“0”值的处理，具体如下：</p>
<p><code>public static int v = 8080;</code>,则为0，将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于static方法(<code>&lt;clinit&gt;()</code>)之中。<code>public static final int v = 8080;</code>在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.TestStatic包含com.sunld.TestStatic</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/TestStatic.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">5</span>-<span class="number">9</span>; size <span class="number">409</span> bytes</span><br><span class="line">  MD5 checksum 7f77187644282a651264bddec7487130</span><br><span class="line">  Compiled from <span class="string">&quot;TestStatic.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">TestStatic</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/TestStatic</span><br><span class="line">   #2 = Utf8               com/sunld/TestStatic</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               a</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               b</span><br><span class="line">   #8 = Utf8               ConstantValue</span><br><span class="line">   #9 = Integer            20</span><br><span class="line">  #10 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #11 = Utf8               ()V</span><br><span class="line">  #12 = Utf8               Code</span><br><span class="line">  #13 = Fieldref           #1.#14         // com/sunld/TestStatic.a:I</span><br><span class="line">  #14 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #15 = Utf8               LineNumberTable</span><br><span class="line">  #16 = Utf8               LocalVariableTable</span><br><span class="line">  #17 = Utf8               &lt;init&gt;</span><br><span class="line">  #18 = Methodref          #3.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #19 = NameAndType        #17:#11        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #20 = Utf8               this</span><br><span class="line">  #21 = Utf8               Lcom/sunld/TestStatic;</span><br><span class="line">  #22 = Utf8               SourceFile</span><br><span class="line">  #23 = Utf8               TestStatic.java</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> b;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         2: putstatic     #13                 // Field a:I</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.sunld.TestStatic();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #18                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestStatic;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestStatic.java&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="零值参考表"><a href="#零值参考表" class="headerlink" title="零值参考表"></a>零值参考表</h4><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">数据类型</th>
    <th class="tg-0lax">零值</th>
    <th class="tg-0lax">数据类型</th>
    <th class="tg-0lax">零值</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">int</td>
    <td class="tg-0lax">0</td>
    <td class="tg-0lax">boolean</td>
    <td class="tg-0lax">false</td>
  </tr>
  <tr>
    <td class="tg-0lax">long</td>
    <td class="tg-0lax">0L</td>
    <td class="tg-0lax">float</td>
    <td class="tg-0lax">0.0f</td>
  </tr>
  <tr>
    <td class="tg-0lax">short</td>
    <td class="tg-0lax">(short)0</td>
    <td class="tg-0lax">double</td>
    <td class="tg-0lax">0.0d</td>
  </tr>
  <tr>
    <td class="tg-0lax">char</td>
    <td class="tg-0lax">'\u0000'</td>
    <td class="tg-0lax">reference</td>
    <td class="tg-0lax">null</td>
  </tr>
  <tr>
    <td class="tg-0lax">byte</td>
    <td class="tg-0lax">(byte)0</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
</tbody>
</table>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>该阶段主要是完成Java虚拟机中常量池中符号引用替换为直接引用的过程。符号引用主要是指class文件中的：</p>
<ol>
<li>CONSTANT_Class_info</li>
<li>CONSTANT_Field_info</li>
<li>CONSTANT_Method_info</li>
</ol>
<h3 id="符号引用（Symbolic-References）"><a href="#符号引用（Symbolic-References）" class="headerlink" title="符号引用（Symbolic References）"></a>符号引用（Symbolic References）</h3><ol>
<li>一组描述引用目标的符号，该符号可以是任意字面量（符合《Java虚拟机规范》）</li>
<li>与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容</li>
</ol>
<h3 id="直接引用（Direct-References）"><a href="#直接引用（Direct-References）" class="headerlink" title="直接引用（Direct References）"></a>直接引用（Direct References）</h3><ol>
<li>直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</li>
<li>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ol>
<h3 id="解析范围"><a href="#解析范围" class="headerlink" title="解析范围"></a>解析范围</h3><p>主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>这7类符号引用进行，分别对应于常量池的<strong>CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dynamic_info和CONSTANT_InvokeDynamic_info</strong> 8种常量类型。</p>
<h4 id="类或接口的解析-CONSTANT-Class-info"><a href="#类或接口的解析-CONSTANT-Class-info" class="headerlink" title="类或接口的解析(CONSTANT_Class_info)"></a>类或接口的解析(CONSTANT_Class_info)</h4><div align="center">

<img src="/2021/02/05/JVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1589283530987.png" class title="CONSTANT_Class_info">

</div>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> C N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM的解析过程：</p>
<ol>
<li>C <code>!=</code>数组类型，D类会使用N的全限定名去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</li>
<li>C<code>=</code>数组类型，并且数组的元素类型为对象（如：<code>[Ljava/lang/Integer</code>），那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是<code>java.lang.Integer</code>，<strong>接着由虚拟机生成一个代表该数组维度和元素的数组对象</strong>。</li>
<li>以上通过之后，C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的<strong>访问权限</strong>。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。如果我们说一个D拥有C的访问权限，那就意味着以下3条规则中至少有其中一条成立：<ul>
<li>被访问类C是public的，并且与访问类D处于同一个模块。</li>
<li>被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块允许被访问类D的模块进行访问。</li>
<li>被访问类C不是public的，但是它与访问类D处于同一个包中。</li>
</ul>
</li>
</ol>
<h4 id="字段解析-CONSTANT-Fieldref-info"><a href="#字段解析-CONSTANT-Fieldref-info" class="headerlink" title="字段解析(CONSTANT_Fieldref_info)"></a>字段解析(CONSTANT_Fieldref_info)</h4><div align="center">

<img src="/2021/02/05/JVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1589283359953.png" class title="CONSTANT_Fieldref_info">

</div>

<ol>
<li>解析<code>class_index</code>项中索引的<code>CONSTANT_Class_info</code>符号引用，也就是字段所属的类或接口的符号引用。解析成功之后定义为<code>C</code></li>
<li>C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li><strong>接口搜索</strong>：C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li><strong>继承搜索</strong>：C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li><strong>查找失败</strong>，抛出java.lang.NoSuchFieldError异常。</li>
</ol>
<p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<h4 id="方法解析-CONSTANT-Methodref-info"><a href="#方法解析-CONSTANT-Methodref-info" class="headerlink" title="方法解析(CONSTANT_Methodref_info)"></a>方法解析(CONSTANT_Methodref_info)</h4><div align="center">

<img src="/2021/02/05/JVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1589284121859.png" class title="CONSTANT_Methodref_info">

</div>

<ol>
<li>首先解析class_index项中索引的方法所属的类或接口的符号引用，解析成功使用C表示该类</li>
<li>在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li>
<li>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</li>
</ol>
<h4 id="接口方法解析-CONSTANT-InterfaceMethodref-info"><a href="#接口方法解析-CONSTANT-InterfaceMethodref-info" class="headerlink" title="接口方法解析(CONSTANT_InterfaceMethodref_info)"></a>接口方法解析(CONSTANT_InterfaceMethodref_info)</h4><div align="center">

<img src="/2021/02/05/JVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1589284472436.png" class title="CONSTANT_InterfaceMethodref_info">

</div>

<ol>
<li>首先解析class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，使用C表示这个接口</li>
<li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>对于规则4，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li>
<li>宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
<li>JDK9之后接口会出现访问权限的问题，抛出java.lang.IllegalAccessError异常。</li>
</ol>
<h2 id="初始化（类变量完成初始化）"><a href="#初始化（类变量完成初始化）" class="headerlink" title="初始化（类变量完成初始化）"></a>初始化（类变量完成初始化）</h2><p>最优一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了<strong>初始阶段，才开始真正执行类中定义的 Java 程序代码</strong>。</p>
<ol>
<li>在初始化阶段会根据业务代码完成静态变量的初始化</li>
<li>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>（javac自动生成的）方法的过程。</li>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</li>
<li>在Java虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是java.lang.Object。由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</li>
<li><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必需的，如果没有想过的静态变量和静态代码块，编译期会自动忽略该方法</li>
<li>接口中不能使用静态代码块，但是可以定义静态变量，所以接口编译之后也会存在<code>&lt;clinit&gt;()</code>方法。<strong>但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</strong></li>
<li>Java虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要<strong>阻塞等待</strong>，直到活动线程执行完毕<code>&lt;clinit&gt;()</code>方法。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，那就可能造成多个进程阻塞</li>
</ol>
<h3 id="不会初始化的情况"><a href="#不会初始化的情况" class="headerlink" title="不会初始化的情况"></a>不会初始化的情况</h3><ol>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化。</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li>
<li>通过类名获取 Class 对象，不会触发类的初始化。</li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器只用于实现类的加载动作，并且每个类记载器都有一个独立的类名称空间（<strong>类加载器+类全限定名来确定类的唯一性</strong>）。类装载的过程是先装在其父类，然后才是自己，卸载则相反。</p>
<h3 id="加载模式"><a href="#加载模式" class="headerlink" title="加载模式"></a>加载模式</h3><p>通常基础类库需要预先载入（常驻内存）、自定义类库需要按需载入（使用时载入，不用时自动被回收）。实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		a.testA();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以下命令：<code>java -verbose Test</code>运行结果如下：<br>部分截图：</p>
<div align="center">

<img src="/2021/02/05/JVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1589349448488.png" class>

</div>

<p>通过运行结果发现，<strong>java是按需载入</strong>。  </p>
<h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3><ol>
<li>隐式：使用new</li>
<li>显示：Class.forName或ClassLoader的loadClass</li>
</ol>
<h3 id="双亲委派原则"><a href="#双亲委派原则" class="headerlink" title="双亲委派原则"></a>双亲委派原则</h3><p>JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。</p>
<div align="center">

<img src="/2021/02/05/JVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1589028654976.png" class title="双亲委派原则">

</div>

<p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就<strong>保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</strong></p>
<div align="center">

<img src="/2021/02/05/JVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1589028697138.png" class>

</div>

<ol>
<li><p>启动类加载器(Bootstrap ClassLoader，C++实现，JVM的一部分)：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar，不能识别的则不能加载）的类。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the class loader for the class.  Some implementations may use</span></span><br><span class="line"><span class="comment"> * null to represent the bootstrap class loader. This method will return</span></span><br><span class="line"><span class="comment"> * null in such implementations if this class was loaded by the bootstrap</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If a security manager is present, and the caller&#x27;s class loader is</span></span><br><span class="line"><span class="comment"> * not null and the caller&#x27;s class loader is not the same as or an ancestor of</span></span><br><span class="line"><span class="comment"> * the class loader for the class whose class loader is requested, then</span></span><br><span class="line"><span class="comment"> * this method calls the security manager&#x27;s &#123;<span class="doctag">@code</span> checkPermission&#125;</span></span><br><span class="line"><span class="comment"> * method with a &#123;<span class="doctag">@code</span> RuntimePermission(&quot;getClassLoader&quot;)&#125;</span></span><br><span class="line"><span class="comment"> * permission to ensure it&#x27;s ok to access the class loader for the class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If this object</span></span><br><span class="line"><span class="comment"> * represents a primitive type or void, null is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the class loader that loaded the class or interface</span></span><br><span class="line"><span class="comment"> *          represented by this object.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment"> *    if a security manager exists and its</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> checkPermission&#125; method denies</span></span><br><span class="line"><span class="comment"> *    access to the class loader for the class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.ClassLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SecurityManager#checkPermission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.RuntimePermission</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = getClassLoader0();</span><br><span class="line">    <span class="keyword">if</span> (cl == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩展类加载器(Extension ClassLoader,在sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。</p>
</li>
<li><p>应用程序类加载器(Application ClassLoader，由sun.misc.Launcher$AppClassLoader实现)：负责加载用户路径（classpath）上的类库，由于应用程序类加载器是ClassLoader类中的<code>getSystemClassLoader()</code>方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。</p>
</li>
</ol>
<h4 id="双亲委派原则参考代码"><a href="#双亲委派原则参考代码" class="headerlink" title="双亲委派原则参考代码"></a>双亲委派原则参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  The</span></span><br><span class="line"><span class="comment"> * default implementation of this method searches for classes in the</span></span><br><span class="line"><span class="comment"> * following order:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke &#123;<span class="doctag">@link</span> #findLoadedClass(String)&#125; to check if the class</span></span><br><span class="line"><span class="comment"> *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method</span></span><br><span class="line"><span class="comment"> *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class</span></span><br><span class="line"><span class="comment"> *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #findClass(String)&#125; method to find the</span></span><br><span class="line"><span class="comment"> *   class.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If the class was found using the above steps, and the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #resolveClass(Class)&#125; method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;&#125; method</span></span><br><span class="line"><span class="comment"> * during the entire class loading process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  resolve</span></span><br><span class="line"><span class="comment"> *         If &lt;tt&gt;true&lt;/tt&gt; then resolve the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassNotFoundException</span></span><br><span class="line"><span class="comment"> *          If the class could not be found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类装载器的层次关系"><a href="#类装载器的层次关系" class="headerlink" title="类装载器的层次关系"></a>类装载器的层次关系</h3><p>当执行java.exe程序时，首先确认使用的jre，然后激活jre中的jvm，激活完成之后会首先完成初始化工作，然后就会初始化类装载器，并且形成类装载器的层次体系。如下所示：</p>
<div align="center">

<img src="/2021/02/05/JVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1589350033984.png" class title="类装载器的层次关系">

</div>

<h3 id="ClassLoader详解"><a href="#ClassLoader详解" class="headerlink" title="ClassLoader详解"></a>ClassLoader详解</h3><h2 id="OSGI（动态模型系统）-模块化系统"><a href="#OSGI（动态模型系统）-模块化系统" class="headerlink" title="OSGI（动态模型系统）:模块化系统"></a>OSGI（动态模型系统）:模块化系统</h2><p>OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。</p>
<h3 id="动态改变构造"><a href="#动态改变构造" class="headerlink" title="动态改变构造"></a>动态改变构造</h3><p>OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。</p>
<h3 id="模块化编程与热插拔"><a href="#模块化编程与热插拔" class="headerlink" title="模块化编程与热插拔"></a>模块化编程与热插拔</h3><p>OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。</p>
<p>OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《深入理解Java虚拟机》</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM加载</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之AQS</title>
    <url>/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS/</url>
    <content><![CDATA[<p><font color="red">AQS是实现同步器的基础组件，并发包中锁的底层实现就是使用AQS来完成的</font></p>
<h2 id="原理结构"><a href="#原理结构" class="headerlink" title="原理结构"></a>原理结构</h2><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS/1589109265967.png" class title="AQS原理结构图">

</div>
<a id="more"></a>


<ol>
<li>使用<code>volatile int state</code>代码共享资源的状态，有三总访问方式<ul>
<li> getState()</li>
<li> setState()</li>
<li> compareAndSetState()</li>
</ul>
</li>
<li>多线程竞争资源时使用阻塞的方式进入FIFO双向等待队列</li>
<li>两种资源共享方式<ul>
<li>Exclusive独占资源-ReentrantLock ，只有一个线程执行</li>
<li>Share共享资源-Semaphore/CountDownLatch，多个线程同时执行</li>
</ul>
</li>
<li>自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/ 唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法： <ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。 </li>
<li>tryAcquire(int)：独占。尝试获取资源，成功true，失败false。 </li>
<li>tryRelease(int)：独占。尝试释放资源，成功true，失败false。</li>
<li>tryAcquireShared(int)：共享。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 </li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。 </li>
</ul>
</li>
</ol>
<h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS/1591455525399.png" class title="类图">

</div>

<h2 id="锁的实现要点"><a href="#锁的实现要点" class="headerlink" title="锁的实现要点"></a>锁的实现要点</h2><h3 id="state（锁状态）"><a href="#state（锁状态）" class="headerlink" title="state（锁状态）"></a>state（锁状态）</h3><p>需要一个state变量，标记该锁的状态,state变量至少有两个值：0、1。对state变量的操作，要确保线程安全，也就是会用到CAS</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> * 锁状态</span></span><br><span class="line"><span class="comment"> * 当state=0时，没有线程持有锁，exclusiveOwnerThread=null；</span></span><br><span class="line"><span class="comment"> * 当state=1时，有一个线程持有锁，exclusiveOwnerThread=该线程；</span></span><br><span class="line"><span class="comment"> * 当state&gt;1时，说明该线程重入了该锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the value of synchronization state.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; write.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newState the new state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment"> * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment"> * and write.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment"> *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="需要记录当前是哪个线程持有锁。"><a href="#需要记录当前是哪个线程持有锁。" class="headerlink" title="需要记录当前是哪个线程持有锁。"></a>需要记录当前是哪个线程持有锁。</h3>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The current owner of exclusive mode synchronization.</span></span><br><span class="line"><span class="comment"> * 记录锁被哪个线程持有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="headerlink" title="阻塞与唤醒"></a>阻塞与唤醒</h3><p>需要底层支持对一个线程进行阻塞或唤醒操作,基于LockSupport中的park和Uunpark，实际调用的是Unsafe中的相关方法</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ol>
<li>FIFO的CLH队列，即CLH队列，提供先来先服务的公平性</li>
<li>AQS的同步机制就是依靠CLH队列实现的</li>
<li>队列中维护所有阻塞的线程，该队列<strong>必须线程安全的无锁队列</strong></li>
<li>CLH队列是<strong>FIFO的双端双向链表队列</strong>(方便尾部节点插入)。线程通过AQS获取锁失败，就会将线程封装成一个Node节点，通过<strong>CAS原子操作插入队列尾</strong>。当有线程释放锁时，会尝试让队头的next节点占用锁，AQS具有如下几个特点：<ul>
<li>在AQS 同步队列中 -1 表示线程在睡眠状态</li>
<li>当前Node节点线程会把前一个Node.ws = -1</li>
<li>持有锁的线程永远不在队列中</li>
<li>在AQS队列中第二个才是最先排队的线程</li>
<li>如果是交替型任务或者单线程任务，即使用了Lock也不会涉及到AQS 队列</li>
<li>不到万不得已不要轻易park线程，很耗时的！所以排队的头线程会自旋的尝试几个获取锁</li>
</ul>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment"> * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment"> * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment"> * CANCELLED.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment"> * method enq to add new wait node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS/1591456659535.png" class title="链表结构">

</div>

<h2 id="独占式获取"><a href="#独占式获取" class="headerlink" title="独占式获取"></a>独占式获取</h2><h3 id="accquire（非中断）"><a href="#accquire（非中断）" class="headerlink" title="accquire（非中断）"></a>accquire（非中断）</h3><ol>
<li>不可中断获取锁</li>
<li>独占式获取锁</li>
<li>成功则直接返回，否则加入等待队列（<strong>不响应中断</strong>）</li>
<li>获取资源后进行自我中断<code>selfInterrupt()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 加入阻塞队列，并且阻塞该线程（自旋获取锁）</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment"> * 当前线程发起中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tryAcquire-arg"><a href="#tryAcquire-arg" class="headerlink" title="tryAcquire(arg)"></a>tryAcquire(arg)</h4><p>尝试获取锁，<strong>需要子类实现</strong>，一般要求是：</p>
<ul>
<li>如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。</li>
<li>如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。</li>
<li>如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="addWaiter-Node-EXCLUSIVE"><a href="#addWaiter-Node-EXCLUSIVE" class="headerlink" title="addWaiter(Node.EXCLUSIVE)"></a>addWaiter(Node.EXCLUSIVE)</h4><p>一旦尝试获取锁未成功，就要使用该方法将其加入同步队列尾部，由于可能有多个线程并发加入队尾产生竞争，因此采用compareAndSetTail锁方法来保证同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> * 把当前线程封装成Node，然后把Node放入双向链表的尾部。</span></span><br><span class="line"><span class="comment"> * 注意：只是把当前线程放入队列，线程本身并未阻塞</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用当前线程构造一个Node对象，mode是一个表示Node类型的字段，或者说是这个节点是独占的还是共享的</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 将目前队列中尾部节点给pred</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 队列不为空的时候</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 尝试加入队尾，失败之后执行enq(node)</span></span><br><span class="line">        <span class="comment">// 先尝试通过AQS方式修改尾节点为最新的节点，如果修改失败，意味着有并发，</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一次尝试添加尾部失败说明有并发，此时进入自旋</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * 这里进行了循环，如果此时存在了tail就执行同上一步骤的添加队尾操作，如果依然不存在，</span></span><br><span class="line"><span class="comment"> * 就把当前线程作为head结点。插入节点后，调用acquireQueued()进行阻塞</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 内部进行队列的初始化，初始化为空的Node</span></span><br><span class="line"><span class="comment">     * 2. 采用自旋的方式尝试加入队尾，直到成功为止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="acquireQueued-addWaiter-Node-EXCLUSIVE-arg"><a href="#acquireQueued-addWaiter-Node-EXCLUSIVE-arg" class="headerlink" title="acquireQueued(addWaiter(Node.EXCLUSIVE), arg)"></a>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</h4><p>一旦加入同步队列，就需要使用该方法，自旋阻塞 唤醒来不断的尝试获取锁，直到被中断或获取到锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 虽然该函数不会中断响应，但它会记录被阻塞期间有没有其他线程向它发送过中断信号。</span></span><br><span class="line"><span class="comment"> * 如果有，则该函数会返回true；否则，返回false。</span></span><br><span class="line"><span class="comment"> * 当返回true则会执行selfInterrupt（自己给自己发起中断信号）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋检查当前节点的前驱节点是否为头结点，才能获取锁</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的上一个节点：Node.prev（前驱节点）</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 处理头结点，如果是头结点则直接返回false，不响应中断(获取锁)</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 节点中的线程循环的检查，自己的前驱节点是否为头节点</span></span><br><span class="line">                <span class="comment">// 只有当前节点 前驱节点是头节点才会 再次调用我们实现的方法tryAcquire</span></span><br><span class="line">                <span class="comment">// 接下来无非就是将当前节点设置为头结点，移除之前的头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则检查前一个节点的状态，看当前获取锁失败的线程是否要挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果需要挂起，借助JUC包下面的LockSupport类的静态方法park挂起当前线程，直到被唤醒</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 两个判断都是true说明 则置true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">//取消请求，将当前节点从队列中移除</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 阻塞当前线程，直到被其他线程唤醒</span></span><br><span class="line">    <span class="comment">// 1.其他线程调用了LockSupport.unpark(Thread t)</span></span><br><span class="line">    <span class="comment">// 2.其他线程调用了t.interrupt（）</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 被唤醒之后，通过Thread.interrupted（）来判断是否被中断唤醒。</span></span><br><span class="line">    <span class="comment">// 如果是情况1，会返回false；如果是情况2，则返回true</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acquireInterruptibly（中断式）"><a href="#acquireInterruptibly（中断式）" class="headerlink" title="acquireInterruptibly（中断式）"></a>acquireInterruptibly（中断式）</h3><ol>
<li>如果线程中断则直接抛出<code>InterruptedException</code>异常，如果未中断则尝试获取锁</li>
<li>调用<code>tryAcquire()</code>获取锁，同accquire（非中断）章节的说明</li>
<li>如果锁空闲则获锁并立即返回，state = 1</li>
<li>如果当前线程已持此锁，state + 1，并且该方法立即返回（可重入）</li>
<li>如果锁被另一个线程保持，出于线程调度目的，禁用当前线程，线程休眠，除非锁由当前线程获得或者当前线程被中断了，中断后会抛出InterruptedException，并且清除当前线程的已中断状态</li>
<li>此方法是一个显式中断点，所以要优先考虑响应中断。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tryAcquireNanos（超时中断）"><a href="#tryAcquireNanos（超时中断）" class="headerlink" title="tryAcquireNanos（超时中断）"></a>tryAcquireNanos（超时中断）</h3><ol>
<li>支持中断，当前线程在超时时间内被中断，抛中断异常后，线程退出</li>
<li>支持超时失败，在指定时间内，线程获取到锁则返回true</li>
<li>到截止时间后线程仍未获取到锁，此时线程获得锁失败，不再等待直接返回false。</li>
<li>原理：<ul>
<li>剩余时间小于0那么acquire失败</li>
<li>该时间大于一次自旋锁时间(spinForTimeoutThreshold = 1000)，并且可以被阻塞，那么调用LockSupport.parkNanos方法阻塞线程。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to acquire in exclusive mode, aborting if interrupted,</span></span><br><span class="line"><span class="comment"> * and failing if the given timeout elapses.  Implemented by first</span></span><br><span class="line"><span class="comment"> * checking interrupt status, then invoking at least once &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125;, returning on success.  Otherwise, the thread is</span></span><br><span class="line"><span class="comment"> * queued, possibly repeatedly blocking and unblocking, invoking</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #tryAcquire&#125; until success or the thread is interrupted</span></span><br><span class="line"><span class="comment"> * or the timeout elapses.  This method can be used to implement</span></span><br><span class="line"><span class="comment"> * method &#123;<span class="doctag">@link</span> Lock#tryLock(long, TimeUnit)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanosTimeout the maximum number of nanoseconds to wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired; &#123;<span class="doctag">@code</span> false&#125; if timed out</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive timed mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享式获取"><a href="#共享式获取" class="headerlink" title="共享式获取"></a>共享式获取</h2><h3 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment"> * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment"> *        and can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tryAcquireShared-arg"><a href="#tryAcquireShared-arg" class="headerlink" title="tryAcquireShared(arg)"></a>tryAcquireShared(arg)</h4><p><strong>模板方法</strong>，尝试获得资源，返回值代表如下含义：<strong>负数表示失败。0 表示成功，但没有剩余可用资源。正数表示成功，且有剩余资源</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to acquire in shared mode. This method should query if</span></span><br><span class="line"><span class="comment"> * the state of the object permits it to be acquired in the shared</span></span><br><span class="line"><span class="comment"> * mode, and if so to acquire it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is always invoked by the thread performing</span></span><br><span class="line"><span class="comment"> * acquire.  If this method reports failure, the acquire method</span></span><br><span class="line"><span class="comment"> * may queue the thread, if it is not already queued, until it is</span></span><br><span class="line"><span class="comment"> * signalled by a release from some other thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation throws &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument. This value is always the one</span></span><br><span class="line"><span class="comment"> *        passed to an acquire method, or is the value saved on entry</span></span><br><span class="line"><span class="comment"> *        to a condition wait.  The value is otherwise uninterpreted</span></span><br><span class="line"><span class="comment"> *        and can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a negative value on failure; zero if acquisition in shared</span></span><br><span class="line"><span class="comment"> *         mode succeeded but no subsequent shared-mode acquire can</span></span><br><span class="line"><span class="comment"> *         succeed; and a positive value if acquisition in shared</span></span><br><span class="line"><span class="comment"> *         mode succeeded and subsequent shared-mode acquires might</span></span><br><span class="line"><span class="comment"> *         also succeed, in which case a subsequent waiting thread</span></span><br><span class="line"><span class="comment"> *         must check availability. (Support for three different</span></span><br><span class="line"><span class="comment"> *         return values enables this method to be used in contexts</span></span><br><span class="line"><span class="comment"> *         where acquires only sometimes act exclusively.)  Upon</span></span><br><span class="line"><span class="comment"> *         success, this object has been acquired.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if acquiring would place this</span></span><br><span class="line"><span class="comment"> *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment"> *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment"> *         correctly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException if shared mode is not supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h4><p>创建节点然后加入到队列中去，这一块和独占模式下的 <strong>addWaiter</strong> 代码差不多，不同的是结点的模式是SHARED，在独占模式 EXCLUSIVE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acquireSharedInterruptibly（共享中断）"><a href="#acquireSharedInterruptibly（共享中断）" class="headerlink" title="acquireSharedInterruptibly（共享中断）"></a>acquireSharedInterruptibly（共享中断）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared mode, aborting if interrupted.  Implemented</span></span><br><span class="line"><span class="comment"> * by first checking interrupt status, then invoking at least once</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;, returning on success.  Otherwise the</span></span><br><span class="line"><span class="comment"> * thread is queued, possibly repeatedly blocking and unblocking,</span></span><br><span class="line"><span class="comment"> * invoking &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; until success or the thread</span></span><br><span class="line"><span class="comment"> * is interrupted.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.</span></span><br><span class="line"><span class="comment"> * This value is conveyed to &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is</span></span><br><span class="line"><span class="comment"> * otherwise uninterpreted and can represent anything</span></span><br><span class="line"><span class="comment"> * you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// tryAcquireShared由具体的子类实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tryAcquireSharedNanos（超时中断）"><a href="#tryAcquireSharedNanos（超时中断）" class="headerlink" title="tryAcquireSharedNanos（超时中断）"></a>tryAcquireSharedNanos（超时中断）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to acquire in shared mode, aborting if interrupted, and</span></span><br><span class="line"><span class="comment"> * failing if the given timeout elapses.  Implemented by first</span></span><br><span class="line"><span class="comment"> * checking interrupt status, then invoking at least once &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquireShared&#125;, returning on success.  Otherwise, the</span></span><br><span class="line"><span class="comment"> * thread is queued, possibly repeatedly blocking and unblocking,</span></span><br><span class="line"><span class="comment"> * invoking &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; until success or the thread</span></span><br><span class="line"><span class="comment"> * is interrupted or the timeout elapses.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment"> *        and can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanosTimeout the maximum number of nanoseconds to wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired; &#123;<span class="doctag">@code</span> false&#125; if timed out</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared timed mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="独占式释放"><a href="#独占式释放" class="headerlink" title="独占式释放"></a>独占式释放</h2><ol>
<li>调用<code>unlock</code>方法，实际调用<code>AQS的release</code>方法</li>
<li>如果同步状态释放成功（tryRelease返回true）则会执行if块中的代码，当head指向的头结点不为null，并且该节点的状态值不为0的话才会执行unparkSuccessor()方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒队列中的后继者</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tryRelease（模板方法）"><a href="#tryRelease（模板方法）" class="headerlink" title="tryRelease（模板方法）"></a>tryRelease（模板方法）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to set the state to reflect a release in exclusive</span></span><br><span class="line"><span class="comment"> * mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is always invoked by the thread performing release.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation throws</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument. This value is always the one</span></span><br><span class="line"><span class="comment"> *        passed to a release method, or the current state value upon</span></span><br><span class="line"><span class="comment"> *        entry to a condition wait.  The value is otherwise</span></span><br><span class="line"><span class="comment"> *        uninterpreted and can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this object is now in a fully released</span></span><br><span class="line"><span class="comment"> *         state, so that any waiting threads may attempt to acquire;</span></span><br><span class="line"><span class="comment"> *         and &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if releasing would place this</span></span><br><span class="line"><span class="comment"> *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment"> *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment"> *         correctly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException if exclusive mode is not supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享式释放"><a href="#共享式释放" class="headerlink" title="共享式释放"></a>共享式释放</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment"> * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment"> *        and can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">// 由具体子类实现</span></span><br><span class="line">        doReleaseShared();<span class="comment">//一次性唤醒队列中所有阻塞的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tryReleaseShared（模板方法）"><a href="#tryReleaseShared（模板方法）" class="headerlink" title="tryReleaseShared（模板方法）"></a>tryReleaseShared（模板方法）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to set the state to reflect a release in shared mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is always invoked by the thread performing release.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation throws</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument. This value is always the one</span></span><br><span class="line"><span class="comment"> *        passed to a release method, or the current state value upon</span></span><br><span class="line"><span class="comment"> *        entry to a condition wait.  The value is otherwise</span></span><br><span class="line"><span class="comment"> *        uninterpreted and can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this release of shared mode may permit a</span></span><br><span class="line"><span class="comment"> *         waiting acquire (shared or exclusive) to succeed; and</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if releasing would place this</span></span><br><span class="line"><span class="comment"> *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment"> *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment"> *         correctly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException if shared mode is not supported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment"> * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment"> * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h2><blockquote>
<p>是一个自旋锁，能确保无饥饿性，提供先来先服务的公平性。<br>CLH 锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p>
</blockquote>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS/1591456622328.png" class title="Node类图">

</div>

<h3 id="Node源码"><a href="#Node源码" class="headerlink" title="Node源码"></a>Node源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 共享锁标识 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** 独占锁标识 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">     *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">     *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">     *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">     *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">     *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">     *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">     *               on failure, block.</span></span><br><span class="line"><span class="comment">     *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">     *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">     *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">     *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">     *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">     *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">     *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">     *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">     *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">     *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">     *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">     *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">     *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">     *               since intervened.</span></span><br><span class="line"><span class="comment">     *   0:          None of the above</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">     * Non-negative values mean that a node doesn&#x27;t need to</span></span><br><span class="line"><span class="comment">     * signal. So, most code doesn&#x27;t need to check for particular</span></span><br><span class="line"><span class="comment">     * values, just for sign.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">     * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">     * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前置节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 后置节点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">     * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">     * 获取锁失败的线程保存在Node节点中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">     * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">     * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">     * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">     * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">     * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">     * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">     * mode.</span></span><br><span class="line"><span class="comment">     * 当我们调用了Condition后他也有一个等待队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">     * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">     * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="waitStatus说明"><a href="#waitStatus说明" class="headerlink" title="waitStatus说明"></a>waitStatus说明</h3><ol>
<li>CANCELLED = 1：当前节点已被取消调度。触发条件：超时或被中断（响应中断的情况下）；进入该状态后的结点将不会再变化。</li>
<li>SIGNAL = -1：后续节点等待当前节点唤醒；后继结点入队时，会将前继结点的状态更新为 SIGNAL。</li>
<li>CONDITION = -2：结点等待在 Condition 上，当其他线程调用了 Condition 的 signal() 方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li>
<li>PROPAGATE = -3：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li>INITIAL = 0：新结点入队时的默认状态。</li>
</ol>
<h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS/1591456931424.png" class title="公平锁与非公平锁的实现类图">

</div>

<p>ReentrantLock中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 直接尝试获取锁，不考虑队列中是否存在其他线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sync默认实现非公平锁"><a href="#Sync默认实现非公平锁" class="headerlink" title="Sync默认实现非公平锁"></a>Sync默认实现非公平锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">// 无锁情况下，进行抢锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 获取到锁，星期设置当前线程获取该锁</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重入，只需要更新state</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FairSync-tryAcquire"><a href="#FairSync-tryAcquire" class="headerlink" title="FairSync.tryAcquire"></a>FairSync.tryAcquire</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有当c==0（没有线程持有锁），并且排在队列的第1个时（即当队列中没有其他线程的时候），</span></span><br><span class="line">            <span class="comment">// 才去抢锁，否则继续排队</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原理分析（ReentrantLock）"><a href="#原理分析（ReentrantLock）" class="headerlink" title="原理分析（ReentrantLock）"></a>原理分析（ReentrantLock）</h2><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS/ReentrantLock%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE.png" class title="ReentrantLock锁的获取和释放">

</div>

<h3 id="独占式加入同步队列"><a href="#独占式加入同步队列" class="headerlink" title="独占式加入同步队列"></a>独占式加入同步队列</h3><ol>
<li><p><a href="#tryAcquire-arg">tryAcquire</a>：在ReentrantLock中分为公平实现和非公平实现（区别是否调用方法<code>hasQueuedPredecessors</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment"> * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有当c==0（没有线程持有锁），并且排在队列的第1个时（即当队列中没有其他线程的时候），</span></span><br><span class="line">        <span class="comment">// 才去抢锁，否则继续排队</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a href="#addWaiter-Node-EXCLUSIVE">addWaiter(Node.EXCLUSIVE,arg)</a>：如果尝试获取同步状态失败的话,则构造同步节点（独占式的Node.EXCLUSIVE），通过addWaiter(Node node,int args)方法将该节点加入到同步队列的队尾</p>
</li>
<li><p><a href="#enq">enq</a>：自旋enq 方法将并发添加节点的请求通过CAS跟自旋将尾节点的添加变得串行化起来。说白了就是让节点放到正确的队尾位置。</p>
</li>
<li><p><a href="#acquireQueued-addWaiter-Node-EXCLUSIVE-arg">acquireQueued</a>： 是当前Node节点线程在死循环中获取同步状态，而只有前驱节点是头节点才能尝试获取锁，原因是：头结点是成功获取同步状态（锁）的节点，而头节点的线程释放了同步状态以后，将会唤醒其后继节点，后继节点的线程被唤醒后要检查自己的前驱节点是否为头结点。维护同步队列的FIFO原则，节点进入同步队列之后，会尝试自旋几次。</p>
</li>
<li><p>shouldParkAfterFailedAcquire</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment"> * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment"> * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 2. 返回true，并且执行parkAndCheckInterrupt</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 3. 当pred所维护的获取请求被取消时（也就是node.waitStatus = CANCELLED，</span></span><br><span class="line">        <span class="comment">// 这时就会循环移除所有被取消的前继节点pred，直到找到未被取消的pred。</span></span><br><span class="line">        <span class="comment">// 移除所有被取消的前继节点后，直接返回false</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1. addWaiter方法调用时执行该方法（初次设置），设置为SIGNAL，并且返回false，继续执行acquireQueued</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a href="#acquireQueued-addWaiter-Node-EXCLUSIVE-arg">parkAndCheckInterrupt</a> 主要任务是暂停当前线程然后查看是否已经暂停了</p>
</li>
<li><p>cancelAcquireacquireQueued方法的finally会判断 failed值，正常运行时候自旋出来的时候会是false，如果中断或者timeout了 则会是true，执行cancelAcquire，其中核心代码是node.waitStatus = Node.CANCELLED</p>
</li>
<li><p><a href="#accquire%EF%BC%88%E9%9D%9E%E4%B8%AD%E6%96%AD%EF%BC%89">selfInterrupt</a></p>
</li>
</ol>
<h3 id="独占式释放队列头节点"><a href="#独占式释放队列头节点" class="headerlink" title="独占式释放队列头节点"></a>独占式释放队列头节点</h3><p>release()会调用tryRelease方法尝试释放当前线程持有的锁，成功的话唤醒后继线程，并返回true，否则直接返回false。</p>
<ol>
<li>tryRelease 这个是子类需要自我实现的，没啥说的根据业务需要实现。</li>
<li>unparkSuccessor 唤醒头结点的后继节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获得头节点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果头节点装小于0 则将其置为0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 这个是新的头节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果新头节点不满足要求</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="comment">// 从队列尾部开始往前去找最前面的一个waitStatus小于0的节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒后继节点对应的线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS队列处理过程"><a href="#AQS队列处理过程" class="headerlink" title="AQS队列处理过程"></a>AQS队列处理过程</h3><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS/CLH%E5%85%AC%E5%B9%B3%E9%94%81%E7%8A%B6%E6%80%81%E4%B8%8B%E5%A2%9E%E5%8A%A0%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="CLH公平锁状态下增加删除节点示意图">

</div>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.toutiao.com/i6909690004134527492">由浅入深逐步讲解Java并发的半壁江山—AQS（上文）</a></li>
<li><a href="https://www.toutiao.com/i6909690786577924611">由浅入深逐步讲解Java并发的半壁江山—AQS（下文）</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>AbstractQueuedSynchronizer</tag>
        <tag>AQS</tag>
        <tag>模板模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之ReentrantLock</title>
    <url>/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BReentrantLock/</url>
    <content><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>继承接口Lock，一种可重入锁</li>
<li>完成synchronized所能的工作</li>
<li>提供诸如可<strong>响应中断锁、可轮询锁请求、定时锁</strong>等避免多线程死锁的方法</li>
<li><strong>等待可中断（可设置超时时间）</strong>：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li><strong>公平锁</strong>：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。</li>
<li><strong>锁绑定多个条件</strong>：一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。<a id="more"></a>

</li>
</ol>
<h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BReentrantLock/ReentrantLock-Class.png" class title="ReentrantLock类图">

</div>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Acquires the lock.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the lock is not available then the current thread becomes</span></span><br><span class="line"><span class="comment">* disabled for thread scheduling purposes and lies dormant until the</span></span><br><span class="line"><span class="comment">* lock has been acquired.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;A &#123;<span class="doctag">@code</span> Lock&#125; implementation may be able to detect erroneous use</span></span><br><span class="line"><span class="comment">* of the lock, such as an invocation that would cause deadlock, and</span></span><br><span class="line"><span class="comment">* may throw an (unchecked) exception in such circumstances.  The</span></span><br><span class="line"><span class="comment">* circumstances and the exception type must be documented by that</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> Lock&#125; implementation.</span></span><br><span class="line"><span class="comment">* - 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, </span></span><br><span class="line"><span class="comment">* - 将禁用当前线程, 直到当前线程获取到锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Acquires the lock only if it is free at the time of invocation.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Acquires the lock if it is available and returns immediately</span></span><br><span class="line"><span class="comment">* with the value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">* If the lock is not available then this method will return</span></span><br><span class="line"><span class="comment">* immediately with the value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;A typical usage idiom for this method would be:</span></span><br><span class="line"><span class="comment">*  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">* Lock lock = ...;</span></span><br><span class="line"><span class="comment">* if (lock.tryLock()) &#123;</span></span><br><span class="line"><span class="comment">*   try &#123;</span></span><br><span class="line"><span class="comment">*     // manipulate protected state</span></span><br><span class="line"><span class="comment">*   &#125; finally &#123;</span></span><br><span class="line"><span class="comment">*     lock.unlock();</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">* &#125; else &#123;</span></span><br><span class="line"><span class="comment">*   // perform alternative actions</span></span><br><span class="line"><span class="comment">* &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This usage ensures that the lock is unlocked if it was acquired, and</span></span><br><span class="line"><span class="comment">* doesn&#x27;t try to unlock if the lock was not acquired.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the lock was acquired and</span></span><br><span class="line"><span class="comment">*         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">* - 如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. </span></span><br><span class="line"><span class="comment">* - 与lock()的区别在于, tryLock()只是&quot;试图&quot;获取锁, 如果锁不可用, 不会导致当前线程被禁用, </span></span><br><span class="line"><span class="comment">* - 当前线程仍然继续往下执行代码. </span></span><br><span class="line"><span class="comment">* - 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Releases the lock.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;A &#123;<span class="doctag">@code</span> Lock&#125; implementation will usually impose</span></span><br><span class="line"><span class="comment">* restrictions on which thread can release a lock (typically only the</span></span><br><span class="line"><span class="comment">* holder of the lock can release it) and may throw</span></span><br><span class="line"><span class="comment">* an (unchecked) exception if the restriction is violated.</span></span><br><span class="line"><span class="comment">* Any restrictions and the exception</span></span><br><span class="line"><span class="comment">* type must be documented by that &#123;<span class="doctag">@code</span> Lock&#125; implementation.</span></span><br><span class="line"><span class="comment">* - 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a new &#123;<span class="doctag">@link</span> Condition&#125; instance that is bound to this</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> Lock&#125; instance.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Before waiting on the condition the lock must be held by the</span></span><br><span class="line"><span class="comment">* current thread.</span></span><br><span class="line"><span class="comment">* A call to &#123;<span class="doctag">@link</span> Condition#await()&#125; will atomically release the lock</span></span><br><span class="line"><span class="comment">* before waiting and re-acquire the lock before the wait returns.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;The exact operation of the &#123;<span class="doctag">@link</span> Condition&#125; instance depends on</span></span><br><span class="line"><span class="comment">* the &#123;<span class="doctag">@code</span> Lock&#125; implementation and must be documented by that</span></span><br><span class="line"><span class="comment">* implementation.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> A new &#123;<span class="doctag">@link</span> Condition&#125; instance for this &#123;<span class="doctag">@code</span> Lock&#125; instance</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> UnsupportedOperationException if this &#123;<span class="doctag">@code</span> Lock&#125;</span></span><br><span class="line"><span class="comment">*         implementation does not support conditions</span></span><br><span class="line"><span class="comment">* - 条件对象，获取等待通知组件。该组件和当前的锁绑定，</span></span><br><span class="line"><span class="comment">* - 当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将释放锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Queries the number of holds on this lock by the current thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;A thread has a hold on a lock for each lock action that is not</span></span><br><span class="line"><span class="comment">* matched by an unlock action.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;The hold count information is typically only used for testing and</span></span><br><span class="line"><span class="comment">* debugging purposes. For example, if a certain section of code should</span></span><br><span class="line"><span class="comment">* not be entered with the lock already held then we can assert that</span></span><br><span class="line"><span class="comment">* fact:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">* class X &#123;</span></span><br><span class="line"><span class="comment">*   ReentrantLock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">*   // ...</span></span><br><span class="line"><span class="comment">*   public void m() &#123;</span></span><br><span class="line"><span class="comment">*     assert lock.getHoldCount() == 0;</span></span><br><span class="line"><span class="comment">*     lock.lock();</span></span><br><span class="line"><span class="comment">*     try &#123;</span></span><br><span class="line"><span class="comment">*       // ... method body</span></span><br><span class="line"><span class="comment">*     &#125; finally &#123;</span></span><br><span class="line"><span class="comment">*       lock.unlock();</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">* &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the number of holds on this lock by the current thread,</span></span><br><span class="line"><span class="comment">*         or zero if this lock is not held by the current thread</span></span><br><span class="line"><span class="comment">* - 查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.getHoldCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns an estimate of the number of threads waiting to</span></span><br><span class="line"><span class="comment">* acquire this lock.  The value is only an estimate because the number of</span></span><br><span class="line"><span class="comment">* threads may change dynamically while this method traverses</span></span><br><span class="line"><span class="comment">* internal data structures.  This method is designed for use in</span></span><br><span class="line"><span class="comment">* monitoring of the system state, not for synchronization</span></span><br><span class="line"><span class="comment">* control.</span></span><br><span class="line"><span class="comment">* -- 返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the estimated number of threads waiting for this lock</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.getQueueLength();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns an estimate of the number of threads waiting on the</span></span><br><span class="line"><span class="comment">* given condition associated with this lock. Note that because</span></span><br><span class="line"><span class="comment">* timeouts and interrupts may occur at any time, the estimate</span></span><br><span class="line"><span class="comment">* serves only as an upper bound on the actual number of waiters.</span></span><br><span class="line"><span class="comment">* This method is designed for use in monitoring of the system</span></span><br><span class="line"><span class="comment">* state, not for synchronization control.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> condition the condition</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the estimated number of waiting threads</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalMonitorStateException if this lock is not held</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if the given condition is</span></span><br><span class="line"><span class="comment">*         not associated with this lock</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if the condition is null</span></span><br><span class="line"><span class="comment">* -- 返回等待与此锁相关的给定条件的线程估计数。</span></span><br><span class="line"><span class="comment">* -- 比如 10 个线程，用同一个 condition 对象，</span></span><br><span class="line"><span class="comment">* -- 并且此时这 10 个线程都执行了 condition 对象的 await 方法，那么此时执行此方法返回 10 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;not owner&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Queries whether any threads are waiting on the given condition</span></span><br><span class="line"><span class="comment">* associated with this lock. Note that because timeouts and</span></span><br><span class="line"><span class="comment">* interrupts may occur at any time, a &#123;<span class="doctag">@code</span> true&#125; return does</span></span><br><span class="line"><span class="comment">* not guarantee that a future &#123;<span class="doctag">@code</span> signal&#125; will awaken any</span></span><br><span class="line"><span class="comment">* threads.  This method is designed primarily for use in</span></span><br><span class="line"><span class="comment">* monitoring of the system state.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> condition the condition</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there are any waiting threads</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalMonitorStateException if this lock is not held</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if the given condition is</span></span><br><span class="line"><span class="comment">*         not associated with this lock</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if the condition is null</span></span><br><span class="line"><span class="comment">* -- 查询是否有线程等待与此锁有关的给定条件</span></span><br><span class="line"><span class="comment">* -- (condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!(condition <span class="keyword">instanceof</span> AbstractQueuedSynchronizer.ConditionObject))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;not owner&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Queries whether the given thread is waiting to acquire this</span></span><br><span class="line"><span class="comment">* lock. Note that because cancellations may occur at any time, a</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> true&#125; return does not guarantee that this thread</span></span><br><span class="line"><span class="comment">* will ever acquire this lock.  This method is designed primarily for use</span></span><br><span class="line"><span class="comment">* in monitoring of the system state.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> thread the thread</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given thread is queued waiting for this lock</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if the thread is null</span></span><br><span class="line"><span class="comment">* -- 查询给定线程是否等待获取此锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.isQueued(thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Queries whether any threads are waiting to acquire this lock. Note that</span></span><br><span class="line"><span class="comment">* because cancellations may occur at any time, a &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">* return does not guarantee that any other thread will ever</span></span><br><span class="line"><span class="comment">* acquire this lock.  This method is designed primarily for use in</span></span><br><span class="line"><span class="comment">* monitoring of the system state.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there may be other threads waiting to</span></span><br><span class="line"><span class="comment">*         acquire the lock</span></span><br><span class="line"><span class="comment">* -- 是否有线程等待锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns &#123;<span class="doctag">@code</span> true&#125; if this lock has fairness set true.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this lock has fairness set true</span></span><br><span class="line"><span class="comment">* -- 该锁是否是公平锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync <span class="keyword">instanceof</span> FairSync;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Queries if this lock is held by the current thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Analogous to the &#123;<span class="doctag">@link</span> Thread#holdsLock(Object)&#125; method for</span></span><br><span class="line"><span class="comment">* built-in monitor locks, this method is typically used for</span></span><br><span class="line"><span class="comment">* debugging and testing. For example, a method that should only be</span></span><br><span class="line"><span class="comment">* called while a lock is held can assert that this is the case:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">* class X &#123;</span></span><br><span class="line"><span class="comment">*   ReentrantLock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">*   // ...</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   public void m() &#123;</span></span><br><span class="line"><span class="comment">*       assert lock.isHeldByCurrentThread();</span></span><br><span class="line"><span class="comment">*       // ... method body</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">* &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;It can also be used to ensure that a reentrant lock is used</span></span><br><span class="line"><span class="comment">* in a non-reentrant manner, for example:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">* class X &#123;</span></span><br><span class="line"><span class="comment">*   ReentrantLock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">*   // ...</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   public void m() &#123;</span></span><br><span class="line"><span class="comment">*       assert !lock.isHeldByCurrentThread();</span></span><br><span class="line"><span class="comment">*       lock.lock();</span></span><br><span class="line"><span class="comment">*       try &#123;</span></span><br><span class="line"><span class="comment">*           // ... method body</span></span><br><span class="line"><span class="comment">*       &#125; finally &#123;</span></span><br><span class="line"><span class="comment">*           lock.unlock();</span></span><br><span class="line"><span class="comment">*       &#125;</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">* &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if current thread holds this lock and</span></span><br><span class="line"><span class="comment">*         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">* -- 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Queries if this lock is held by any thread. This method is</span></span><br><span class="line"><span class="comment">* designed for use in monitoring of the system state,</span></span><br><span class="line"><span class="comment">* not for synchronization control.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if any thread holds this lock and</span></span><br><span class="line"><span class="comment">*         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">* --- 此锁是否有任意线程占用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.isLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Acquires the lock only if it is not held by another thread at the time</span></span><br><span class="line"><span class="comment">* of invocation.仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 </span></span><br><span class="line"><span class="comment">* 1）如果该锁没有被另一个线程保持，并且立即返回 true 值，则将锁的保持计数设置为 1。</span></span><br><span class="line"><span class="comment">* 即使已将此锁设置为使用公平排序策略，但是调用 tryLock() 仍将 立即获取锁（如果有可用的），</span></span><br><span class="line"><span class="comment">* 而不管其他线程当前是否正在等待该锁。在某些情况下，此“闯入”行为可能很有用，即使它会打破公</span></span><br><span class="line"><span class="comment">* 平性也如此。如果希望遵守此锁的公平设置，则使用 tryLock(0, TimeUnit.SECONDS) </span></span><br><span class="line"><span class="comment">* ，它几乎是等效的（也检测中断）</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Acquires the lock if it is not held by another thread and</span></span><br><span class="line"><span class="comment">* returns immediately with the value &#123;<span class="doctag">@code</span> true&#125;, setting the</span></span><br><span class="line"><span class="comment">* lock hold count to one. Even when this lock has been set to use a</span></span><br><span class="line"><span class="comment">* fair ordering policy, a call to &#123;<span class="doctag">@code</span> tryLock()&#125; &lt;em&gt;will&lt;/em&gt;</span></span><br><span class="line"><span class="comment">* immediately acquire the lock if it is available, whether or not</span></span><br><span class="line"><span class="comment">* other threads are currently waiting for the lock.</span></span><br><span class="line"><span class="comment">* This &amp;quot;barging&amp;quot; behavior can be useful in certain</span></span><br><span class="line"><span class="comment">* circumstances, even though it breaks fairness. If you want to honor</span></span><br><span class="line"><span class="comment">* the fairness setting for this lock, then use</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) &#125;</span></span><br><span class="line"><span class="comment">* which is almost equivalent (it also detects interruption).</span></span><br><span class="line"><span class="comment">* 2）如果当前线程已经保持此锁，则将保持计数加 1，该方法将返回 true。 </span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the current thread already holds this lock then the hold</span></span><br><span class="line"><span class="comment">* count is incremented by one and the method returns &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">* 3）如果锁被另一个线程保持，则此方法将立即返回 false 值。 </span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the lock is held by another thread then this method will return</span></span><br><span class="line"><span class="comment">* immediately with the value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">* return：如果锁是自由的并且被当前线程获取，或者当前线程已经保持该锁，则返回 true；否则返回 false</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the lock was free and was acquired by the</span></span><br><span class="line"><span class="comment">*         current thread, or the lock was already held by the current</span></span><br><span class="line"><span class="comment">*         thread; and &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Acquires the lock.</span></span><br><span class="line"><span class="comment">* 1.如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Acquires the lock if it is not held by another thread and returns</span></span><br><span class="line"><span class="comment">* immediately, setting the lock hold count to one.</span></span><br><span class="line"><span class="comment">* 2.如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回</span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the current thread already holds the lock then the hold</span></span><br><span class="line"><span class="comment">* count is incremented by one and the method returns immediately.</span></span><br><span class="line"><span class="comment">* 3.如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，</span></span><br><span class="line"><span class="comment">*            并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1</span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the lock is held by another thread then the</span></span><br><span class="line"><span class="comment">* current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">* purposes and lies dormant until the lock has been acquired,</span></span><br><span class="line"><span class="comment">* at which time the lock hold count is set to one.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1.如果当前线程未被中断，则获取锁。 </span></span><br><span class="line"><span class="comment">* Acquires the lock unless the current thread is</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 2.如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。 </span></span><br><span class="line"><span class="comment">* &lt;p&gt;Acquires the lock if it is not held by another thread and returns</span></span><br><span class="line"><span class="comment">* immediately, setting the lock hold count to one.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 3.如果当前线程已经保持此锁，则将保持计数加 1，并且该方法立即返回。 </span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the current thread already holds this lock then the hold count</span></span><br><span class="line"><span class="comment">* is incremented by one and the method returns immediately.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 4.如果锁被另一个线程保持，则出于线程调度目的，禁用当前线程，并且在发生以下两种情况之一以前，该线程将一直处于休眠状态： </span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the lock is held by another thread then the</span></span><br><span class="line"><span class="comment">* current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">* purposes and lies dormant until one of two things happens:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;ul&gt;</span></span><br><span class="line"><span class="comment">* 4.1锁由当前线程获得</span></span><br><span class="line"><span class="comment">* &lt;li&gt;The lock is acquired by the current thread; or</span></span><br><span class="line"><span class="comment">* 4.2其他某个线程中断当前线程</span></span><br><span class="line"><span class="comment">* &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125; the</span></span><br><span class="line"><span class="comment">* current thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">* 5.如果当前线程获得该锁，则将锁保持计数设置为 1,如果当前线程出现两种情况则抛出 InterruptedException，并且清除当前线程的已中断状态。</span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the lock is acquired by the current thread then the lock hold</span></span><br><span class="line"><span class="comment">* count is set to one.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the current thread:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;ul&gt;</span></span><br><span class="line"><span class="comment">* 5.1在进入此方法时已经设置了该线程的中断状态</span></span><br><span class="line"><span class="comment">* &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment">* 5.2在等待获取锁的同时被中断</span></span><br><span class="line"><span class="comment">* &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while acquiring</span></span><br><span class="line"><span class="comment">* the lock,</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span></span><br><span class="line"><span class="comment">* interrupted status is cleared.</span></span><br><span class="line"><span class="comment">* 6.在此实现中，因为此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应锁的普通获取或重入获取</span></span><br><span class="line"><span class="comment">* &lt;p&gt;In this implementation, as this method is an explicit</span></span><br><span class="line"><span class="comment">* interruption point, preference is given to responding to the</span></span><br><span class="line"><span class="comment">* interrupt over normal or reentrant acquisition of the lock.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment">* -- 如果当前线程未被中断，获取锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* lockInterruptibly()方法能够中断等待获取锁的线程。</span></span><br><span class="line"><span class="comment">* 当两个线程同时通过lock.lockInterruptibly()获取某个锁时，假若此时线程A获取到了锁，而线程B只有等待，</span></span><br><span class="line"><span class="comment">* 那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lock、trylock、lockInterruptibly对比"><a href="#lock、trylock、lockInterruptibly对比" class="headerlink" title="lock、trylock、lockInterruptibly对比"></a>lock、trylock、lockInterruptibly对比</h4><ol>
<li>lock(), 拿不到lock就不罢休，不然线程就一直block。 比较无赖的做法。</li>
<li>tryLock()，马上返回，拿到lock就返回true，不然返回false。 比较潇洒的做法。带时间限制的tryLock()，拿不到lock，就等一段时间，超时返回false。比较聪明的做法。</li>
<li>lockInterruptibly()：打扰机制，每个线程都有一个 打扰标志。这里分两种情况，<ul>
<li>线程在sleep或wait,join， 此时如果别的进程调用此进程的 interrupt（）方法，此线程会被唤醒并被要求处理InterruptedException；(thread在做IO操作时也可能有类似行为，见java thread api)此线程在运行中， 则不会收到提醒。但是 此线程的 “打扰标志”会被设置， 可以通过isInterrupted()查看并 作出处理。lockInterruptibly()和上面的第一种情况是一样的， 线程在请求lock并被阻塞时，如果被interrupt，则“此线程会被唤醒并被要求处理InterruptedException”。并且如果线程已经被interrupt，再使用lockInterruptibly的时候，此线程也会被要求处理interruptedException</li>
</ul>
</li>
<li>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程， lock 不会抛出异常，而 lockInterruptibly 会抛出异常。</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * 可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</span></span><br><span class="line"><span class="comment"> * 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/30 20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockReentryTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test1----&quot;</span>);</span><br><span class="line">            test2();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test2----&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockReentryTest.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果。。。。</span></span><br><span class="line"><span class="comment">//test1----</span></span><br><span class="line"><span class="comment">//test2----</span></span><br></pre></td></tr></table></figure>
<h3 id="可中断（lockInterruptibly、lock）"><a href="#可中断（lockInterruptibly、lock）" class="headerlink" title="可中断（lockInterruptibly、lock）"></a>可中断（lockInterruptibly、lock）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 可中断测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/30 20:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockInterruptedTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInterruptedEnable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testInterruptedEnable:子线程开始：。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;testInterruptedEnable:子线程等待锁的过程被中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;testInterruptedEnable:子线程获得了锁。。&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;可中断线程！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;testInterruptedEnable:主线程获得了锁。。&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;testInterruptedEnable:子线程thread开始中断。。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;testInterruptedEnable:主线程等待锁的过程被中断&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInterruptedUnable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testInterruptedEnable:子线程开始：。。。&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;testInterruptedEnable:子线程获得了锁。。&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;可中断线程！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;testInterruptedEnable:主线程获得了锁。。&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;testInterruptedEnable:子线程thread开始中断。。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;testInterruptedEnable:主线程等待锁的过程被中断&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ReentrantLockInterruptedTest.testInterruptedEnable();</span></span><br><span class="line">        ReentrantLockInterruptedTest.testInterruptedUnable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可中断结果"><a href="#可中断结果" class="headerlink" title="可中断结果"></a>可中断结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">testInterruptedEnable:主线程获得了锁。。</span><br><span class="line">testInterruptedEnable:子线程开始：。。。</span><br><span class="line">testInterruptedEnable:子线程thread开始中断。。</span><br><span class="line">testInterruptedEnable:子线程等待锁的过程被中断</span><br><span class="line">testInterruptedEnable:子线程获得了锁。。</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">898</span>)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">	at com.sunld.thread.lock.ReentrantLockInterruptedTest.lambda$testInterruptedEnable$<span class="number">0</span>(ReentrantLockInterruptedTest.java:<span class="number">18</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">Exception in thread <span class="string">&quot;可中断线程！！&quot;</span> java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:<span class="number">151</span>)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:<span class="number">1261</span>)</span><br><span class="line">	at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:<span class="number">457</span>)</span><br><span class="line">	at com.sunld.thread.lock.ReentrantLockInterruptedTest.lambda$testInterruptedEnable$<span class="number">0</span>(ReentrantLockInterruptedTest.java:<span class="number">26</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="不可中断结果"><a href="#不可中断结果" class="headerlink" title="不可中断结果"></a>不可中断结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">testInterruptedEnable:主线程获得了锁。。</span><br><span class="line">testInterruptedEnable:子线程开始：。。。</span><br><span class="line">testInterruptedEnable:子线程thread开始中断。。</span><br><span class="line">testInterruptedEnable:子线程获得了锁。。</span><br></pre></td></tr></table></figure>
<h3 id="超时锁（tryLock）"><a href="#超时锁（tryLock）" class="headerlink" title="超时锁（tryLock）"></a>超时锁（tryLock）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 锁超时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/30 21:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTimeOutTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeOut0</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; thread start ...&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!lock.tryLock())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; thread get lock by 0s failed ...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; thread get lock success..&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot; thread release lock success..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;子线程！！！&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot; main thread get lock success..&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot; main thread interrupted..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot; main thread release lock success..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeOut1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; thread start ...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot; thread get lock by 1s failed ...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot; thread get lock interrupted ....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; thread get lock success..&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot; thread release lock success..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;子线程！！！&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot; main thread get lock success..&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot; main thread interrupted..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot; main thread release lock success..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockTimeOutTest.timeOut0();</span><br><span class="line"><span class="comment">//        ReentrantLockTimeOutTest.timeOut1();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="立即返回"><a href="#立即返回" class="headerlink" title="立即返回"></a>立即返回</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main thread get lock success..</span><br><span class="line">thread start ...</span><br><span class="line">thread get lock by 0s failed ...</span><br><span class="line">main thread release lock success..</span><br></pre></td></tr></table></figure>
<h4 id="超时返回"><a href="#超时返回" class="headerlink" title="超时返回"></a>超时返回</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main thread get lock success..</span><br><span class="line">thread start ...</span><br><span class="line">thread get lock by 1s failed ...</span><br><span class="line">main thread release lock success..</span><br></pre></td></tr></table></figure>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 公平锁测试</span></span><br><span class="line"><span class="comment"> * 公平锁一般没有必要，会降低并发度，后面分析原理时会讲解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/30 22:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockFairTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFair</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1s 之后去争抢锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start...&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;强行写入&quot;</span>).start();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//公平</span></span><br><span class="line">        ReentrantLockFairTest.testFair(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//非公平</span></span><br><span class="line">        ReentrantLockFairTest.testFair(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件变量-Condition"><a href="#条件变量-Condition" class="headerlink" title="条件变量(Condition)"></a>条件变量(Condition)</h3><p>Condition的详细使用，参考：<a href="book/java-condition.md">Condition</a>  </p>
<ol>
<li>synchronized 中也有条件变量，就是waitSet，当条件不满足时进入waitSet 等待</li>
<li>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li>
</ul>
</li>
<li>使用要点<ul>
<li>await 前需要获得锁</li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.thread.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : sunliaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : V1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/5/30 22:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//Lock lock=new ReentrantLock(true);//公平锁</span></span><br><span class="line">    <span class="comment">//Lock lock=new ReentrantLock(false);//非公平锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition condition = lock.newCondition();<span class="comment">//创建 Condition</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">//lock 加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1：wait 方法等待：</span></span><br><span class="line">            System.out.println(<span class="string">&quot;开始 wait&quot;</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            <span class="comment">//通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadName=&quot;</span> + Thread.currentThread().getName()+ (<span class="string">&quot; &quot;</span> + (i + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">//lock 加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1：开始唤醒：</span></span><br><span class="line">            System.out.println(<span class="string">&quot;开始 signal&quot;</span>);</span><br><span class="line">            <span class="comment">//2：signal 方法唤醒</span></span><br><span class="line">            <span class="comment">//condition 对象的 signal 方法可以唤醒 wait 线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;唤醒释放锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            ReentrantLockConditionTest.testWait();</span><br><span class="line">        &#125;, <span class="string">&quot;等待通知&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            ReentrantLockConditionTest.testNotify();</span><br><span class="line">        &#125;,<span class="string">&quot;启动通知&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> * 开始 wait</span></span><br><span class="line"><span class="comment"> * 开始 signal</span></span><br><span class="line"><span class="comment"> * 唤醒释放锁</span></span><br><span class="line"><span class="comment"> * ThreadName=等待通知 1</span></span><br><span class="line"><span class="comment"> * ThreadName=等待通知 2</span></span><br><span class="line"><span class="comment"> * ThreadName=等待通知 3</span></span><br><span class="line"><span class="comment"> * ThreadName=等待通知 4</span></span><br><span class="line"><span class="comment"> * ThreadName=等待通知 5</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="synchronized-和-ReentrantLock-的关系"><a href="#synchronized-和-ReentrantLock-的关系" class="headerlink" title="synchronized 和 ReentrantLock 的关系"></a>synchronized 和 ReentrantLock 的关系</h2><p>不要在Lock和Condition上使用wait、notiffy、notifyAll方法！</p>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BReentrantLock/1589108538300.png" class title="synchronized 和 ReentrantLock 的关系">

</div>


<h3 id="两者的共同点"><a href="#两者的共同点" class="headerlink" title="两者的共同点"></a>两者的共同点</h3><ol>
<li>   都是用来协调多线程对共享对象、变量的访问 </li>
<li>   都是可重入锁，同一线程可以多次获得同一个锁 </li>
<li>   都保证了可见性和互斥性 </li>
</ol>
<h3 id="两者的不同点"><a href="#两者的不同点" class="headerlink" title="两者的不同点"></a>两者的不同点</h3><ol>
<li>   ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁 </li>
<li>   ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 </li>
<li>   ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的 </li>
<li>   ReentrantLock 可以实现公平锁 </li>
<li>   ReentrantLock 通过 Condition 可以绑定多个条件 </li>
<li>   底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略 </li>
<li>   Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。 </li>
<li>   synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。 </li>
<li>   Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。 </li>
<li>   通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 </li>
<li>   Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。  </li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之ThreadPoolExecutor</title>
    <url>/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadPoolExecutor/</url>
    <content><![CDATA[<h2 id="构建函数"><a href="#构建函数" class="headerlink" title="构建函数"></a>构建函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> *        -- 当提交一个任务到线程池时，线程池会创建一个线程来执行任务，</span></span><br><span class="line"><span class="comment"> *        -- 即使其他空闲的基本线程能够执行新任务也会创建线程，</span></span><br><span class="line"><span class="comment"> *        -- 等到需要执行的任务数大于线程池基本大小时就不再创建。</span></span><br><span class="line"><span class="comment"> *        -- 调用prestartAllCoreThreads()后，线程池会提前创建并启动所有基本线程。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> *        -- 允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，</span></span><br><span class="line"><span class="comment"> *        -- 则线程池会再创建新的线程执行任务（无线队列会使该参数失效）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> *        -- 线程池的工作线程空闲后，保持存活的时间。</span></span><br><span class="line"><span class="comment"> *        -- 如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * 		  -- 天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、</span></span><br><span class="line"><span class="comment"> *        -- 微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> *        -- 用于保存等待执行的任务的阻塞队列</span></span><br><span class="line"><span class="comment"> *        -- ❑ ArrayBlockingQueue：基于数组结构的有界阻塞队列，排序规则：FIFO</span></span><br><span class="line"><span class="comment"> *        -- ❑ LinkedBlockingQueue：基于链表结构的阻塞队列，排序规则：FIFO，</span></span><br><span class="line"><span class="comment">                                    吞吐量通常要高于ArrayBlockingQueue。</span></span><br><span class="line"><span class="comment">                                    Executors.newFixedThreadPool()使用了这个队列。</span></span><br><span class="line"><span class="comment"> *        -- ❑ SynchronousQueue：一个不存储元素的阻塞队列（读写交换执行，否则会阻塞。）</span></span><br><span class="line"><span class="comment">                                  吞吐量通常要高于Linked-BlockingQueue，</span></span><br><span class="line"><span class="comment">                                  Executors.newCachedThreadPool使用了这个队列。</span></span><br><span class="line"><span class="comment"> *        -- ❑ PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> *        -- 设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</span></span><br><span class="line"><span class="comment"> *        -- 使用开源框架guava提供的ThreadFactoryBuilder</span></span><br><span class="line"><span class="comment">             可以快速给线程池里的线程设置有意义的名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> *        -- 当队列和线程池都满了（饱和状态），那么必须采取一种策略处理提交的新任务。</span></span><br><span class="line"><span class="comment"> *        -- 这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常</span></span><br><span class="line"><span class="comment"> *        -- ❑ AbortPolicy：直接抛出异常。</span></span><br><span class="line"><span class="comment"> *        -- ❑ CallerRunsPolicy：只用调用者所在线程来运行任务。</span></span><br><span class="line"><span class="comment"> *        -- ❑ DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</span></span><br><span class="line"><span class="comment"> *        -- ❑ DiscardPolicy：不处理，丢弃掉。</span></span><br><span class="line"><span class="comment"> *        -- 实现RejectedExecutionHandler接口自定义策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment"> *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol>
<li>corePoolSize（线程池的基本大小）<ul>
<li>当提交一个任务到线程池时，线程池会创建一个线程来执行任务</li>
<li>即使其他空闲的基本线程能够执行新任务也会创建线程</li>
<li>等到需要执行的任务数大于线程池基本大小时就不再创建</li>
<li>调用prestartAllCoreThreads()后，线程池会提前创建并启动所有基本线程</li>
</ul>
</li>
<li>maximumPoolSize（线程池最大数量）<ul>
<li>允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数</li>
<li>则线程池会再创建新的线程执行任务</li>
<li>无线队列会使该参数失效</li>
</ul>
</li>
<li>keepAliveTime（线程活动保持时间）<ul>
<li>线程池的工作线程空闲后，保持存活的时间</li>
<li>如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率</li>
</ul>
</li>
<li>unit（线程活动保持的时间单位）<ul>
<li>天（DAYS）</li>
<li>小时（HOURS）</li>
<li>分钟（MINUTES）</li>
<li>毫秒（MILLISECONDS）、</li>
<li>微秒（MICROSECONDS，千分之一毫秒）</li>
<li>纳秒（NANOSECONDS，千分之一微秒）</li>
</ul>
</li>
<li>workQueue（任务队列）：用于保存等待执行的任务的阻塞队列<ul>
<li>ArrayBlockingQueue：<ul>
<li>基于数组结构的有界阻塞队列，排序规则：FIFO</li>
</ul>
</li>
<li>LinkedBlockingQueue：<ul>
<li>基于链表结构的阻塞队列，排序规则：FIFO，</li>
<li>吞吐量通常要高于ArrayBlockingQueue。</li>
<li>Executors.newFixedThreadPool()使用了这个队列。</li>
</ul>
</li>
<li>SynchronousQueue：<ul>
<li>一个不存储元素的阻塞队列（读写交换执行，否则会阻塞。）</li>
<li>吞吐量通常要高于Linked-BlockingQueue，</li>
<li>Executors.newCachedThreadPool使用了这个队列。</li>
</ul>
</li>
<li>PriorityBlockingQueue：<ul>
<li>一个具有优先级的无限阻塞队列。</li>
</ul>
</li>
</ul>
</li>
<li>threadFactory（线程工厂）<ul>
<li>设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li>
<li>使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字</li>
</ul>
</li>
<li>handler（拒绝策略）<ul>
<li>当队列和线程池都满了（饱和状态）或关闭时，那么必须采取一种策略处理提交的新任务</li>
<li>这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常</li>
<li>具体策略包括：<ul>
<li>AbortPolicy：直接抛出异常</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</li>
<li>DiscardPolicy：不处理，丢弃掉</li>
<li>实现RejectedExecutionHandler接口自定义策略</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="排队的方式"><a href="#排队的方式" class="headerlink" title="排队的方式"></a>排队的方式</h4><ol>
<li>直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以<strong>避免在处理可能具有内部依赖性的请求集时出现锁</strong>。直接提交通常要求<strong>无界 maximumPoolSizes 以避免拒绝新提交的任务</strong>。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>
<li>无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>
<li>有界队列。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。  </li>
</ol>
<h2 id="任务封装"><a href="#任务封装" class="headerlink" title="任务封装"></a>任务封装</h2><p>线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()方法里看到这点。</p>
<h3 id="工作线程定义"><a href="#工作线程定义" class="headerlink" title="工作线程定义"></a>工作线程定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Class Worker mainly maintains interrupt control state for</span></span><br><span class="line"><span class="comment">* threads running tasks, along with other minor bookkeeping.</span></span><br><span class="line"><span class="comment">* This class opportunistically extends AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="comment">* to simplify acquiring and releasing a lock surrounding each</span></span><br><span class="line"><span class="comment">* task execution.  This protects against interrupts that are</span></span><br><span class="line"><span class="comment">* intended to wake up a worker thread waiting for a task from</span></span><br><span class="line"><span class="comment">* instead interrupting a task being run.  We implement a simple</span></span><br><span class="line"><span class="comment">* non-reentrant mutual exclusion lock rather than use</span></span><br><span class="line"><span class="comment">* ReentrantLock because we do not want worker tasks to be able to</span></span><br><span class="line"><span class="comment">* reacquire the lock when they invoke pool control methods like</span></span><br><span class="line"><span class="comment">* setCorePoolSize.  Additionally, to suppress interrupts until</span></span><br><span class="line"><span class="comment">* the thread actually starts running tasks, we initialize lock</span></span><br><span class="line"><span class="comment">* state to a negative value, and clear it upon start (in</span></span><br><span class="line"><span class="comment">* runWorker).</span></span><br><span class="line"><span class="comment">* -Worker继承了AQS抽象类，其重写了AQS的一些方法，</span></span><br><span class="line"><span class="comment">* -并且其也可作为一个Runnable对象，从而可以创建线程Thread</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">    * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="comment">// worker 所对应的线程，用来封装worker（因为worker为Runnable对象），表示一个线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    <span class="comment">// worker所对应的第一个任务</span></span><br><span class="line">    <span class="comment">// 表示该worker所包含的Runnable对象，即用户自定义的Runnable对象，</span></span><br><span class="line">    <span class="comment">// 完成用户自定义的逻辑的Runnable对象</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="comment">// 已完成任务数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">//并设置AQS的state为-1</span></span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="comment">// 初始化第一个任务</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 根据当前worker，初始化线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="comment">/** 重写Runnable中的run方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工作线程任务的真正执行"><a href="#工作线程任务的真正执行" class="headerlink" title="工作线程任务的真正执行"></a>工作线程任务的真正执行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* - 真正执行任务的方法</span></span><br><span class="line"><span class="comment">* 1.线程开始执行前，需要对worker加锁，完成一个任务后执行unlock()</span></span><br><span class="line"><span class="comment">* 2.在任务执行前后，执行beforeExecute()和afterExecute()方法</span></span><br><span class="line"><span class="comment">* 3.记录任务执行中的异常后，继续抛出</span></span><br><span class="line"><span class="comment">* 4.每个任务完成后，会记录当前线程完成的任务数</span></span><br><span class="line"><span class="comment">* 5.当worker执行完一个任务的时候，包括初始任务firstTask，</span></span><br><span class="line"><span class="comment">    会调用getTask()继续获取任务，这个方法调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环执行，直到阻塞队列为空</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 在执行之前调用钩子函数</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 运行给定的任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行完后调用钩子函数</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 处理完成后，调用钩子函数</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Performs cleanup and bookkeeping for a dying worker. Called</span></span><br><span class="line"><span class="comment">* only from worker threads. Unless completedAbruptly is set,</span></span><br><span class="line"><span class="comment">* assumes that workerCount has already been adjusted to account</span></span><br><span class="line"><span class="comment">* for exit.  This method removes thread from worker set, and</span></span><br><span class="line"><span class="comment">* possibly terminates the pool or replaces the worker if either</span></span><br><span class="line"><span class="comment">* it exited due to user task exception or if fewer than</span></span><br><span class="line"><span class="comment">* corePoolSize workers are running or queue is non-empty but</span></span><br><span class="line"><span class="comment">* there are no workers.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> completedAbruptly if the worker died due to user exception</span></span><br><span class="line"><span class="comment">* processWorkerExit函数是在worker退出时调用到的钩子函数，而引起worker退出的主要因素如下</span></span><br><span class="line"><span class="comment">* ① 阻塞队列已经为空，即没有任务可以运行了。</span></span><br><span class="line"><span class="comment">* ② 调用了shutDown或shutDownNow函数</span></span><br><span class="line"><span class="comment">* 此函数会根据是否中断了空闲线程来确定是否减少workerCount的值，</span></span><br><span class="line"><span class="comment">* 并且将worker从workers集合中移除并且会尝试终止线程池。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果被中断，则需要减少workCount</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将worker完成的任务添加到总的完成任务中</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从workers集合中移除该worker</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;<span class="comment">// 小于STOP的运行状态</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">// 允许核心超时并且workQueue阻塞队列不为空</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)<span class="comment">// workerCount大于等于min</span></span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加worker</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment">* current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment">* must exit because of any of:</span></span><br><span class="line"><span class="comment">* 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment">*    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment">* 2. The pool is stopped.</span></span><br><span class="line"><span class="comment">* 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment">* 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment">*    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment">*    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment">*    both before and after the timed wait, and if the queue is</span></span><br><span class="line"><span class="comment">*    non-empty, this worker is not the last thread in the pool.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment">*         workerCount is decremented</span></span><br><span class="line"><span class="comment">* -此函数用于从workerQueue阻塞队列中获取Runnable对象，由于是阻塞队列，</span></span><br><span class="line"><span class="comment">* -所以支持有限时间等待（poll）和无限时间等待（take）。</span></span><br><span class="line"><span class="comment">* -在该函数中还会响应shutDown和、shutDownNow函数的操作，若检测到线程池处于SHUTDOWN或STOP状态，</span></span><br><span class="line"><span class="comment">* -则会返回null，而不再返回阻塞队列中的Runnalbe对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 大于等于SHUTDOWN（表示调用了shutDown）并且（大于等于STOP（调用了shutDownNow）或者worker阻塞队列为空）</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 减少worker的数量</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 返回null，不执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// 是否允许coreThread超时或者workerCount大于核心大小</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<span class="comment">// worker数量大于maximumPoolSize</span></span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;<span class="comment">// workerCount大于1或者worker阻塞队列为空（在阻塞队列不为空时，需要保证至少有一个wc）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))<span class="comment">// 比较并减少workerCount</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 返回null，不执行任务，该worker会退出</span></span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">// 跳过剩余部分，继续循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h2><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadPoolExecutor/1587871132076.png" class title="任务提交">

</div>

<ol>
<li>主线程首先要创建实现Runnable或者Callable接口的任务对象。工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））。</li>
<li>然后可以把Runnable对象直接交给ExecutorService执行（ExecutorService.execute（Runnable command））；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行（Executor-Service.submit（Runnable task）或ExecutorService.submit（Callable<T>task））。</T></li>
<li>如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。</li>
<li>最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</li>
</ol>
<blockquote>
<p>说明：<br>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功<br>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
</blockquote>
<h2 id="任务执行过程"><a href="#任务执行过程" class="headerlink" title="任务执行过程"></a>任务执行过程</h2><ol>
<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务，即使此时线程池中存在空闲线程；<strong>（需要使用全局锁处理）</strong></li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入workQueue队列，等待线程池中任务调度执行；</li>
<li>如果这时候workQueue队列满了（无法加入队列），而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<strong>（需要使用全局锁处理）</strong></li>
<li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，会出行对应的拒绝策略。</li>
</ul>
</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小，当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</li>
</ol>
<div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadPoolExecutor/1587867917277.png" class>

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadPoolExecutor/1587867935740.png" class>

</div>

<blockquote>
<p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），基本上都是加入到等待队列中处理。</p>
</blockquote>
<h2 id="任务执行分析"><a href="#任务执行分析" class="headerlink" title="任务执行分析"></a>任务执行分析</h2><div align="center">

<img src="/2021/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadPoolExecutor/1587868053700.png" class title="任务执行">

</div>

<h3 id="任务提交执行代码"><a href="#任务提交执行代码" class="headerlink" title="任务提交执行代码"></a>任务提交执行代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment">* may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment">* executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment">* the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment">*         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment">*         cannot be accepted for execution</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * - 进行下面三步</span></span><br><span class="line"><span class="comment">    * - 1. 如果运行的线程小于corePoolSize,则尝试使用用户定义的Runnalbe对象创建一个新的线程</span></span><br><span class="line"><span class="comment">    * -    调用addWorker函数会原子性的检查runState和workCount，通过返回false来防止在不应</span></span><br><span class="line"><span class="comment">    * -    该添加线程时添加了线程</span></span><br><span class="line"><span class="comment">    * -</span></span><br><span class="line"><span class="comment">    * - 2. 如果一个任务能够成功入队列，在添加一个线城时仍需要进行双重检查（因为在前一次检查后</span></span><br><span class="line"><span class="comment">    * -    该线程死亡了），或者当进入到此方法时，线程池已经shutdown了，所以需要再次检查状态，</span></span><br><span class="line"><span class="comment">    * -    若有必要，当停止时还需要回滚入队列操作，或者当线程池没有线程时需要创建一个新线程</span></span><br><span class="line"><span class="comment">    * -</span></span><br><span class="line"><span class="comment">    * - 3. 如果无法入队列，那么需要增加一个新线程，如果此操作失败，</span></span><br><span class="line"><span class="comment">    * - 那么就意味着线程池已经shutdown或者已经饱和了，所以拒绝任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get(); <span class="comment">// 获取线程池控制状态</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 添加成功后则返回，否则继续执行</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get(); <span class="comment">// 不成功则再次获取线程池控制状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程池处于RUNNING状态，将命令（用户自定义的Runnable对象）添加进workQueue队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次检查，获取线程池控制状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池不处于RUNNING状态，将命令从workQueue队列中移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command); <span class="comment">// 拒绝执行命令</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) <span class="comment">// 添加worker失败</span></span><br><span class="line">        reject(command); <span class="comment">// 拒绝执行命令</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment">* pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment">* the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment">* new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment">* first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment">* eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment">* factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment">* creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment">* null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment">* Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment">* null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment">* (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment">* than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment">* or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment">* Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment">* prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment">* maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment">* value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment">* state).</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * -① 原子性的增加workerCount。</span></span><br><span class="line"><span class="comment">    * -② 将用户给定的任务封装成为一个worker，并将此worker添加进workers集合中。</span></span><br><span class="line"><span class="comment">    * -③ 启动worker对应的线程，并启动该线程，运行worker的run方法。</span></span><br><span class="line"><span class="comment">    * -④ 回滚worker的创建动作，即将worker从workers集合中删除，并原子性的减少workerCount。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 双层无限循环，尝试增加线程数到ctl变量，并且做一些比较判断，</span></span><br><span class="line"><span class="comment">    * 如果超出线程数限定或者ThreadPoolExecutor的状态不符合要求，则直接返回false，增加worker失败。</span></span><br><span class="line"><span class="comment">    * 第二部分：从第28行开始到结尾，把firstTask这个Runnable对象传给Worker构造方法，赋值给Worker对象的task属性。Worker对象把自身（也是一个Runnable）封装成一个Thread对象赋予Worker对象的thread属性。锁住整个线程池并实际增加worker到workers的HashSet对象当中。成功增加后开始执行t.start()，就是worker的thread属性开始运行，实际上就是运行Worker对象的run方法。Worker的run()方法实际上调用了ThreadPoolExecutor的runWorker()方法。在看runWorker()之前先看一下Worker对象。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();<span class="comment">// 获取线程池控制状态</span></span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// worker数量</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry; <span class="comment">// 调出外循环</span></span><br><span class="line">            <span class="comment">// 获取线程池控制状态</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 此次的状态与上次获取的状态不相同</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="comment">// 跳过剩余部分，继续循环</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 把firstTask这个Runnable对象传给Worker构造方法，赋值给Worker对象的task属性。</span></span><br><span class="line"><span class="comment">        * Worker对象把自身（也是一个Runnable）封装成一个Thread对象赋予Worker对象的thread属性。</span></span><br><span class="line"><span class="comment">        * 锁住整个线程池并实际增加worker到workers的HashSet对象当中。</span></span><br><span class="line"><span class="comment">        * 成功增加后开始执行t.start()，就是worker的thread属性开始运行，实际上就是运行Worker对象的run方法。</span></span><br><span class="line"><span class="comment">        * Worker的run()方法实际上调用了ThreadPoolExecutor的runWorker()方法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// worker开始标识</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// worker被添加标识</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用用户任务初始化worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 获取worker对应的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 线程池的运行状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h2><p>使用<code>shutdown</code>或<code>shutdownNow</code>方法关闭线程池。它原理是遍历线程池中的工作线程，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>
<ol>
<li>shutdownNow:任务要不求执行完成<ul>
<li>将线程池的状态设置成STOP，</li>
<li>尝试停止所有的正在执行或暂停任务的线程，</li>
<li>返回等待执行任务的列表</li>
</ul>
</li>
<li>shutdown:任务需要执行完成<ul>
<li>将线程池的状态设置成SHUTDOWN状态</li>
<li>中断所有没有正在执行任务的线程。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意事项<br><code>isShutdown</code>方法在调用<code>shutdown</code>或<code>shutdownNow</code>之后立即返回true<br><code>isTerminaed</code>当所有任务都关闭后，表示线程池关闭成功，并且返回true  </p>
</blockquote>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Initiates an orderly shutdown in which previously submitted</span></span><br><span class="line"><span class="comment">* tasks are executed, but no new tasks will be accepted.</span></span><br><span class="line"><span class="comment">* Invocation has no additional effect if already shut down.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method does not wait for previously submitted tasks to</span></span><br><span class="line"><span class="comment">* complete execution.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125;</span></span><br><span class="line"><span class="comment">* to do that.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此函数会按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查shutdown权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 尝试将状态切换到SHUTDOWN，这样就不会再接收新的任务提交。</span></span><br><span class="line"><span class="comment">        * 对空闲线程进行中断调用。最后检查线程池线程是否为0，并尝试切换到TERMINATED状态。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲worker</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 调用shutdown钩子函数</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Attempts to stop all actively executing tasks, halts the</span></span><br><span class="line"><span class="comment">* processing of waiting tasks, and returns a list of the tasks</span></span><br><span class="line"><span class="comment">* that were awaiting execution. These tasks are drained (removed)</span></span><br><span class="line"><span class="comment">* from the task queue upon return from this method.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;This method does not wait for actively executing tasks to</span></span><br><span class="line"><span class="comment">* terminate.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125; to</span></span><br><span class="line"><span class="comment">* do that.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span></span><br><span class="line"><span class="comment">* processing actively executing tasks.  This implementation</span></span><br><span class="line"><span class="comment">* cancels tasks via &#123;<span class="doctag">@link</span> Thread#interrupt&#125;, so any task that</span></span><br><span class="line"><span class="comment">* fails to respond to interrupts may never terminate.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h2><ol>
<li><p>taskCount：线程池需要执行的任务数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -- 返回曾经计划执行的任务总数的近似值（由于任务和线程的状态可能在计算期间发生变化）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of tasks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 已经执行完成的任务数</span></span><br><span class="line">        <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">        <span class="comment">// 加上任务中执行完成的数量</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            n += w.completedTasks;</span><br><span class="line">            <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加上阻塞队列的大小</span></span><br><span class="line">        <span class="keyword">return</span> n + workQueue.size();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>completedTaskCount:线程池在运行过程中已完成的任务数量，小于或等于taskCount。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Counter for completed tasks. Updated only on termination of</span></span><br><span class="line"><span class="comment"> * worker threads. Accessed only under mainLock.</span></span><br><span class="line"><span class="comment"> * - 完成的任务数，只有在工作线程完成之后才更新该值，需要通过mainLock下获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the approximate total number of tasks that have</span></span><br><span class="line"><span class="comment"> * completed execution. Because the states of tasks and threads</span></span><br><span class="line"><span class="comment"> * may change dynamically during computation, the returned value</span></span><br><span class="line"><span class="comment"> * is only an approximation, but one that does not ever decrease</span></span><br><span class="line"><span class="comment"> * across successive calls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of tasks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            n += w.completedTasks;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tracks largest attained pool size. Accessed only under</span></span><br><span class="line"><span class="comment"> * mainLock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the largest number of threads that have ever</span></span><br><span class="line"><span class="comment"> * simultaneously been in the pool.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of threads</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLargestPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> largestPoolSize;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current number of threads in the pool.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of threads</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Remove rare and surprising possibility of</span></span><br><span class="line">        <span class="comment">// isTerminated() &amp;&amp; getPoolSize() &gt; 0</span></span><br><span class="line">        <span class="keyword">return</span> runStateAtLeast(ctl.get(), TIDYING) ? <span class="number">0</span></span><br><span class="line">            : workers.size();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>getActiveCount：获取活动的线程数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the approximate number of threads that are actively</span></span><br><span class="line"><span class="comment"> * executing tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of threads</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                ++n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法</p>
</blockquote>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Java并发编程的艺术》</li>
<li>《Java并发编程》</li>
<li>《Java多线程编程核心技术》</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
        <category>Java线程池</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之HashMap</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>HashMap是一种使用<strong>数组+链表+红黑树</strong>数据结构实现的Map</li>
<li>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序不确定。</li>
<li>HashMap只允许一个key为null，允许多个value为null</li>
<li>HashMap 非线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。<a id="more"></a>

</li>
</ol>
<h2 id="Java7的实现方式"><a href="#Java7的实现方式" class="headerlink" title="Java7的实现方式"></a>Java7的实现方式</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589101907833.png" class title="Java7 HashMap结构">

</div>
数组+单向链表的方式实现，上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。

<ol>
<li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</li>
<li>loadFactor：负载因子，默认为 0.75。</li>
<li>threshold：扩容的阈值，等于 capacity * loadFactor</li>
</ol>
<h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主干数组，是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂。</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure>
<h3 id="Entry静态内部类"><a href="#Entry静态内部类" class="headerlink" title="Entry静态内部类"></a>Entry静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      <span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">      Entry&lt;K,V&gt; next;</span><br><span class="line">      <span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line">      <span class="keyword">int</span> hash;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Creates new entry.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">          value = v;</span><br><span class="line">          next = n;</span><br><span class="line">          key = k;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589101953955.png" class title="Java7 HashMap链表结构">

</div>

<p>HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，<strong>HashMap中的链表出现越少，性能才会越好</strong>。</p>
<h3 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**实际存储的key-value键值对的个数*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；</span></span><br><span class="line"><span class="comment">* 当table被填充时，为table分配内存空间后，threshold一般为 capacity*loadFactory。</span></span><br><span class="line"><span class="comment">* HashMap在进行扩容时需要参考threshold</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 负载因子，代表了table的填充度有多少，默认是0.75</span></span><br><span class="line"><span class="comment">* 为了减缓哈希冲突和自动扩容的临界值</span></span><br><span class="line"><span class="comment">* 当初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。</span></span><br><span class="line"><span class="comment">* 所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**HashMap被改变的次数，</span></span><br><span class="line"><span class="comment">* 由于HashMap非线程安全，在对HashMap进行迭代时，如果数据发生变化</span></span><br><span class="line"><span class="comment">* 抛出ConcurrentModificationException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在常规构造函数中没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组（懒加载）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加数据源码解析"><a href="#添加数据源码解析" class="headerlink" title="添加数据源码解析"></a>添加数据源码解析</h3><h4 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间,入参是threshold）</span></span><br><span class="line">    <span class="comment">//此时threshold为initialCapacity 默认是1&lt;&lt;4(2^4=16)</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//获取在table中的实际位置</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//新增一个entry</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="inflateTable、roundUpToPowerOf2"><a href="#inflateTable、roundUpToPowerOf2" class="headerlink" title="inflateTable、roundUpToPowerOf2"></a>inflateTable、roundUpToPowerOf2</h4><p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//capacity一定是2的次幂</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">/**计算threshold</span></span><br><span class="line"><span class="comment">     * 取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，</span></span><br><span class="line"><span class="comment">     * capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="添加到链表中"><a href="#添加到链表中" class="headerlink" title="添加到链表中"></a>添加到链表中</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法。</p>
<h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//for循环中的代码，逐个遍历链表，重新计算索引位置，</span></span><br><span class="line">    <span class="comment">//将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，</span></span><br><span class="line">            <span class="comment">//有可能也是个entry链，如果是entry链，直接在链表头部插入。</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。  </p>
<p>HashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)。</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102034044.png" class>

</div>
还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102056292.png" class>

</div>

<p>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102083089.png" class>

</div>

<p>如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p>
<h3 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**这是一个神奇的函数，用了很多的异或，移位等运算</span></span><br><span class="line"><span class="comment">* 对key的hashcode进一步进行计算以及二进制位的调整等</span></span><br><span class="line"><span class="comment">* 来保证最终获取的存储位置尽量分布均匀</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回数组下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>h&amp;（length-1）</strong>保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为index=2。位运算对计算机来说，性能更高一些（HashMap中有大量位运算）<br>所以最终存储位置的确定流程是这样的：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102000853.png" class>

</div>

<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果key为null,则直接去table[0]处去检索即可。</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> getForNullKey();</span><br><span class="line">  Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法。</p>
<h4 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过key的hashcode值计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">//indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null。</p>
<p>在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>
<h2 id="JAVA8"><a href="#JAVA8" class="headerlink" title="JAVA8"></a>JAVA8</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了<strong>红黑树</strong>，所以其由 <strong>数组+链表+红黑树</strong> 组成。<br>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102119067.png" class title="Java8 HashMap结构">

</div>

<h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><ol>
<li>源码中的头节点一般是指table表上索引位置的节点，也就是链表的头节点</li>
<li>红黑树中的root节点指最上面的节点（没有父节点的节点），但是根节点不一定是索引位置的头节点（也就是链表的头节点），HashMap 通过 moveRootToFront 方法来维持红黑树的根结点就是索引位置的头结点，但是在 removeTreeNode 方法中，当 movable 为 false 时，不会调用 moveRootToFront 方法，此时红黑树的根节点不一定是索引位置的头节点，该场景发生在 HashIterator 的 remove 方法中。</li>
<li>转为红黑树节点后，链表的结构还存在，通过 next 属性维持，红黑树节点在进行操作时都会维护链表的结构，</li>
<li>在红黑树上，叶子节点也可能有 next 节点，因为红黑树的结构跟链表的结构是互不影响的链表移除操作</li>
</ol>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102145189.png" class>

</div>

<ol>
<li>红黑链表维护结构</li>
</ol>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102168356.png" class>

</div>

<ol>
<li>源码中进行红黑树的查找时，会反复用到以下两条规则：<ul>
<li>如果目标节点的 hash 值小于 p 节点的 hash 值，则向 p 节点的左边遍历；否则向 p 节点的右边遍历。</li>
<li>如果目标节点的 key 值小于 p 节点的 key 值，则向 p 节点的左边遍历；否则向 p 节点的右边遍历。这两条规则是利用了红黑树的特性（左节点 &lt; 根节点 &lt; 右节点）</li>
</ul>
</li>
<li>源码中进行红黑树的查找时，会用 dir（direction）来表示向左还是向右查找，dir 存储的值是目标节点的 hash/key 与 p 节点的 hash/key 的比较结果</li>
</ol>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> * 默认容量，1向左移位4个，00000001变成00010000，</span></span><br><span class="line"><span class="comment"> * 也就是2的4次方为16，使用移位是因为移位是计算机基础运算，效率比加减乘除快。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> * 用于扩容的加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> * 当桶的数量大于该值时，会把链表结构转换成红黑树结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> * 当桶的节点数量小于该值时，会自动转换成链表结构，前天是当前结构为红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> * 当hashmap中元素的数量大于该值时，桶的存储结构也会转换成红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> * 链表结构定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> * 存储实际元素的数组，被transient修饰，表示不被序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> * 将数据转换成set的另一种存储形式，这个变量主要用于迭代功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> * 元素数量,实际存储key-value键值对的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> * 统计map的结构化修改次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> * 扩容的临界值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> * 加载因子，定义为可使用的变量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment"> * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment"> * linked node.</span></span><br><span class="line"><span class="comment"> * -- 红黑树结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>如何在不遍历链表/红黑树的情况下快速定位原始，可以大大优化查询效率，并且通过hash算法可以使数据均匀分布，尽量减少哈希碰撞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment"> * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> * 使用key的hashCode进行移位异或运算，尽量避免hash碰撞</span></span><br><span class="line"><span class="comment"> * 如果在修改某个对象的hashCode方法时需要尽量保障唯一性，</span></span><br><span class="line"><span class="comment"> * 否则在使用map数据结构存储时会出现数据覆盖的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.首先获取key的hashCode值</span></span><br><span class="line"><span class="comment">     * 2.将hashCode值的高16位参与运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到元素的hash值之后通过以下方式完成索引定位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = tab.length;</span><br><span class="line"><span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>
<p>hashmap使用模运算算法均匀分布数据，由于模运算比较消耗系统性能，JDK团队使用位与运算（(table.length -1) &amp; h）来替代模运算。这个优化是基于以下公式：x mod 2^n = x &amp; (2^n - 1)。由于 HashMap 底层数组的长度总是 2 的 n 次方，并且取模运算为 “h mod table.length”，对应上面的公式，可以得到该运算等同于“h &amp; (table.length - 1)”。这是 HashMap 在速度上的优化，因为 &amp; 比 % 具有更高的效率。在 JDK1.8 的实现中，还优化了高位运算的算法，将 hashCode 的高 16 位与 hashCode 进行异或运算，主要是为了在 table 的 length 较小的时候，让高位也参与运算，并且不会有太大的开销。  </p>
<p>举例说明：<br>当 table 长度为 16 时，table.length - 1 = 15 ，用二进制来看，此时低 4 位全是 1，高 28 位全是 0，与 0 进行 &amp; 运算必然为 0，因此此时 hashCode 与 “table.length - 1” 的 &amp; 运算结果只取决于 hashCode 的低 4 位，在这种情况下，hashCode 的高 28 位就没有任何作用，并且由于 hash 结果只取决于 hashCode 的低 4 位，hash 冲突的概率也会增加。因此，在 JDK 1.8 中，将高位也参与计算，目的是为了降低 hash 冲突的概率。</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102211003.png" class>

</div>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有当table不为空，且table长度大于0，</span></span><br><span class="line"><span class="comment">     * 且table索引位置(使用table.length - 1和hash值进行位与运算)的节点不为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * 2.检查first节点的hash值和key是否和入参的一样，</span></span><br><span class="line"><span class="comment">    	 * 如果一样则first即为目标节点，直接返回first节点</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.如果first不是目标节点，并且first的next节点不为空则继续遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            	<span class="comment">/**</span></span><br><span class="line"><span class="comment">            	 * 3.如果first不是目标节点，并且first的next节点不为空则继续遍历</span></span><br><span class="line"><span class="comment">            	 */</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">            	<span class="comment">/**</span></span><br><span class="line"><span class="comment">            	 * 5.执行链表节点的查找，向下遍历链表, 直至找到节点的key和入参的key相等时,返回该节点</span></span><br><span class="line"><span class="comment">            	 */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有查询到数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls find for root node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 首先获取root节点，然后根据root节点进行find</span></span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定位根节点"><a href="#定位根节点" class="headerlink" title="定位根节点"></a>定位根节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment"> * -- 没有父节点的节点为根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用根节点进行find"><a href="#使用根节点进行find" class="headerlink" title="使用根节点进行find"></a>使用根节点进行find</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Finds the node starting at root p with the given hash and key.</span></span><br><span class="line"><span class="comment">     * The kc argument caches comparableClassFor(key) upon first use</span></span><br><span class="line"><span class="comment">     * comparing keys.</span></span><br><span class="line"><span class="comment">     * 从调用此方法的节点开始查找, 通过hash值和key找到对应的节点</span></span><br><span class="line"><span class="comment">     * 此方法是红黑树节点的查找, 红黑树是特殊的自平衡二叉查找树</span></span><br><span class="line"><span class="comment">     * 平衡二叉查找树的特点：左节点&lt;根节点&lt;右节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 1.将p节点赋值为调用此方法的节点，即为红黑树根节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">            <span class="comment">// 3.如果传入的hash值小于p节点的hash值，则往p节点的左边遍历</span></span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                p = pl;</span><br><span class="line">            <span class="comment">// 4.如果传入的hash值大于p节点的hash值，则往p节点的右边遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="comment">// 5.如果传入的hash值和key值等于p节点的hash值和key值,则p节点为目标节点,返回p节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            <span class="comment">// 6.p节点的左节点为空则将向右遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="comment">// 7.p节点的右节点为空则向左遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                p = pl;</span><br><span class="line">            <span class="comment">// 8.将p节点与k进行比较</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp; <span class="comment">// 8.1 kc不为空代表k实现了Comparable</span></span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>) <span class="comment">// 8.2 k&lt;pk则dir&lt;0, k&gt;pk则dir&gt;0</span></span><br><span class="line">            	<span class="comment">// 8.3 k&lt;pk则向左遍历(p赋值为p的左节点), 否则向右遍历</span></span><br><span class="line">            	p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">            <span class="comment">// 9.代码走到此处, 代表key所属类没有实现Comparable, 直接指定向p的右边遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            <span class="comment">// 10.代码走到此处代表“pr.find(h, k, kc)”为空, 因此直接向左遍历</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns x&#x27;s Class if it is of the form &quot;class C implements</span></span><br><span class="line"><span class="comment"> * Comparable&lt;C&gt;&quot;, else null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">	<span class="comment">// 1.判断x是否实现了Comparable接口</span></span><br><span class="line">	<span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="comment">// 2.校验x是否为String类型</span></span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 3.遍历x实现的所有接口</span></span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">        		<span class="comment">// 4.如果x实现了Comparable接口，则返回x的Class</span></span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Put逻辑"><a href="#Put逻辑" class="headerlink" title="Put逻辑"></a>Put逻辑</h3><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102248734.png" class title="Put处理逻辑">

</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.（初始化时使用false）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * tab 哈希数组，</span></span><br><span class="line"><span class="comment">	 * p 该哈希桶的首节点，</span></span><br><span class="line"><span class="comment">	 * n hashMap的长度，</span></span><br><span class="line"><span class="comment">	 * i 计算出的数组下标</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.使用懒加载的方式完成table的初始化（通过扩容完成：resize方法）</span></span><br><span class="line"><span class="comment">     * 2.如果table为空或者长度为0，则调用resize完成初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过hash值计算索引位置，如果计算出的该哈希桶的位置没有值，</span></span><br><span class="line"><span class="comment">     * 则把新插入的key-value放到此处，并且赋值给p（首节点）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    	<span class="comment">//如果p（首节点）为空，则在该索引位置新增一个节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * table索引位置不为空，及首节点不为空，则进行查找</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">    	<span class="comment">// e 临时节点的作用， k 存放该当前节点的key</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一种：插入的key-value的hash值，key都与当前节点的相等，e = p，</span></span><br><span class="line"><span class="comment">         * 则表示为首节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二种：hash值不等于首节点，判断该p是否属于红黑树的节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        	 * 为红黑树的节点，则在红黑树中进行添加，</span></span><br><span class="line"><span class="comment">        	 * 如果该节点已经存在，则返回该节点（不为null），</span></span><br><span class="line"><span class="comment">        	 * 该值很重要，用来判断put操作是否成功，如果添加成功返回null</span></span><br><span class="line"><span class="comment">        	 */</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第三种，hash值不等于首节点，不为红黑树的节点，则为链表的节点，使用binCount统计链表数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">// 遍历链表</span></span><br><span class="line">            	<span class="comment">/**</span></span><br><span class="line"><span class="comment">            	 * 如果找到尾部，则表明添加的key-value没有重复，在尾部进行添加</span></span><br><span class="line"><span class="comment">            	 */</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断是否转换成红黑树结构，减1，是由于循环从p的下一个节点开始</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果链表中有重复的key，e则为当前重复的节点，结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e; <span class="comment">// 将p指向下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果存在重复key，则使用新值插入，并且返回旧值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在没有重复值的情况下，完成以下操作</span></span><br><span class="line"><span class="comment">     * 1.modCount + 1</span></span><br><span class="line"><span class="comment">     * 2.实际长度size + 1</span></span><br><span class="line"><span class="comment">     * 3.根据实际情况完成扩容</span></span><br><span class="line"><span class="comment">     * 4.返回null，表示添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 该方法目前未具体实现，在LinkedHashMap中有实现</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="红黑树结构维护数据"><a href="#红黑树结构维护数据" class="headerlink" title="红黑树结构维护数据"></a>红黑树结构维护数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tree version of putVal.</span></span><br><span class="line"><span class="comment"> * -- 红黑树的put操作，红黑树插入会同时维护原来的链表属性, 即原来的next属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取根节点，索引位置的头节点不一定是根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将根节点赋值给p，然后进行遍历查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="comment">// 如果传入的hash值小于p节点的hash值，将dir赋值为-1，代表向p的左边查找树</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果传入的hash值大于p节点的hash值， 将dir赋值为1，代表向p的右边查找树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果传入的hash值和key值等于p节点的hash值和key值, 则p节点即为目标节点, 返回p节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果k所属的类没有实现Comparable接口 或者 k和p节点的key相等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        	 * 第一次符合条件, 从p节点的左节点和右节点分别调用find方法进行查找, </span></span><br><span class="line"><span class="comment">        	 * 如果查找到目标节点则返回</span></span><br><span class="line"><span class="comment">        	 */</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 否则使用定义的一套规则来比较k和p节点的key的大小, 用来决定向左还是向右查找</span></span><br><span class="line"><span class="comment">             * dir&lt;0则代表k&lt;pk，则向p左边查找；反之亦然</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xp赋值为x的父节点,中间变量,用于下面给x的父节点赋值</span></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 表示已经找到x的位置，只需要将x放到该位置即可</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            <span class="comment">// 创建新的节点, 其中x的next节点为xpn, 即将x节点插入xp与xpn之间</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 调整x、xp、xpn之间的属性关系</span></span><br><span class="line"><span class="comment">             * 如果时dir &lt;= 0, 则代表x节点为xp的左节点</span></span><br><span class="line"><span class="comment">             * 如果时dir&gt; 0, 则代表x节点为xp的右节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;<span class="comment">// 将xp的next节点设置为x</span></span><br><span class="line">            x.parent = x.prev = xp;<span class="comment">// 将x的parent和prev节点设置为xp</span></span><br><span class="line">            <span class="comment">// 如果xpn不为空,则将xpn的prev节点设置为x节点,与上文的x节点的next节点对应</span></span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            <span class="comment">// 进行红黑树的插入平衡调整</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tie-breaking utility for ordering insertions when equal</span></span><br><span class="line"><span class="comment"> * hashCodes and non-comparable. We don&#x27;t require a total</span></span><br><span class="line"><span class="comment"> * order, just a consistent insertion rule to maintain</span></span><br><span class="line"><span class="comment"> * equivalence across rebalancings. Tie-breaking further than</span></span><br><span class="line"><span class="comment"> * necessary simplifies testing a bit.</span></span><br><span class="line"><span class="comment"> * - 用于不可比较或者hashCode相同时进行比较的方法, </span></span><br><span class="line"><span class="comment"> * - 只是一个一致的插入规则，用来维护重定位的等价性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">         compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">             -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> * -- 链表转换成红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果tab为空，或者长度小于64，则调用resize方法进行扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据hash值计算索引值，将该索引位置的节点赋值给e，从e开始遍历该索引位置的链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        	 * 将链表转换成红黑树</span></span><br><span class="line"><span class="comment">        	 */</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)<span class="comment">// 第一次遍历，将节点赋值给hd</span></span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">/**</span></span><br><span class="line"><span class="comment">            	 * 如果不是第一次遍历，则处理当前节点的prev属性和上一个节点的next属性</span></span><br><span class="line"><span class="comment">            	 */</span></span><br><span class="line">                p.prev = tl; <span class="comment">// 当前节点的prev属性设为上一个节点</span></span><br><span class="line">                tl.next = p; <span class="comment">// 上一个节点的next属性设置为当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 将p节点赋值给tl，用于在下一次循环中作为上一个节点进行一些链表的关联操作</span></span><br><span class="line"><span class="comment">             * （p.prev = tl 和 tl.next = p）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">        	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        	 * 将table该索引位置赋值为新转的TreeNode的头节点，</span></span><br><span class="line"><span class="comment">        	 * 如果该节点不为空，则以以头节点(hd)为根节点, 构建红黑树</span></span><br><span class="line"><span class="comment">        	 */</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For treeifyBin</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之String</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BString/</url>
    <content><![CDATA[<h2 id="String介绍"><a href="#String介绍" class="headerlink" title="String介绍"></a>String介绍</h2><h3 id="API描述"><a href="#API描述" class="headerlink" title="API描述"></a>API描述</h3><blockquote>
<p>在<code>java.lang.String</code>的源码中明确说明，<code>String</code>类表示字符串，Java中所有的字符串传字面值（如：”abc”）都是该类的实例；并且字符串是常量，一旦创建之后则不可以改变，String buffers支持可变的字符串。因为<code>String</code>对象是不可变的，但是可以共享。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * The &#123;<span class="meta">@code</span> String&#125; <span class="class"><span class="keyword">class</span> <span class="title">represents</span> <span class="title">character</span> <span class="title">strings</span>. <span class="title">All</span></span></span><br><span class="line"><span class="class"> * <span class="title">string</span> <span class="title">literals</span> <span class="title">in</span> <span class="title">Java</span> <span class="title">programs</span>, <span class="title">such</span> <span class="title">as</span> </span>&#123;<span class="meta">@code</span> <span class="string">&quot;abc&quot;</span>&#125;, are</span><br><span class="line"> * implemented as instances of <span class="keyword">this</span> class.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Strings are constant; their values cannot be changed after they</span><br><span class="line"> * are created. String buffers support mutable strings.</span><br><span class="line"> * Because String objects are immutable they can be shared.</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通过API定义总结以下信息：</p>
<ol>
<li>使用final修饰，则不能被继承（该类中的成员方法默认都是final）</li>
<li>实现接口<code>Serializable</code>，说明可以进行序列化</li>
<li>实现接口<code>Comparable</code>,说明可以大小比较</li>
<li>实现接口<code>CharSequence</code>,说明String本身就是char类型的数组，而且通过成员变量定义可以进行佐证</li>
<li>通过char字符数组实现<a id="more"></a>

</li>
</ol>
<h2 id="如何创建字符串"><a href="#如何创建字符串" class="headerlink" title="如何创建字符串"></a>如何创建字符串</h2><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><p>直接赋值方式创建对象是在<font color="red">方法区的常量池。</font><br><code>String str = &quot;abc&quot;;</code></p>
<h3 id="使用new"><a href="#使用new" class="headerlink" title="使用new"></a>使用new</h3><p>通过构造方法创建字符串对象是在<font color="red">堆内存.  </font><br><code>String str = new String(&quot;abc&quot;);</code>  </p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p><code>String str = &quot;abc&quot; + &quot;bdc&quot;;</code></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str1 = <span class="string">&quot;sunld&quot;</span>;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;sunld&quot;</span>);</span><br><span class="line">        <span class="comment">//引用传递，str3直接指向st2的堆内存地址</span></span><br><span class="line">        String str3 = str2; </span><br><span class="line">        String str4 = <span class="string">&quot;sunld&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  ==:</span></span><br><span class="line"><span class="comment">         * 1. 基本数据类型：比较的是基本数据类型的值是否相同</span></span><br><span class="line"><span class="comment">         * 2. 引用数据类型：比较的是引用数据类型的地址值是否相同</span></span><br><span class="line"><span class="comment">         * 3. 所以在这里的话：String类对象==比较，比较的是地址，而不是内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">         System.out.println(str1==str3);<span class="comment">//false</span></span><br><span class="line">         System.out.println(str3==str2);<span class="comment">//true</span></span><br><span class="line">         System.out.println(str1==str4);<span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BString/1587630935534.png" class title="内存分配">

</div>

<blockquote>
<p>特殊说明</p>
<blockquote>
<ol>
<li>在使用new创建对象时，首先会在堆中的对象区域创建一个区域分配空间和完成初始化  </li>
<li>在使用字符串时，首先会判断字符串常量池中是否存在，否则则创建，然后堆对象会指向该字符串  </li>
<li>直接赋值：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。  </li>
<li>构造方法:会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public  String intern();方法进行手工入池。  </li>
<li>String类对象一旦声明则不可以改变；而改变的只是地址，原来的字符串还是存在的，并且产生垃圾  </li>
<li>当使用字符串拼接生成字符串时，如果在编译器就可以确定字符串，则使用==判断时则返回true  </li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//对匿名对象&quot;hello&quot;进行手工入池操作</span></span><br><span class="line">     String str =<span class="keyword">new</span> String(<span class="string">&quot;sunld&quot;</span>).intern();</span><br><span class="line">     String str1=<span class="string">&quot;sunld&quot;</span>;</span><br><span class="line">     System.out.println(str==str1);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String 使用final 修饰的字符数组进行存储，</span></span><br><span class="line"><span class="comment">* 并且字符串的长度和是否为空都是通过该数组的长度判断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Class String is special cased within the Serialization Stream Protocol.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* A String instance is written into an ObjectOutputStream according to</span></span><br><span class="line"><span class="comment">* &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../platform/serialization/spec/output.html&quot;&gt;</span></span><br><span class="line"><span class="comment">* Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><p>String内部是以char数组的形式存储，数组的长度是int类型，那么String允许的最大长度就是Integer.MAX_VALUE了。又由于java中的字符是以16位存储的，因此大概需要4GB的内存才能存储最大长度的字符串。不过这仅仅是对字符串变量而言，如果是字符串字面量(string literals)，如“abc”、”1a2b”之类写在代码中的字符串literals，那么允许的最大长度取决于字符串在常量池中的存储大小，也就是字符串在class格式文件中的存储格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">        u1 tag;</span><br><span class="line">        u2 length;</span><br><span class="line">        u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>u2是无符号的16位整数，因此理论上允许的string literal的最大长度是2^16-1=65535。然而实际测试表明，允许的最大长度仅为65534，超过就编译错误了，有兴趣可以写段代码试试，估计是length还不能为0。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;border-color:#bbb;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#bbb;color:#594F4F;background-color:#E0FFEB;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#bbb;color:#493F3F;background-color:#9DE0AD;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0lax">Constructor</th>
    <th class="tg-0lax"><span style="font-weight:400;font-style:normal">Description</span><br></th>
  </tr>
  <tr>
    <td class="tg-0lax">String()</td>
    <td class="tg-0lax">初始化新创建的 String对象，使其表示空字符序列。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes)</td>
    <td class="tg-0lax">通过使用平台的默认字符集解码指定的字节数组来构造新的 String 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes, Charset charset)</td>
    <td class="tg-0lax">构造一个新的String由指定用指定的字节的数组解码charset 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes, int offset, int length)</td>
    <td class="tg-0lax">通过使用平台的默认字符集解码指定的字节子阵列来构造新的 String 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes, int offset, int length, Charset charset)</td>
    <td class="tg-0lax">构造一个新的String通过使用指定的指定字节子阵列解码charset 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes, int offset, int length, String charsetName)</td>
    <td class="tg-0lax">构造一个新的 String通过使用指定的字符集解码指定的字节子阵列。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes, String charsetName)</td>
    <td class="tg-0lax">构造一个新的String由指定用指定的字节的数组解码charset 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(char[] value)</td>
    <td class="tg-0lax">分配一个新的 String ，以便它表示当前包含在字符数组参数中的字符序列。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(char[] value, int offset, int count)</td>
    <td class="tg-0lax">分配一个新的 String ，其中包含字符数组参数的子阵列中的字符。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(int[] codePoints, int offset, int count)</td>
    <td class="tg-0lax">分配一个新的 String ，其中包含 Unicode code point数组参数的子阵列中的 字符 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(String original)</td>
    <td class="tg-0lax">初始化新创建的String对象，使其表示与参数相同的字符序列<br>
    换句话说，新创建的字符串是参数字符串的副本。
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">String(StringBuffer buffer)</td>
    <td class="tg-0lax">分配一个新的字符串，其中包含当前包含在字符串缓冲区参数中的字符序列。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(StringBuilder builder)</td>
    <td class="tg-0lax">分配一个新的字符串，其中包含当前包含在字符串构建器参数中的字符序列。</td>
  </tr>
</table>

<h3 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h3><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>比较字符串内容是否相同。重写Object类中的<code>equals</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Compares this string to the specified object.  The result is &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    * true&#125; if and only if the argument is not &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    * String&#125; object that represents the same sequence of characters as this</span></span><br><span class="line"><span class="comment">    * object.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  anObject</span></span><br><span class="line"><span class="comment">    *         The object to compare this &#123;<span class="doctag">@code</span> String&#125; against</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the given object represents a &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment">    *          equivalent to this string, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>  #compareTo(String)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>  #equalsIgnoreCase(String)</span></span><br><span class="line"><span class="comment">    * 判断对象存储内容是否相同</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;<span class="comment">// 首先判断是否属于同一对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 类型String----长度---数组中的字符</span></span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;<span class="comment">// 循环判断不等</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="equalsIgnoreCase"><a href="#equalsIgnoreCase" class="headerlink" title="equalsIgnoreCase"></a>equalsIgnoreCase</h4><p>比较字符串的内容是否相同,忽略大小写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Compares this &#123;<span class="doctag">@code</span> String&#125; to another &#123;<span class="doctag">@code</span> String&#125;, ignoring case</span></span><br><span class="line"><span class="comment">    * considerations.  Two strings are considered equal ignoring case if they</span></span><br><span class="line"><span class="comment">    * are of the same length and corresponding characters in the two strings</span></span><br><span class="line"><span class="comment">    * are equal ignoring case.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; Two characters &#123;<span class="doctag">@code</span> c1&#125; and &#123;<span class="doctag">@code</span> c2&#125; are considered the same</span></span><br><span class="line"><span class="comment">    * ignoring case if at least one of the following is true:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt; The two characters are the same (as compared by the</span></span><br><span class="line"><span class="comment">    *        &#123;<span class="doctag">@code</span> ==&#125; operator)</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt; Applying the method &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">    *        java.lang.Character#toUpperCase(char)&#125; to each character</span></span><br><span class="line"><span class="comment">    *        produces the same result</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt; Applying the method &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">    *        java.lang.Character#toLowerCase(char)&#125; to each character</span></span><br><span class="line"><span class="comment">    *        produces the same result</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  anotherString</span></span><br><span class="line"><span class="comment">    *         The &#123;<span class="doctag">@code</span> String&#125; to compare this &#123;<span class="doctag">@code</span> String&#125; against</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the argument is not &#123;<span class="doctag">@code</span> null&#125; and it</span></span><br><span class="line"><span class="comment">    *          represents an equivalent &#123;<span class="doctag">@code</span> String&#125; ignoring case; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    *          false&#125; otherwise</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>  #equals(Object)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == anotherString) ? <span class="keyword">true</span></span><br><span class="line">            : (anotherString != <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; (anotherString.value.length == value.length)</span><br><span class="line">            &amp;&amp; regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if two string regions are equal.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * A substring of this &#123;<span class="doctag">@code</span> String&#125; object is compared to a substring</span></span><br><span class="line"><span class="comment">    * of the argument &#123;<span class="doctag">@code</span> other&#125;. The result is &#123;<span class="doctag">@code</span> true&#125; if these</span></span><br><span class="line"><span class="comment">    * substrings represent character sequences that are the same, ignoring</span></span><br><span class="line"><span class="comment">    * case if and only if &#123;<span class="doctag">@code</span> ignoreCase&#125; is true. The substring of</span></span><br><span class="line"><span class="comment">    * this &#123;<span class="doctag">@code</span> String&#125; object to be compared begins at index</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> toffset&#125; and has length &#123;<span class="doctag">@code</span> len&#125;. The substring of</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> other&#125; to be compared begins at index &#123;<span class="doctag">@code</span> ooffset&#125; and</span></span><br><span class="line"><span class="comment">    * has length &#123;<span class="doctag">@code</span> len&#125;. The result is &#123;<span class="doctag">@code</span> false&#125; if and only if</span></span><br><span class="line"><span class="comment">    * at least one of the following is true:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;&lt;li&gt;&#123;<span class="doctag">@code</span> toffset&#125; is negative.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;&#123;<span class="doctag">@code</span> ooffset&#125; is negative.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;&#123;<span class="doctag">@code</span> toffset+len&#125; is greater than the length of this</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> String&#125; object.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;&#123;<span class="doctag">@code</span> ooffset+len&#125; is greater than the length of the other</span></span><br><span class="line"><span class="comment">    * argument.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;&#123;<span class="doctag">@code</span> ignoreCase&#125; is &#123;<span class="doctag">@code</span> false&#125; and there is some nonnegative</span></span><br><span class="line"><span class="comment">    * integer &lt;i&gt;k&lt;/i&gt; less than &#123;<span class="doctag">@code</span> len&#125; such that:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * this.charAt(toffset+k) != other.charAt(ooffset+k)</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;&#123;<span class="doctag">@code</span> ignoreCase&#125; is &#123;<span class="doctag">@code</span> true&#125; and there is some nonnegative</span></span><br><span class="line"><span class="comment">    * integer &lt;i&gt;k&lt;/i&gt; less than &#123;<span class="doctag">@code</span> len&#125; such that:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * Character.toLowerCase(this.charAt(toffset+k)) !=</span></span><br><span class="line"><span class="comment">    Character.toLowerCase(other.charAt(ooffset+k))</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    * and:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * Character.toUpperCase(this.charAt(toffset+k)) !=</span></span><br><span class="line"><span class="comment">    *         Character.toUpperCase(other.charAt(ooffset+k))</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   ignoreCase   if &#123;<span class="doctag">@code</span> true&#125;, ignore case when comparing</span></span><br><span class="line"><span class="comment">    *                       characters.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   toffset      the starting offset of the subregion in this</span></span><br><span class="line"><span class="comment">    *                       string.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   other        the string argument.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   ooffset      the starting offset of the subregion in the string</span></span><br><span class="line"><span class="comment">    *                       argument.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   len          the number of characters to compare.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the specified subregion of this string</span></span><br><span class="line"><span class="comment">    *          matches the specified subregion of the string argument;</span></span><br><span class="line"><span class="comment">    *          &#123;<span class="doctag">@code</span> false&#125; otherwise. Whether the matching is exact</span></span><br><span class="line"><span class="comment">    *          or case insensitive depends on the &#123;<span class="doctag">@code</span> ignoreCase&#125;</span></span><br><span class="line"><span class="comment">    *          argument.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,</span></span></span><br><span class="line"><span class="function"><span class="params">        String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">    <span class="keyword">int</span> po = ooffset;</span><br><span class="line">    <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">            || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">            || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">        <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ignoreCase) &#123;</span><br><span class="line">            <span class="comment">// If characters don&#x27;t match but case may be ignored,</span></span><br><span class="line">            <span class="comment">// try converting both characters to uppercase.</span></span><br><span class="line">            <span class="comment">// If the results match, then the comparison scan should</span></span><br><span class="line">            <span class="comment">// continue.</span></span><br><span class="line">            <span class="keyword">char</span> u1 = Character.toUpperCase(c1);</span><br><span class="line">            <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">            <span class="keyword">if</span> (u1 == u2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Unfortunately, conversion to uppercase does not work properly</span></span><br><span class="line">            <span class="comment">// for the Georgian alphabet, which has strange rules about case</span></span><br><span class="line">            <span class="comment">// conversion.  So we need to make one last check before</span></span><br><span class="line">            <span class="comment">// exiting.</span></span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h4><p>判断字符串对象是否以指定的str开头。源码中表现为按照长度截断之后进行循环比对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if the substring of this string beginning at the</span></span><br><span class="line"><span class="comment">    * specified index starts with the specified prefix.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   prefix    the prefix.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   toffset   where to begin looking in this string.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the character sequence represented by the</span></span><br><span class="line"><span class="comment">    *          argument is a prefix of the substring of this object starting</span></span><br><span class="line"><span class="comment">    *          at index &#123;<span class="doctag">@code</span> toffset&#125;; &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">    *          The result is &#123;<span class="doctag">@code</span> false&#125; if &#123;<span class="doctag">@code</span> toffset&#125; is</span></span><br><span class="line"><span class="comment">    *          negative or greater than the length of this</span></span><br><span class="line"><span class="comment">    *          &#123;<span class="doctag">@code</span> String&#125; object; otherwise the result is the same</span></span><br><span class="line"><span class="comment">    *          as the result of the expression</span></span><br><span class="line"><span class="comment">    *          &lt;pre&gt;</span></span><br><span class="line"><span class="comment">    *          this.substring(toffset).startsWith(prefix)</span></span><br><span class="line"><span class="comment">    *          &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = prefix.value;</span><br><span class="line">    <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">    <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h4><p>判断字符串对象是否以指定的str结尾,源码中转换成<code>startsWith</code>处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if this string ends with the specified suffix.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   suffix   the suffix.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the character sequence represented by the</span></span><br><span class="line"><span class="comment">    *          argument is a suffix of the character sequence represented by</span></span><br><span class="line"><span class="comment">    *          this object; &#123;<span class="doctag">@code</span> false&#125; otherwise. Note that the</span></span><br><span class="line"><span class="comment">    *          result will be &#123;<span class="doctag">@code</span> true&#125; if the argument is the</span></span><br><span class="line"><span class="comment">    *          empty string or is equal to this &#123;<span class="doctag">@code</span> String&#125; object</span></span><br><span class="line"><span class="comment">    *          as determined by the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h3><h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p>获取字符串的长度，其实也就是字符个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the length of this string.</span></span><br><span class="line"><span class="comment">    * The length is equal to the number of &lt;a href=&quot;Character.html#unicode&quot;&gt;Unicode</span></span><br><span class="line"><span class="comment">    * code units&lt;/a&gt; in the string.</span></span><br><span class="line"><span class="comment">    * 返回字符串的长度，长度等于字符串中的Unicode代码单元的数目（UTF-16的代码单元的数目）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the length of the sequence of characters represented by this</span></span><br><span class="line"><span class="comment">    *          object.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h4><p>获取指定索引处的字符</p>
<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><p>获取str在字符串对象中第一次出现的索引</p>
<h4 id="substring-int-start-int-end"><a href="#substring-int-start-int-end" class="headerlink" title="substring(int start,int end)"></a>substring(int start,int end)</h4><p>从start开始，到end结束截取字符串。包括start，不包括end</p>
<h3 id="转换功能"><a href="#转换功能" class="headerlink" title="转换功能"></a>转换功能</h3><h4 id="toCharArray"><a href="#toCharArray" class="headerlink" title="toCharArray"></a>toCharArray</h4><p>把字符串转换为字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Converts this string to a new character array.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a newly allocated character array whose length is the length</span></span><br><span class="line"><span class="comment">    *          of this string and whose contents are initialized to contain</span></span><br><span class="line"><span class="comment">    *          the character sequence represented by this string.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">    <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1. String 和Arrays 都属于rt.jar中的类，但是BootstrapClassloader在加载这两个类的顺序是不同的。</span></span><br><span class="line"><span class="comment">        * 2. 所以当String.class被加载进内存的时候,Arrays此时没有被加载，所以直接使用肯定会抛异常。</span></span><br><span class="line"><span class="comment">        * 3. 而System.arrayCopy是使用native代码，则不会有这个问题。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];</span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase"></a>toLowerCase</h4><p>把字符串转换为小写字符串</p>
<h4 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h4><p>把字符串转换为大写字符串</p>
<h3 id="其他常用"><a href="#其他常用" class="headerlink" title="其他常用"></a>其他常用</h3><h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><p>去除字符串两端空格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a string whose value is this string, with any leading and trailing</span></span><br><span class="line"><span class="comment">    * whitespace removed.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * If this &#123;<span class="doctag">@code</span> String&#125; object represents an empty character</span></span><br><span class="line"><span class="comment">    * sequence, or the first and last characters of character sequence</span></span><br><span class="line"><span class="comment">    * represented by this &#123;<span class="doctag">@code</span> String&#125; object both have codes</span></span><br><span class="line"><span class="comment">    * greater than &#123;<span class="doctag">@code</span> &#x27;\u005Cu0020&#x27;&#125; (the space character), then a</span></span><br><span class="line"><span class="comment">    * reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Otherwise, if there is no character with a code greater than</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> &#x27;\u005Cu0020&#x27;&#125; in the string, then a</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> String&#125; object representing an empty string is</span></span><br><span class="line"><span class="comment">    * returned.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Otherwise, let &lt;i&gt;k&lt;/i&gt; be the index of the first character in the</span></span><br><span class="line"><span class="comment">    * string whose code is greater than &#123;<span class="doctag">@code</span> &#x27;\u005Cu0020&#x27;&#125;, and let</span></span><br><span class="line"><span class="comment">    * &lt;i&gt;m&lt;/i&gt; be the index of the last character in the string whose code</span></span><br><span class="line"><span class="comment">    * is greater than &#123;<span class="doctag">@code</span> &#x27;\u005Cu0020&#x27;&#125;. A &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment">    * object is returned, representing the substring of this string that</span></span><br><span class="line"><span class="comment">    * begins with the character at index &lt;i&gt;k&lt;/i&gt; and ends with the</span></span><br><span class="line"><span class="comment">    * character at index &lt;i&gt;m&lt;/i&gt;-that is, the result of</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> this.substring(k, m + 1)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * This method may be used to trim whitespace (as defined above) from</span></span><br><span class="line"><span class="comment">    * the beginning and end of a string.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  A string whose value is this string, with any leading and trailing white</span></span><br><span class="line"><span class="comment">    *          space removed, or this string if it has no leading or</span></span><br><span class="line"><span class="comment">    *          trailing white space.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>按照指定符号分割字符串</p>
<h4 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Compares two strings lexicographically.</span></span><br><span class="line"><span class="comment">    * The comparison is based on the Unicode value of each character in</span></span><br><span class="line"><span class="comment">    * the strings. The character sequence represented by this</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> String&#125; object is compared lexicographically to the</span></span><br><span class="line"><span class="comment">    * character sequence represented by the argument string. The result is</span></span><br><span class="line"><span class="comment">    * a negative integer if this &#123;<span class="doctag">@code</span> String&#125; object</span></span><br><span class="line"><span class="comment">    * lexicographically precedes the argument string. The result is a</span></span><br><span class="line"><span class="comment">    * positive integer if this &#123;<span class="doctag">@code</span> String&#125; object lexicographically</span></span><br><span class="line"><span class="comment">    * follows the argument string. The result is zero if the strings</span></span><br><span class="line"><span class="comment">    * are equal; &#123;<span class="doctag">@code</span> compareTo&#125; returns &#123;<span class="doctag">@code</span> 0&#125; exactly when</span></span><br><span class="line"><span class="comment">    * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method would return &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * This is the definition of lexicographic ordering. If two strings are</span></span><br><span class="line"><span class="comment">    * different, then either they have different characters at some index</span></span><br><span class="line"><span class="comment">    * that is a valid index for both strings, or their lengths are different,</span></span><br><span class="line"><span class="comment">    * or both. If they have different characters at one or more index</span></span><br><span class="line"><span class="comment">    * positions, let &lt;i&gt;k&lt;/i&gt; be the smallest such index; then the string</span></span><br><span class="line"><span class="comment">    * whose character at position &lt;i&gt;k&lt;/i&gt; has the smaller value, as</span></span><br><span class="line"><span class="comment">    * determined by using the &amp;lt; operator, lexicographically precedes the</span></span><br><span class="line"><span class="comment">    * other string. In this case, &#123;<span class="doctag">@code</span> compareTo&#125; returns the</span></span><br><span class="line"><span class="comment">    * difference of the two character values at position &#123;<span class="doctag">@code</span> k&#125; in</span></span><br><span class="line"><span class="comment">    * the two string -- that is, the value:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * this.charAt(k)-anotherString.charAt(k)</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    * If there is no index position at which they differ, then the shorter</span></span><br><span class="line"><span class="comment">    * string lexicographically precedes the longer string. In this case,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> compareTo&#125; returns the difference of the lengths of the</span></span><br><span class="line"><span class="comment">    * strings -- that is, the value:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * this.length()-anotherString.length()</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   anotherString   the &#123;<span class="doctag">@code</span> String&#125; to be compared.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the value &#123;<span class="doctag">@code</span> 0&#125; if the argument string is equal to</span></span><br><span class="line"><span class="comment">    *          this string; a value less than &#123;<span class="doctag">@code</span> 0&#125; if this string</span></span><br><span class="line"><span class="comment">    *          is lexicographically less than the string argument; and a</span></span><br><span class="line"><span class="comment">    *          value greater than &#123;<span class="doctag">@code</span> 0&#125; if this string is</span></span><br><span class="line"><span class="comment">    *          lexicographically greater than the string argument.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 比较字符串大小，因为String实现了Comparable&lt;String&gt;接口，所有重写了compareTo方法</span></span><br><span class="line"><span class="comment">    * 2. 返回int类型，正数为大，负数为小，基于字符的ASSIC码比较</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2); <span class="comment">//获取长度比较小的字符串长度</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123; <span class="comment">//当前索引小于两个字符串中长度较小的字符串长度时，循环继续</span></span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2; <span class="comment">//从前向后遍历，有一个字符不相同，返回差值</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2; <span class="comment">//如果遍历结束，都相同，比较两个字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h2><p>在定义String时增加了<code>final</code>标记，并且存储数据的数组也被定义为<code>final</code>，则表示String一但创建就注定不可变。<strong>对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</strong></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式,每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。需要说明一点的是，在object中，equals()是用来比较内存地址的，但是String重写了equals()方法，用来比较内容的，即使是不同地址，只要内容一致，也会返回true，这也就是为什么a.equals(c)返回true的原因了。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。</li>
<li>安全性更高</li>
<li>传参与基础类型一样，更加直观</li>
</ol>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>后续会在JVM中进行详细的讲解。</p>
<h3 id="字符串常量池概述"><a href="#字符串常量池概述" class="headerlink" title="字符串常量池概述"></a>字符串常量池概述</h3><h4 id="常量池表（Constant-Pool-table）"><a href="#常量池表（Constant-Pool-table）" class="headerlink" title="常量池表（Constant_Pool table）"></a>常量池表（Constant_Pool table）</h4><ol>
<li>Class文件中存储所有常量（包括字符串）的table。</li>
<li>Class文件中的内容，不是运行内容，表示Class文件中的字节码指令</li>
</ol>
<h4 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h4><ol>
<li>JVM内存中方法区的一部分，这是运行时的内容</li>
<li>这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个Class对应一个运行时常量池</li>
<li>除了 Class中常量池内容，还可能包括动态生成并加入这里的内容</li>
</ol>
<h4 id="字符串常量池（String-Pool）"><a href="#字符串常量池（String-Pool）" class="headerlink" title="字符串常量池（String Pool）"></a>字符串常量池（String Pool）</h4><ol>
<li>这部分也在方法区中，但与Runtime Constant Pool不是一个概念，String Pool是JVM实例全局共享的，全局只有一个</li>
<li>JVM规范要求进入这里的String实例叫“被驻留的interned string”，各个JVM可以有不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。</li>
</ol>
<h3 id="亨元模式"><a href="#亨元模式" class="headerlink" title="亨元模式"></a>亨元模式</h3><p>字符串在使用过程中使用到了享元模式（一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素），而那个存储元素的地方就叫做“字符串常量池 - String Pool”</p>
<h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p><code>String str = &quot;hello&quot;;</code>的执行过程：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BString/1587636643511.png" class title="String Pool的详细过程">

</div>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="String与StringBuffer、StringBuilder"><a href="#String与StringBuffer、StringBuilder" class="headerlink" title="String与StringBuffer、StringBuilder"></a>String与StringBuffer、StringBuilder</h3><ol>
<li>String是不可变的字符序列</li>
<li>StringBuffer和StringBuilder是可变的字符序列</li>
<li>StringBuffer是线程安全的，效率低</li>
<li>StringBuilder和String是线程不安全的，效率高一些，</li>
<li>效率从高到低：StringBuilder&gt;String&gt;StringBuffer</li>
</ol>
<h4 id="String循环拼接对象"><a href="#String循环拼接对象" class="headerlink" title="String循环拼接对象"></a>String循环拼接对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.string;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String string = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">			string += <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(string);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Test1.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">string</span>.<span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.sunld.string.Test1();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #16                 // String</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: iconst_0</span><br><span class="line">       <span class="number">4</span>: istore_2</span><br><span class="line">       <span class="number">5</span>: goto          <span class="number">31</span></span><br><span class="line">       8: new           #18                 // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">11</span>: dup</span><br><span class="line">      <span class="number">12</span>: aload_1</span><br><span class="line">      13: invokestatic  #20                 // Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">      16: invokespecial #26                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">      19: ldc           #29                 // String hello</span><br><span class="line">      21: invokevirtual #31                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #35                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">27</span>: astore_1</span><br><span class="line">      <span class="number">28</span>: iinc          <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">      <span class="number">31</span>: iload_2</span><br><span class="line">      <span class="number">32</span>: sipush        <span class="number">10000</span></span><br><span class="line">      <span class="number">35</span>: if_icmplt     <span class="number">8</span></span><br><span class="line">      38: getstatic     #39                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">41</span>: aload_1</span><br><span class="line">      42: invokevirtual #45                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">45</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8~35行是整个循环过程，并且每次都会new一个StringBuilder（String拼接被jvm优化为使用StringBuilder处理）</p>
<h4 id="使用StringBuilder"><a href="#使用StringBuilder" class="headerlink" title="使用StringBuilder"></a>使用StringBuilder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StringBuilder string = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">			string.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(string.toString());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Test2.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">string</span>.<span class="title">Test2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.sunld.string.Test2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #16                 // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokespecial #18                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: iconst_0</span><br><span class="line">       <span class="number">9</span>: istore_2</span><br><span class="line">      <span class="number">10</span>: goto          <span class="number">23</span></span><br><span class="line">      <span class="number">13</span>: aload_1</span><br><span class="line">      14: ldc           #19                 // String hello</span><br><span class="line">      16: invokevirtual #21                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      <span class="number">19</span>: pop</span><br><span class="line">      <span class="number">20</span>: iinc          <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">      <span class="number">23</span>: iload_2</span><br><span class="line">      <span class="number">24</span>: sipush        <span class="number">10000</span></span><br><span class="line">      <span class="number">27</span>: if_icmplt     <span class="number">13</span></span><br><span class="line">      30: getstatic     #25                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">33</span>: aload_1</span><br><span class="line">      34: invokevirtual #31                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      37: invokevirtual #35                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">40</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>13~27整个循环处理过程，只创建了一次对象。</p>
<h3 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h3><p>==在对字符串比较的时候，对比的是内存地址，而equals比较的是字符串内容，在开发的过程中，equals()通过接受参数，可以避免空指向<code>&quot;hello&quot;.equals(str)</code>。</p>
<h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>java中的String类是按照Unicode的方式进行编码，并且默认编码方式为UTF-16。使用字节的方式可以指定编码方式，以及编码方式的转换（<strong>转换不对会出现乱码问题</strong>）。并且不能的编码方式对应的数组长度不同。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String b = <span class="string">&quot;𝄞&quot;</span>;</span><br><span class="line">		System.out.println(b.length()); 	<span class="comment">//输出为2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过length的描述:知道返回的字符串长度时Unicode代码单元的数目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the length of this string.</span></span><br><span class="line"><span class="comment">    * The length is equal to the number of &lt;a href=&quot;Character.html#unicode&quot;&gt;Unicode</span></span><br><span class="line"><span class="comment">    * code units&lt;/a&gt; in the string.</span></span><br><span class="line"><span class="comment">    * 返回字符串的长度，长度等于字符串中的Unicode代码单元的数目（UTF-16的代码单元的数目）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the length of the sequence of characters represented by this</span></span><br><span class="line"><span class="comment">    *          object.</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>在java中的编码方式分为内码和外码：</p>
<ol>
<li>内码：char或string在内存中使用的编码方式，java中的使用utf16作为内码</li>
<li>外码：除内码都可以认为是外码，包括class文件的编码</li>
</ol>
<blockquote>
<p>代码单元：一种转换格式（UTF）中最小的一个分隔，称为一个代码单元（code unit），一个转换公式只会包含整数个单元。UTF-X中的X表示各自码单元的位数。<br>UTF-16，可以包含一个单元和两个单元，也就是两个字节和四个字节</p>
</blockquote>
<h4 id="替代方案：codePointCount"><a href="#替代方案：codePointCount" class="headerlink" title="替代方案：codePointCount"></a>替代方案：codePointCount</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the number of Unicode code points in the specified text</span></span><br><span class="line"><span class="comment">    * range of this &#123;<span class="doctag">@code</span> String&#125;. The text range begins at the</span></span><br><span class="line"><span class="comment">    * specified &#123;<span class="doctag">@code</span> beginIndex&#125; and extends to the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> char&#125; at index &#123;<span class="doctag">@code</span> endIndex - 1&#125;. Thus the</span></span><br><span class="line"><span class="comment">    * length (in &#123;<span class="doctag">@code</span> char&#125;s) of the text range is</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> endIndex-beginIndex&#125;. Unpaired surrogates within</span></span><br><span class="line"><span class="comment">    * the text range count as one code point each.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beginIndex the index to the first &#123;<span class="doctag">@code</span> char&#125; of</span></span><br><span class="line"><span class="comment">    * the text range.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> endIndex the index after the last &#123;<span class="doctag">@code</span> char&#125; of</span></span><br><span class="line"><span class="comment">    * the text range.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the number of Unicode code points in the specified text</span></span><br><span class="line"><span class="comment">    * range</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span> IndexOutOfBoundsException if the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> beginIndex&#125; is negative, or &#123;<span class="doctag">@code</span> endIndex&#125;</span></span><br><span class="line"><span class="comment">    * is larger than the length of this &#123;<span class="doctag">@code</span> String&#125;, or</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> beginIndex&#125; is larger than &#123;<span class="doctag">@code</span> endIndex&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">    * 可以使用该方法返回字符串的准确长度（相对于length方法）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span> || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7689974.html#_lab2_0_1">Java常用类（二）String类详解</a></li>
<li><a href="https://blog.csdn.net/qq_34691713/article/details/92572843">String源码分析（基于JDK1.8)</a></li>
<li><a href="https://www.cnblogs.com/benbenalin/p/7152570.html">刨根究底字符编码之十四——UTF-16究竟是怎么编码的</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾收集器与内存分配策略</title>
    <url>/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="对象已死"><a href="#对象已死" class="headerlink" title="对象已死"></a>对象已死</h2><h3 id="引用计数算法（reference-counting）"><a href="#引用计数算法（reference-counting）" class="headerlink" title="引用计数算法（reference-counting）"></a>引用计数算法（reference-counting）</h3><p><strong>定义</strong>：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p><strong>缺点</strong>：无法简单的处理对象循环引用</p>
<div align="center">

<img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%BC%95%E7%94%A8%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95.png" class title="引用计算算法">

</div>

<h3 id="可达性算法（GC-Roots-Tracing）"><a href="#可达性算法（GC-Roots-Tracing）" class="headerlink" title="可达性算法（GC Roots Tracing）"></a>可达性算法（GC Roots Tracing）</h3><p><strong>定义</strong>：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<a id="more"></a>

<div align="center">

<img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png" class title="可达性算法">

</div>

<h4 id="GCRoot对象"><a href="#GCRoot对象" class="headerlink" title="GCRoot对象"></a>GCRoot对象</h4><ol>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（StringTable）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<h4 id="对象死亡"><a href="#对象死亡" class="headerlink" title="对象死亡"></a>对象死亡</h4><div align="center">

<img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB.png" class title="对象已死">

</div>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><strong>定义</strong>：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>在程序代码之中普遍存在的，类似<code>Object obj = new Object()</code>这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象；</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>描述一些还有用但非必需的对象。对于软引用关联着的对象，<strong>在系统将要发生内存溢出异常之前</strong>，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常；</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象；</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知；</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>废弃常量和无用的类</strong>。</p>
<h4 id="回收废弃常量"><a href="#回收废弃常量" class="headerlink" title="回收废弃常量"></a>回收废弃常量</h4><ol>
<li>与Java堆中的对象回收类似</li>
<li>举例：字符串常量“java”，如果jvm中没有其他地方引用这个字面量并且没有任何字符串对象已用这个常量；jvm有可能会把该常量移除常量池</li>
<li>类（接口）、方法、自动的符号引用类似</li>
</ol>
<h4 id="如何判断一个类是否是无用的类"><a href="#如何判断一个类是否是无用的类" class="headerlink" title="如何判断一个类是否是无用的类"></a>如何判断一个类是否是无用的类</h4><ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li>
<li>加载该类的<strong>ClassLoader</strong>已经被回收；</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；</li>
</ol>
<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是可以，而并不是和对象一样，不使用了就必然会回收。</p>
<blockquote>
<p>关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p>
</blockquote>
<h2 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h2><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">GC类型</th>
    <th class="tg-0lax">触发条件</th>
    <th class="tg-0lax">触发时发生的事情</th>
    <th class="tg-0lax">注意</th>
    <th class="tg-0lax">查看方式</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>YGC&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>eden空间不足&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">清空eden+from survivor中的所有no ref对象占用的内存<br>将eden+from survivor中所有存活的对象copy到to survivor中<br>一些对象升级到old中：to survivor放不下、存储次数超过turing threshold<br>重新计算tenuring threshold(serial parallel   GC会触发此项)<br>重新调整Eden 和from的大小(parallel GC会触发此项)   </td>
    <td class="tg-0lax">全部暂停应用<br>是否为多线程处理由具体的GC决定   </td>
    <td class="tg-0lax">jstat -gcutil<br>gc log   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>FGC&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">old空间不足<br>perm空间不足<br>显示调用System.GC，RMI等定时触发<br>YGC的悲观策略<br>Dump live内存信息时（jmap   -dump:live）   </td>
    <td class="tg-0lax">清空heap中的no ref的对象<br>permgen中已经呗卸载的classloader中加载的class信息<br>如果配置了CollectGenOFirst/ScavengeBeforeFullGC，则先触发YGC（针对serival GC）   </td>
    <td class="tg-0lax">全部暂停应用<br>是否为多线程处理由具体的GC决定<br>是否压缩需要看配置的具体GC   </td>
    <td class="tg-0lax">jstat -gcutil<br>gc log   </td>
  </tr>
</tbody>
</table>

<p>permanent generation空间不足会引发Full GC,仍然不够会引发PermGen Space错误。</p>
<h3 id="GC信息的选项"><a href="#GC信息的选项" class="headerlink" title="GC信息的选项"></a>GC信息的选项</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails 显示GC的详细信息</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime 打印应用执行的时间</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime 打印应用被暂停的时间</span><br></pre></td></tr></table></figure>
<h2 id="垃圾收集器整体介绍"><a href="#垃圾收集器整体介绍" class="headerlink" title="垃圾收集器整体介绍"></a>垃圾收集器整体介绍</h2><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-z9od{font-size:12px;text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 791px">
<colgroup>
<col style="width: 82px">
<col style="width: 218px">
<col style="width: 250px">
<col style="width: 241px">
</colgroup>
<thead>
  <tr>
    <th class="tg-z9od"><span style="font-weight:bold">类别</span></th>
    <th class="tg-z9od"><span style="font-weight:bold">Serial collector串行</span></th>
    <th class="tg-z9od"><span style="font-weight:bold">Parallel</span>&nbsp;&nbsp;<span style="font-weight:bold">Collector并行</span><br><span style="font-weight:bold">（throughput collector</span></th>
    <th class="tg-z9od"><span style="font-weight:bold">Concurrent&nbsp;&nbsp;&nbsp;collector并发</span><br><br><span style="font-weight:bold">（concurrent low pause collector）</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-z9od">   <br>介绍   </td>
    <td class="tg-z9od">单线程收集器<br>使用单线程完成所有的gc工作，没有线程间的通信，这种方式会相对较高效&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">并行收集器<br>使用多线程的方式，利用多CPU来提高GC的效率，主要以达到<span style="color:red">一定的吞吐量</span>为目标&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">并发收集器<br>使用多线程的方式，利用多CPU来提高GC的效率<span style="color:red">并发</span>完成大部分工作，提高gc&nbsp;&nbsp;&nbsp;pause&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-z9od">使用场景&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">单处理器且没有pause time的要求&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">科学计算和后台处理有中规模/大规模数据集大小的应用且运行在多个处理器上，<span style="color:red">关注吞吐量（throughput）</span>&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">中规模/大规模数据集大小的应用，应用服务，电信领域。<span style="color:red">关注响应时间</span>&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-z9od">&nbsp;&nbsp;&nbsp;<br>使用&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">Client模式下默认<br>可使用-XX:UseSerialGC强制使用<br>优点：对server应用没有优点<br>缺点：不能充分使用硬件资源&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">Server模式下默认 <br>--YGC:PS&nbsp;&nbsp;&nbsp;FGC:Parallel MSC <br>可用-XX:+UseParallelGC或-XX+UseParallelOldGC强制指定<br>--ParallelGC代表FGC为Parallel MSC<br>--ParallelOldGC代表FGC为Parallel Compacting<br>优点:高效<br>缺点:当heap变大后,造成的暂停时间会变得比较长</td>
    <td class="tg-z9od">可用-XX:+UseConcMarkSweepGC强制指定<br>优点:<br>对old进行回收时,对应用造成的暂停时间非常短,适合对latency要求比较高的应用<br>缺点:<br>1.内存碎片和浮动垃圾<br>2.old去的内存分配效率低<br>3.回收的整个耗时比较长<br>4.和应用争抢CPU&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-z9od">   <br>内存回收触发   </td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>eden空间不足<br><span style="font-weight:bold">FGC</span><br>old空间不足<br>perm空间不足<br>显示调用System.gc()&nbsp;&nbsp;&nbsp;,包括RMI等的定时触发<br>YGC时的悲观策略<br>dump live的内存信息时(jmap&nbsp;&nbsp;&nbsp;–dump:live)&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>eden空间不足<br><span style="font-weight:bold">FGC</span><br>old空间不足<br>perm空间不足<br>显示调用System.gc()&nbsp;&nbsp;&nbsp;,包括RMI等的定时触发<br>YGC时的悲观策略--YGC前&amp;YGC后<br>dump live的内存信息时(jmap&nbsp;&nbsp;&nbsp;–dump:live)&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>eden空间不足<br><span style="font-weight:bold">CMS GC</span><br>1.old Gen的使用率大于一定的比率 默认为92%<br>2.配置了CMSClassUnloadingEnabled,且Perm Gen的使用达到一定的比率 默认为92%<br>3.Hotspot自己根据估计决定是否要触法<br>4.在配置了ExplictGCInvokesConcurrent的情况下显示调用了System.gc.<br>Full GC(Serial MSC)<br>promotion failed 或 concurrent&nbsp;&nbsp;&nbsp;Mode Failure时;&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-z9od">   <br>发生的事情   </td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>eden空间不足<br><span style="font-weight:bold">FGC</span><br>old空间不足<br>perm空间不足<br>显示调用System.gc()&nbsp;&nbsp;&nbsp;,包括RMI等的定时触发<br>YGC时的悲观策略<br>dump live的内存信息时(jmap&nbsp;&nbsp;&nbsp;–dump:live)&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>同serial动作基本相同,不同点:<br>1.多线程处理<br>2.YGC的最后不仅重新计算Tenuring&nbsp;&nbsp;&nbsp;Threshold,还会重新调整Eden和From的大小<br><span style="font-weight:bold">FGC</span><br>1.如配置了ScavengeBeforeFullGC(默认),则先触发YGC(??)<br>2.MSC:清空heap中的no ref对象,permgen中已经被卸载的classloader中加载的class信息,并进行压缩<br>3.Compacting:清空heap中部分no ref的对象,permgen中已经被卸载的classloader中加载的class信息,并进行部分压缩<br>多线程做以上动作.&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od"><span style="font-weight:bold">YGC</span><br>同serial动作基本相同,不同点:<br>1.多线程处理<br><span style="font-weight:bold">CMSGC</span>:<br>1.old gen到达比率时只清除old&nbsp;&nbsp;&nbsp;gen中no ref的对象所占用的空间<br>2.perm gen到达比率时只清除已被清除的classloader加载的class信息<br><span style="font-weight:bold">FGC</span><br>同serial&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-z9od">   <br>细节参数   </td>
    <td class="tg-z9od">可用-XX:+UseSerialGC强制使用<br>-XX:SurvivorRatio=x,控制eden/s0/s1的大小<br>-XX:MaxTenuringThreshold,用于控制对象在新生代存活的最大次数<br>-XX:PretenureSizeThreshold=x,控制超过多大的字节的对象就在old分配.&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od"><span style="font-weight:bold">-</span>XX:SurvivorRatio=x,控制eden/s0/s1的大小<br>-XX:MaxTenuringThreshold,用于控制对象在新生代存活的最大次数<br>-XX:UseAdaptiveSizePolicy 去掉YGC后动态调整eden from已经tenuringthreshold的动作<br>-XX:ParallelGCThreads&nbsp;&nbsp;&nbsp;设置并行的线程数&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-z9od">-XX:CMSInitiatingOccupancyFraction 设置old gen使用到达多少比率时触发<br>-XX:CMSInitiatingPermOccupancyFraction,设置Perm Gen使用到达多少比率时触发<br>-XX:+UseCMSInitiatingOccupancyOnly禁止hostspot自行触发CMS GC&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 776px">
<colgroup>
<col style="width: 130px">
<col style="width: 646px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"><span style="font-weight:bold">算法</span></th>
    <th class="tg-0lax"><span style="font-weight:bold">说明</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>标记-清除&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">
    基础算法（以下算法以此为基础）<br>
    标记：标记出所有需要回收的对象<br>
    回收：回收掉所有被标记的对象<br>
    缺点：效率太低；出现大量碎片后，无法分配大的对象<br>   
    <img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" class title="标记-清除算法">
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>复制&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">
    内存空间平均分成两块，每次使用其中一块<br>
    优点：不用考虑内存碎片；实现简单，效率高<br>
    缺点：浪费内存；长时间存活的对象复制效率低  <br> 
    <img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" class title="复制算法">
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>标记-压缩&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">
    标记过程与“标记-清除”算法一样<br>
    回收：存活对象移动到另一端，然后直接清理另一端的内存<br>  
    <img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.png" class title="标记-压缩算法"> 
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>分代收集&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">
    假设：<span style="color:red">绝大部分对象的生命周期都非常短暂，存活时间短</span><br>
    把Java堆分为新生代和老年代，采用同的回收算法<br>
    新生代：复制算法（大量死去，少量存活）<br>
    老年代：“标记-压缩-清除”（存活率高，没有额外空间复制）<br>
    <img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%BB%93%E6%9E%84.png" class title="分代收集结构"> 
    </td>
  </tr>
</tbody>
</table>

<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 799px">
<colgroup>
<col style="width: 149px">
<col style="width: 650px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"><span style="font-weight:bold">收集器</span><br></th>
    <th class="tg-0lax"><span style="font-weight:bold">说明</span><br></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>Serial收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">
    最基础、最古老的简单高效收集器；<br>
    单线程收集，暂停其他所有工作线程（JVM后台完成，STW）<br>
    <span style="color:red">新生代：复制算法</span><br>
    适用于客户端模式<br>
    -XX:+UseSerialGC  串行收集器   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>ParNew收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">
    Serial收集器的多线程并行版本<br>
    <span style="color:red">新生代：复制算法</span><br>
    -XX:+UseParNewGC  ParNew收集器<br>
    -XX:ParallelGCThreads   限制线程数量   </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>Parallel Scavenge收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">
    <span style="color:red">类似ParNew，Parallel收集器更关注系统的吞吐量（通过参数动态调整）</span><br>
    吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）<br>
    <span style="color:red">新生代：复制算法</span><br>
    -XX:+UseParallelGC<br>
    -XX：MaxGCPauseMillis 最大垃圾收集停顿时间<br>
    -XX：GCTimeRatio 吞吐量大小<br>
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>Parallel&nbsp;&nbsp;&nbsp;Old 收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">Parallel Scavenge收集器的老年代版本，使用多线程和“<span style="color:red">标记－整理</span>”算法。<br>
    JDK 1.6中才开始提供<br>
    -XX:+UseParallelOldGC <br></td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>CMS收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">特点：<br>
    1. <span style="color:red">一种以获取最短回收停顿时间为目标的收集器</span><br>
    2. <span style="color:red">基于标记-清除算法</span><br>
    3. <span style="color:red">顶一个真正意义的并发收集器（回收和用户线程同时工作）</span><br>
   <span style="font-weight:bold">收集步骤：</span><br>
   1. 初始标记（CMS initial mark）：会出现短暂SWT，标记GC Roots能直接关联到的对象<br>
   2. 并发标记（CMS concurrent mark）：执行GC Root Tracing<br>
   3. 重新标记（CMS remark）：出现SWT（稍长），修正并发标记中由于用户程序执行产生变动的对象<br>
   4. 并发清除（CMS concurrent sweep）：开启用户线程，同时GC线程开始对标记的区域做清扫<br>
优点：并发收集、低停顿<br>
缺点：<br>
1. 对CPU资源敏感<br>
2. 无法处理浮动垃圾（Floating Garbage）；<br>
3. 基于标记-清除算法实现的收集器，这意味着收集结束时会有大量空间碎片产生<br>
  </td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;<br>G1收集器&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">
    一种面向服务端应用的收集器，对于多CPU和大内存的机器可以极高满足停顿时间和吞吐量<br>
    特点：<br>
    1. <span style="color:red">并行与并发：充分利用CPU，基于多核硬件缩短SWT</span><br>
    2. <span style="color:red">分代收集：管理整个GC堆，但保留了分代收集的概念</span><br>
    3. <span style="color:red">空间整合：整体上基于标记-整理算法，局部上基于复制算法，无碎片化</span><br>
    4. <span style="color:red">可预测的停顿：建立可预测的停顿时间模型，便于使用者指定停顿时间</span><br>
   
G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。<br>
   
   <span style="font-weight:bold">收集步骤：</span><br>
1. 初始标记（Initial Marking）：标记GC Roots直接关联对象，修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象；借用Minor GC的时候同步完成短暂停顿<br>
2. 并发标记（Concurrent Marking）：对象可达性分析，找出需要回收的对象，这阶段耗时较长，但可与用户程序并发执行处理完成后，需要重新处理SATB记录下的在并发时有引用变动的对象。<br>
3. 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。<br>
4. 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。<br>
  </td></tr>
</tbody>
</table>

<h2 id="收集器组合"><a href="#收集器组合" class="headerlink" title="收集器组合"></a>收集器组合</h2><div align="center">

<img src="/2021/02/18/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88.png" class title="JVM垃圾收集器组合">

</div>

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-rz5g{background-color:#92D050;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 819px">
<colgroup>
<col style="width: 142px">
<col style="width: 137px">
<col style="width: 540px">
</colgroup>
<thead>
  <tr>
    <th class="tg-rz5g"><span style="font-weight:bold">YGC</span></th>
    <th class="tg-rz5g"><span style="font-weight:bold">FGC</span></th>
    <th class="tg-rz5g"><span style="font-weight:bold">说明</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">Serial   </td>
    <td class="tg-0lax">Serial   Old   </td>
    <td class="tg-0lax">Serial和Serial   Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td>
  </tr>
  <tr>
    <td class="tg-0lax">Serial   </td>
    <td class="tg-0lax">CMS+Serial   Old   </td>
    <td class="tg-0lax">CMS（Concurrent Mark   Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。   </td>
  </tr>
  <tr>
    <td class="tg-0lax">ParNew   </td>
    <td class="tg-0lax">CMS   </td>
    <td class="tg-0lax">使用-XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。<br>如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew   GC策略。   </td>
  </tr>
  <tr>
    <td class="tg-0lax">ParNew   </td>
    <td class="tg-0lax">Serial   Old   </td>
    <td class="tg-0lax">使用-XX:+UseParNewGC选项来开启。新生代使用ParNew   GC策略，年老代默认使用Serial Old GC策略。   </td>
  </tr>
  <tr>
    <td class="tg-0lax">Parallel   Scavenge  </td>
    <td class="tg-0lax">Serial   Old   </td>
    <td class="tg-0lax">Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间   / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。   </td>
  </tr>
  <tr>
    <td class="tg-0lax">Parallel   Scavenge </td>
    <td class="tg-0lax">Parallel   Old   </td>
    <td class="tg-0lax">Parallel Old是Serial Old的并行版本   </td>
  </tr>
  <tr>
    <td class="tg-0lax">G1GC   </td>
    <td class="tg-0lax">G1GC   </td>
    <td class="tg-0lax">-XX:+UnlockExperimentalVMOptions   -XX:+UseG1GC        #开启<br>-XX:MaxGCPauseMillis   =50                  #暂停时间目标<br>-XX:GCPauseIntervalMillis   =200          #暂停间隔目标<br>-XX:+G1YoungGenSize=512m            #年轻代大小<br>-XX:SurvivorRatio=6                            #幸存区比例   </td>
  </tr>
</tbody>
</table>

<h2 id="如何选择收集器"><a href="#如何选择收集器" class="headerlink" title="如何选择收集器"></a>如何选择收集器</h2><ol>
<li>app运行在单处理器机器上且没有pause time的要求，让vm选择UseSerialGC.</li>
<li>重点考虑peak application performance(高性能)，没有pause time太严格要求，让vm选择或者UseParallelGC+UseParallelOldGC(optionally).</li>
<li>重点考虑response time,pause time要小，UseConcMarkSweepGC.</li>
<li>默认情况下，<strong>JDK5.0以前都是使用串行收集器</strong>，如果需要使用其他收集器需要在启动的是时候加入相应的参数。JDK5.0以后，JVM会根据当前系统的配置进行判断。</li>
</ol>
<p><strong>并行</strong>：指多条垃圾收集器线程并行工作，但此时仍是“Stop The World”状态，即用户线程处于等待状态；<br><strong>并发</strong>：指用户线程和垃圾收集线程同时执行（不一定是并行的，很有可能是线程交替运行），用户线程继续运行，而垃圾收集程序运行在另一个CPU上。</p>
<h3 id="吞吐量优先的并行收集器"><a href="#吞吐量优先的并行收集器" class="headerlink" title="吞吐量优先的并行收集器"></a>吞吐量优先的并行收集器</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>并行收集器主要以达到一定的吞吐量为目标，适用于科学技术和后台处理。分为两种：</p>
<ol>
<li>并行收集器（-XX:+ UseParallelGC）在次要回收中使用多线程来执行，在主要回收中使用单线程执行；</li>
<li>并行旧生代收集器（Parallet Old Collection）(XX:+UseParallelOldGC),在次要回收和主要回收都使用多线程，当年老区填满后会触发主要回收</li>
</ol>
<h4 id="典型配置"><a href="#典型配置" class="headerlink" title="典型配置"></a>典型配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:UseParallelGC -XX:ParallelGCThreans = <span class="number">20</span></span><br><span class="line">java -Xmx3500m -Xms3500m -Xmn2g -Xss128k -XX:+UseparallelGC - XX:ParallelGCThreans = <span class="number">20</span> -XX:+UseParallelOldGC</span><br><span class="line">java -Xms3550m -Xmm3550m -Xmn2g -Xss128k -XX:+UseparallelGC -XX:MaxGCPauseMillis = <span class="number">100</span></span><br><span class="line">java -Xms3550m -Xmm3550m -Xmn2g -Xss128k -XX:+UseparallelGC -XX:MaxGCPauseMillis = <span class="number">100</span> -XX:+UseAdaptiveSizePolicy</span><br></pre></td></tr></table></figure>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 808px">
<colgroup>
<col style="width: 214px">
<col style="width: 594px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"><span style="font-weight:bold">参数</span></th>
    <th class="tg-0lax"><span style="font-weight:bold">说明</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-Xmx3800m</span>   </td>
    <td class="tg-0lax">最大堆大小   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-Xms3800m</span>   </td>
    <td class="tg-0lax">初始堆大小,此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-Xmn2g</span>   </td>
    <td class="tg-0lax">设置<span style="color:red">年轻</span>代大小为2G。<span style="font-weight:bold;color:red">整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小</span>。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-Xss128k</span>   </td>
    <td class="tg-0lax">设置每个线程的<span style="color:red">堆栈大小</span>。JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。<span style="font-weight:bold;color:red">在相同物理内存下，减小这个值能生成更多的线程</span>。但是操作系统对一个进程内的线程数还是有限制的，<br>不能无限生成，经验值在3000~5000左右。   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:+UseParallelGC</span>   </td>
    <td class="tg-0lax">选择垃圾收集器为并行收集器。<span style="font-weight:bold;color:red">此配置仅对年轻代有效</span>。即该配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:ParallelGCThreans = 20</span>   </td>
    <td class="tg-0lax">配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。<span style="font-weight:bold;color:red">此值的配置最好与处理器数目相等</span>。   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:+UseParallelOldGC</span>   </td>
    <td class="tg-0lax">配置老年代垃圾收集器为并行收集。JDK6.0支持对老年代并行收集   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:MaxGCPauseMillis = 100</span>   </td>
    <td class="tg-0lax">设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:+UseAdaptiveSizePolicy</span>   </td>
    <td class="tg-0lax">设置此项以后，并行收集器会自动选择年轻代大小和相应的Surivior区比例，以达到目标系统规定的最低响应时间或者收集频率等，<span style="color:red">此值建议使用并行收集器时一直打开</span>   </td>
  </tr>
</tbody>
</table>

<h3 id="响应时间优先并发收集器"><a href="#响应时间优先并发收集器" class="headerlink" title="响应时间优先并发收集器"></a>响应时间优先并发收集器</h3><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>并发收集器主要保证系统的响应时间，减少垃圾收集的停顿时间。适用于应用服务器、电信领域。<br>CMS（Concurrent Mark Sweep）并发标记清理收集器<br>CMS（-XX:+UseConcMarkSweepGC）收集器在老年代使用，专门收集那些在主要回收中不可能到达的年老对象。它与应用程序并发执行，在年老代保持一直有足够的空间以保证不会发生年轻代晋升失败。</p>
<h4 id="典型配置-1"><a href="#典型配置-1" class="headerlink" title="典型配置"></a>典型配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xmx3550m -Xmm3550m -Xmn2g -Xss128K -XX:ParallelGCThread = <span class="number">20</span> -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFULLGCsBeforCompaction=<span class="number">5</span> -XX:+UseCMSCompactAtFullCollection</span><br></pre></td></tr></table></figure>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-rz5g{background-color:#92D050;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 808px">
<colgroup>
<col style="width: 284px">
<col style="width: 524px">
</colgroup>
<thead>
  <tr>
    <th class="tg-rz5g">参数</th>
    <th class="tg-rz5g">说明<br></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:+UseConcMarkSweepGC</span>   <br></td>
    <td class="tg-0lax">设置年老代为并发收集   </td>
  </tr>
  <tr>
    <td class="tg-0lax">-<span style="font-weight:bold">XX:+UseParNewGC</span>   <br></td>
    <td class="tg-0lax">设置年轻代为并行收集。可以和CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行配置，所以无需再配置此值。   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:CMSFULLGCsBeforCompaction=5</span>   </td>
    <td class="tg-0lax">由于并发收集器不对内粗空间进行压缩、整理，所以运行一段时间会产生“碎片”，使得运行效率低。此值设置运行多少次GC以后对内训空间进行压缩、整理   </td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="font-weight:bold">-XX:+UseCMSCompactAtFullCollection</span>   </td>
    <td class="tg-0lax">打开对年老代的压缩。可能会影响性能，但是可以消除碎片   </td>
  </tr>
</tbody>
</table>

<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><h3 id="JAVA-OPTS"><a href="#JAVA-OPTS" class="headerlink" title="JAVA_OPTS"></a>JAVA_OPTS</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 749px">
<colgroup>
<col style="width: 170px">
<col style="width: 192px">
<col style="width: 122px">
<col style="width: 265px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"><span style="font-weight:bold">参数名称</span></th>
    <th class="tg-0lax"><span style="font-weight:bold">含义</span></th>
    <th class="tg-0lax"><span style="font-weight:bold">默认值</span></th>
    <th class="tg-0lax"><span style="background-color:#FFF">详细说明</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xms</span><br></td>
    <td class="tg-0lax"><span style="color:#333">初始堆大小</span><br></td>
    <td class="tg-0lax">物理内存的1/64(&lt;1GB)<br></td>
    <td class="tg-0lax">默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xmx</span><br></td>
    <td class="tg-0lax"><span style="color:#333">最大堆大小</span><br></td>
    <td class="tg-0lax">物理内存的1/4(&lt;1GB)<br></td>
    <td class="tg-0lax">默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xmn</span><br></td>
    <td class="tg-0lax">年轻代大小(1.4or lator)<br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"><span style="font-weight:bold">注意</span>：此处的大小是（eden+ 2 survivor space).与jmap   -heap中显示的New gen是不同的。<br><span style="background-color:red">整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.</span><br>增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:NewSize</span></td>
    <td class="tg-0lax">设置年轻代大小(for   1.3/1.4)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:MaxNewSize</span></td>
    <td class="tg-0lax">年轻代最大值(for 1.3/1.4)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:PermSize</span></td>
    <td class="tg-0lax">设置持久代(perm gen)初始值</td>
    <td class="tg-0lax">物理内存的1/64</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:MaxPermSize</span></td>
    <td class="tg-0lax"><span style="color:#333">设置持久代最大值</span></td>
    <td class="tg-0lax">物理内存的1/4</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xss</span><br></td>
    <td class="tg-0lax"><span style="color:#333">每个线程的堆栈大小</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K. 根据应用的线程所需内存大小进行   调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右<br>一般小的应用， 如果栈不是很深， 应该128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。<br>和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named   ThreadStackSize”. 一般设置128k或者256k这个值就可以了。</td>
  </tr>
  <tr>
    <td class="tg-0lax">-<span style="font-style:italic">XX:ThreadStackSize</span></td>
    <td class="tg-0lax"><span style="color:#333">Thread   Stack Size</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"><span style="color:#333">(0   means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in   5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and   earlier); all others 0.]</span></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:NewRatio</span></td>
    <td class="tg-0lax">年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5<br>Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:SurvivorRatio</span></td>
    <td class="tg-0lax">Eden区与Survivor区的大小比值<br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:LargePageSizeIn</span><br><span style="color:#333">Bytes</span></td>
    <td class="tg-0lax">内存页的大小不可设置过大， 会影响Perm的大小</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"><span style="color:#333">=128m</span><br></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseFastAccessor</span><br><span style="color:#333">Methods</span><br></td>
    <td class="tg-0lax"><span style="color:#333">原始类型的快速优化</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+DisableExplicitGC</span></td>
    <td class="tg-0lax">关闭System.gc()</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"><span style="color:#333">这个参数需要严格的测试</span></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:MaxTenuring</span><br><span style="color:#333">Threshold</span><br></td>
    <td class="tg-0lax"><span style="color:#333">垃圾最大年龄</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活   时间,增加在年轻代即被回收的概率<br>该参数只有在串行GC时才有效.</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+AggressiveOpts</span></td>
    <td class="tg-0lax"><span style="color:#333">加快编译</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseBiasedLocking</span></td>
    <td class="tg-0lax"><span style="color:#333">锁机制的性能改善</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xnoclassgc</span></td>
    <td class="tg-0lax"><span style="color:#333">禁用垃圾回收</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:SoftRefLRUPolicy</span><br><span style="color:#333">MSPerMB</span></td>
    <td class="tg-0lax">每兆堆空闲空间中SoftReference的存活时间</td>
    <td class="tg-0lax"><span style="color:#333">1s</span><br></td>
    <td class="tg-0lax"><span style="color:#333">softly   reachable objects will remain alive for some amount of time after the last   time they were referenced. The default value is one second of lifetime per   free megabyte in the heap</span></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:PretenureSize</span><br><span style="color:#333">Threshold</span></td>
    <td class="tg-0lax"><span style="color:#333">对象超过多大是直接在旧生代分配</span><br></td>
    <td class="tg-0lax"><span style="background-color:#FFF">0</span></td>
    <td class="tg-0lax">单位字节 新生代采用Parallel   Scavenge GC时无效<br>另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:TLABWasteTarget</span><br><span style="color:#333">Percent</span><br></td>
    <td class="tg-0lax">TLAB占eden区的百分比<br></td>
    <td class="tg-0lax"><span style="color:#333">1%</span><br></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+</span><span style="font-style:italic">CollectGen0First</span></td>
    <td class="tg-0lax">FullGC时是否先YGC</td>
    <td class="tg-0lax"><span style="color:#333">false</span></td>
    <td class="tg-0lax"></td>
  </tr>
</tbody>
</table>

<h3 id="并行收集器相关参数设置"><a href="#并行收集器相关参数设置" class="headerlink" title="并行收集器相关参数设置"></a>并行收集器相关参数设置</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 814px">
<colgroup>
<col style="width: 190px">
<col style="width: 186px">
<col style="width: 53px">
<col style="width: 385px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax">参数</th>
    <th class="tg-0lax">说明</th>
    <th class="tg-0lax">默认值</th>
    <th class="tg-0lax">详细说明</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseParallelGC</span></td>
    <td class="tg-0lax">Full GC采用parallel MSC<br>(此项待验证)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseParNewGC</span></td>
    <td class="tg-0lax"><span style="color:#333">设置年轻代为并行收集</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">可与CMS收集同时使用<br>JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:ParallelGCThreads</span><br></td>
    <td class="tg-0lax"><span style="color:#333">并行收集器的线程数</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">此值最好配置与处理器数目相等 同样适用于CMS</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseParallelOldGC</span></td>
    <td class="tg-0lax">年老代垃圾收集方式为并行收集(Parallel   Compacting)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">这个是JAVA 6出现的参数选项</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:MaxGCPauseMillis</span></td>
    <td class="tg-0lax">每次年轻代垃圾回收的最长时间(最大暂停时间)</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseAdaptiveSizePolicy</span></td>
    <td class="tg-0lax">自动选择年轻代区大小和相应的Survivor区比例</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:GCTimeRatio</span></td>
    <td class="tg-0lax"><span style="color:#333">设置垃圾回收时间占程序运行时间的百分比</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">公式为1/(1+n)<br></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+</span><span style="font-style:italic">ScavengeBeforeFullGC</span></td>
    <td class="tg-0lax">Full GC前调用YGC</td>
    <td class="tg-0lax"><span style="color:#333">true</span></td>
    <td class="tg-0lax"><span style="color:#333">Do   young generation GC prior to a full GC. (Introduced in 1.4.1.)</span></td>
  </tr>
</tbody>
</table>

<h3 id="CMS相关参数设置"><a href="#CMS相关参数设置" class="headerlink" title="CMS相关参数设置"></a>CMS相关参数设置</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 777px">
<colgroup>
<col style="width: 210px">
<col style="width: 165px">
<col style="width: 53px">
<col style="width: 349px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax">参数</th>
    <th class="tg-0lax">说明</th>
    <th class="tg-0lax">默认值</th>
    <th class="tg-0lax">详细说明</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseConcMarkSweepGC</span><br></td>
    <td class="tg-0lax">使用CMS内存收集<br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.???</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+AggressiveHeap</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"><span style="color:#333">试图是使用大量的物理内存</span><br><span style="color:#333">长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）</span><br>至少需要256MB内存<br>大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:CMSFullGCsBefore</span><br><span style="color:#333">Compaction</span></td>
    <td class="tg-0lax"><span style="color:#333">多少次后进行内存压缩</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生"碎片",使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+CMSParallelRemark</span><br><span style="color:#333">Enabled</span></td>
    <td class="tg-0lax"><span style="color:#333">降低标记停顿</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX+UseCMSCompact</span><br><span style="color:#333">AtFullCollection</span></td>
    <td class="tg-0lax">在FULL GC的时候， 对年老代的压缩</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">CMS是不会移动内存的， 因此，   这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。<br>可能会影响性能,但是可以消除碎片</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+UseCMSInitiating</span><br><span style="color:#333">OccupancyOnly</span></td>
    <td class="tg-0lax">使用手动定义初始化定义开始CMS收集</td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">禁止hostspot自行触发CMS GC</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:CMSInitiating</span><br><span style="color:#333">OccupancyFraction=70</span></td>
    <td class="tg-0lax">使用cms作为垃圾回收<br>使用70％后开始CMS收集</td>
    <td class="tg-0lax"><span style="color:#333">92</span></td>
    <td class="tg-0lax"><span style="color:#333">为了保证不出现promotion   failed(见下面介绍)错误,该值的设置需要满足以下公式</span><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html#CMSInitiatingOccupancyFraction_value" target="_blank" rel="noopener noreferrer"><span style="font-weight:bold">CMSInitiatingOccupancyFraction计算公式</span></a></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:CMSInitiating</span><br><span style="color:#333">PermOccupancyFraction</span></td>
    <td class="tg-0lax">设置Perm Gen使用到达多少比率时触发<br></td>
    <td class="tg-0lax"><span style="color:#333">92</span><br></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+CMSIncrementalMode</span></td>
    <td class="tg-0lax"><span style="color:#333">设置为增量模式</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">用于单CPU情况</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+CMSClassUnloading</span><br><span style="color:#333">Enabled</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
</tbody>
</table>

<h3 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 761px">
<colgroup>
<col style="width: 188px">
<col style="width: 188px">
<col style="width: 385px">
</colgroup>
<thead>
  <tr>
    <th class="tg-0lax"><span style="color:#333">-XX:+PrintGC</span></th>
    <th class="tg-0lax"></th>
    <th class="tg-0lax">输出形式:<br><span style="color:#333">[GC   118250K-&gt;113543K(130112K), 0.0094143 secs]</span><br><span style="color:#333">[Full   GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintGCDetails</span><br></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">输出形式:[GC [DefNew:   8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K),   0.0124633 secs]<br><span style="color:#333">[GC   [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured:   112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K),   0.0436268 secs]</span></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintGCTimeStamps</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintGC:PrintGCTime</span><br><span style="color:#333">Stamps</span></td>
    <td class="tg-0lax"></td>
    <td class="tg-0lax">可与-XX:+PrintGC   -XX:+PrintGCDetails混合使用<br>输出形式:11.851: [GC   98328K-&gt;93620K(130112K), 0.0082960 secs]</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintGCApplication</span><br><span style="color:#333">StoppedTime</span></td>
    <td class="tg-0lax">打印垃圾回收期间程序暂停的时间.可与上面混合使用</td>
    <td class="tg-0lax">输出形式:Total time for   which application threads were stopped: 0.0468229 seconds<br></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintGCApplication</span><br><span style="color:#333">ConcurrentTime</span></td>
    <td class="tg-0lax">打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td>
    <td class="tg-0lax">输出形式:Application   time: 0.5291524 seconds</td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintHeapAtGC</span></td>
    <td class="tg-0lax">打印GC前后的详细堆栈信息</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-Xloggc:filename</span></td>
    <td class="tg-0lax">把相关日志信息记录到文件以便分析.<br><span style="color:#333">与上面几个配合使用</span></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintClassHistogram</span></td>
    <td class="tg-0lax"><span style="color:#333">garbage   collects before printing the histogram.</span></td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="color:#333">-XX:+PrintTLAB</span></td>
    <td class="tg-0lax">查看TLAB空间的使用情况</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax"><span style="background-color:#FFF">-</span><span style="color:#333">XX:+PrintTenuring</span><br><span style="color:#333">Distribution</span></td>
    <td class="tg-0lax">查看每次minor GC后新的存活周期的阈值<br></td>
    <td class="tg-0lax"><span style="color:#333">Desired   survivor size 1048576 bytes, new threshold 7 (max 15)</span><br>new threshold 7即标识新的存活周期的阈值为7。</td>
  </tr>
</tbody>
</table>

<h2 id="调优技巧"><a href="#调优技巧" class="headerlink" title="调优技巧"></a>调优技巧</h2><h3 id="年轻代大小选择"><a href="#年轻代大小选择" class="headerlink" title="年轻代大小选择"></a>年轻代大小选择</h3><ol>
<li><strong>响应时间优先的应用</strong>：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象</li>
<li><strong>吞吐量优先的应用</strong>：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用</li>
</ol>
<h3 id="年老代大小选择"><a href="#年老代大小选择" class="headerlink" title="年老代大小选择"></a>年老代大小选择</h3><ol>
<li><p><strong>响应时间优先的应用</strong>：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</p>
<ul>
<li>并发垃圾收集信息</li>
<li>持久代并发收集次数</li>
<li>传统GC信息</li>
<li>花在年轻代和年老代回收上的时间比例</li>
<li>减少年轻代和年老代花费的时间，一般会提高应用的效率</li>
</ul>
</li>
<li><p><strong>吞吐量优先的应用</strong>：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="较小堆引起的碎片问题"><a href="#较小堆引起的碎片问题" class="headerlink" title="较小堆引起的碎片问题"></a>较小堆引起的碎片问题</h4><p>因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：<code>-XX:+UseCMSCompactAtFullCollection</code>：使用并发收集器时，开启对年老代的压缩。<code>-XX:CMSFullGCsBeforeCompaction=0：</code>上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</p>
<h2 id="HotSpot算法实现细节"><a href="#HotSpot算法实现细节" class="headerlink" title="HotSpot算法实现细节"></a>HotSpot算法实现细节</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>可作为GC Roots节点的主要数据为：</p>
<ol>
<li>全局引用：如常量或类静态属性</li>
<li>执行上线文：如栈帧中的本地变量表</li>
</ol>
<p>所有的收集器在收集GC Roots可达对象时都会出现SWT；在Hotspot中使用OopMap（记录了在该类型的对象内什么偏移量上是什么类型的数据）结构可以指导在那些地方存放着对象的引用，这样可以减少停顿时间（不需要重头到尾的扫描）。</p>
<blockquote>
<p>每个被JIT编译过后的方法也会在一些特定的位置记录下OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用。这样GC在扫描栈的时候就会查询这些OopMap就知道哪里是引用了。这些特定的位置(safepoint)主要在：<br>1、循环的末尾<br>2、方法临返回前 / 调用方法的call指令后<br>3、可能抛异常的位置</p>
</blockquote>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>安全点（Safepoint）。有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。生成OopMap的地方。到达安全点的方法：</p>
<ol>
<li>抢先式中断：垃圾收集时触发，中断全部用户线程，如果发现用户线程不在安全点上，就恢复该线程执行，之后在重新中断，直到在安全点上。很少有收集器使用该方式。</li>
<li>主动式中断：收集器需要中断时，只是记录一个标志位，各个线程在执行过程中会不停的主动轮询这个标志，一旦发现为真就自己在最近的安全点上主动中断挂起。Hotspot使用内存保护陷阱的方式（精简至一条汇编指令），提高轮询的效率。</li>
</ol>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>当线程处于sleep或阻塞状态时，自己无法中断自己达到安全点；为了解决这个问题引入安全区域。安全区域是指能够确保在某一段代码片段中，引用关系不发生变化。处理过程如下：</p>
<ol>
<li>用户线程执行到安全区域时，标识自己进入安全区域</li>
<li>垃圾回收时不处理该区域的数据</li>
<li>线程离开安全区域时，首先检测JVM是否完成根节点枚举，如果完成则线程继续执行，否则一直等待直到可以离开安全区域</li>
</ol>
<h3 id="记忆卡与卡表"><a href="#记忆卡与卡表" class="headerlink" title="记忆卡与卡表"></a>记忆卡与卡表</h3><ol>
<li>在新生代中建立记忆卡，避免整个老年代加入GC Roots扫描（跨代引用）</li>
<li>记忆卡是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</li>
<li>字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）</li>
<li>一个卡页中可能会包含多个对象，只要存在一个对象引用则记录为脏页；来及回收时只需要把脏页加入GC Roots中扫描即可</li>
</ol>
<h3 id="写屏障（卡表原始维护）"><a href="#写屏障（卡表原始维护）" class="headerlink" title="写屏障（卡表原始维护）"></a>写屏障（卡表原始维护）</h3><ol>
<li>变脏的时间点：引用类型赋值的那一刻</li>
<li>Hotspot中使用写屏障维护卡表的状态，在虚拟机层面对引用类型字段赋值的AOP切面</li>
<li>伪共享：当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低</li>
<li>解决伪共享：不采用无条件的写屏障，需要先检查卡表记录，只有未标记时才标记为脏</li>
<li>-XX：+UseCondCardMark：是否开启卡表更新的条件判断</li>
</ol>
<h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><p>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行。</p>
<p>是否可达的三色法（灰色对象是黑色对象与白色对象之间的中间态）：</p>
<ol>
<li>白色：尚未被垃圾收集器访问过；初始状态都是白色；如果分析结束后还是白色则表示不可达</li>
<li>黑色：已经被访问过且所有引用都被访问过；如果有其它的对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li>
<li>灰色：表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过。</li>
</ol>
<h4 id="对象消失的问题"><a href="#对象消失的问题" class="headerlink" title="对象消失的问题"></a>对象消失的问题</h4><p>产生条件：</p>
<ol>
<li>条件一：赋值器插入了一条或者多条从黑色对象到白色对象的新引用。</li>
<li>条件二：赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ol>
<p>解决方式：</p>
<p>增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）；CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/parryyang/p/5750146.html">Java GC收集器配置说明</a></li>
<li><a href="https://www.cnblogs.com/ityouknow/p/5614961.html">GC算法 垃圾收集器</a></li>
<li><a href="https://segmentfault.com/a/1190000020483916">垃圾收集器与内存分配策略</a></li>
<li><a href="https://www.cnblogs.com/thisiswhy/p/12354864.html">面试官:你说你熟悉jvm?那你讲一下并发的可达性分析</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>垃圾收集器</tag>
        <tag>内存分配策略</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之备份与恢复</title>
    <url>/2021/02/04/MySQL%E4%B9%8B%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="备份的目的"><a href="#备份的目的" class="headerlink" title="备份的目的"></a>备份的目的</h3><ol>
<li>做灾难恢复：对损坏的数据进行恢复和还原</li>
<li>需求改变：因需求改变而需要把数据还原到改变以前</li>
<li>测试：测试新功能是否可用</li>
</ol>
<h3 id="备份需要考虑的问题"><a href="#备份需要考虑的问题" class="headerlink" title="备份需要考虑的问题"></a>备份需要考虑的问题</h3><ol>
<li>可以容忍丢失多长时间的数据；</li>
<li>恢复数据要在多长时间内完；</li>
<li>恢复的时候是否需要持续提供服务；</li>
<li>恢复的对象，是整个库，多个表，还是单个库，单个表。<a id="more"></a>

</li>
</ol>
<h3 id="备份的类型"><a href="#备份的类型" class="headerlink" title="备份的类型"></a>备份的类型</h3><h4 id="根据是否需要数据库离线"><a href="#根据是否需要数据库离线" class="headerlink" title="根据是否需要数据库离线"></a>根据是否需要数据库离线</h4><ol>
<li>冷备（cold backup）：需要关mysql服务，读写请求均不允许状态下进行；</li>
<li>温备（warm backup）： 服务在线，但仅支持读请求，不允许写请求；</li>
<li>热备（hot backup）：备份的同时，业务不受影响。</li>
</ol>
<blockquote>
<p>注：</p>
<blockquote>
<p>1、这种类型的备份，取决于业务的需求，而不是备份工具<br>2、MyISAM不支持热备，InnoDB支持热备，但是需要专门的工具  </p>
</blockquote>
</blockquote>
<h4 id="根据要备份的数据集合的范围"><a href="#根据要备份的数据集合的范围" class="headerlink" title="根据要备份的数据集合的范围"></a>根据要备份的数据集合的范围</h4><ol>
<li>完全备份：full backup，备份全部字符集。</li>
<li>增量备份: incremental backup 上次完全备份或增量备份以来改变了的数据，不能单独使用，要借助完全备份，备份的频率取决于数据的更新频率。</li>
<li>差异备份：differential backup 上次完全备份以来改变了的数据。</li>
</ol>
<p>建议的恢复策略：  </p>
<ol>
<li>完全+增量+二进制日志</li>
<li>完全+差异+二进制日志</li>
</ol>
<h4 id="根据备份数据或文件"><a href="#根据备份数据或文件" class="headerlink" title="根据备份数据或文件"></a>根据备份数据或文件</h4><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;类型&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;优点&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;缺点&nbsp;&nbsp;&nbsp;</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;物理备份&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;直接备份数据文件&nbsp;&nbsp;&nbsp;备份和恢复操作都比较简单，能够跨mysql的版本，&nbsp;&nbsp;&nbsp;恢复速度快，属于文件系统级别的&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;不要假设备份一定可用，要测试&nbsp;&nbsp;&nbsp;mysql&gt;check&nbsp;&nbsp;&nbsp;tables；检测表是否可用&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;逻辑备份&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;备份表中的数据和代码&nbsp;&nbsp;&nbsp;恢复简单、备份的结果为ASCII文件，可以编辑&nbsp;&nbsp;&nbsp;与存储引擎无关&nbsp;&nbsp;&nbsp;可以通过网络备份和恢复&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;备份或恢复都需要mysql服务器进程参与&nbsp;&nbsp;&nbsp;备份结果占据更多的空间，&nbsp;&nbsp;&nbsp;浮点数可能会丢失精度&nbsp;&nbsp;&nbsp;还原之后，缩影需要重建&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<h3 id="备份对象"><a href="#备份对象" class="headerlink" title="备份对象"></a>备份对象</h3><ol>
<li>数据；</li>
<li>配置文件；</li>
<li>代码：存储过程、存储函数、触发器</li>
<li>os相关的配置文件</li>
<li>复制相关的配置</li>
<li>二进制日志</li>
</ol>
<h2 id="数据库备份与还原"><a href="#数据库备份与还原" class="headerlink" title="数据库备份与还原"></a>数据库备份与还原</h2><h3 id="利用select-into-outfile实现数据的备份与还原"><a href="#利用select-into-outfile实现数据的备份与还原" class="headerlink" title="利用select into outfile实现数据的备份与还原"></a>利用select into outfile实现数据的备份与还原</h3><h4 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sunld_db           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sys                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use sunld_db;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_sunld_user;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> a    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 啊   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_sunld_user <span class="keyword">into</span> outfile <span class="string">&#x27;/var/lib/mysql/t_sunld_user_01.txt&#x27;</span>;</span><br><span class="line">ERROR <span class="number">1290</span> (HY000): The MySQL server <span class="keyword">is</span> <span class="keyword">running</span> <span class="keyword">with</span> the <span class="comment">--secure-file-priv option so it cannot execute this statement</span></span><br></pre></td></tr></table></figure>
<h5 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h5><p>出现这个问题的原因是因为启动MySQL的时候使用了–secure-file-priv这个参数，这个参数的主要目的就是限制LOAD DATA INFILE或者SELECT INTO OUTFILE之类文件的目录位置，我们可以使用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;secure_file_priv&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> secure_file_priv <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">-</span>files<span class="operator">/</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>如果要解决这个问题，我们可以通过下面2种方式：</p>
<ol>
<li>将你要导入或导出的文件位置指定到你设置的路径里</li>
<li>由于不能动态修改，我们可以修改my.cnf里关于这个选项的配置，然后重启即可。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_sunld_user <span class="keyword">into</span> outfile <span class="string">&#x27;/var/lib/mysql-files/t_sunld_user_01.txt&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.08</span> sec)</span><br></pre></td></tr></table></figure>
<h5 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root@]# pwd</span><br><span class="line"><span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">-</span>files</span><br><span class="line">[root@]# cat t_sunld_user_01.txt</span><br><span class="line"><span class="number">1</span>	a</span><br><span class="line"><span class="number">2</span>	啊</span><br></pre></td></tr></table></figure>
<p>发现文件只是一个文本文件，如果导入的话需要使用load data infile进行数据恢复</p>
<h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> t_sunld_user;</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_sunld_user;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> load data infile <span class="string">&#x27;/var/lib/mysql-files/t_sunld_user_01.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> t_sunld_user;</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Deleted: <span class="number">0</span>  Skipped: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_sunld_user;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> a    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 啊   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h4 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `metadatakeys` <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;D:/outfile.txt&#x27;</span> FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;|&#x27;</span> ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;&quot;&#x27;</span> LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">LOAD DATA INFILE <span class="string">&#x27;D:/outfile.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> `metadatakeys`FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;|&#x27;</span> ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;&quot;&#x27;</span> LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\r\n&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用mysqldump备份数据和还原数据"><a href="#使用mysqldump备份数据和还原数据" class="headerlink" title="使用mysqldump备份数据和还原数据"></a>使用mysqldump备份数据和还原数据</h3><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ol>
<li>mysqldump命令将数据库中的数据备份成一个文本文件。表的结构和表中的数据将存储在生成的文本文件中。</li>
<li>mysqldump命令的工作原理很简单。它先查出需要备份的表的结构，再在文本文件中生成一个CREATE语句。然后，将表中的所有记录转换成一条INSERT语句。然后通过这些语句，就能够创建表并插入数据。</li>
<li>抛开源码不谈，其实我们可以通过打开general log，查看mysqldump全库备份时执行的命令来了解mysqldump背后的原理。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">打开general log</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> general_log<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line">其中，general log的存放路径可通过以下命令查看</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general_log_file%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: mysqldump [OPTIONS] database [tables]</span><br><span class="line">OR     mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]</span><br><span class="line">OR     mysqldump [OPTIONS] --all-databases [OPTIONS]</span><br><span class="line">mysqldump -u username -p dbname table1 table2 ...-&gt; BackupName.sql</span><br><span class="line">其中：</span><br><span class="line">dbname参数表示数据库的名称；</span><br><span class="line">table1和table2参数表示需要备份的表的名称，为空则整个数据库备份；</span><br><span class="line">BackupName.sql参数表设计备份文件的名称，文件名前面可以加上一个绝对路径。通常将数据库被分成一个后缀名为sql的文件；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="备份一个数据库"><a href="#备份一个数据库" class="headerlink" title="备份一个数据库"></a>备份一个数据库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123456a? cloudos_db t_sunld_user &gt; back001.sql</span><br></pre></td></tr></table></figure>
<h5 id="备份多个数据库"><a href="#备份多个数据库" class="headerlink" title="备份多个数据库"></a>备份多个数据库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">mysqldump -u username -p --databases dbname2 dbname2 &gt; Backup.sql</span><br><span class="line">加上了--databases选项，然后后面跟多个数据库</span><br><span class="line">mysqldump -u root -p --databases <span class="built_in">test</span> mysql &gt; backup.sql</span><br></pre></td></tr></table></figure>
<h5 id="备份全部数据库"><a href="#备份全部数据库" class="headerlink" title="备份全部数据库"></a>备份全部数据库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump命令备份所有数据库的语法如下：</span><br><span class="line">mysqldump -u username -p -all-databases &gt; BackupName.sql</span><br><span class="line">示例：</span><br><span class="line">mysqldump -u -root -p -all-databases &gt; all.sql</span><br></pre></td></tr></table></figure>
<h4 id="施加读锁的方式"><a href="#施加读锁的方式" class="headerlink" title="施加读锁的方式"></a>施加读锁的方式</h4><p>mysqldump 常用来做温备，所以我们首先需要对想备份的数据施加读锁</p>
<h5 id="直接在备份的时候添加选项"><a href="#直接在备份的时候添加选项" class="headerlink" title="直接在备份的时候添加选项"></a>直接在备份的时候添加选项</h5><ol>
<li>–lock-all-tables 是对要备份的数据库的所有表施加读锁</li>
<li>–lock-table 仅对单张表施加读锁，即使是备份整个数据库，它也是在我们备份某张表的时候才对该表施加读锁，因此适用于备份单张表</li>
</ol>
<h5 id="在服务器端书写命令"><a href="#在服务器端书写命令" class="headerlink" title="在服务器端书写命令"></a>在服务器端书写命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; flush tables with <span class="built_in">read</span> lock; 施加锁，表示把位于内存上的表统统都同步到磁盘上去，然后施加读锁</span><br><span class="line">mysql&gt; flush tables with <span class="built_in">read</span> lock;释放读锁</span><br></pre></td></tr></table></figure>
<p>但这对于InnoDB存储引擎来讲，虽然你也能够请求道读锁，但是不代表它的所有数据都已经同步到磁盘上，因此当面对InnoDB的时候，我们要使用mysql&gt; show engine innodb status; 看看InnoDB所有的数据都已经同步到磁盘上去了，才进行备份操作。</p>
<h4 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h4><p>完全备份+增量备份+二进制日志</p>
<h4 id="完整备份数据库"><a href="#完整备份数据库" class="headerlink" title="完整备份数据库"></a>完整备份数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123456a? --single-transaction --master-data=2 --databases sunld_db &gt; /var/lib/mysql/sunld_db_`date +%F`.sql</span><br><span class="line">mysqldump: [Warning] Using a password on the <span class="built_in">command</span> line interface can be insecure.</span><br><span class="line"></span><br><span class="line">--single-transaction: 基于此选项能实现热备InnoDB表；因此，不需要同时使用--lock-all-tables；</span><br><span class="line">--master-data=2  记录备份那一时刻的二进制日志的位置，并且注释掉，1是不注释的</span><br><span class="line">--databases hellodb 指定备份的数据库</span><br></pre></td></tr></table></figure>
<h5 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ mysql]<span class="comment"># pwd</span></span><br><span class="line">/var/lib/mysql</span><br><span class="line">[root@ mysql]<span class="comment"># ll|grep sunld_db</span></span><br><span class="line">drwxr-x--- 2 mysql mysql         65 Dec 19 21:57 sunld_db</span><br><span class="line">-rw-r--r-- 1 root  root        2232 Dec 19 22:03 sunld_db_2017-12-19.sql</span><br></pre></td></tr></table></figure>
<h5 id="文件内容-1"><a href="#文件内容-1" class="headerlink" title="文件内容"></a>文件内容</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#文件中以“<span class="comment">--”开头的都是SQL语言的注释</span></span><br><span class="line">#以&quot;/*!40101&quot;等形式开头的是与MySQL有关的注释。</span><br><span class="line">#<span class="number">40101</span>是MySQL数据库的版本号，如果MySQL的版本比<span class="number">1.11</span>高，则<span class="comment">/*!40101和*/</span>之间的内容就被当做<span class="keyword">SQL</span>命令来执行，如果比<span class="number">4.1</span><span class="number">.1</span>低就会被当做注释。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL dump 10.13  Distrib 5.7.17, for Linux (x86_64)#文件的开头会记录MySQL的版本、备份的主机名和数据库名。</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Host: localhost    Database: sunld_db</span></span><br><span class="line"><span class="comment">-- ------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Server version	5.7.17-log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET NAMES utf8 */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Position to start replication or point-in-time recovery from</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- CHANGE MASTER TO MASTER_LOG_FILE=&#x27;mysql-bin.000016&#x27;, MASTER_LOG_POS=143358362;#记录了二进制日志的位置 </span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Current Database: `sunld_db`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span> `sunld_db` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span>;</span><br><span class="line">USE `sunld_db`;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `t_sunld_user`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_sunld_user`;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = utf8 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_sunld_user` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Dumping data for table `t_sunld_user`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">LOCK TABLES `t_sunld_user` WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `t_sunld_user` DISABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_sunld_user` <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;啊&#x27;</span>);</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `t_sunld_user` ENABLE KEYS */</span>;</span><br><span class="line">UNLOCK TABLES;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span>;</span><br><span class="line"><span class="comment">-- Dump completed on 2017-12-19 22:03:10</span></span><br></pre></td></tr></table></figure>
<h4 id="日志文件内容general-log"><a href="#日志文件内容general-log" class="headerlink" title="日志文件内容general log"></a>日志文件内容general log</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">59</span>    <span class="number">14</span> <span class="keyword">Connect</span>   root<span class="variable">@localhost</span> <span class="keyword">on</span></span><br><span class="line">Query     <span class="comment">/*!40100 SET @@SQL_MODE=&#x27;&#x27; */</span></span><br><span class="line">Query     <span class="comment">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */</span></span><br><span class="line">Query     FLUSH <span class="comment">/*!40101 LOCAL */</span> TABLES</span><br><span class="line">Query     FLUSH TABLES <span class="keyword">WITH</span> READ LOCK</span><br><span class="line">Query     <span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ</span><br><span class="line">Query     <span class="keyword">START</span> TRANSACTION <span class="comment">/*!40100 WITH CONSISTENT SNAPSHOT */</span></span><br><span class="line">Query     <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;gtid\_mode&#x27;</span></span><br><span class="line">Query     <span class="keyword">SHOW</span> MASTER STATUS</span><br><span class="line">Query     UNLOCK TABLES</span><br><span class="line">Query     <span class="keyword">SELECT</span> LOGFILE_GROUP_NAME, FILE_NAME, TOTAL_EXTENTS, INITIAL_SIZE, ENGINE, EXTRA <span class="keyword">FROM</span> INFORMATION_SCHEMA.FILES <span class="keyword">WHERE</span> FILE_TYPE <span class="operator">=</span> <span class="string">&#x27;UNDO LOG&#x27;</span> <span class="keyword">AND</span> FILE_NAME <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> LOGFILE_GROUP_NAME, FILE_NAME, ENGINE <span class="keyword">ORDER</span> <span class="keyword">BY</span> LOGFILE_GROUP_NAME</span><br><span class="line">Query     <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> TABLESPACE_NAME, FILE_NAME, LOGFILE_GROUP_NAME, EXTENT_SIZE, INITIAL_SIZE, ENGINE <span class="keyword">FROM</span> INFORMATION_SCHEMA.FILES <span class="keyword">WHERE</span> FILE_TYPE <span class="operator">=</span> <span class="string">&#x27;DATAFILE&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> TABLESPACE_NAME, LOGFILE_GROUP_NAME</span><br><span class="line">Query     <span class="keyword">SHOW</span> DATABASES</span><br><span class="line">Query     <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;ndbinfo\_version&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="FLUSH-40101-LOCAL-TABLES"><a href="#FLUSH-40101-LOCAL-TABLES" class="headerlink" title="FLUSH /*!40101 LOCAL */ TABLES"></a>FLUSH /*!40101 LOCAL */ TABLES</h5><p>Closes all open tables, forces all tables in use to be closed, and flushes the query cache.</p>
<h5 id="FLUSH-TABLES-WITH-READ-LOCK"><a href="#FLUSH-TABLES-WITH-READ-LOCK" class="headerlink" title="FLUSH TABLES WITH READ LOCK"></a>FLUSH TABLES WITH READ LOCK</h5><p>执行flush tables操作，并加一个全局读锁，很多童鞋可能会好奇，这两个命令貌似是重复的，为什么不在第一次执行flush tables操作的时候加上锁呢？  </p>
<p>下面看看源码中的解释：</p>
<blockquote>
<p>We do first a FLUSH TABLES. If a long update is running, the FLUSH TABLES,will wait but will not stall the whole mysqld, and when the long update is done the FLUSH TABLES WITH READ LOCK will start and succeed quickly. So,FLUSH TABLES is to lower the probability of a stage where both mysqldump and most client connections are stalled. Of course, if a second long update starts between the two FLUSHes, we have that bad stall.</p>
</blockquote>
<p>简而言之，是为了避免较长的事务操作造成FLUSH TABLES WITH READ LOCK操作迟迟得不到锁，但同时又阻塞了其它客户端操作。</p>
<h5 id="SET-SESSION-TRANSACTION-ISOLATION-LEVEL-REPEATABLE-READ"><a href="#SET-SESSION-TRANSACTION-ISOLATION-LEVEL-REPEATABLE-READ" class="headerlink" title="SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ"></a>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ</h5><p>设置当前会话的事务隔离等级为RR，RR可避免不可重复读和幻读。</p>
<h5 id="START-TRANSACTION-40100-WITH-CONSISTENT-SNAPSHOT"><a href="#START-TRANSACTION-40100-WITH-CONSISTENT-SNAPSHOT" class="headerlink" title="START TRANSACTION /*!40100 WITH CONSISTENT SNAPSHOT */"></a>START TRANSACTION /*!40100 WITH CONSISTENT SNAPSHOT */</h5><ol>
<li>获取当前数据库的快照，这个是由mysqldump中–single-transaction决定的。</li>
<li>这个只适用于支持事务的表，在MySQL中，只有Innodb。</li>
</ol>
<blockquote>
<p>注意：  </p>
<blockquote>
<p>START TRANSACTION和START TRANSACTION WITH CONSISTENT SNAPSHOT并不一样，<br>START TRANSACTION WITH CONSISTENT SNAPSHOT是开启事务的一致性快照。  </p>
</blockquote>
</blockquote>
<p>下面看看官方的说法，  </p>
<p>The WITH CONSISTENT SNAPSHOT modifier starts a consistent read for storage engines that are capable of it. This applies only to InnoDB. The effect is the same as issuing a START TRANSACTION followed by a SELECT from any InnoDB table.  </p>
<p>简而言之，就是开启事务并对所有表执行了一次SELECT操作，这样可保证备份时，在任意时间点执行select * from table得到的数据和执行START TRANSACTION WITH CONSISTENT SNAPSHOT时的数据一致。  </p>
<blockquote>
<p>注意，WITH CONSISTENT SNAPSHOT只在RR隔离级别下有效。  </p>
</blockquote>
<h5 id="SHOW-MASTER-STATUS"><a href="#SHOW-MASTER-STATUS" class="headerlink" title="SHOW MASTER STATUS"></a>SHOW MASTER STATUS</h5><p>这个是由–master-data决定的，记录了开始备份时，binlog的状态信息，包括MASTER_LOG_FILE和MASTER_LOG_POS</p>
<h5 id="UNLOCK-TABLES"><a href="#UNLOCK-TABLES" class="headerlink" title="UNLOCK TABLES"></a>UNLOCK TABLES</h5><p>释放锁。</p>
<h4 id="在服务器端执行相关sql，然后查看二进制日志的记录位置"><a href="#在服务器端执行相关sql，然后查看二进制日志的记录位置" class="headerlink" title="在服务器端执行相关sql，然后查看二进制日志的记录位置"></a>在服务器端执行相关sql，然后查看二进制日志的记录位置</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> test1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);#准备数据</span><br><span class="line">ERROR <span class="number">1136</span> (<span class="number">21</span>S01): <span class="keyword">Column</span> count doesn<span class="string">&#x27;t match value count at row 1</span></span><br><span class="line"><span class="string">mysql&gt; insert into test1 values (1),(2),(3);</span></span><br><span class="line"><span class="string">Query OK, 3 rows affected (0.01 sec)</span></span><br><span class="line"><span class="string">Records: 3  Duplicates: 0  Warnings: 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mysql&gt; select * from test1;</span></span><br><span class="line"><span class="string">+------+</span></span><br><span class="line"><span class="string">| id   |</span></span><br><span class="line"><span class="string">+------+</span></span><br><span class="line"><span class="string">|    1 |</span></span><br><span class="line"><span class="string">|    2 |</span></span><br><span class="line"><span class="string">|    3 |</span></span><br><span class="line"><span class="string">+------+</span></span><br><span class="line"><span class="string">3 rows in set (0.00 sec)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#查看二进制的记录位置，从备份文件里边记录的位置到我们此时的位置，即为增量的部分</span></span><br><span class="line"><span class="string">mysql&gt; show master status;</span></span><br><span class="line"><span class="string">+------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="string">| File             | Position  | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span></span><br><span class="line"><span class="string">+------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="string">| mysql-bin.000016 | 168329475 |              |                  |                   |</span></span><br><span class="line"><span class="string">+------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="string">1 row in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>
<h4 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --no-defaults --start-position=143358362 --stop-position=168329475  /var/lib/mysql/mysql-bin.000016 &gt; /var/lib/mysql/sunld_db_`date +%F_%H`.sql</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> sql_log_bin<span class="operator">=</span><span class="number">0</span>;  关闭二进制日志</span><br><span class="line">mysql<span class="operator">&gt;</span> flush logs; 滚动下日志</span><br></pre></td></tr></table></figure>
<h4 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p [dbname] &lt; backup.sql</span><br><span class="line">示例：</span><br><span class="line">mysql -u root -p &lt; backup.sql</span><br><span class="line">[root@www ]<span class="comment"># mysql &lt; /var/lib/mysql/sunld_db_2017-12-19.sql  //导入完全备份文件</span></span><br><span class="line">[root@www ]<span class="comment"># mysql &lt; /var/lib/mysql/sunld_db_2017-12-19_22.sql //导入增量备份文件</span></span><br></pre></td></tr></table></figure>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>真正在生产环境中，我们应该导出的是整个mysql服务器中的数据，而不是单个库，因此应该使用–all-databases</li>
<li>在导出二进制日志的时候，可以直接复制文件即可，但是要注意的是，备份之前滚动下日志。</li>
</ol>
<h3 id="直接复制整个数据库目录"><a href="#直接复制整个数据库目录" class="headerlink" title="直接复制整个数据库目录"></a>直接复制整个数据库目录</h3><p>MySQL有一种非常简单的备份方法，就是将MySQL中的数据库文件直接复制出来。这是最简单，速度最快的方法。<br>不过在此之前，要先将服务器停止，这样才可以保证在复制期间数据库的数据不会发生变化。如果在复制数据库的过程中还有数据写入，就会造成数据不一致。这种情况在开发环境可以，但是在生产环境中很难允许备份服务器。</p>
<blockquote>
<p>注意：这种方法不适用于InnoDB存储引擎的表，而对于MyISAM存储引擎的表很方便。同时，还原时MySQL的版本最好相同。</p>
</blockquote>
<h3 id="使用mysqlhotcopy工具快速备份"><a href="#使用mysqlhotcopy工具快速备份" class="headerlink" title="使用mysqlhotcopy工具快速备份"></a>使用mysqlhotcopy工具快速备份</h3><p>mysqlhotcopy支持不停止MySQL服务器备份。而且，mysqlhotcopy的备份方式比mysqldump快。mysqlhotcopy是一个perl脚本，主要在Linux系统下使用。其使用LOCK TABLES、FLUSH TABLES和cp来进行快速备份。<br>原理：先将需要备份的数据库加上一个读锁，然后用FLUSH TABLES将内存中的数据写回到硬盘上的数据库，最后，把需要备份的数据库文件复制到目标目录。<br>命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqlhotcopy [option] dbname1 dbname2 backupDir/</span><br><span class="line">dbname：数据库名称；</span><br><span class="line">backupDir：备份到哪个文件夹下；</span><br><span class="line">常用选项：</span><br><span class="line">--<span class="built_in">help</span>：查看mysqlhotcopy帮助；</span><br><span class="line">--allowold：如果备份目录下存在相同的备份文件，将旧的备份文件加上_old；</span><br><span class="line">--keepold：如果备份目录下存在相同的备份文件，不删除旧的备份文件，而是将旧的文件更名；</span><br><span class="line">--flushlog：本次辈分之后，将对数据库的更新记录到日志中；</span><br><span class="line">--noindices：只备份数据文件，不备份索引文件；</span><br><span class="line">--user=用户名：用来指定用户名，可以用-u代替；</span><br><span class="line">--password=密码：用来指定密码，可以用-p代替。使用-p时，密码与-p之间没有空格；</span><br><span class="line">--port=端口号：用来指定访问端口，可以用-P代替；</span><br><span class="line">--socket=socket文件：用来指定socket文件，可以用-S代替；</span><br></pre></td></tr></table></figure>
<p>mysqlhotcopy并非mysql自带，需要安装Perl的数据库接口包；下载地址为:<a href="http://dev.mysql.com/downloads/dbi.html">http://dev.mysql.com/downloads/dbi.html</a>  </p>
<p>目前，该工具也仅仅能够备份MyISAM类型的表  </p>
<h2 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h2><h3 id="还原直接复制目录的备份"><a href="#还原直接复制目录的备份" class="headerlink" title="还原直接复制目录的备份"></a>还原直接复制目录的备份</h3><p>通过这种方式还原时，必须保证两个MySQL数据库的版本号是相同的。MyISAM类型的表有效，对于InnoDB类型的表不可用，InnoDB表的表空间不能直接复制。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="mysql查询表的数据大小"><a href="#mysql查询表的数据大小" class="headerlink" title="mysql查询表的数据大小"></a>mysql查询表的数据大小</h3><h4 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h4><p>在mysql中有一个information_schema数据库，这个数据库中装的是mysql的元数据，包括数据库信息、数据库中表的信息等。所以要想查询数据库占用磁盘的空间大小可以通过对information_schema数据库进行操作。</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;关键表&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;作用&nbsp;&nbsp;&nbsp;</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;schemata&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;这个表里面主要是存储在mysql中的所有的数据库的信息&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;这个表里存储了所有数据库中的表的信息，包括每个表有多少个列等信息&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;columns&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;这个表存储了所有表中的表字段信息&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;statistics&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;存储了表中索引的信息&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;user_privileges&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;存储了用户的权限信息&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;schema_privileges&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;存储了数据库权限&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;table_privileges&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;存储了表的权限&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;column_privileges&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;存储了列的权限信息&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;character_sets&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;存储了mysql可以用的字符集的信息&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;collations&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;提供各个字符集的对照信息&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;collation_character_set_applicability&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;相当于collations表和character_sets表的前两个字段的一个对比，记录了字符集之间的对照信息。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;table_constraints&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;这个表主要是用于记录表的描述存在约束的表和约束类型&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;key_column_usage&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;记录具有约束的列&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;routines&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;记录了存储过程和函数的信息，不包含自定义的过程或函数信息。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;views&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;记录了视图信息，需要有show view权限&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;triggers&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;存储了触发器的信息，需要有super权限&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<h3 id="要查询表所占的容量，就是把表的数据和索引加起来就可以了"><a href="#要查询表所占的容量，就是把表的数据和索引加起来就可以了" class="headerlink" title="要查询表所占的容量，就是把表的数据和索引加起来就可以了"></a>要查询表所占的容量，就是把表的数据和索引加起来就可以了</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(DATA_LENGTH)<span class="operator">+</span><span class="built_in">sum</span>(INDEX_LENGTH) <span class="keyword">from</span> information_schema.tables  <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;数据库名&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查询所有的数据大小"><a href="#查询所有的数据大小" class="headerlink" title="查询所有的数据大小"></a>查询所有的数据大小</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(round(<span class="built_in">sum</span>(DATA_LENGTH<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;M&#x27;</span>) <span class="keyword">from</span> tables; <span class="comment">-- 查询所有的数据大小</span></span><br></pre></td></tr></table></figure>
<h3 id="查询某个表的数据"><a href="#查询某个表的数据" class="headerlink" title="查询某个表的数据"></a>查询某个表的数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(round(<span class="built_in">sum</span>(DATA_LENGTH<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;M&#x27;</span>) <span class="keyword">from</span> tables <span class="keyword">where</span> table_schema<span class="operator">=</span>’数据库名’ <span class="keyword">AND</span> table_name<span class="operator">=</span>’表名’;</span><br></pre></td></tr></table></figure>
<h3 id="mysqldump参数汇总"><a href="#mysqldump参数汇总" class="headerlink" title="mysqldump参数汇总"></a>mysqldump参数汇总</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;参数&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;说明&nbsp;&nbsp;&nbsp;</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--all-databases ,&nbsp;&nbsp;&nbsp;-A&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;导出全部数据库。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--all-tablespaces&nbsp;&nbsp;&nbsp;, -Y&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;导出全部表空间。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --all-tablespaces&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--no-tablespaces ,&nbsp;&nbsp;&nbsp;-y&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;不导出任何表空间信息。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --no-tablespaces&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--add-drop-database&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;每个数据库创建之前添加drop数据库语句。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases&nbsp;&nbsp;&nbsp;--add-drop-database&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--add-drop-table&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用--skip-add-drop-table取消选项)&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p&nbsp;&nbsp;&nbsp;--all-databases  (默认添加drop语句)&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p&nbsp;&nbsp;&nbsp;--all-databases --skip-add-drop-table  (取消drop语句)&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--add-locks&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在每个表导出之前增加LOCK TABLES并且之后UNLOCK  TABLE。(默认为打开状态，使用--skip-add-locks取消选项)&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases  (默认添加LOCK语句)&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --skip-add-locks   (取消LOCK语句)&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--allow-keywords&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;允许创建是关键词的列名字。这由表名前缀于每个列名做到。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --allow-keywords&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--apply-slave-statements&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在'CHANGE MASTER'前添加'STOP&nbsp;&nbsp;&nbsp;SLAVE'，并且在导出的最后添加'START SLAVE'。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases&nbsp;&nbsp;&nbsp;--apply-slave-statements&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--character-sets-dir&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;字符集文件的目录&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases &nbsp;&nbsp;&nbsp;--character-sets-dir=/usr/local/mysql/share/mysql/charsets&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--comments&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;附加注释信息。默认为打开，可以用--skip-comments取消&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p&nbsp;&nbsp;&nbsp;--all-databases  (默认记录注释)&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p&nbsp;&nbsp;&nbsp;--all-databases --skip-comments   (取消注释)&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--compatible&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;导出的数据将和其它数据库或旧版本的MySQL&nbsp;&nbsp;&nbsp;相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，&nbsp;&nbsp;&nbsp;要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --compatible=ansi&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--compact&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：--skip-add-drop-table  --skip-add-locks --skip-comments&nbsp;&nbsp;&nbsp;--skip-disable-keys&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --compact&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--complete-insert,&nbsp;&nbsp;&nbsp;-c&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --complete-insert&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--compress, -C&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在客户端和服务器之间启用压缩传递所有信息&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --compress&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--create-options,&nbsp;&nbsp;&nbsp;-a&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态)&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--databases, -B&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;导出几个数据库。参数后面所有名字参量都被看作数据库名。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --databases test mysql&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--debug&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;输出debug信息，用于调试。默认值为：d:t:o,/tmp/mysqldump.trace&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --debug&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --debug=”&nbsp;&nbsp;&nbsp;d:t:o,/tmp/debug.trace”&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--debug-check&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;检查内存和打开文件使用说明并退出。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --debug-check&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--debug-info&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;输出调试信息并退出&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --debug-info&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--default-character-set&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;设置默认字符集，默认值为utf8&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases&nbsp;&nbsp;&nbsp;--default-character-set=latin1&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--delayed-insert&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;采用延时插入方式（INSERT DELAYED）导出数据&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --delayed-insert&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--delete-master-logs&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;master备份后删除日志. 这个参数将自动激活--master-data。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases&nbsp;&nbsp;&nbsp;--delete-master-logs&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--disable-keys&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;对于每个表，用/*!40000 ALTER TABLE tbl_name&nbsp;&nbsp;&nbsp;DISABLE KEYS */;和/*!40000 ALTER TABLE tbl_name ENABLE KEYS&nbsp;&nbsp;&nbsp;*/;语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases&nbsp;&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--dump-slave&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;该选项将导致主的binlog位置和文件名追加到导出数据的文件中。设置为1时，将会以CHANGE&nbsp;&nbsp;&nbsp;MASTER命令输出到数据文件；设置为2时，在命令前增加说明信息。该选项将会打开--lock-all-tables，除非--single-transaction被指定。该选项会自动关闭--lock-tables选项。默认值为0。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --dump-slave=1&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --dump-slave=2&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--events, -E&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;导出事件。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --events&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--extended-insert,&nbsp;&nbsp;&nbsp;-e&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用--skip-extended-insert取消选项。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p&nbsp;&nbsp;&nbsp;--all-databases--skip-extended-insert  &nbsp;&nbsp;&nbsp;(取消选项)&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--fields-terminated-by&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;导出文件中忽略给定字段。与--tab选项一起使用，不能用于--databases和--all-databases选项&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p test test --tab=”/home/mysql”&nbsp;&nbsp;&nbsp;--fields-terminated-by=”#”&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--fields-enclosed-by&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;输出文件中的各个字段用给定字符包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p test test --tab=”/home/mysql”&nbsp;&nbsp;&nbsp;--fields-enclosed-by=”#”&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--fields-optionally-enclosed-by&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;输出文件中的各个字段用给定字符选择性包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p test test&nbsp;&nbsp;&nbsp;--tab=”/home/mysql” &nbsp;&nbsp;&nbsp;--fields-enclosed-by=”#” --fields-optionally-enclosed =”#”&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--fields-escaped-by&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;输出文件中的各个字段忽略给定字符。与--tab选项一起使用，不能用于--databases和--all-databases选项&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p mysql user --tab=”/home/mysql”&nbsp;&nbsp;&nbsp;--fields-escaped-by=”#”&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--flush-logs&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;开始导出之前刷新日志。&nbsp;&nbsp;&nbsp;请注意：假如一次导出多个数据库(使用选项--databases或者--all-databases)，将会逐个数据库刷新日志。除使用--lock-all-tables或者--master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用--lock-all-tables&nbsp;&nbsp;&nbsp;或者--master-data 和--flush-logs。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --flush-logs&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--flush-privileges&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在导出mysql数据库之后，发出一条FLUSH  PRIVILEGES&nbsp;&nbsp;&nbsp;语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases&nbsp;&nbsp;&nbsp;--flush-privileges&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--force&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在导出过程中忽略出现的SQL错误。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --force&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--help&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;显示帮助信息并退出。&nbsp;&nbsp;&nbsp;mysqldump  --help&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--hex-blob&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --all-databases --hex-blob&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--host, -h&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;需要导出的主机信息&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--ignore-table&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：--ignore-table=database.table1 --ignore-table=database.table2 ……&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--ignore-table=mysql.user&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--include-master-host-port&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在--dump-slave产生的'CHANGE  MASTER&nbsp;&nbsp;&nbsp;TO..'语句中增加'MASTER_HOST=&lt;host&gt;，MASTER_PORT=&lt;port&gt;' &nbsp;&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--include-master-host-port&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--insert-ignore&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在插入行时使用INSERT IGNORE语句.&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--insert-ignore&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--lines-terminated-by&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;输出文件的每行用给定字符串划分。与--tab选项一起使用，不能用于--databases和--all-databases选项。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost test test&nbsp;&nbsp;&nbsp;--tab=”/tmp/mysql” &nbsp;&nbsp;&nbsp;--lines-terminated-by=”##”&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--lock-all-tables,&nbsp;&nbsp;&nbsp;-x&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭--single-transaction&nbsp;&nbsp;&nbsp;和--lock-tables 选项。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--lock-all-tables&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--lock-tables, -l&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;开始导出前，锁定所有表。用READ &nbsp;&nbsp;&nbsp;LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，--single-transaction是一个更好的选择，因为它根本不需要锁定表。&nbsp;&nbsp;&nbsp;请注意当导出多个数据库时，--lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--lock-tables&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--log-error&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;附加警告和错误信息到给定文件&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost&nbsp;&nbsp;&nbsp;--all-databases &nbsp;&nbsp;&nbsp;--log-error=/tmp/mysqldump_error_log.err&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--master-data&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;该选项将binlog的位置和文件名追加到输出文件中。如果为1，将会输出CHANGE&nbsp;&nbsp;&nbsp;MASTER 命令；如果为2，输出的CHANGE &nbsp;&nbsp;&nbsp;MASTER命令前添加注释信息。该选项将打开--lock-all-tables&nbsp;&nbsp;&nbsp;选项，除非--single-transaction也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的--single-transaction选项）。该选项自动关闭--lock-tables选项。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--master-data=1;&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--master-data=2;&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--max_allowed_packet&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;服务器发送和接受的最大包长度。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--max_allowed_packet=10240&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--net_buffer_length&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;TCP/IP和socket连接的缓存大小。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--net_buffer_length=1024&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--no-autocommit&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用autocommit/commit 语句包裹表。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--no-autocommit&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--no-create-db, -n&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;只导出数据，而不添加CREATE DATABASE 语句。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--no-create-db&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--no-create-info,&nbsp;&nbsp;&nbsp;-t&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;只导出数据，而不添加CREATE TABLE 语句。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--no-create-info&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--no-data, -d&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;不导出任何数据，只导出数据库表结构。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--no-data&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--no-set-names, -N&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;等同于--skip-set-charset&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--no-set-names&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--opt&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;等同于--add-drop-table,  --add-locks, --create-options, --quick,&nbsp;&nbsp;&nbsp;--extended-insert, --lock-tables, &nbsp;&nbsp;&nbsp;--set-charset, --disable-keys 该选项默认开启, &nbsp;&nbsp;&nbsp;可以用--skip-opt禁用.&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--opt&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--order-by-primary&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--order-by-primary&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--password, -p&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;连接数据库密码&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--pipe(windows系统可用)&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用命名管道连接mysql&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--pipe&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--port, -P&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;连接数据库端口号&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--protocol&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用的连接协议，包括：tcp, socket, pipe, memory.&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--protocol=tcp&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--quick, -q&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;不缓冲查询，直接导出到标准输出。默认为打开状态，使用--skip-quick取消该选项。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--skip-quick&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--quote-names,-Q&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用（`）引起表和列名。默认为打开状态，使用--skip-quote-names取消该选项。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--skip-quote-names&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--replace&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用REPLACE INTO 取代INSERT INTO.&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--replace&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--result-file, -r&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;直接输出到指定文件中。该选项应该用在使用回车换行对（\\r\\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--result-file=/tmp/mysqldump_result_file.txt&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--routines, -R&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;导出存储过程以及自定义函数。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--routines&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--set-charset&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;添加'SET NAMES &nbsp;&nbsp;&nbsp;default_character_set'到输出文件。默认为打开状态，使用--skip-set-charset关闭选项。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--skip-set-charset&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--single-transaction&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN&nbsp;&nbsp;&nbsp;不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎，仅InnoDB。本选项和--lock-tables 选项是互斥的，因为LOCK &nbsp;&nbsp;&nbsp;TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用--quick 选项。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--single-transaction&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--dump-date&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;将导出时间添加到输出文件中。默认为打开状态，使用--skip-dump-date关闭选项。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--skip-dump-date&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--skip-opt&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;禁用–opt选项.&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--skip-opt&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--socket,-S&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;指定连接mysql的socket文件位置，默认路径/tmp/mysql.sock&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--socket=/tmp/mysqld.sock&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--tab,-T&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost test test&nbsp;&nbsp;&nbsp;--tab="/home/mysql"&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;覆盖--databases (-B)参数，指定需要导出的表名。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --databases test&nbsp;&nbsp;&nbsp;--tables test&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--triggers&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;导出触发器。该选项默认启用，用--skip-triggers禁用它。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--triggers&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--tz-utc&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在导出顶部设置时区TIME_ZONE='+00:00'&nbsp;&nbsp;&nbsp;，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--tz-utc&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--user, -u&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;指定连接的用户名。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--verbose, --v&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;输出多种平台信息。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--version, -V&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;输出mysqldump版本信息并退出&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;-where, -w&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--where=” user=’root’”&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--xml, -X&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;导出XML格式.&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--xml&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--plugin_dir&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;客户端插件的目录，用于兼容不同的插件版本。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--plugin_dir=”/usr/local/lib/plugin”&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;--default_auth&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;客户端插件默认使用权限。&nbsp;&nbsp;&nbsp;mysqldump  -uroot -p --host=localhost --all-databases&nbsp;&nbsp;&nbsp;--default-auth=”/usr/local/lib/plugin/&lt;PLUGIN&gt;”&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.jb51.net/article/41570.htm">mysql备份的三种方式详解</a></li>
<li><a href="https://www.cnblogs.com/roverliang/p/6436140.html">MySQL备份与恢复</a></li>
<li><a href="https://www.cnblogs.com/ivictor/p/5505307.html">mysqldump的实现原理</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>备份</tag>
        <tag>恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之锁</title>
    <url>/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%94%81/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在多线程同时访问同一个资源时，如果需要考虑对共享资源的竞争问题以及数据的正确性，这需要引入锁的概念，这就是所谓的线程安全。最常见的场景就是i–操作。</p>
<a id="more"></a>

<h3 id="实例分析（i–-分析）"><a href="#实例分析（i–-分析）" class="headerlink" title="实例分析（i–/++分析）"></a>实例分析（i–/++分析）</h3><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ITest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        i--;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字节码指令-javap"><a href="#字节码指令-javap" class="headerlink" title="字节码指令(javap)"></a>字节码指令(javap)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;C:\Program Files\Java\jdk1.8.0_152\bin\javap.exe&quot;</span> -v -c com.sunld.thread.ITest</span><br><span class="line">Classfile /D:/workspace/learning/target/classes/com/sunld/thread/ITest.class</span><br><span class="line">  Last modified <span class="number">2021</span>-<span class="number">2</span>-<span class="number">22</span>; size <span class="number">496</span> bytes</span><br><span class="line">  MD5 checksum dc04316ac92307b849ac52ae7654d8d6</span><br><span class="line">  Compiled from <span class="string">&quot;ITest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">thread</span>.<span class="title">ITest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#21         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#22         // com/sunld/thread/ITest.i:I</span><br><span class="line">   #3 = Class              #23            // com/sunld/thread/ITest</span><br><span class="line">   #4 = Class              #24            // java/lang/Object</span><br><span class="line">   #5 = Utf8               i</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/sunld/thread/ITest;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #19 = Utf8               SourceFile</span><br><span class="line">  #20 = Utf8               ITest.java</span><br><span class="line">  #21 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #22 = NameAndType        #5:#6          // i:I</span><br><span class="line">  #23 = Utf8               com/sunld/thread/ITest</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.sunld.thread.ITest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/thread/ITest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field i:I，获取静态变量i的值（1）</span><br><span class="line">         <span class="number">3</span>: iconst_1                          <span class="comment">// 将int型1推入栈顶</span></span><br><span class="line">         <span class="number">4</span>: isub                              <span class="comment">// 将栈顶两个int型数值相减并将结果压入栈顶</span></span><br><span class="line">         5: putstatic     #2                  // Field i:I，为指定域中的静态变量赋值</span><br><span class="line">         8: getstatic     #2                  // Field i:I，获取静态变量i的值（1）</span><br><span class="line">        <span class="number">11</span>: iconst_1                          <span class="comment">// 将int型1推入栈顶</span></span><br><span class="line">        <span class="number">12</span>: iadd                              <span class="comment">// 将栈顶两个int型数值相加并将结果压入栈顶</span></span><br><span class="line">        13: putstatic     #2                  // Field i:I，为指定域中的静态变量赋值</span><br><span class="line">        <span class="number">16</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">16</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">17</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: iconst_1</span><br><span class="line">         1: putstatic     #2                  // Field i:I</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;ITest.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="i–-流程图"><a href="#i–-流程图" class="headerlink" title="i–/++流程图"></a>i–/++流程图</h4><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%94%81/i++%E3%80%81i--%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class title="i--&#x2F;++流程图">

</div>

<h3 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h3><ol>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程<strong>访问共享资源</strong><ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul>
</li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</li>
</ol>
<h3 id="竞态条件-Race-Condition"><a href="#竞态条件-Race-Condition" class="headerlink" title="竞态条件 Race Condition"></a>竞态条件 Race Condition</h3><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ol>
<li>阻塞：锁（synchronized、lock）</li>
<li>非阻塞：原子化、cas</li>
</ol>
<h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><h3 id="宏观分类"><a href="#宏观分类" class="headerlink" title="宏观分类"></a>宏观分类</h3><h4 id="乐观锁-（宏观分类）"><a href="#乐观锁-（宏观分类）" class="headerlink" title="乐观锁 （宏观分类）"></a>乐观锁 （宏观分类）</h4><ol>
<li>场景：多读少写</li>
<li>思想：读数据时认为数据不会被修改，不加锁；写数据时需要判断数据是否被修改过</li>
<li>Java实现：版本控制和CAS</li>
<li>CAS说明：一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败）</li>
</ol>
<h4 id="悲观锁（宏观分类）"><a href="#悲观锁（宏观分类）" class="headerlink" title="悲观锁（宏观分类）"></a>悲观锁（宏观分类）</h4><ol>
<li>场景：写多读少</li>
<li>每次获取数据时都需要加锁，防止被别人修改</li>
<li>Java实现：Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。 </li>
</ol>
<h3 id="公平分类"><a href="#公平分类" class="headerlink" title="公平分类"></a>公平分类</h3><h4 id="非公平锁-（Nonfair）"><a href="#非公平锁-（Nonfair）" class="headerlink" title="非公平锁 （Nonfair）"></a>非公平锁 （Nonfair）</h4><ol>
<li>原理：JVM 按随机、就近原则分配锁</li>
<li>ReentrantLock：默认非公平，可以配置为公平</li>
<li>常用：非公平执行效率高于公平锁</li>
<li>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待 <ul>
<li>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列 </li>
</ul>
</li>
<li>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。 </li>
</ol>
<h4 id="公平锁-（Fair）"><a href="#公平锁-（Fair）" class="headerlink" title="公平锁 （Fair）"></a>公平锁 （Fair）</h4><ol>
<li>先对锁提出获取请求的线程会先被分配到锁</li>
<li>ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁</li>
<li>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得</li>
</ol>
<h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><p>java 并发包提供的加锁模式分为独占锁和共享锁。 </p>
<h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。 </p>
<h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 </p>
<ol>
<li>   AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。 </li>
<li>   java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。 </li>
</ol>
<h3 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h3><p>重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p><strong>对象头相关知识点，参考<a href="https://www.sunliaodong.cn/2021/02/05/JVM-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/" target="_blank">HotSpot虚拟机对象探秘</a></strong></p>
<p>高效并发是从JDK 5升级到JDK 6后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量的资源去实现各种锁优化技术，如<strong>适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁膨胀（LockCoarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）</strong> 等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率。<br><strong>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。</strong> </p>
<h3 id="锁优化方式"><a href="#锁优化方式" class="headerlink" title="锁优化方式"></a>锁优化方式</h3><ol>
<li>锁升级：随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。 </li>
<li>优化方式<ul>
<li>减少锁的持有时间：只用在有线程安全要求的线程上加锁</li>
<li>减小锁粒度 ：偏向锁、分段锁</li>
<li>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。</li>
<li>降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。 </li>
</ul>
</li>
<li>锁分离<ul>
<li>读写锁分离，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能</li>
</ul>
</li>
<li>锁粗化 <ul>
<li>使用锁的时间尽量短，即时进行释放</li>
<li>防止锁的多次请求、同步和释放</li>
</ul>
</li>
<li>锁消除 锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。 </li>
</ol>
<h2 id="偏向锁（偏向第一个获取它的线程，优化锁机制）"><a href="#偏向锁（偏向第一个获取它的线程，优化锁机制）" class="headerlink" title="偏向锁（偏向第一个获取它的线程，优化锁机制）"></a>偏向锁（偏向第一个获取它的线程，优化锁机制）</h2><ol>
<li>背景：锁在大部分情况下不仅不存在多线程竞争，并且可能会被同一个线程访问多次</li>
<li>目的：消除这个线程锁冲入的开销</li>
<li>优点：减少不必要轻量级锁执行路径（轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗））</li>
<li>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能</li>
<li>偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了</li>
<li>启动方式：启用参数-XX：+UseBiased Locking，这是自JDK 6起HotSpot虚拟机的默认值</li>
<li>JVM延迟偏向锁是因为：如果不延迟，一上来就是偏向锁，假设程序后续还有线程调用，他会升级。jvm确定同步块中大部分代码都不是偏向锁，所以在启动的时候延迟。</li>
</ol>
<h3 id="偏向锁获取过程"><a href="#偏向锁获取过程" class="headerlink" title="偏向锁获取过程"></a>偏向锁获取过程</h3><ol>
<li>初始化创建对象时（<strong>未锁定，不偏向</strong>）</li>
<li>第一次调用（<strong>未锁定，已偏向</strong>），进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中</li>
<li>第二次调用：通过Markword判断是否可偏向（偏向锁标识为1且锁标志为01）<ol>
<li>相同：可偏向，判断线程ID是否与当前线程相同，相同则执行代码块</li>
<li>不相同，通过CAS操作竞争锁，成功则设置Markword中threadID为当前线程，并执行代码块</li>
</ol>
</li>
<li>竞争失败（锁升级为轻量级锁），当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word，时间很短</li>
</ol>
<h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><p><strong>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。</strong><br>根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态</p>
<h3 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h3><ol>
<li>对象计算过hash之后不能进入偏向状态</li>
<li>偏向状态的对象需要进行hash计算时，偏向锁膨胀为重量锁</li>
<li>在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作；在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用；</p>
<h3 id="查看停顿–安全点停顿日志"><a href="#查看停顿–安全点停顿日志" class="headerlink" title="查看停顿–安全点停顿日志"></a>查看停顿–安全点停顿日志</h3><ol>
<li>打开安全点日志（不能这一会打开）<ul>
<li>-XX:+PrintGCApplicationStoppedTime 会打出系统停止的时间，</li>
<li>-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 这两个参数会打印出详细信息，可以查看到使用偏向锁导致的停顿，时间非常短暂，但是争用严重的情况下，停顿次数也会非常多</li>
</ul>
</li>
<li>安全点日志的缺点<ul>
<li>安全点日志默认输出到stdout，一是stdout日志的整洁性，二是stdout所重定向的文件如果不在/dev/shm，可能被锁。 </li>
<li>对于一些很短的停顿，比如取消偏向锁，打印的消耗比停顿本身还大。 </li>
<li>安全点日志是在安全点内打印的，本身加大了安全点的停顿时间。</li>
</ul>
</li>
<li>如果在生产系统上要打开，再增加下面四个参数： <ul>
<li>-XX:+UnlockDiagnosticVMOptions </li>
<li>-XX: -DisplayVMOutput </li>
<li>-XX:+LogVMOutput </li>
<li>-XX:LogFile=/dev/shm/vm.log </li>
</ul>
</li>
<li>打开Diagnostic（只是开放了更多的flag可选，不会主动激活某个flag），关掉输出VM日志到stdout，输出到独立文件,/dev/shm目录（内存文件系统）。</li>
</ol>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%94%81/1589109071755.png" class>

</div>

<h4 id="安全点日志分析"><a href="#安全点日志分析" class="headerlink" title="安全点日志分析"></a>安全点日志分析</h4><ol>
<li>第一部分是时间戳，VM Operation的类型 </li>
<li>第二部分是线程概况，被中括号括起来 <ul>
<li>total: 安全点里的总线程数 </li>
<li>initially_running: 安全点开始时正在运行状态的线程数 </li>
<li>wait_to_block: 在VM Operation开始前需要等待其暂停的线程数</li>
</ul>
</li>
<li>第三部分是到达安全点时的各个阶段以及执行操作所花的时间，其中最重要的是vmop<ul>
<li>spin: 等待线程响应safepoint号召的时间；</li>
<li>block: 暂停所有线程所用的时间；</li>
<li>sync: 等于 spin+block，这是从开始到进入安全点所耗的时间，可用于判断进入安全点耗时；</li>
<li>cleanup: 清理所用时间；</li>
<li>vmop: 真正执行VM Operation的时间。</li>
</ul>
</li>
</ol>
<p><strong>可见，那些很多但又很短的安全点，全都是RevokeBias， 高并发的应用会禁用掉偏向锁。</strong></p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><ol>
<li>目的：轻量级锁并不是用来代替重量级锁的，轻量级锁的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</li>
<li>限制：依赖于Java对象的头信息</li>
<li>场景：线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。 </li>
<li>由来：轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </li>
</ol>
<h3 id="Lock-record"><a href="#Lock-record" class="headerlink" title="Lock record"></a>Lock record</h3><ol>
<li><strong>作用：</strong>用于偏向锁和轻量锁的优化</li>
<li><strong>包含的数据：</strong>The lock record holds the original value of the object’s mark word and also contains metadata necessary to identify which object is locked.</li>
<li><strong>创建时机：</strong>When an object is lightweight locked by a monitorenter bytecode, a lock record is either implicitly or explicitly allocated on the stack of the thread performing the lock acquisition operation.</li>
<li><strong>创建位置：</strong>Interpreted frames contain a region which holds the lock records for all monitors owned by the activation. During interpreted method execution this region grows or shrinks depending upon the number of locks held.（在线程的Interpretered Frame上(解释帧)分配）</li>
<li>作用：<ul>
<li>持有displaced word和锁住对象的元数据</li>
<li>解释器使用lock record来检测非法的锁状态</li>
<li>隐式地充当锁重入机制的计数器</li>
</ul>
</li>
</ol>
<h4 id="basicLock-hpp初始化"><a href="#basicLock-hpp初始化" class="headerlink" title="basicLock.hpp初始化"></a>basicLock.hpp初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHARE_VM_RUNTIME_BASICLOCK_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHARE_VM_RUNTIME_BASICLOCK_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;oops/markOop.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;runtime/handles.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utilities/top.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicLock</span> <span class="title">VALUE_OBJ_CLASS_SPEC</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> markOop _displaced_header;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">markOop      <span class="title">displaced_header</span><span class="params">()</span> <span class="keyword">const</span>               </span>&#123; <span class="keyword">return</span> _displaced_header; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>         <span class="title">set_displaced_header</span><span class="params">(markOop header)</span>   </span>&#123; _displaced_header = header; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_on</span><span class="params">(outputStream* st)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move a basic lock (used during deoptimization</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">move_to</span><span class="params">(oop obj, BasicLock* dest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">displaced_header_offset_in_bytes</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> offset_of(BasicLock, _displaced_header); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A BasicObjectLock associates a specific Java object with a BasicLock.</span></span><br><span class="line"><span class="comment">// It is currently embedded in an interpreter frame.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Because some machines have alignment restrictions on the control stack,</span></span><br><span class="line"><span class="comment">// the actual space allocated by the interpreter may include padding words</span></span><br><span class="line"><span class="comment">// after the end of the BasicObjectLock.  Also, in order to guarantee</span></span><br><span class="line"><span class="comment">// alignment of the embedded BasicLock objects on such machines, we</span></span><br><span class="line"><span class="comment">// put the embedded BasicLock at the beginning of the struct.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicObjectLock</span> <span class="title">VALUE_OBJ_CLASS_SPEC</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  BasicLock _lock;                                    <span class="comment">// the lock, must be double word aligned</span></span><br><span class="line">  oop       _obj;                                     <span class="comment">// object holds the lock;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Manipulation</span></span><br><span class="line">  <span class="function">oop      <span class="title">obj</span><span class="params">()</span> <span class="keyword">const</span>                                </span>&#123; <span class="keyword">return</span> _obj;  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_obj</span><span class="params">(oop obj)</span>                               </span>&#123; _obj = obj; &#125;</span><br><span class="line">  <span class="function">BasicLock* <span class="title">lock</span><span class="params">()</span>                                   </span>&#123; <span class="keyword">return</span> &amp;_lock; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: Use frame::interpreter_frame_monitor_size() for the size of BasicObjectLocks</span></span><br><span class="line">  <span class="comment">//       in interpreter activation frames since it includes machine-specific padding.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                                   </span>&#123; <span class="keyword">return</span> <span class="keyword">sizeof</span>(BasicObjectLock)/wordSize; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GC support</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">oops_do</span><span class="params">(OopClosure* f)</span> </span>&#123; f-&gt;do_oop(&amp;_obj); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">obj_offset_in_bytes</span><span class="params">()</span>                    </span>&#123; <span class="keyword">return</span> offset_of(BasicObjectLock, _obj);  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lock_offset_in_bytes</span><span class="params">()</span>                   </span>&#123; <span class="keyword">return</span> offset_of(BasicObjectLock, _lock); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SHARE_VM_RUNTIME_BASICLOCK_HPP</span></span></span><br></pre></td></tr></table></figure>
<h4 id="轻量级加锁代码（bytecodeInterpreter-cpp）"><a href="#轻量级加锁代码（bytecodeInterpreter-cpp）" class="headerlink" title="轻量级加锁代码（bytecodeInterpreter.cpp）"></a>轻量级加锁代码（bytecodeInterpreter.cpp）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Traditional lightweight locking.</span></span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  markOop displaced = rcvr-&gt;mark()-&gt;set_unlocked();</span><br><span class="line">  mon-&gt;lock()-&gt;set_displaced_header(displaced);</span><br><span class="line">  <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">  <span class="keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(mon, rcvr-&gt;mark_addr(), displaced) != displaced) &#123;</span><br><span class="line">    <span class="comment">// Is it simple recursive case?</span></span><br><span class="line">    <span class="keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;</span><br><span class="line">      mon-&gt;lock()-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="轻量级锁加锁过程"><a href="#轻量级锁加锁过程" class="headerlink" title="轻量级锁加锁过程"></a>轻量级锁加锁过程</h3><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%94%81/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E8%BF%87%E7%A8%8B.png" class title="轻量级锁的获取过程">

</div>

<p>当对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</p>
<ol>
<li>拷贝对象头中的Mark Word复制到锁记录中；</li>
<li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word<ul>
<li>如果成功，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态</li>
<li>如果失败<ul>
<li>会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行</li>
<li>否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h3><h4 id="释放锁线程视角"><a href="#释放锁线程视角" class="headerlink" title="释放锁线程视角"></a>释放锁线程视角</h4><ol>
<li>轻量锁切换重量锁是发生在轻量锁释放锁的期间，</li>
<li>比对：在释放锁的时候使用复制的Markword与对象中的Markword的比对，如果不一致则切换到重量级锁（说明在这期间有线程修改了Markword）</li>
<li>无需mutex的场景：确认该markword是否被其他线程持有，如果否说明线程已经释放了markword，通过CAS后就可以直接进入线程，无需进入mutex</li>
</ol>
<h4 id="尝试获取锁线程视角"><a href="#尝试获取锁线程视角" class="headerlink" title="尝试获取锁线程视角"></a>尝试获取锁线程视角</h4><ol>
<li>线程尝试获取锁，如果轻量锁正在被其他线程占有，则修改markwod为重量级锁</li>
<li>等待轻量锁的线程不会阻塞，它会一直自旋等待锁，并如上所说修改markword。这就是自旋锁，尝试获取锁的线程，在没有获得锁的时候，不被挂起，而转而去执行一个空循环，即自旋。在若干个自旋后，如果还没有获得锁，则才被挂起，获得锁，则执行代码。</li>
</ol>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ol>
<li>原理：消耗CPU自旋，用来获取锁</li>
<li>目的：减少内核态和用户态之间的切换，防止进入阻塞挂起状态</li>
<li>退出：获取到了锁，或者超过了自旋最大时间</li>
</ol>
<h3 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h3><ol>
<li>减少线程的阻塞，</li>
<li>锁竞争不激烈：可以提高性能</li>
<li>锁竞争激烈：浪费资源</li>
<li>持有锁的线程长时间不释放锁：浪费资源</li>
</ol>
<h3 id="自旋锁时间阈值（1-6引入了适应性自旋锁）"><a href="#自旋锁时间阈值（1-6引入了适应性自旋锁）" class="headerlink" title="自旋锁时间阈值（1.6引入了适应性自旋锁）"></a>自旋锁时间阈值（1.6引入了适应性自旋锁）</h3><p>JVM 对于自旋周期的选择，jdk1.5 这个限度是写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化：</p>
<ol>
<li>如果平均负载小于 CPUs 则一直自旋，</li>
<li>如果有超过(CPUs/2) 个线程正在自旋，则后来线程直接阻塞，</li>
<li>如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，</li>
<li>如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU 的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），</li>
<li>自旋时会适当放弃线程优先级之间的差异。 </li>
</ol>
<h3 id="自旋锁的开启"><a href="#自旋锁的开启" class="headerlink" title="自旋锁的开启"></a>自旋锁的开启</h3><p>JDK1.6 中-XX:+UseSpinning 开启；<br>-XX:PreBlockSpin=10 为自旋次数；<br>JDK1.7 后，去掉此参数，由 jvm 控制； </p>
<h2 id="重量级锁（Mutex-Lock）"><a href="#重量级锁（Mutex-Lock）" class="headerlink" title="重量级锁（Mutex Lock）"></a>重量级锁（Mutex Lock）</h2><ol>
<li>定义：依赖于操作系统 Mutex Lock 所实现的锁（线程之间的切换需要从用户态转换成核心态，成本非常高）</li>
<li>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的</li>
<li>监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的</li>
</ol>
<h3 id="ObjectMonitor对象（每个对象都具备jdk1-8）"><a href="#ObjectMonitor对象（每个对象都具备jdk1-8）" class="headerlink" title="ObjectMonitor对象（每个对象都具备jdk1.8）"></a>ObjectMonitor对象（每个对象都具备jdk1.8）</h3><p>objectMonitor.hpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;     <span class="comment">// 重入次数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,     <span class="comment">// 等待线程数</span></span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;  <span class="comment">// 当前持有锁的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;  <span class="comment">// 调用wait方法的线程被阻塞放置在这里</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 等待锁处于block的线程，才有资格成为候选资源的线程</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="锁升级分析"><a href="#锁升级分析" class="headerlink" title="锁升级分析"></a>锁升级分析</h2><div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%94%81/%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" class title="锁升级过程">

</div>

<h3 id="直接使用（轻量锁）"><a href="#直接使用（轻量锁）" class="headerlink" title="直接使用（轻量锁）"></a>直接使用（轻量锁）</h3><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMarkWord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MarkWord obj1 = <span class="keyword">new</span> MarkWord();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------- lock before ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----------- locking ------------&quot;</span>);</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------- after lock ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkWord</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------- lock before ------------</span><br><span class="line"># WARNING: Unable to attach Serviceability Agent. You can try again with escalated privileges. Two options: a) use -Djol.tryWithSudo=true to try with sudo; b) echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">----------- locking ------------</span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           d8 f4 <span class="number">16</span> <span class="number">03</span> (<span class="number">11011000</span> <span class="number">11110100</span> <span class="number">00010110</span> <span class="number">00000011</span>) (<span class="number">51836120</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">----------- after lock ------------</span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-mukq{background-color:#96FFFB;border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-as6s{background-color:#FFFC9E;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-mukq" rowspan="3">锁状态</th>
    <th class="tg-as6s" colspan="7">64bit</th>
  </tr>
  <tr>
    <td class="tg-as6s" colspan="3">56bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">4bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">2bit</td>
  </tr>
  <tr>
    <td class="tg-as6s">25bit（unused）</td>
    <td class="tg-as6s">29bit</td>
    <td class="tg-as6s">2bit</td>
    <td class="tg-as6s">1bit（unused）</td>
    <td class="tg-as6s">age</td>
    <td class="tg-as6s">偏向模式</td>
    <td class="tg-as6s">标志位</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-mukq">未锁定</td>
    <td class="tg-0pky">00000000 00000000 00000000 0</td>
    <td class="tg-0pky" colspan="2">对象哈希码（31）<br>0000000 00000000 00000000 00000000</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0000</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">01</td>
  </tr>
  <tr>
    <td class="tg-mukq">锁定中</td>
    <td class="tg-0pky" colspan="6">指向调用栈中锁记录指针（Lock Record）<br>ptr_to_lock_record(62)<br>00000000 00000000 00000000 00000000<br>00000011&nbsp;&nbsp;00010110 11110100 110110</td>
    <td class="tg-c3ow">00</td>
  </tr>
  <tr>
    <td class="tg-mukq">锁释放</td>
    <td class="tg-0pky">00000000 00000000 00000000 0</td>
    <td class="tg-0pky" colspan="2">对象哈希码（31）<br>0000000 00000000 00000000 00000000</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0000</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">01</td>
  </tr>
</tbody>
</table>

<p>结论：<strong>默认启动由于偏向锁延迟4s，所以默认为不偏向、未锁定；获取锁时为轻量锁；释放锁时为不偏向、未锁定</strong></p>
<h3 id="延迟后使用（偏向锁）"><a href="#延迟后使用（偏向锁）" class="headerlink" title="延迟后使用（偏向锁）"></a>延迟后使用（偏向锁）</h3><h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMarkWord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">        MarkWord obj1 = <span class="keyword">new</span> MarkWord();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------- lock before ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----------- locking ------------&quot;</span>);</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------- after lock ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkWord</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------- lock before ------------</span><br><span class="line"># WARNING: Unable to attach Serviceability Agent. You can try again with escalated privileges. Two options: a) use -Djol.tryWithSudo=true to try with sudo; b) echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">----------- locking ------------</span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> e8 <span class="number">94</span> <span class="number">03</span> (<span class="number">00000101</span> <span class="number">11101000</span> <span class="number">10010100</span> <span class="number">00000011</span>) (<span class="number">60090373</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">----------- after lock ------------</span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> e8 <span class="number">94</span> <span class="number">03</span> (<span class="number">00000101</span> <span class="number">11101000</span> <span class="number">10010100</span> <span class="number">00000011</span>) (<span class="number">60090373</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-mukq{background-color:#96FFFB;border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-as6s{background-color:#FFFC9E;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-fw9x{background-color:#96FFFB;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-mukq" rowspan="3">锁状态</th>
    <th class="tg-as6s" colspan="7">64bit</th>
  </tr>
  <tr>
    <td class="tg-as6s" colspan="3">56bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">4bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">2bit</td>
  </tr>
  <tr>
    <td class="tg-as6s">25bit</td>
    <td class="tg-as6s">29bit</td>
    <td class="tg-as6s">2bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">age</td>
    <td class="tg-as6s">偏向模式</td>
    <td class="tg-as6s">标志位</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-mukq">可偏向</td>
    <td class="tg-0pky" colspan="2">当前线程指针JavaThread*（54）<br>00000000 00000000 00000000 00000000<br>00000000 00000000 000000</td>
    <td class="tg-0pky">Epoch（2）<br>00</td>
    <td class="tg-0pky">unused<br>0</td>
    <td class="tg-0pky">分代年龄<br>0000</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">01</td>
  </tr>
  <tr>
    <td class="tg-fw9x">可偏向</td>
    <td class="tg-0lax" colspan="2">当前线程指针JavaThread*（54）<br>00000000 00000000 00000000 00000000<br>00000011 10010100 111010</td>
    <td class="tg-0lax">Epoch（2）<br>00</td>
    <td class="tg-0lax">unused<br>0</td>
    <td class="tg-0lax">分代年龄<br>0000</td>
    <td class="tg-0lax">1</td>
    <td class="tg-0lax">01</td>
  </tr>
  <tr>
    <td class="tg-fw9x">可偏向</td>
    <td class="tg-0lax" colspan="2">当前线程指针JavaThread*（54）<br>00000000 00000000 00000000 00000000<br>00000011 10010100 111010</td>
    <td class="tg-0lax">Epoch（2）<br>00</td>
    <td class="tg-0lax">unused<br>0</td>
    <td class="tg-0lax">分代年龄<br>0000</td>
    <td class="tg-0lax">1</td>
    <td class="tg-0lax">01</td>
  </tr>
</tbody>
</table>

<p>结论：<strong>在可偏向状态下，默认为可偏向、未加锁；获取锁时为可偏向、未加锁且存在Thread线程信息；释放锁时为可偏向、未加锁且保持Thread线程信息</strong></p>
<h3 id="hash对锁的影响"><a href="#hash对锁的影响" class="headerlink" title="hash对锁的影响"></a>hash对锁的影响</h3><h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMarkWord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">        MarkWord obj1 = <span class="keyword">new</span> MarkWord();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------- before hash ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1 hashcode is: &quot;</span> + Integer.toBinaryString(obj1.hashCode()));</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1 hashcode is: &quot;</span> + Integer.toHexString(obj1.hashCode()));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------- after hash ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----------- locking ------------&quot;</span>);</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------- after lock ------------&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkWord</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">----------- before hash ------------</span><br><span class="line"># WARNING: Unable to attach Serviceability Agent. You can try again with escalated privileges. Two options: a) use -Djol.tryWithSudo=true to try with sudo; b) echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">obj1 hashcode is: <span class="number">10010101110110100110111111000</span></span><br><span class="line">obj1 hashcode is: 12bb4df8</span><br><span class="line">----------- after hash ------------</span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> f8 <span class="number">4d</span> bb (<span class="number">00000001</span> <span class="number">11111000</span> <span class="number">01001101</span> <span class="number">10111011</span>) (-<span class="number">1152518143</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">12</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00010010</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">18</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">----------- locking ------------</span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">88</span> f3 af <span class="number">03</span> (<span class="number">10001000</span> <span class="number">11110011</span> <span class="number">10101111</span> <span class="number">00000011</span>) (<span class="number">61862792</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">----------- after lock ------------</span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> f8 <span class="number">4d</span> bb (<span class="number">00000001</span> <span class="number">11111000</span> <span class="number">01001101</span> <span class="number">10111011</span>) (-<span class="number">1152518143</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">12</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00010010</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">18</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-mukq{background-color:#96FFFB;border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-baqh{text-align:center;vertical-align:top}
.tg .tg-as6s{background-color:#FFFC9E;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-fw9x{background-color:#96FFFB;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-mukq" rowspan="3">锁状态</th>
    <th class="tg-as6s" colspan="7">64bit</th>
  </tr>
  <tr>
    <td class="tg-as6s" colspan="3">56bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">4bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">2bit</td>
  </tr>
  <tr>
    <td class="tg-as6s">25bit</td>
    <td class="tg-as6s">29bit</td>
    <td class="tg-as6s">2bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">age</td>
    <td class="tg-as6s">偏向模式</td>
    <td class="tg-as6s">标志位</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-mukq">hash前</td>
    <td class="tg-0pky" colspan="2">当前线程指针JavaThread*（54）<br>00000000 00000000 00000000 00000000<br>00000000 00000000 000000</td>
    <td class="tg-0pky">Epoch（2）<br>00</td>
    <td class="tg-0pky">unused<br>0</td>
    <td class="tg-0pky">分代年龄<br>0000</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">01</td>
  </tr>
  <tr>
    <td class="tg-mukq">hash后</td>
    <td class="tg-0pky">unused<br>00000000 00000000 00000000 0</td>
    <td class="tg-0pky" colspan="2">对象哈希码（31）<br>0010010 10111011 01001101 11111000</td>
    <td class="tg-0pky">unused<br>0</td>
    <td class="tg-0pky">分代年龄<br>0000</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">01</td>
  </tr>
  <tr>
    <td class="tg-fw9x">轻量级锁</td>
    <td class="tg-0lax" colspan="6">指向调用栈中锁记录指针（Lock Record）<br>ptr_to_lock_record(62)<br>00000000 00000000 00000000 00000000<br>00000011 10101111&nbsp;&nbsp;11110011&nbsp;&nbsp;100010</td>
    <td class="tg-baqh">00</td>
  </tr>
  <tr>
    <td class="tg-mukq">释放锁</td>
    <td class="tg-0pky">unused<br>00000000 00000000 00000000 0</td>
    <td class="tg-0pky" colspan="2">对象哈希码（31）<br>0010010 10111011 01001101 11111000</td>
    <td class="tg-0pky">unused<br>0</td>
    <td class="tg-0pky">分代年龄<br>0000</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">01</td>
  </tr>
</tbody>
</table>

<p>总结：<strong>hash后偏向锁会变成带有hash值，不可偏向未锁定状态；加锁之后变成轻量级锁，释放之后为hash后的状态。</strong></p>
<h3 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h3><h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMarkWord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> MarkWord obj1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">        obj1 = <span class="keyword">new</span> MarkWord();</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot; before lock 偏向未锁定 \n&quot;</span> +</span><br><span class="line">                ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line"></span><br><span class="line">        Thread t1= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot; t1 thread before lock  \n&quot;</span> +</span><br><span class="line">                    ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot; t1 thread locking \n&quot;</span> +</span><br><span class="line">                        ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot; t1 thread unlock \n&quot;</span> +</span><br><span class="line">                    ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot; t2 thread before lock  \n&quot;</span> +</span><br><span class="line">                    ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot; t2 thread locking \n&quot;</span> +</span><br><span class="line">                        ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot; t2 thread unlock \n&quot;</span> +</span><br><span class="line">                    ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">// 先保证t1执行完成</span></span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">// 主线程先睡一会，让子线程先执行起来。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        处理主线程</span></span><br><span class="line">        sync();</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot; after1 t1 or t2 unlock \n&quot;</span> +</span><br><span class="line">                ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 主线程先睡一会，让重量锁充分释放（几百毫秒有时也可以，但不一定）。</span></span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot; after2 t1 or t2 unlock \n&quot;</span> +</span><br><span class="line">                ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot; after gc  \n&quot;</span> +</span><br><span class="line">                ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot; main thread before lock  \n&quot;</span> +</span><br><span class="line">                ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot;main thread locking \n&quot;</span> +</span><br><span class="line">                    ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot; main thread unlock \n&quot;</span> +</span><br><span class="line">                ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkWord</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出结果-3"><a href="#输出结果-3" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1614039798031</span> before lock 偏向未锁定 </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039860069</span> t1 thread before lock  </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039860069</span> t1 thread locking </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">40</span> d8 <span class="number">1f</span> (<span class="number">00000101</span> <span class="number">01000000</span> <span class="number">11011000</span> <span class="number">00011111</span>) (<span class="number">534265861</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039860572</span> t1 thread unlock </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">40</span> d8 <span class="number">1f</span> (<span class="number">00000101</span> <span class="number">01000000</span> <span class="number">11011000</span> <span class="number">00011111</span>) (<span class="number">534265861</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039861077</span> t2 thread before lock  </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">40</span> d8 <span class="number">1f</span> (<span class="number">00000101</span> <span class="number">01000000</span> <span class="number">11011000</span> <span class="number">00011111</span>) (<span class="number">534265861</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039861078</span> t2 thread locking </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           a0 f4 b3 <span class="number">00</span> (<span class="number">10100000</span> <span class="number">11110100</span> <span class="number">10110011</span> <span class="number">00000000</span>) (<span class="number">11793568</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039862090</span> main thread before lock  </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           a0 f4 b3 <span class="number">00</span> (<span class="number">10100000</span> <span class="number">11110100</span> <span class="number">10110011</span> <span class="number">00000000</span>) (<span class="number">11793568</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039869082</span> t2 thread unlock </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           4a 1a cc 1c (<span class="number">01001010</span> <span class="number">00011010</span> <span class="number">11001100</span> <span class="number">00011100</span>) (<span class="number">483138122</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">1614039869082main thread locking </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           4a 1a cc 1c (<span class="number">01001010</span> <span class="number">00011010</span> <span class="number">11001100</span> <span class="number">00011100</span>) (<span class="number">483138122</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039869083</span> main thread unlock </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           4a 1a cc 1c (<span class="number">01001010</span> <span class="number">00011010</span> <span class="number">11001100</span> <span class="number">00011100</span>) (<span class="number">483138122</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039869084</span> after1 t1 or t2 unlock </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           4a 1a cc 1c (<span class="number">01001010</span> <span class="number">00011010</span> <span class="number">11001100</span> <span class="number">00011100</span>) (<span class="number">483138122</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039871090</span> after2 t1 or t2 unlock </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">1614039871104</span> after gc  </span><br><span class="line">com.sunld.jvm.MarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           09 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00001001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">9</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-mukq{background-color:#96FFFB;border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-as6s{background-color:#FFFC9E;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-mukq" rowspan="3">锁状态</th>
    <th class="tg-as6s" colspan="7">64bit</th>
  </tr>
  <tr>
    <td class="tg-as6s" colspan="3">56bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">4bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">2bit</td>
  </tr>
  <tr>
    <td class="tg-as6s">25bit</td>
    <td class="tg-as6s">29bit</td>
    <td class="tg-as6s">2bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">age</td>
    <td class="tg-as6s">偏向模式</td>
    <td class="tg-as6s">标志位</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-mukq">可偏向<br>t1获取锁前</td>
    <td class="tg-0pky" colspan="2">当前线程指针JavaThread*（54）<br>00000000 00000000 00000000 00000000<br>00000000 00000000 000000</td>
    <td class="tg-0pky">Epoch（2）<br>00</td>
    <td class="tg-0pky">unused<br>0</td>
    <td class="tg-0pky">分代年龄<br>0000</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">01</td>
  </tr>
  <tr>
    <td class="tg-mukq">t1获取锁<br>t1释放锁<br>t2获取锁前</td>
    <td class="tg-0pky" colspan="2">当前线程指针JavaThread*（54）<br>00000000 00000000 00000000 00000000<br>00011111&nbsp;&nbsp;11011000 010000</td>
    <td class="tg-0pky">Epoch（2）<br>00</td>
    <td class="tg-0pky">unused<br>0</td>
    <td class="tg-0pky">分代年龄<br>0000</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">01</td>
  </tr>
  <tr>
    <td class="tg-mukq">t2获取锁<br>main 获取锁前<br>锁升级</td>
    <td class="tg-0pky" colspan="6">指向调用栈中锁记录指针（Lock Record）<br>ptr_to_lock_record(62)<br>00000000 00000000 00000000 00000000<br>00000000 10110011 11110100&nbsp;&nbsp;101000</td>
    <td class="tg-c3ow">00</td>
  </tr>
  <tr>
    <td class="tg-mukq">t2释放锁<br>main获取锁<br>main释放锁<br>未充分释放<br>锁膨胀</td>
    <td class="tg-0pky" colspan="6">指向互斥量（重量级锁）的指针<br>ptr_to_heavyweigth_monitor(62)<br>00000000 00000000 00000000 00000000<br>00011100 11001100&nbsp;&nbsp;00011010 010010</td>
    <td class="tg-c3ow">10</td>
  </tr>
  <tr>
    <td class="tg-mukq">充分释放</td>
    <td class="tg-0pky">unused<br>00000000 00000000 00000000 0</td>
    <td class="tg-0pky" colspan="2">对象哈希码（31）<br>0000000 00000000 00000000 00000000</td>
    <td class="tg-0pky">unused<br>0</td>
    <td class="tg-0pky">分代年龄<br>0000</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">01</td>
  </tr>
  <tr>
    <td class="tg-mukq">gc</td>
    <td class="tg-0pky">unused<br>00000000 00000000 00000000 0</td>
    <td class="tg-0pky" colspan="2">对象哈希码（31）<br>0000000 00000000 00000000 00000000</td>
    <td class="tg-0pky">unused<br>0</td>
    <td class="tg-0pky">分代年龄<br>0001</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">01</td>
  </tr>
</tbody>
</table>

<h3 id="wait方法的影响"><a href="#wait方法的影响" class="headerlink" title="wait方法的影响"></a>wait方法的影响</h3><h4 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.jvm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWaitMarkWord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> WaitMarkWord obj1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">        obj1 = <span class="keyword">new</span> WaitMarkWord();</span><br><span class="line">        System.out.println(<span class="string">&quot;befre lock \n&quot;</span> +</span><br><span class="line">                ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line"></span><br><span class="line">        Thread t1= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;before wait \n&quot;</span> +</span><br><span class="line">                                ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">                        obj1.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;after wait \n&quot;</span> +</span><br><span class="line">                                ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">7000</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">            obj1.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitMarkWord</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="输出结果-4"><a href="#输出结果-4" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># WARNING: Unable to attach Serviceability Agent. You can try again with escalated privileges. Two options: a) use -Djol.tryWithSudo=true to try with sudo; b) echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line">befre lock </span><br><span class="line">com.sunld.jvm.WaitMarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">before wait </span><br><span class="line">com.sunld.jvm.WaitMarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">60</span> a8 <span class="number">20</span> (<span class="number">00000101</span> <span class="number">01100000</span> <span class="number">10101000</span> <span class="number">00100000</span>) (<span class="number">547905541</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">after wait </span><br><span class="line">com.sunld.jvm.WaitMarkWord object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           1a <span class="number">35</span> <span class="number">9d</span> <span class="number">1d</span> (<span class="number">00011010</span> <span class="number">00110101</span> <span class="number">10011101</span> <span class="number">00011101</span>) (<span class="number">496842010</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168253</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-mukq{background-color:#96FFFB;border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-as6s{background-color:#FFFC9E;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-mukq" rowspan="3">锁状态</th>
    <th class="tg-as6s" colspan="7">64bit</th>
  </tr>
  <tr>
    <td class="tg-as6s" colspan="3">56bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">4bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">2bit</td>
  </tr>
  <tr>
    <td class="tg-as6s">25bit</td>
    <td class="tg-as6s">29bit</td>
    <td class="tg-as6s">2bit</td>
    <td class="tg-as6s">1bit</td>
    <td class="tg-as6s">age</td>
    <td class="tg-as6s">偏向模式</td>
    <td class="tg-as6s">标志位</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-mukq">可偏向<br>t1获取锁前</td>
    <td class="tg-0pky" colspan="2">当前线程指针JavaThread*（54）<br>00000000 00000000 00000000 00000000<br>00000000 00000000 000000</td>
    <td class="tg-0pky">Epoch（2）<br>00</td>
    <td class="tg-0pky">unused<br>0</td>
    <td class="tg-0pky">分代年龄<br>0000</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">01</td>
  </tr>
  <tr>
    <td class="tg-mukq">wait前</td>
    <td class="tg-0pky" colspan="2">当前线程指针JavaThread*（54）<br>00000000 00000000 00000000 00000000<br>00100000 10101000 011000</td>
    <td class="tg-0pky">Epoch（2）<br>00</td>
    <td class="tg-0pky">unused<br>0</td>
    <td class="tg-0pky">分代年龄<br>0000</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">01</td>
  </tr>
  <tr>
    <td class="tg-mukq">wait后</td>
    <td class="tg-0pky" colspan="6">指向互斥量（重量级锁）的指针<br>ptr_to_heavyweigth_monitor(62)<br>00000000 00000000 00000000 00000000<br>00011101 10011101&nbsp;&nbsp;00110101 000110</td>
    <td class="tg-c3ow">10</td>
  </tr>
</tbody>
</table>

<p><strong>总结：调用wait之后则直接升级为重量锁</strong></p>
<h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>java的读写锁，在没有写锁的情况下读无阻塞。</p>
<ol>
<li>读锁：并发读</li>
<li>写锁：单独写，阻塞读写 </li>
</ol>
<h4 id="Java中的实现"><a href="#Java中的实现" class="headerlink" title="Java中的实现"></a>Java中的实现</h4><ol>
<li>接口ReadWriteLock实现类ReentrantReadWriteLock；可以用来实现TreeMap的线程安全使用</li>
<li>CopyOnWrite容器（写时复制的容器，读多写少的场景；CopyOnWriteArrayList、CopyOnWriteArraySet）: 添加数据的步骤<ul>
<li> 复制当前容器</li>
<li> 添加数据到新容器中</li>
<li> 修改原容器引用指向新容器</li>
</ul>
</li>
</ol>
<h2 id="锁粗化（减小锁的粒度）"><a href="#锁粗化（减小锁的粒度）" class="headerlink" title="锁粗化（减小锁的粒度）"></a>锁粗化（减小锁的粒度）</h2><p>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段。</p>
<h3 id="分段锁-ConcurrentHashMap"><a href="#分段锁-ConcurrentHashMap" class="headerlink" title="分段锁-ConcurrentHashMap"></a>分段锁-ConcurrentHashMap</h3><p>java中的ConcurrentHashMap在jdk1.8之前的版本，使用一个Segment 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Segment&lt; K,V &gt;[] segments</span><br></pre></td></tr></table></figure>
<ol>
<li>Segment继承ReentrantLock，可重入</li>
<li>在segment中使用HashEntry&lt; K,V &gt;维护数据，在执行put的时候只需要锁定当前的segment（segment的个数表示了并发度）</li>
<li>ConcurrentHashMap 是由Segment 数组结构和HashEntry 数组结构组成 </li>
</ol>
<div align="center">

<img src="/2021/02/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%94%81/1589108702724.png" class>

</div>

<h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><ol>
<li>LongAdder有一个根据当前并发状况动态改变的Cell数组，Cell对象里面有一个long类型的value用来存储值;</li>
<li>在没有竞争或初始化时使用cas来将值累加到成员变量的base上</li>
<li>竞争时，LongAdder会初始化cells数组（个数决定并发度），在Cell数组中选定一个Cell加锁，最后将数组中每个Cell中的value相加，在加上base的值，就是最终的值</li>
<li>cell数组还能根据当前线程争用情况进行扩容，初始长度为2，每次扩容会增长一倍，直到扩容到大于等于cpu数量就不再扩容，这也就是为什么LongAdder比cas和AtomicInteger效率要高的原因，后面两者都是volatile+cas实现的，他们的竞争维度是1，LongAdder的竞争维度为“Cell个数+1”为什么要+1？因为它还有一个base，如果竞争不到锁还会尝试将数值加到base上；</li>
</ol>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue也体现了这样的思想，在队列头入队，在队列尾出队，入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高；<br>拆锁的粒度不能无限拆，最多可以将一个锁拆为当前cup数量个锁即可；</p>
<h2 id="无锁编程"><a href="#无锁编程" class="headerlink" title="无锁编程"></a>无锁编程</h2><ol>
<li>一写一读的无锁队列：内存屏障</li>
<li>一写多读的无锁队列：volatile关键字</li>
<li>多写多读的无锁队列：CAS</li>
<li>无锁栈</li>
<li>无锁链表</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="同步锁与死锁"><a href="#同步锁与死锁" class="headerlink" title="同步锁与死锁"></a>同步锁与死锁</h3><h4 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h4><p>当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。 </p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。  </p>
<h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>互斥同步（Mutual Exclusion &amp; Synchronization）是一种最常见也是最主要的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（CriticalSection）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式。因此在“互斥同步”这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p>
<h3 id="锁的基本实现原理"><a href="#锁的基本实现原理" class="headerlink" title="锁的基本实现原理"></a>锁的基本实现原理</h3><ol>
<li>对象内部得有一个标志位（state变量），记录自己有没有被某个线程占用，最简单的情况是这个state有0、1两个取值，0表示没有线程占用这个锁，1表示有某个线程占用了这个锁。</li>
<li>如果这个对象被某个线程占用，它得记录这个线程的thread ID，知道自己是被哪个线程占用了</li>
<li>这个对象还得维护一个thread id list，记录其他所有阻塞的、等待拿这个锁的线程（也就是记录所有在外边等待的游客）。在当前线程释放锁之后（也就是把state从1改回0），从这个thread id list里面取一个线程唤醒。</li>
</ol>
<h3 id="锁之间的比对"><a href="#锁之间的比对" class="headerlink" title="锁之间的比对"></a>锁之间的比对</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">锁</th>
    <th class="tg-0lax">优点</th>
    <th class="tg-0lax">缺点</th>
    <th class="tg-0lax">场景</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">偏向锁</td>
    <td class="tg-0lax">1.加锁和解锁不需要case，没有额外的消耗<br>2.与非同步方法相比仅存在纳秒级差别</td>
    <td class="tg-0lax">存在竞争时带来偏向撤销的资源消耗</td>
    <td class="tg-0lax">只有一个线程访问同步的场景</td>
  </tr>
  <tr>
    <td class="tg-0lax">轻量锁</td>
    <td class="tg-0lax">竞争的线程不会阻塞，提高响应速度</td>
    <td class="tg-0lax">自旋消耗CPU</td>
    <td class="tg-0lax">追求响应时间，同步快，执行速度快</td>
  </tr>
  <tr>
    <td class="tg-0lax">重量锁</td>
    <td class="tg-0lax">不自旋，不消化额外的cpu</td>
    <td class="tg-0lax">1.响应速度慢<br>2.频繁获取释放锁，消耗性能</td>
    <td class="tg-0lax">追求吞吐量，同步快，执行速度较长</td>
  </tr>
</tbody>
</table>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.jianshu.com/p/39628e1180a9">Java锁 - 导读</a></li>
<li><a href="https://blog.csdn.net/zqz_zqz/article/details/70233767">java 中的锁 – 偏向锁、轻量级锁、自旋锁、重量级锁</a></li>
<li><a href="https://www.usenix.org/legacy/event/jvm01/full_papers/dice/dice.pdf">David Dice’s paper Implementing Fast Java Monitors with Relaxed-Locks</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot常用配置参考</title>
    <url>/2021/02/07/SpringBoot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h2 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># ===================================================================</span><br><span class="line"># COMMON SPRING BOOT PROPERTIES</span><br><span class="line">#</span><br><span class="line"># This sample file is provided as a guideline. Do NOT copy it in its</span><br><span class="line"># entirety to your own application.               ^^^</span><br><span class="line"># ===================================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ----------------------------------------</span><br><span class="line"># CORE PROPERTIES</span><br><span class="line"># ----------------------------------------</span><br><span class="line"></span><br><span class="line"># BANNER</span><br><span class="line">banner.charset=UTF-8 # Banner file encoding.</span><br><span class="line">banner.location=classpath:banner.txt # Banner file location.</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="LOGGING"><a href="#LOGGING" class="headerlink" title="LOGGING"></a>LOGGING</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># LOGGING</span><br><span class="line">logging.config= # Location of the logging configuration file. For instance `classpath:logback.xml` for Logback</span><br><span class="line">logging.exception-conversion-word=%wEx # Conversion word used when logging exceptions.</span><br><span class="line">logging.file= # Log file name. For instance `myapp.log`</span><br><span class="line">logging.level.*= # Log levels severity mapping. For instance `logging.level.org.springframework=DEBUG`</span><br><span class="line">logging.path= # Location of the log file. For instance `/var/log`</span><br><span class="line">logging.pattern.console= # Appender pattern for output to the console. Only supported with the default logback setup.</span><br><span class="line">logging.pattern.file= # Appender pattern for output to the file. Only supported with the default logback setup.</span><br><span class="line">logging.pattern.level= # Appender pattern for log level (default %5p). Only supported with the default logback setup.</span><br><span class="line">logging.register-shutdown-hook=false # Register a shutdown hook for the logging system when it is initialized.</span><br></pre></td></tr></table></figure>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># AOP</span><br><span class="line">spring.aop.auto=true # Add @EnableAspectJAutoProxy.</span><br><span class="line">spring.aop.proxy-target-class=false # Whether subclass-based (CGLIB) proxies are to be created (true) as opposed to standard Java interface-based proxies (false).</span><br></pre></td></tr></table></figure>
<h2 id="IDENTITY"><a href="#IDENTITY" class="headerlink" title="IDENTITY"></a>IDENTITY</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># IDENTITY (ContextIdApplicationContextInitializer)</span><br><span class="line">spring.application.index= # Application index.</span><br><span class="line">spring.application.name= # Application name.</span><br><span class="line"></span><br><span class="line"># ADMIN (SpringApplicationAdminJmxAutoConfiguration)</span><br><span class="line">spring.application.admin.enabled=false # Enable admin features for the application.</span><br><span class="line">spring.application.admin.jmx-name=org.springframework.boot:type=Admin,name=SpringApplication # JMX name of the application admin MBean.</span><br></pre></td></tr></table></figure>
<h2 id="AUTO-CONFIGURATION"><a href="#AUTO-CONFIGURATION" class="headerlink" title="AUTO-CONFIGURATION"></a>AUTO-CONFIGURATION</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># AUTO-CONFIGURATION</span><br><span class="line">spring.autoconfigure.exclude= # Auto-configuration classes to exclude.</span><br></pre></td></tr></table></figure>
<h2 id="SPRING-CORE"><a href="#SPRING-CORE" class="headerlink" title="SPRING CORE"></a>SPRING CORE</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># SPRING CORE</span><br><span class="line">spring.beaninfo.ignore=true # Skip search of BeanInfo classes.</span><br></pre></td></tr></table></figure>
<h2 id="SPRING-CACHE-CacheProperties"><a href="#SPRING-CACHE-CacheProperties" class="headerlink" title="SPRING CACHE (CacheProperties)"></a>SPRING CACHE (CacheProperties)</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># SPRING CACHE (CacheProperties)</span><br><span class="line">spring.cache.cache-names= # Comma-separated list of cache names to create if supported by the underlying cache manager.</span><br><span class="line">spring.cache.ehcache.config= # The location of the configuration file to use to initialize EhCache.</span><br><span class="line">spring.cache.guava.spec= # The spec to use to create caches. Check CacheBuilderSpec for more details on the spec format.</span><br><span class="line">spring.cache.hazelcast.config= # The location of the configuration file to use to initialize Hazelcast.</span><br><span class="line">spring.cache.infinispan.config= # The location of the configuration file to use to initialize Infinispan.</span><br><span class="line">spring.cache.jcache.config= # The location of the configuration file to use to initialize the cache manager.</span><br><span class="line">spring.cache.jcache.provider= # Fully qualified name of the CachingProvider implementation to use to retrieve the JSR-107 compliant cache manager. Only needed if more than one JSR-107 implementation is available on the classpath.</span><br><span class="line">spring.cache.type= # Cache type, auto-detected according to the environment by default.</span><br></pre></td></tr></table></figure>
<h2 id="SPRING-CONFIG"><a href="#SPRING-CONFIG" class="headerlink" title="SPRING CONFIG"></a>SPRING CONFIG</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># SPRING CONFIG - using environment property only (ConfigFileApplicationListener)</span><br><span class="line">spring.config.location= # Config file locations.</span><br><span class="line">spring.config.name=application # Config file name.</span><br></pre></td></tr></table></figure>
<h2 id="HAZELCAST"><a href="#HAZELCAST" class="headerlink" title="HAZELCAST"></a>HAZELCAST</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># HAZELCAST (HazelcastProperties)</span><br><span class="line">spring.hazelcast.config= # The location of the configuration file to use to initialize Hazelcast.</span><br></pre></td></tr></table></figure>
<h2 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># JMX</span><br><span class="line">spring.jmx.default-domain= # JMX domain name.</span><br><span class="line">spring.jmx.enabled=true # Expose management beans to the JMX domain.</span><br><span class="line">spring.jmx.server=mbeanServer # MBeanServer bean name.</span><br></pre></td></tr></table></figure>
<h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Email (MailProperties)</span><br><span class="line">spring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.</span><br><span class="line">spring.mail.host= # SMTP server host. For instance `smtp.example.com`</span><br><span class="line">spring.mail.jndi-name= # Session JNDI name. When set, takes precedence to others mail settings.</span><br><span class="line">spring.mail.password= # Login password of the SMTP server.</span><br><span class="line">spring.mail.port= # SMTP server port.</span><br><span class="line">spring.mail.properties.*= # Additional JavaMail session properties.</span><br><span class="line">spring.mail.protocol=smtp # Protocol used by the SMTP server.</span><br><span class="line">spring.mail.test-connection=false # Test that the mail server is available on startup.</span><br><span class="line">spring.mail.username= # Login user of the SMTP server.</span><br></pre></td></tr></table></figure>
<h2 id="APPLICATION-SETTINGS"><a href="#APPLICATION-SETTINGS" class="headerlink" title="APPLICATION SETTINGS"></a>APPLICATION SETTINGS</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># APPLICATION SETTINGS (SpringApplication)</span><br><span class="line">spring.main.banner-mode=console # Mode used to display the banner when the application runs.</span><br><span class="line">spring.main.sources= # Sources (class name, package name or XML resource location) to include in the ApplicationContext.</span><br><span class="line">spring.main.web-environment= # Run the application in a web environment (auto-detected by default).</span><br></pre></td></tr></table></figure>
<h2 id="FILE-ENCODING"><a href="#FILE-ENCODING" class="headerlink" title="FILE ENCODING"></a>FILE ENCODING</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># FILE ENCODING (FileEncodingApplicationListener)</span><br><span class="line">spring.mandatory-file-encoding= # Expected character encoding the application must use.</span><br></pre></td></tr></table></figure>
<h2 id="INTERNATIONALIZATION"><a href="#INTERNATIONALIZATION" class="headerlink" title="INTERNATIONALIZATION"></a>INTERNATIONALIZATION</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># INTERNATIONALIZATION (MessageSourceAutoConfiguration)</span><br><span class="line">spring.messages.basename=messages # Comma-separated list of basenames, each following the ResourceBundle convention.</span><br><span class="line">spring.messages.cache-seconds=-1 # Loaded resource bundle files cache expiration, in seconds. When set to -1, bundles are cached forever.</span><br><span class="line">spring.messages.encoding=UTF-8 # Message bundles encoding.</span><br><span class="line">spring.messages.fallback-to-system-locale=true # Set whether to fall back to the system Locale if no files for a specific Locale have been found.</span><br></pre></td></tr></table></figure>
<h2 id="OUTPUT"><a href="#OUTPUT" class="headerlink" title="OUTPUT"></a>OUTPUT</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># OUTPUT</span><br><span class="line">spring.output.ansi.enabled=detect # Configure the ANSI output (can be &quot;detect&quot;, &quot;always&quot;, &quot;never&quot;).</span><br></pre></td></tr></table></figure>
<h2 id="PID-FILE"><a href="#PID-FILE" class="headerlink" title="PID FILE"></a>PID FILE</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># PID FILE (ApplicationPidFileWriter)</span><br><span class="line">spring.pid.fail-on-write-error= # Fail if ApplicationPidFileWriter is used but it cannot write the PID file.</span><br><span class="line">spring.pid.file= # Location of the PID file to write (if ApplicationPidFileWriter is used).</span><br></pre></td></tr></table></figure>
<h2 id="PROFILES"><a href="#PROFILES" class="headerlink" title="PROFILES"></a>PROFILES</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># PROFILES</span><br><span class="line">spring.profiles.active= # Comma-separated list of active profiles.</span><br><span class="line">spring.profiles.include= # Unconditionally activate the specified comma separated profiles.</span><br></pre></td></tr></table></figure>
<h2 id="SENDGRID"><a href="#SENDGRID" class="headerlink" title="SENDGRID"></a>SENDGRID</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># SENDGRID (SendGridAutoConfiguration)</span><br><span class="line">spring.sendgrid.username= # SendGrid account username</span><br><span class="line">spring.sendgrid.password= # SendGrid account password</span><br><span class="line">spring.sendgrid.proxy.host= # SendGrid proxy host</span><br><span class="line">spring.sendgrid.proxy.port= # SendGrid proxy port</span><br></pre></td></tr></table></figure>
<h2 id="WEB-PROPERTIES"><a href="#WEB-PROPERTIES" class="headerlink" title="WEB PROPERTIES"></a>WEB PROPERTIES</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># ----------------------------------------</span><br><span class="line"># WEB PROPERTIES</span><br><span class="line"># ----------------------------------------</span><br><span class="line"></span><br><span class="line"># MULTIPART (MultipartProperties)</span><br><span class="line">multipart.enabled=true # Enable support of multi-part uploads.</span><br><span class="line">multipart.file-size-threshold=0 # Threshold after which files will be written to disk. Values can use the suffixed &quot;MB&quot; or &quot;KB&quot; to indicate a Megabyte or Kilobyte size.</span><br><span class="line">multipart.location= # Intermediate location of uploaded files.</span><br><span class="line">multipart.max-file-size=1Mb # Max file size. Values can use the suffixed &quot;MB&quot; or &quot;KB&quot; to indicate a Megabyte or Kilobyte size.</span><br><span class="line">multipart.max-request-size=10Mb # Max request size. Values can use the suffixed &quot;MB&quot; or &quot;KB&quot; to indicate a Megabyte or Kilobyte size.</span><br><span class="line"></span><br><span class="line"># EMBEDDED SERVER CONFIGURATION (ServerProperties)</span><br><span class="line">server.address= # Network address to which the server should bind to.</span><br><span class="line">server.compression.enabled=false # If response compression is enabled.</span><br><span class="line">server.compression.excluded-user-agents= # List of user-agents to exclude from compression.</span><br><span class="line">server.compression.mime-types= # Comma-separated list of MIME types that should be compressed. For instance `text/html,text/css,application/json`</span><br><span class="line">server.compression.min-response-size= # Minimum response size that is required for compression to be performed. For instance 2048</span><br><span class="line">server.context-parameters.*= # Servlet context init parameters. For instance `server.context-parameters.a=alpha`</span><br><span class="line">server.context-path= # Context path of the application.</span><br><span class="line">server.display-name=application # Display name of the application.</span><br><span class="line">server.error.include-stacktrace=never # When to include a &quot;stacktrace&quot; attribute.</span><br><span class="line">server.error.path=/error # Path of the error controller.</span><br><span class="line">server.error.whitelabel.enabled=true # Enable the default error page displayed in browsers in case of a server error.</span><br><span class="line">server.jsp-servlet.class-name=org.apache.jasper.servlet.JspServlet # The class name of the JSP servlet.</span><br><span class="line">server.jsp-servlet.init-parameters.*= # Init parameters used to configure the JSP servlet</span><br><span class="line">server.jsp-servlet.registered=true # Whether or not the JSP servlet is registered</span><br><span class="line">server.port=8080 # Server HTTP port.</span><br><span class="line">server.server-header= # The value sent in the server response header (uses servlet container default if empty)</span><br><span class="line">server.servlet-path=/ # Path of the main dispatcher servlet.</span><br><span class="line">server.session.cookie.comment= # Comment for the session cookie.</span><br><span class="line">server.session.cookie.domain= # Domain for the session cookie.</span><br><span class="line">server.session.cookie.http-only= # &quot;HttpOnly&quot; flag for the session cookie.</span><br><span class="line">server.session.cookie.max-age= # Maximum age of the session cookie in seconds.</span><br><span class="line">server.session.cookie.name= # Session cookie name.</span><br><span class="line">server.session.cookie.path= # Path of the session cookie.</span><br><span class="line">server.session.cookie.secure= # &quot;Secure&quot; flag for the session cookie.</span><br><span class="line">server.session.persistent=false # Persist session data between restarts.</span><br><span class="line">server.session.store-dir= # Directory used to store session data.</span><br><span class="line">server.session.timeout= # Session timeout in seconds.</span><br><span class="line">server.session.tracking-modes= # Session tracking modes (one or more of the following: &quot;cookie&quot;, &quot;url&quot;, &quot;ssl&quot;).</span><br><span class="line">server.ssl.ciphers= # Supported SSL ciphers.</span><br><span class="line">server.ssl.client-auth= # Whether client authentication is wanted (&quot;want&quot;) or needed (&quot;need&quot;). Requires a trust store.</span><br><span class="line">server.ssl.enabled= #</span><br><span class="line">server.ssl.key-alias= #</span><br><span class="line">server.ssl.key-password= #</span><br><span class="line">server.ssl.key-store= #</span><br><span class="line">server.ssl.key-store-password= #</span><br><span class="line">server.ssl.key-store-provider= #</span><br><span class="line">server.ssl.key-store-type= #</span><br><span class="line">server.ssl.protocol= #</span><br><span class="line">server.ssl.trust-store= #</span><br><span class="line">server.ssl.trust-store-password= #</span><br><span class="line">server.ssl.trust-store-provider= #</span><br><span class="line">server.ssl.trust-store-type= #</span><br><span class="line">server.tomcat.accesslog.directory=logs # Directory in which log files are created. Can be relative to the tomcat base dir or absolute.</span><br><span class="line">server.tomcat.accesslog.enabled=false # Enable access log.</span><br><span class="line">server.tomcat.accesslog.pattern=common # Format pattern for access logs.</span><br><span class="line">server.tomcat.accesslog.prefix=access_log # Log file name prefix.</span><br><span class="line">server.tomcat.accesslog.suffix=.log # Log file name suffix.</span><br><span class="line">server.tomcat.background-processor-delay=30 # Delay in seconds between the invocation of backgroundProcess methods.</span><br><span class="line">server.tomcat.basedir= # Tomcat base directory. If not specified a temporary directory will be used.</span><br><span class="line">server.tomcat.internal-proxies=10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span><br><span class="line">        192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span><br><span class="line">        169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span><br><span class="line">        127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span><br><span class="line">        172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span><br><span class="line">        172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span><br><span class="line">        172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125; # regular expression matching trusted IP addresses.</span><br><span class="line">server.tomcat.max-http-header-size=0 # Maximum size in bytes of the HTTP message header.</span><br><span class="line">server.tomcat.max-threads=0 # Maximum amount of worker threads.</span><br><span class="line">server.tomcat.port-header=X-Forwarded-Port # Name of the HTTP header used to override the original port value.</span><br><span class="line">server.tomcat.protocol-header= # Header that holds the incoming protocol, usually named &quot;X-Forwarded-Proto&quot;.</span><br><span class="line">server.tomcat.protocol-header-https-value=https # Value of the protocol header that indicates that the incoming request uses SSL.</span><br><span class="line">server.tomcat.remote-ip-header= # Name of the http header from which the remote ip is extracted. For instance `X-FORWARDED-FOR`</span><br><span class="line">server.tomcat.uri-encoding=UTF-8 # Character encoding to use to decode the URI.</span><br><span class="line">server.undertow.accesslog.dir= # Undertow access log directory.</span><br><span class="line">server.undertow.accesslog.enabled=false # Enable access log.</span><br><span class="line">server.undertow.accesslog.pattern=common # Format pattern for access logs.</span><br><span class="line">server.undertow.buffer-size= # Size of each buffer in bytes.</span><br><span class="line">server.undertow.buffers-per-region= # Number of buffer per region.</span><br><span class="line">server.undertow.direct-buffers= # Allocate buffers outside the Java heap.</span><br><span class="line">server.undertow.io-threads= # Number of I/O threads to create for the worker.</span><br><span class="line">server.undertow.worker-threads= # Number of worker threads.</span><br><span class="line">server.use-forward-headers= # If X-Forwarded-* headers should be applied to the HttpRequest.</span><br><span class="line"></span><br><span class="line"># FREEMARKER (FreeMarkerAutoConfiguration)</span><br><span class="line">spring.freemarker.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.</span><br><span class="line">spring.freemarker.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.</span><br><span class="line">spring.freemarker.cache=false # Enable template caching.</span><br><span class="line">spring.freemarker.charset=UTF-8 # Template encoding.</span><br><span class="line">spring.freemarker.check-template-location=true # Check that the templates location exists.</span><br><span class="line">spring.freemarker.content-type=text/html # Content-Type value.</span><br><span class="line">spring.freemarker.enabled=true # Enable MVC view resolution for this technology.</span><br><span class="line">spring.freemarker.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.</span><br><span class="line">spring.freemarker.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.</span><br><span class="line">spring.freemarker.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring&#x27;s macro library, under the name &quot;springMacroRequestContext&quot;.</span><br><span class="line">spring.freemarker.prefer-file-system-access=true # Prefer file system access for template loading. File system access enables hot detection of template changes.</span><br><span class="line">spring.freemarker.prefix= # Prefix that gets prepended to view names when building a URL.</span><br><span class="line">spring.freemarker.request-context-attribute= # Name of the RequestContext attribute for all views.</span><br><span class="line">spring.freemarker.settings.*= # Well-known FreeMarker keys which will be passed to FreeMarker&#x27;s Configuration.</span><br><span class="line">spring.freemarker.suffix= # Suffix that gets appended to view names when building a URL.</span><br><span class="line">spring.freemarker.template-loader-path=classpath:/templates/ # Comma-separated list of template paths.</span><br><span class="line">spring.freemarker.view-names= # White list of view names that can be resolved.</span><br><span class="line"></span><br><span class="line"># GROOVY TEMPLATES (GroovyTemplateAutoConfiguration)</span><br><span class="line">spring.groovy.template.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.</span><br><span class="line">spring.groovy.template.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.</span><br><span class="line">spring.groovy.template.cache= # Enable template caching.</span><br><span class="line">spring.groovy.template.charset=UTF-8 # Template encoding.</span><br><span class="line">spring.groovy.template.check-template-location=true # Check that the templates location exists.</span><br><span class="line">spring.groovy.template.configuration.*= # See GroovyMarkupConfigurer</span><br><span class="line">spring.groovy.template.content-type=test/html # Content-Type value.</span><br><span class="line">spring.groovy.template.enabled=true # Enable MVC view resolution for this technology.</span><br><span class="line">spring.groovy.template.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.</span><br><span class="line">spring.groovy.template.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.</span><br><span class="line">spring.groovy.template.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring&#x27;s macro library, under the name &quot;springMacroRequestContext&quot;.</span><br><span class="line">spring.groovy.template.prefix= # Prefix that gets prepended to view names when building a URL.</span><br><span class="line">spring.groovy.template.request-context-attribute= # Name of the RequestContext attribute for all views.</span><br><span class="line">spring.groovy.template.resource-loader-path=classpath:/templates/ # Template path.</span><br><span class="line">spring.groovy.template.suffix=.tpl # Suffix that gets appended to view names when building a URL.</span><br><span class="line">spring.groovy.template.view-names= # White list of view names that can be resolved.</span><br><span class="line"></span><br><span class="line"># SPRING HATEOAS (HateoasProperties)</span><br><span class="line">spring.hateoas.use-hal-as-default-json-media-type=true # Specify if application/hal+json responses should be sent to requests that accept application/json.</span><br><span class="line"></span><br><span class="line"># HTTP message conversion</span><br><span class="line">spring.http.converters.preferred-json-mapper=jackson # Preferred JSON mapper to use for HTTP message conversion. Set to &quot;gson&quot; to force the use of Gson when both it and Jackson are on the classpath.</span><br><span class="line"></span><br><span class="line"># HTTP encoding (HttpEncodingProperties)</span><br><span class="line">spring.http.encoding.charset=UTF-8 # Charset of HTTP requests and responses. Added to the &quot;Content-Type&quot; header if not set explicitly.</span><br><span class="line">spring.http.encoding.enabled=true # Enable http encoding support.</span><br><span class="line">spring.http.encoding.force=true # Force the encoding to the configured charset on HTTP requests and responses.</span><br><span class="line"></span><br><span class="line"># JACKSON (JacksonProperties)</span><br><span class="line">spring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance `yyyy-MM-dd HH:mm:ss`.</span><br><span class="line">spring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.</span><br><span class="line">spring.jackson.generator.*= # Jackson on/off features for generators.</span><br><span class="line">spring.jackson.joda-date-time-format= # Joda date time format string. If not configured, &quot;date-format&quot; will be used as a fallback if it is configured with a format string.</span><br><span class="line">spring.jackson.locale= # Locale used for formatting.</span><br><span class="line">spring.jackson.mapper.*= # Jackson general purpose on/off features.</span><br><span class="line">spring.jackson.parser.*= # Jackson on/off features for parsers.</span><br><span class="line">spring.jackson.property-naming-strategy= # One of the constants on Jackson&#x27;s PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.</span><br><span class="line">spring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.</span><br><span class="line">spring.jackson.serialization-inclusion= # Controls the inclusion of properties during serialization. Configured with one of the values in Jackson&#x27;s JsonInclude.Include enumeration.</span><br><span class="line">spring.jackson.time-zone= # Time zone used when formatting dates. For instance `America/Los_Angeles`</span><br><span class="line"></span><br><span class="line"># JERSEY (JerseyProperties)</span><br><span class="line">spring.jersey.application-path= # Path that serves as the base URI for the application. Overrides the value of &quot;@ApplicationPath&quot; if specified.</span><br><span class="line">spring.jersey.filter.order=0 # Jersey filter chain order.</span><br><span class="line">spring.jersey.init.*= # Init parameters to pass to Jersey via the servlet or filter.</span><br><span class="line">spring.jersey.type=servlet # Jersey integration type. Can be either &quot;servlet&quot; or &quot;filter&quot;.</span><br><span class="line"></span><br><span class="line"># SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)</span><br><span class="line">spring.mobile.devicedelegatingviewresolver.enable-fallback=false # Enable support for fallback resolution.</span><br><span class="line">spring.mobile.devicedelegatingviewresolver.enabled=false # Enable device view resolver.</span><br><span class="line">spring.mobile.devicedelegatingviewresolver.mobile-prefix=mobile/ # Prefix that gets prepended to view names for mobile devices.</span><br><span class="line">spring.mobile.devicedelegatingviewresolver.mobile-suffix= # Suffix that gets appended to view names for mobile devices.</span><br><span class="line">spring.mobile.devicedelegatingviewresolver.normal-prefix= # Prefix that gets prepended to view names for normal devices.</span><br><span class="line">spring.mobile.devicedelegatingviewresolver.normal-suffix= # Suffix that gets appended to view names for normal devices.</span><br><span class="line">spring.mobile.devicedelegatingviewresolver.tablet-prefix=tablet/ # Prefix that gets prepended to view names for tablet devices.</span><br><span class="line">spring.mobile.devicedelegatingviewresolver.tablet-suffix= # Suffix that gets appended to view names for tablet devices.</span><br><span class="line"></span><br><span class="line"># SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)</span><br><span class="line">spring.mobile.sitepreference.enabled=true # Enable SitePreferenceHandler.</span><br><span class="line"></span><br><span class="line"># MUSTACHE TEMPLATES (MustacheAutoConfiguration)</span><br><span class="line">spring.mustache.cache=false # Enable template caching.</span><br><span class="line">spring.mustache.charset=UTF-8 # Template encoding.</span><br><span class="line">spring.mustache.check-template-location=true # Check that the templates location exists.</span><br><span class="line">spring.mustache.content-type=text/html # Content-Type value.</span><br><span class="line">spring.mustache.enabled=true # Enable MVC view resolution for this technology.</span><br><span class="line">spring.mustache.prefix=classpath:/templates/ # Prefix to apply to template names.</span><br><span class="line">spring.mustache.suffix=.html # Suffix to apply to template names.</span><br><span class="line">spring.mustache.view-names= # White list of view names that can be resolved.</span><br><span class="line"></span><br><span class="line"># SPRING MVC (WebMvcProperties)</span><br><span class="line">spring.mvc.async.request-timeout= # Amount of time (in milliseconds) before asynchronous request handling times out.</span><br><span class="line">spring.mvc.date-format= # Date format to use. For instance `dd/MM/yyyy`.</span><br><span class="line">spring.mvc.dispatch-trace-request=false # Dispatch TRACE requests to the FrameworkServlet doService method.</span><br><span class="line">spring.mvc.dispatch-options-request=false # Dispatch OPTIONS requests to the FrameworkServlet doService method.</span><br><span class="line">spring.mvc.favicon.enabled=true # Enable resolution of favicon.ico.</span><br><span class="line">spring.mvc.formcontent.putfilter.enabled=true # Enable Spring&#x27;s HttpPutFormContentFilter.</span><br><span class="line">spring.mvc.ignore-default-model-on-redirect=true # If the content of the &quot;default&quot; model should be ignored during redirect scenarios.</span><br><span class="line">spring.mvc.locale= # Locale to use.</span><br><span class="line">spring.mvc.media-types.*= # Maps file extensions to media types for content negotiation.</span><br><span class="line">spring.mvc.message-codes-resolver-format= # Formatting strategy for message codes. For instance `PREFIX_ERROR_CODE`.</span><br><span class="line">spring.mvc.static-path-pattern=/** # Path pattern used for static resources.</span><br><span class="line">spring.mvc.throw-exception-if-no-handler-found=false # If a &quot;NoHandlerFoundException&quot; should be thrown if no Handler was found to process a request.</span><br><span class="line">spring.mvc.view.prefix= # Spring MVC view prefix.</span><br><span class="line">spring.mvc.view.suffix= # Spring MVC view suffix.</span><br><span class="line"></span><br><span class="line"># SPRING RESOURCES HANDLING (ResourceProperties)</span><br><span class="line">spring.resources.add-mappings=true # Enable default resource handling.</span><br><span class="line">spring.resources.cache-period= # Cache period for the resources served by the resource handler, in seconds.</span><br><span class="line">spring.resources.chain.cache=true # Enable caching in the Resource chain.</span><br><span class="line">spring.resources.chain.enabled= # Enable the Spring Resource Handling chain. Disabled by default unless at least one strategy has been enabled.</span><br><span class="line">spring.resources.chain.html-application-cache=false # Enable HTML5 application cache manifest rewriting.</span><br><span class="line">spring.resources.chain.strategy.content.enabled=false # Enable the content Version Strategy.</span><br><span class="line">spring.resources.chain.strategy.content.paths=/** # Comma-separated list of patterns to apply to the Version Strategy.</span><br><span class="line">spring.resources.chain.strategy.fixed.enabled=false # Enable the fixed Version Strategy.</span><br><span class="line">spring.resources.chain.strategy.fixed.paths= # Comma-separated list of patterns to apply to the Version Strategy.</span><br><span class="line">spring.resources.chain.strategy.fixed.version= # Version string to use for the Version Strategy.</span><br><span class="line">spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ # Locations of static resources.</span><br><span class="line"></span><br><span class="line"># SPRING SOCIAL (SocialWebAutoConfiguration)</span><br><span class="line">spring.social.auto-connection-views=false # Enable the connection status view for supported providers.</span><br><span class="line"></span><br><span class="line"># SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)</span><br><span class="line">spring.social.facebook.app-id= # your application&#x27;s Facebook App ID</span><br><span class="line">spring.social.facebook.app-secret= # your application&#x27;s Facebook App Secret</span><br><span class="line"></span><br><span class="line"># SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)</span><br><span class="line">spring.social.linkedin.app-id= # your application&#x27;s LinkedIn App ID</span><br><span class="line">spring.social.linkedin.app-secret= # your application&#x27;s LinkedIn App Secret</span><br><span class="line"></span><br><span class="line"># SPRING SOCIAL TWITTER (TwitterAutoConfiguration)</span><br><span class="line">spring.social.twitter.app-id= # your application&#x27;s Twitter App ID</span><br><span class="line">spring.social.twitter.app-secret= # your application&#x27;s Twitter App Secret</span><br><span class="line"></span><br><span class="line"># THYMELEAF (ThymeleafAutoConfiguration)</span><br><span class="line">spring.thymeleaf.cache=true # Enable template caching.</span><br><span class="line">spring.thymeleaf.check-template-location=true # Check that the templates location exists.</span><br><span class="line">spring.thymeleaf.content-type=text/html # Content-Type value.</span><br><span class="line">spring.thymeleaf.enabled=true # Enable MVC Thymeleaf view resolution.</span><br><span class="line">spring.thymeleaf.encoding=UTF-8 # Template encoding.</span><br><span class="line">spring.thymeleaf.excluded-view-names= # Comma-separated list of view names that should be excluded from resolution.</span><br><span class="line">spring.thymeleaf.mode=HTML5 # Template mode to be applied to templates. See also StandardTemplateModeHandlers.</span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/ # Prefix that gets prepended to view names when building a URL.</span><br><span class="line">spring.thymeleaf.suffix=.html # Suffix that gets appended to view names when building a URL.</span><br><span class="line">spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain.</span><br><span class="line">spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.</span><br><span class="line"></span><br><span class="line"># VELOCITY TEMPLATES (VelocityAutoConfiguration)</span><br><span class="line">spring.velocity.allow-request-override=false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.</span><br><span class="line">spring.velocity.allow-session-override=false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.</span><br><span class="line">spring.velocity.cache= # Enable template caching.</span><br><span class="line">spring.velocity.charset=UTF-8 # Template encoding.</span><br><span class="line">spring.velocity.check-template-location=true # Check that the templates location exists.</span><br><span class="line">spring.velocity.content-type=text/html # Content-Type value.</span><br><span class="line">spring.velocity.date-tool-attribute= # Name of the DateTool helper object to expose in the Velocity context of the view.</span><br><span class="line">spring.velocity.enabled=true # Enable MVC view resolution for this technology.</span><br><span class="line">spring.velocity.expose-request-attributes=false # Set whether all request attributes should be added to the model prior to merging with the template.</span><br><span class="line">spring.velocity.expose-session-attributes=false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.</span><br><span class="line">spring.velocity.expose-spring-macro-helpers=true # Set whether to expose a RequestContext for use by Spring&#x27;s macro library, under the name &quot;springMacroRequestContext&quot;.</span><br><span class="line">spring.velocity.number-tool-attribute= # Name of the NumberTool helper object to expose in the Velocity context of the view.</span><br><span class="line">spring.velocity.prefer-file-system-access=true # Prefer file system access for template loading. File system access enables hot detection of template changes.</span><br><span class="line">spring.velocity.prefix= # Prefix that gets prepended to view names when building a URL.</span><br><span class="line">spring.velocity.properties.*= # Additional velocity properties.</span><br><span class="line">spring.velocity.request-context-attribute= # Name of the RequestContext attribute for all views.</span><br><span class="line">spring.velocity.resource-loader-path=classpath:/templates/ # Template path.</span><br><span class="line">spring.velocity.suffix=.vm # Suffix that gets appended to view names when building a URL.</span><br><span class="line">spring.velocity.toolbox-config-location= # Velocity Toolbox config location. For instance `/WEB-INF/toolbox.xml`</span><br><span class="line">spring.velocity.view-names= # White list of view names that can be resolved.</span><br></pre></td></tr></table></figure>
<h2 id="SECURITY-PROPERTIES"><a href="#SECURITY-PROPERTIES" class="headerlink" title="SECURITY PROPERTIES"></a>SECURITY PROPERTIES</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># ----------------------------------------</span><br><span class="line"># SECURITY PROPERTIES</span><br><span class="line"># ----------------------------------------</span><br><span class="line"># SECURITY (SecurityProperties)</span><br><span class="line">security.basic.authorize-mode=role # Security authorize mode to apply.</span><br><span class="line">security.basic.enabled=true # Enable basic authentication.</span><br><span class="line">security.basic.path=/** # Comma-separated list of paths to secure.</span><br><span class="line">security.basic.realm=Spring # HTTP basic realm name.</span><br><span class="line">security.enable-csrf=false # Enable Cross Site Request Forgery support.</span><br><span class="line">security.filter-order=0 # Security filter chain order.</span><br><span class="line">security.filter-dispatcher-types=ASYNC, FORWARD, INCLUDE, REQUEST # Security filter chain dispatcher types.</span><br><span class="line">security.headers.cache=true # Enable cache control HTTP headers.</span><br><span class="line">security.headers.content-type=true # Enable &quot;X-Content-Type-Options&quot; header.</span><br><span class="line">security.headers.frame=true # Enable &quot;X-Frame-Options&quot; header.</span><br><span class="line">security.headers.hsts= # HTTP Strict Transport Security (HSTS) mode (none, domain, all).</span><br><span class="line">security.headers.xss=true # Enable cross site scripting (XSS) protection.</span><br><span class="line">security.ignored= # Comma-separated list of paths to exclude from the default secured paths.</span><br><span class="line">security.require-ssl=false # Enable secure channel for all requests.</span><br><span class="line">security.sessions=stateless # Session creation policy (always, never, if_required, stateless).</span><br><span class="line">security.user.name=user # Default user name.</span><br><span class="line">security.user.password= # Password for the default user name. A random password is logged on startup by default.</span><br><span class="line">security.user.role=USER # Granted roles for the default user name.</span><br><span class="line"></span><br><span class="line"># SECURITY OAUTH2 CLIENT (OAuth2ClientProperties</span><br><span class="line">security.oauth2.client.client-id= # OAuth2 client id.</span><br><span class="line">security.oauth2.client.client-secret= # OAuth2 client secret. A random secret is generated by default</span><br><span class="line"></span><br><span class="line"># SECURITY OAUTH2 RESOURCES (ResourceServerProperties</span><br><span class="line">security.oauth2.resource.id= # Identifier of the resource.</span><br><span class="line">security.oauth2.resource.jwt.key-uri= # The URI of the JWT token. Can be set if the value is not available and the key is public.</span><br><span class="line">security.oauth2.resource.jwt.key-value= # The verification key of the JWT token. Can either be a symmetric secret or PEM-encoded RSA public key.</span><br><span class="line">security.oauth2.resource.prefer-token-info=true # Use the token info, can be set to false to use the user info.</span><br><span class="line">security.oauth2.resource.service-id=resource #</span><br><span class="line">security.oauth2.resource.token-info-uri= # URI of the token decoding endpoint.</span><br><span class="line">security.oauth2.resource.token-type= # The token type to send when using the userInfoUri.</span><br><span class="line">security.oauth2.resource.user-info-uri= # URI of the user endpoint.</span><br><span class="line"></span><br><span class="line"># SECURITY OAUTH2 SSO (OAuth2SsoProperties</span><br><span class="line">security.oauth2.sso.filter-order= # Filter order to apply if not providing an explicit WebSecurityConfigurerAdapter</span><br><span class="line">security.oauth2.sso.login-path=/login # Path to the login page, i.e. the one that triggers the redirect to the OAuth2 Authorization Server</span><br></pre></td></tr></table></figure>
<h2 id="DATA-PROPERTIES"><a href="#DATA-PROPERTIES" class="headerlink" title="DATA PROPERTIES"></a>DATA PROPERTIES</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># ----------------------------------------</span><br><span class="line"># DATA PROPERTIES</span><br><span class="line"># ----------------------------------------</span><br><span class="line"></span><br><span class="line"># FLYWAY (FlywayProperties)</span><br><span class="line">flyway.baseline-description= #</span><br><span class="line">flyway.baseline-version=1 # version to start migration</span><br><span class="line">flyway.baseline-on-migrate= #</span><br><span class="line">flyway.check-location=false # Check that migration scripts location exists.</span><br><span class="line">flyway.clean-on-validation-error= #</span><br><span class="line">flyway.enabled=true # Enable flyway.</span><br><span class="line">flyway.encoding= #</span><br><span class="line">flyway.ignore-failed-future-migration= #</span><br><span class="line">flyway.init-sqls= # SQL statements to execute to initialize a connection immediately after obtaining it.</span><br><span class="line">flyway.locations=classpath:db/migration # locations of migrations scripts</span><br><span class="line">flyway.out-of-order= #</span><br><span class="line">flyway.password= # JDBC password if you want Flyway to create its own DataSource</span><br><span class="line">flyway.placeholder-prefix= #</span><br><span class="line">flyway.placeholder-replacement= #</span><br><span class="line">flyway.placeholder-suffix= #</span><br><span class="line">flyway.placeholders.*= #</span><br><span class="line">flyway.schemas= # schemas to update</span><br><span class="line">flyway.sql-migration-prefix=V #</span><br><span class="line">flyway.sql-migration-separator= #</span><br><span class="line">flyway.sql-migration-suffix=.sql #</span><br><span class="line">flyway.table= #</span><br><span class="line">flyway.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.</span><br><span class="line">flyway.user= # Login user of the database to migrate.</span><br><span class="line">flyway.validate-on-migrate= #</span><br><span class="line"></span><br><span class="line"># LIQUIBASE (LiquibaseProperties)</span><br><span class="line">liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml # Change log configuration path.</span><br><span class="line">liquibase.check-change-log-location=true # Check the change log location exists.</span><br><span class="line">liquibase.contexts= # Comma-separated list of runtime contexts to use.</span><br><span class="line">liquibase.default-schema= # Default database schema.</span><br><span class="line">liquibase.drop-first=false # Drop the database schema first.</span><br><span class="line">liquibase.enabled=true # Enable liquibase support.</span><br><span class="line">liquibase.labels= # Comma-separated list of runtime labels to use.</span><br><span class="line">liquibase.parameters.*= # Change log parameters.</span><br><span class="line">liquibase.password= # Login password of the database to migrate.</span><br><span class="line">liquibase.url= # JDBC url of the database to migrate. If not set, the primary configured data source is used.</span><br><span class="line">liquibase.user= # Login user of the database to migrate.</span><br><span class="line"></span><br><span class="line"># DAO (PersistenceExceptionTranslationAutoConfiguration)</span><br><span class="line">spring.dao.exceptiontranslation.enabled=true # Enable the PersistenceExceptionTranslationPostProcessor.</span><br><span class="line"></span><br><span class="line"># CASSANDRA (CassandraProperties)</span><br><span class="line">spring.data.cassandra.cluster-name= # Name of the Cassandra cluster.</span><br><span class="line">spring.data.cassandra.compression= # Compression supported by the Cassandra binary protocol.</span><br><span class="line">spring.data.cassandra.connect-timeout-millis= # Socket option: connection time out.</span><br><span class="line">spring.data.cassandra.consistency-level= # Queries consistency level.</span><br><span class="line">spring.data.cassandra.contact-points=localhost # Comma-separated list of cluster node addresses.</span><br><span class="line">spring.data.cassandra.fetch-size= # Queries default fetch size.</span><br><span class="line">spring.data.cassandra.keyspace-name= # Keyspace name to use.</span><br><span class="line">spring.data.cassandra.load-balancing-policy= # Class name of the load balancing policy.</span><br><span class="line">spring.data.cassandra.port= # Port of the Cassandra server.</span><br><span class="line">spring.data.cassandra.password= # Login password of the server.</span><br><span class="line">spring.data.cassandra.read-timeout-millis= # Socket option: read time out.</span><br><span class="line">spring.data.cassandra.reconnection-policy= # Reconnection policy class.</span><br><span class="line">spring.data.cassandra.retry-policy= # Class name of the retry policy.</span><br><span class="line">spring.data.cassandra.serial-consistency-level= # Queries serial consistency level.</span><br><span class="line">spring.data.cassandra.ssl=false # Enable SSL support.</span><br><span class="line">spring.data.cassandra.username= # Login user of the server.</span><br><span class="line"></span><br><span class="line"># ELASTICSEARCH (ElasticsearchProperties)</span><br><span class="line">spring.data.elasticsearch.cluster-name=elasticsearch # Elasticsearch cluster name.</span><br><span class="line">spring.data.elasticsearch.cluster-nodes= # Comma-separated list of cluster node addresses. If not specified, starts a client node.</span><br><span class="line">spring.data.elasticsearch.properties.*= # Additional properties used to configure the client.</span><br><span class="line">spring.data.elasticsearch.repositories.enabled=true # Enable Elasticsearch repositories.</span><br><span class="line"></span><br><span class="line"># MONGODB (MongoProperties)</span><br><span class="line">spring.data.mongodb.authentication-database= # Authentication database name.</span><br><span class="line">spring.data.mongodb.database=test # Database name.</span><br><span class="line">spring.data.mongodb.field-naming-strategy= # Fully qualified name of the FieldNamingStrategy to use.</span><br><span class="line">spring.data.mongodb.grid-fs-database= # GridFS database name.</span><br><span class="line">spring.data.mongodb.host=localhost # Mongo server host.</span><br><span class="line">spring.data.mongodb.password= # Login password of the mongo server.</span><br><span class="line">spring.data.mongodb.port=27017 # Mongo server port.</span><br><span class="line">spring.data.mongodb.repositories.enabled=true # Enable Mongo repositories.</span><br><span class="line">spring.data.mongodb.uri=mongodb://localhost/test # Mongo database URI. When set, host and port are ignored.</span><br><span class="line">spring.data.mongodb.username= # Login user of the mongo server.</span><br><span class="line"></span><br><span class="line"># DATA REST (RepositoryRestProperties)</span><br><span class="line">spring.data.rest.base-path= # Base path to be used by Spring Data REST to expose repository resources.</span><br><span class="line">spring.data.rest.default-page-size= # Default size of pages.</span><br><span class="line">spring.data.rest.enable-enum-translation= # Enable enum value translation via the Spring Data REST default resource bundle.</span><br><span class="line">spring.data.rest.limit-param-name= # Name of the URL query string parameter that indicates how many results to return at once.</span><br><span class="line">spring.data.rest.max-page-size= # Maximum size of pages.</span><br><span class="line">spring.data.rest.page-param-name= # Name of the URL query string parameter that indicates what page to return.</span><br><span class="line">spring.data.rest.return-body-on-create= # Return a response body after creating an entity.</span><br><span class="line">spring.data.rest.return-body-on-update= # Return a response body after updating an entity.</span><br><span class="line">spring.data.rest.sort-param-name= # Name of the URL query string parameter that indicates what direction to sort results.</span><br><span class="line"></span><br><span class="line"># SOLR (SolrProperties)</span><br><span class="line">spring.data.solr.host=http://127.0.0.1:8983/solr # Solr host. Ignored if &quot;zk-host&quot; is set.</span><br><span class="line">spring.data.solr.repositories.enabled=true # Enable Solr repositories.</span><br><span class="line">spring.data.solr.zk-host= # ZooKeeper host address in the form HOST:PORT.</span><br><span class="line"></span><br><span class="line"># DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)</span><br><span class="line">spring.datasource.continue-on-error=false # Do not stop if an error occurs while initializing the database.</span><br><span class="line">spring.datasource.data= # Data (DML) script resource reference.</span><br><span class="line">spring.datasource.driver-class-name= # Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span><br><span class="line">spring.datasource.initialize=true # Populate the database using &#x27;data.sql&#x27;.</span><br><span class="line">spring.datasource.jmx-enabled=false # Enable JMX support (if provided by the underlying pool).</span><br><span class="line">spring.datasource.jndi-name= # JNDI location of the datasource. Class, url, username &amp; password are ignored when set.</span><br><span class="line">spring.datasource.max-active= # For instance 100</span><br><span class="line">spring.datasource.max-idle= # For instance 8</span><br><span class="line">spring.datasource.max-wait=</span><br><span class="line">spring.datasource.min-evictable-idle-time-millis=</span><br><span class="line">spring.datasource.min-idle=8</span><br><span class="line">spring.datasource.name=testdb # Name of the datasource.</span><br><span class="line">spring.datasource.password= # Login password of the database.</span><br><span class="line">spring.datasource.platform=all # Platform to use in the schema resource (schema-$&#123;platform&#125;.sql).</span><br><span class="line">spring.datasource.schema= # Schema (DDL) script resource reference.</span><br><span class="line">spring.datasource.separator=; # Statement separator in SQL initialization scripts.</span><br><span class="line">spring.datasource.sql-script-encoding= # SQL scripts encoding.</span><br><span class="line">spring.datasource.test-on-borrow= # For instance `false`</span><br><span class="line">spring.datasource.test-on-return= # For instance `false`</span><br><span class="line">spring.datasource.test-while-idle= #</span><br><span class="line">spring.datasource.time-between-eviction-runs-millis= 1</span><br><span class="line">spring.datasource.type= # Fully qualified name of the connection pool implementation to use. By default, it is auto-detected from the classpath.</span><br><span class="line">spring.datasource.url= # JDBC url of the database.</span><br><span class="line">spring.datasource.username=</span><br><span class="line">spring.datasource.validation-query=</span><br><span class="line"></span><br><span class="line"># H2 Web Console (H2ConsoleProperties)</span><br><span class="line">spring.h2.console.enabled=false # Enable the console.</span><br><span class="line">spring.h2.console.path=/h2-console # Path at which the console will be available.</span><br><span class="line"></span><br><span class="line"># JOOQ (JooqAutoConfiguration)</span><br><span class="line">spring.jooq.sql-dialect= # SQLDialect JOOQ used when communicating with the configured datasource. For instance `POSTGRES`</span><br><span class="line"></span><br><span class="line"># JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)</span><br><span class="line">spring.data.jpa.repositories.enabled=true # Enable JPA repositories.</span><br><span class="line">spring.jpa.database= # Target database to operate on, auto-detected by default. Can be alternatively set using the &quot;databasePlatform&quot; property.</span><br><span class="line">spring.jpa.database-platform= # Name of the target database to operate on, auto-detected by default. Can be alternatively set using the &quot;Database&quot; enum.</span><br><span class="line">spring.jpa.generate-ddl=false # Initialize the schema on startup.</span><br><span class="line">spring.jpa.hibernate.ddl-auto= # DDL mode. This is actually a shortcut for the &quot;hibernate.hbm2ddl.auto&quot; property. Default to &quot;create-drop&quot; when using an embedded database, &quot;none&quot; otherwise.</span><br><span class="line">spring.jpa.hibernate.naming-strategy= # Naming strategy fully qualified name.</span><br><span class="line">spring.jpa.open-in-view=true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.</span><br><span class="line">spring.jpa.properties.*= # Additional native properties to set on the JPA provider.</span><br><span class="line">spring.jpa.show-sql=false # Enable logging of SQL statements.</span><br><span class="line"></span><br><span class="line"># JTA (JtaAutoConfiguration)</span><br><span class="line">spring.jta.log-dir= # Transaction logs directory.</span><br><span class="line"></span><br><span class="line"># ATOMIKOS</span><br><span class="line">spring.jta.checkpoint-interval=500 # Interval between checkpoints.</span><br><span class="line">spring.jta.console-file-count=1 # Number of debug logs files that can be created.</span><br><span class="line">spring.jta.console-file-limit=-1 # How many bytes can be stored at most in debug logs files.</span><br><span class="line">spring.jta.console-file-name=tm.out # Debug logs file name.</span><br><span class="line">spring.jta.console-log-level= # Console log level.</span><br><span class="line">spring.jta.default-jta-timeout=10000 # Default timeout for JTA transactions.</span><br><span class="line">spring.jta.enable-logging=true # Enable disk logging.</span><br><span class="line">spring.jta.force-shutdown-on-vm-exit=false # Specify if a VM shutdown should trigger forced shutdown of the transaction core.</span><br><span class="line">spring.jta.log-base-dir= # Directory in which the log files should be stored.</span><br><span class="line">spring.jta.log-base-name=tmlog # Transactions log file base name.</span><br><span class="line">spring.jta.max-actives=50 # Maximum number of active transactions.</span><br><span class="line">spring.jta.max-timeout=300000 # Maximum timeout (in milliseconds) that can be allowed for transactions.</span><br><span class="line">spring.jta.output-dir= # Directory in which to store the debug log files.</span><br><span class="line">spring.jta.serial-jta-transactions=true # Specify if sub-transactions should be joined when possible.</span><br><span class="line">spring.jta.service= # Transaction manager implementation that should be started.</span><br><span class="line">spring.jta.threaded-two-phase-commit=true # Use different (and concurrent) threads for two-phase commit on the participating resources.</span><br><span class="line">spring.jta.transaction-manager-unique-name= # Transaction manager&#x27;s unique name.</span><br><span class="line">spring.jta.atomikos.connectionfactory.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.</span><br><span class="line">spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag=true # Whether or not to ignore the transacted flag when creating session.</span><br><span class="line">spring.jta.atomikos.connectionfactory.local-transaction-mode=false # Whether or not local transactions are desired.</span><br><span class="line">spring.jta.atomikos.connectionfactory.maintenance-interval=60 # The time, in seconds, between runs of the pool&#x27;s maintenance thread.</span><br><span class="line">spring.jta.atomikos.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.</span><br><span class="line">spring.jta.atomikos.connectionfactory.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.</span><br><span class="line">spring.jta.atomikos.connectionfactory.max-pool-size=1 # The maximum size of the pool.</span><br><span class="line">spring.jta.atomikos.connectionfactory.min-pool-size=1 # The minimum size of the pool.</span><br><span class="line">spring.jta.atomikos.connectionfactory.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.</span><br><span class="line">spring.jta.atomikos.connectionfactory.unique-resource-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.</span><br><span class="line">spring.jta.atomikos.datasource.borrow-connection-timeout=30 # Timeout, in seconds, for borrowing connections from the pool.</span><br><span class="line">spring.jta.atomikos.datasource.default-isolation-level= # Default isolation level of connections provided by the pool.</span><br><span class="line">spring.jta.atomikos.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.</span><br><span class="line">spring.jta.atomikos.datasource.maintenance-interval=60 # The time, in seconds, between runs of the pool&#x27;s maintenance thread.</span><br><span class="line">spring.jta.atomikos.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.</span><br><span class="line">spring.jta.atomikos.datasource.max-lifetime=0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.</span><br><span class="line">spring.jta.atomikos.datasource.max-pool-size=1 # The maximum size of the pool.</span><br><span class="line">spring.jta.atomikos.datasource.min-pool-size=1 # The minimum size of the pool.</span><br><span class="line">spring.jta.atomikos.datasource.reap-timeout=0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.</span><br><span class="line">spring.jta.atomikos.datasource.test-query= # SQL query or statement used to validate a connection before returning it.</span><br><span class="line">spring.jta.atomikos.datasource.unique-resource-name=dataSource # The unique name used to identify the resource during recovery.</span><br><span class="line"></span><br><span class="line"># BITRONIX</span><br><span class="line">spring.jta.allow-multiple-lrc=false # Allow multiple LRC resources to be enlisted into the same transaction.</span><br><span class="line">spring.jta.asynchronous2-pc=false # Enable asynchronously execution of two phase commit.</span><br><span class="line">spring.jta.background-recovery-interval-seconds=60 # Interval in seconds at which to run the recovery process in the background.</span><br><span class="line">spring.jta.current-node-only-recovery=true # Recover only the current node.</span><br><span class="line">spring.jta.debug-zero-resource-transaction=false # Log the creation and commit call stacks of transactions executed without a single enlisted resource.</span><br><span class="line">spring.jta.default-transaction-timeout=60 # Default transaction timeout in seconds.</span><br><span class="line">spring.jta.disable-jmx=false # Enable JMX support.</span><br><span class="line">spring.jta.exception-analyzer= # Set the fully qualified name of the exception analyzer implementation to use.</span><br><span class="line">spring.jta.filter-log-status=false # Enable filtering of logs so that only mandatory logs are written.</span><br><span class="line">spring.jta.force-batching-enabled=true #  Set if disk forces are batched.</span><br><span class="line">spring.jta.forced-write-enabled=true # Set if logs are forced to disk.</span><br><span class="line">spring.jta.graceful-shutdown-interval=60 # Maximum amount of seconds the TM will wait for transactions to get done before aborting them at shutdown time.</span><br><span class="line">spring.jta.jndi-transaction-synchronization-registry-name= # JNDI name of the TransactionSynchronizationRegistry.</span><br><span class="line">spring.jta.jndi-user-transaction-name= # JNDI name of the UserTransaction.</span><br><span class="line">spring.jta.journal=disk # Name of the journal. Can be &#x27;disk&#x27;, &#x27;null&#x27; or a class name.</span><br><span class="line">spring.jta.log-part1-filename=btm1.tlog # Name of the first fragment of the journal.</span><br><span class="line">spring.jta.log-part2-filename=btm2.tlog # Name of the second fragment of the journal.</span><br><span class="line">spring.jta.max-log-size-in-mb=2 # Maximum size in megabytes of the journal fragments.</span><br><span class="line">spring.jta.resource-configuration-filename= # ResourceLoader configuration file name.</span><br><span class="line">spring.jta.server-id= # ASCII ID that must uniquely identify this TM instance. Default to the machine&#x27;s IP address.</span><br><span class="line">spring.jta.skip-corrupted-logs=false # Skip corrupted transactions log entries.</span><br><span class="line">spring.jta.warn-about-zero-resource-transaction=true # Log a warning for transactions executed without a single enlisted resource.</span><br><span class="line">spring.jta.bitronix.connectionfactory.acquire-increment=1 # Number of connections to create when growing the pool.</span><br><span class="line">spring.jta.bitronix.connectionfactory.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.</span><br><span class="line">spring.jta.bitronix.connectionfactory.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.</span><br><span class="line">spring.jta.bitronix.connectionfactory.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.</span><br><span class="line">spring.jta.bitronix.connectionfactory.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.</span><br><span class="line">spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.</span><br><span class="line">spring.jta.bitronix.connectionfactory.cache-producers-consumers=true # Whether or not produces and consumers should be cached.</span><br><span class="line">spring.jta.bitronix.connectionfactory.defer-connection-release=true # Whether or not the provider can run many transactions on the same connection and supports transaction interleaving.</span><br><span class="line">spring.jta.bitronix.connectionfactory.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.</span><br><span class="line">spring.jta.bitronix.connectionfactory.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.</span><br><span class="line">spring.jta.bitronix.connectionfactory.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.</span><br><span class="line">spring.jta.bitronix.connectionfactory.min-pool-size=0 # The minimum size of the pool.</span><br><span class="line">spring.jta.bitronix.connectionfactory.password= # The password to use to connect to the JMS provider.</span><br><span class="line">spring.jta.bitronix.connectionfactory.share-transaction-connections=false #  Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.</span><br><span class="line">spring.jta.bitronix.connectionfactory.test-connections=true # Whether or not connections should be tested when acquired from the pool.</span><br><span class="line">spring.jta.bitronix.connectionfactory.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).</span><br><span class="line">spring.jta.bitronix.connectionfactory.unique-name=jmsConnectionFactory # The unique name used to identify the resource during recovery.</span><br><span class="line">spring.jta.bitronix.connectionfactory.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.</span><br><span class="line">spring.jta.bitronix.connectionfactory.user= # The user to use to connect to the JMS provider.</span><br><span class="line">spring.jta.bitronix.datasource.acquire-increment=1 # Number of connections to create when growing the pool.</span><br><span class="line">spring.jta.bitronix.datasource.acquisition-interval=1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.</span><br><span class="line">spring.jta.bitronix.datasource.acquisition-timeout=30 # Timeout, in seconds, for acquiring connections from the pool.</span><br><span class="line">spring.jta.bitronix.datasource.allow-local-transactions=true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.</span><br><span class="line">spring.jta.bitronix.datasource.apply-transaction-timeout=false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.</span><br><span class="line">spring.jta.bitronix.datasource.automatic-enlisting-enabled=true # Whether or not resources should be enlisted and delisted automatically.</span><br><span class="line">spring.jta.bitronix.datasource.cursor-holdability= # The default cursor holdability for connections.</span><br><span class="line">spring.jta.bitronix.datasource.defer-connection-release=true # Whether or not the database can run many transactions on the same connection and supports transaction interleaving.</span><br><span class="line">spring.jta.bitronix.datasource.enable-jdbc4-connection-test= # Whether or not Connection.isValid() is called when acquiring a connection from the pool.</span><br><span class="line">spring.jta.bitronix.datasource.ignore-recovery-failures=false # Whether or not recovery failures should be ignored.</span><br><span class="line">spring.jta.bitronix.datasource.isolation-level= # The default isolation level for connections.</span><br><span class="line">spring.jta.bitronix.datasource.local-auto-commit= # The default auto-commit mode for local transactions.</span><br><span class="line">spring.jta.bitronix.datasource.login-timeout= # Timeout, in seconds, for establishing a database connection.</span><br><span class="line">spring.jta.bitronix.datasource.max-idle-time=60 # The time, in seconds, after which connections are cleaned up from the pool.</span><br><span class="line">spring.jta.bitronix.datasource.max-pool-size=10 # The maximum size of the pool. 0 denotes no limit.</span><br><span class="line">spring.jta.bitronix.datasource.min-pool-size=0 # The minimum size of the pool.</span><br><span class="line">spring.jta.bitronix.datasource.prepared-statement-cache-size=0 # The target size of the prepared statement cache. 0 disables the cache.</span><br><span class="line">spring.jta.bitronix.datasource.share-transaction-connections=false #  Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.</span><br><span class="line">spring.jta.bitronix.datasource.test-query= # SQL query or statement used to validate a connection before returning it.</span><br><span class="line">spring.jta.bitronix.datasource.two-pc-ordering-position=1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).</span><br><span class="line">spring.jta.bitronix.datasource.unique-name=dataSource # The unique name used to identify the resource during recovery.</span><br><span class="line">spring.jta.bitronix.datasource.use-tm-join=true Whether or not TMJOIN should be used when starting XAResources.</span><br><span class="line"></span><br><span class="line"># EMBEDDED MONGODB (EmbeddedMongoProperties)</span><br><span class="line">spring.mongodb.embedded.features=SYNC_DELAY # Comma-separated list of features to enable.</span><br><span class="line">spring.mongodb.embedded.version=2.6.10 # Version of Mongo to use.</span><br><span class="line"></span><br><span class="line"># REDIS (RedisProperties)</span><br><span class="line">spring.redis.database=0 # Database index used by the connection factory.</span><br><span class="line">spring.redis.host=localhost # Redis server host.</span><br><span class="line">spring.redis.password= # Login password of the redis server.</span><br><span class="line">spring.redis.pool.max-active=8 # Max number of connections that can be allocated by the pool at a given time. Use a negative value for no limit.</span><br><span class="line">spring.redis.pool.max-idle=8 # Max number of &quot;idle&quot; connections in the pool. Use a negative value to indicate an unlimited number of idle connections.</span><br><span class="line">spring.redis.pool.max-wait=-1 # Maximum amount of time (in milliseconds) a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely.</span><br><span class="line">spring.redis.pool.min-idle=0 # Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if it is positive.</span><br><span class="line">spring.redis.port=6379 # Redis server port.</span><br><span class="line">spring.redis.sentinel.master= # Name of Redis server.</span><br><span class="line">spring.redis.sentinel.nodes= # Comma-separated list of host:port pairs.</span><br><span class="line">spring.redis.timeout=0 # Connection timeout in milliseconds.</span><br></pre></td></tr></table></figure>
<h2 id="INTEGRATION-PROPERTIES"><a href="#INTEGRATION-PROPERTIES" class="headerlink" title="INTEGRATION PROPERTIES"></a>INTEGRATION PROPERTIES</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># ----------------------------------------</span><br><span class="line"># INTEGRATION PROPERTIES</span><br><span class="line"># ----------------------------------------</span><br><span class="line"></span><br><span class="line"># ACTIVEMQ (ActiveMQProperties)</span><br><span class="line">spring.activemq.broker-url= # URL of the ActiveMQ broker. Auto-generated by default. For instance `tcp://localhost:61616`</span><br><span class="line">spring.activemq.in-memory=true # Specify if the default broker URL should be in memory. Ignored if an explicit broker has been specified.</span><br><span class="line">spring.activemq.password= # Login password of the broker.</span><br><span class="line">spring.activemq.pooled=false # Specify if a PooledConnectionFactory should be created instead of a regular ConnectionFactory.</span><br><span class="line">spring.activemq.user= # Login user of the broker.</span><br><span class="line"></span><br><span class="line"># ARTEMIS (ArtemisProperties)</span><br><span class="line">spring.artemis.embedded.cluster-password= # Cluster password. Randomly generated on startup by default.</span><br><span class="line">spring.artemis.embedded.data-directory= # Journal file directory. Not necessary if persistence is turned off.</span><br><span class="line">spring.artemis.embedded.enabled=true # Enable embedded mode if the Artemis server APIs are available.</span><br><span class="line">spring.artemis.embedded.persistent=false # Enable persistent store.</span><br><span class="line">spring.artemis.embedded.queues= # Comma-separated list of queues to create on startup.</span><br><span class="line">spring.artemis.embedded.server-id= # Server id. By default, an auto-incremented counter is used.</span><br><span class="line">spring.artemis.embedded.topics= # Comma-separated list of topics to create on startup.</span><br><span class="line">spring.artemis.host=localhost # Artemis broker host.</span><br><span class="line">spring.artemis.mode= # Artemis deployment mode, auto-detected by default. Can be explicitly set to &quot;native&quot; or &quot;embedded&quot;.</span><br><span class="line">spring.artemis.port=61616 # Artemis broker port.</span><br><span class="line"></span><br><span class="line"># SPRING BATCH (BatchProperties)</span><br><span class="line">spring.batch.initializer.enabled=true # Create the required batch tables on startup if necessary.</span><br><span class="line">spring.batch.job.enabled=true # Execute all Spring Batch jobs in the context on startup.</span><br><span class="line">spring.batch.job.names= # Comma-separated list of job names to execute on startup (For instance `job1,job2`). By default, all Jobs found in the context are executed.</span><br><span class="line">spring.batch.schema=classpath:org/springframework/batch/core/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span><br><span class="line">spring.batch.table-prefix= # Table prefix for all the batch meta-data tables.</span><br><span class="line"></span><br><span class="line"># HORNETQ (HornetQProperties)</span><br><span class="line">spring.hornetq.embedded.cluster-password= # Cluster password. Randomly generated on startup by default.</span><br><span class="line">spring.hornetq.embedded.data-directory= # Journal file directory. Not necessary if persistence is turned off.</span><br><span class="line">spring.hornetq.embedded.enabled=true # Enable embedded mode if the HornetQ server APIs are available.</span><br><span class="line">spring.hornetq.embedded.persistent=false # Enable persistent store.</span><br><span class="line">spring.hornetq.embedded.queues= # Comma-separated list of queues to create on startup.</span><br><span class="line">spring.hornetq.embedded.server-id= # Server id. By default, an auto-incremented counter is used.</span><br><span class="line">spring.hornetq.embedded.topics= # Comma-separated list of topics to create on startup.</span><br><span class="line">spring.hornetq.host=localhost # HornetQ broker host.</span><br><span class="line">spring.hornetq.mode= # HornetQ deployment mode, auto-detected by default. Can be explicitly set to &quot;native&quot; or &quot;embedded&quot;.</span><br><span class="line">spring.hornetq.port=5445 # HornetQ broker port.</span><br><span class="line"></span><br><span class="line"># JMS (JmsProperties)</span><br><span class="line">spring.jms.jndi-name= # Connection factory JNDI name. When set, takes precedence to others connection factory auto-configurations.</span><br><span class="line">spring.jms.listener.acknowledge-mode= # Acknowledge mode of the container. By default, the listener is transacted with automatic acknowledgment.</span><br><span class="line">spring.jms.listener.auto-startup=true # Start the container automatically on startup.</span><br><span class="line">spring.jms.listener.concurrency= # Minimum number of concurrent consumers.</span><br><span class="line">spring.jms.listener.max-concurrency= # Maximum number of concurrent consumers.</span><br><span class="line">spring.jms.pub-sub-domain=false # Specify if the default destination type is topic.</span><br><span class="line"></span><br><span class="line"># RABBIT (RabbitProperties)</span><br><span class="line">spring.rabbitmq.addresses= # Comma-separated list of addresses to which the client should connect to.</span><br><span class="line">spring.rabbitmq.dynamic=true # Create an AmqpAdmin bean.</span><br><span class="line">spring.rabbitmq.host=localhost # RabbitMQ host.</span><br><span class="line">spring.rabbitmq.listener.acknowledge-mode= # Acknowledge mode of container.</span><br><span class="line">spring.rabbitmq.listener.auto-startup=true # Start the container automatically on startup.</span><br><span class="line">spring.rabbitmq.listener.concurrency= # Minimum number of consumers.</span><br><span class="line">spring.rabbitmq.listener.max-concurrency= # Maximum number of consumers.</span><br><span class="line">spring.rabbitmq.listener.prefetch= # Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).</span><br><span class="line">spring.rabbitmq.listener.transaction-size= # Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.</span><br><span class="line">spring.rabbitmq.password= # Login to authenticate against the broker.</span><br><span class="line">spring.rabbitmq.port=5672 # RabbitMQ port.</span><br><span class="line">spring.rabbitmq.requested-heartbeat= # Requested heartbeat timeout, in seconds; zero for none.</span><br><span class="line">spring.rabbitmq.ssl.enabled=false # Enable SSL support.</span><br><span class="line">spring.rabbitmq.ssl.key-store= # Path to the key store that holds the SSL certificate.</span><br><span class="line">spring.rabbitmq.ssl.key-store-password= # Password used to access the key store.</span><br><span class="line">spring.rabbitmq.ssl.trust-store= # Trust store that holds SSL certificates.</span><br><span class="line">spring.rabbitmq.ssl.trust-store-password= # Password used to access the trust store.</span><br><span class="line">spring.rabbitmq.ssl.algorithm= # SSL algorithm to use. By default configure by the rabbit client library.</span><br><span class="line">spring.rabbitmq.username= # Login user to authenticate to the broker.</span><br><span class="line">spring.rabbitmq.virtual-host= # Virtual host to use when connecting to the broker.</span><br></pre></td></tr></table></figure>
<h2 id="ACTUATOR-PROPERTIES"><a href="#ACTUATOR-PROPERTIES" class="headerlink" title="ACTUATOR PROPERTIES"></a>ACTUATOR PROPERTIES</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># ----------------------------------------</span><br><span class="line"># ACTUATOR PROPERTIES</span><br><span class="line"># ----------------------------------------</span><br><span class="line"></span><br><span class="line"># ENDPOINTS (AbstractEndpoint subclasses)</span><br><span class="line">endpoints.enabled=true # Enable endpoints.</span><br><span class="line">endpoints.sensitive= # Default endpoint sensitive setting.</span><br><span class="line">endpoints.actuator.enabled=true # Enable the endpoint.</span><br><span class="line">endpoints.actuator.path= # Endpoint URL path.</span><br><span class="line">endpoints.actuator.sensitive=false # Enable security on the endpoint.</span><br><span class="line">endpoints.autoconfig.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.autoconfig.id= # Endpoint identifier.</span><br><span class="line">endpoints.autoconfig.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.beans.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.beans.id= # Endpoint identifier.</span><br><span class="line">endpoints.beans.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.configprops.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.configprops.id= # Endpoint identifier.</span><br><span class="line">endpoints.configprops.keys-to-sanitize=password,secret,key,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.</span><br><span class="line">endpoints.configprops.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.docs.curies.enabled=false # Enable the curie generation.</span><br><span class="line">endpoints.docs.enabled=true # Enable actuator docs endpoint.</span><br><span class="line">endpoints.docs.path=/docs #</span><br><span class="line">endpoints.docs.sensitive=false #</span><br><span class="line">endpoints.dump.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.dump.id= # Endpoint identifier.</span><br><span class="line">endpoints.dump.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.env.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.env.id= # Endpoint identifier.</span><br><span class="line">endpoints.env.keys-to-sanitize=password,secret,key,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regex expressions.</span><br><span class="line">endpoints.env.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.flyway.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.flyway.id= # Endpoint identifier.</span><br><span class="line">endpoints.flyway.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.health.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.health.id= # Endpoint identifier.</span><br><span class="line">endpoints.health.mapping.*= # Mapping of health statuses to HttpStatus codes. By default, registered health statuses map to sensible defaults (i.e. UP maps to 200).</span><br><span class="line">endpoints.health.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.health.time-to-live=1000 # Time to live for cached result, in milliseconds.</span><br><span class="line">endpoints.info.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.info.id= # Endpoint identifier.</span><br><span class="line">endpoints.info.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.jolokia.enabled=true # Enable Jolokia endpoint.</span><br><span class="line">endpoints.jolokia.path=/jolokia # Endpoint URL path.</span><br><span class="line">endpoints.jolokia.sensitive=true # Enable security on the endpoint.</span><br><span class="line">endpoints.liquibase.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.liquibase.id= # Endpoint identifier.</span><br><span class="line">endpoints.liquibase.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.logfile.enabled=true # Enable the endpoint.</span><br><span class="line">endpoints.logfile.path=/logfile # Endpoint URL path.</span><br><span class="line">endpoints.logfile.sensitive=true # Enable security on the endpoint.</span><br><span class="line">endpoints.mappings.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.mappings.id= # Endpoint identifier.</span><br><span class="line">endpoints.mappings.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.metrics.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.metrics.filter.enabled=true # Enable the metrics servlet filter.</span><br><span class="line">endpoints.metrics.id= # Endpoint identifier.</span><br><span class="line">endpoints.metrics.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.shutdown.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.shutdown.id= # Endpoint identifier.</span><br><span class="line">endpoints.shutdown.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line">endpoints.trace.enabled= # Enable the endpoint.</span><br><span class="line">endpoints.trace.id= # Endpoint identifier.</span><br><span class="line">endpoints.trace.sensitive= # Mark if the endpoint exposes sensitive information.</span><br><span class="line"></span><br><span class="line"># ENDPOINTS CORS CONFIGURATION (EndpointCorsProperties)</span><br><span class="line">endpoints.cors.allow-credentials= # Set whether credentials are supported. When not set, credentials are not supported.</span><br><span class="line">endpoints.cors.allowed-headers= # Comma-separated list of headers to allow in a request. &#x27;*&#x27; allows all headers.</span><br><span class="line">endpoints.cors.allowed-methods=GET # Comma-separated list of methods to allow. &#x27;*&#x27; allows all methods.</span><br><span class="line">endpoints.cors.allowed-origins= # Comma-separated list of origins to allow. &#x27;*&#x27; allows all origins. When not set, CORS support is disabled.</span><br><span class="line">endpoints.cors.exposed-headers= # Comma-separated list of headers to include in a response.</span><br><span class="line">endpoints.cors.max-age=1800 # How long, in seconds, the response from a pre-flight request can be cached by clients.</span><br><span class="line"></span><br><span class="line"># JMX ENDPOINT (EndpointMBeanExportProperties)</span><br><span class="line">endpoints.jmx.domain= # JMX domain name. Initialized with the value of &#x27;spring.jmx.default-domain&#x27; if set.</span><br><span class="line">endpoints.jmx.enabled=true # Enable JMX export of all endpoints.</span><br><span class="line">endpoints.jmx.static-names= # Additional static properties to append to all ObjectNames of MBeans representing Endpoints.</span><br><span class="line">endpoints.jmx.unique-names=false # Ensure that ObjectNames are modified in case of conflict.</span><br><span class="line"></span><br><span class="line"># JOLOKIA (JolokiaProperties)</span><br><span class="line">jolokia.config.*= # See Jolokia manual</span><br><span class="line"></span><br><span class="line"># MANAGEMENT HTTP SERVER (ManagementServerProperties)</span><br><span class="line">management.add-application-context-header=true # Add the &quot;X-Application-Context&quot; HTTP header in each response.</span><br><span class="line">management.address= # Network address that the management endpoints should bind to.</span><br><span class="line">management.context-path= # Management endpoint context-path. For instance `/actuator`</span><br><span class="line">management.port= # Management endpoint HTTP port. Use the same port as the application by default.</span><br><span class="line">management.security.enabled=true # Enable security.</span><br><span class="line">management.security.role=ADMIN # Role required to access the management endpoint.</span><br><span class="line">management.security.sessions=stateless # Session creating policy to use (always, never, if_required, stateless).</span><br><span class="line"></span><br><span class="line"># HEALTH INDICATORS (previously health.*)</span><br><span class="line">management.health.db.enabled=true # Enable database health check.</span><br><span class="line">management.health.defaults.enabled=true # Enable default health indicators.</span><br><span class="line">management.health.diskspace.enabled=true # Enable disk space health check.</span><br><span class="line">management.health.diskspace.path= # Path used to compute the available disk space.</span><br><span class="line">management.health.diskspace.threshold=0 # Minimum disk space that should be available, in bytes.</span><br><span class="line">management.health.elasticsearch.enabled=true # Enable elasticsearch health check.</span><br><span class="line">management.health.elasticsearch.indices= # Comma-separated index names.</span><br><span class="line">management.health.elasticsearch.response-timeout=100 # The time, in milliseconds, to wait for a response from the cluster.</span><br><span class="line">management.health.jms.enabled=true # Enable JMS health check.</span><br><span class="line">management.health.mail.enabled=true # Enable Mail health check.</span><br><span class="line">management.health.mongo.enabled=true # Enable MongoDB health check.</span><br><span class="line">management.health.rabbit.enabled=true # Enable RabbitMQ health check.</span><br><span class="line">management.health.redis.enabled=true # Enable Redis health check.</span><br><span class="line">management.health.solr.enabled=true # Enable Solr health check.</span><br><span class="line">management.health.status.order=DOWN, OUT_OF_SERVICE, UNKNOWN, UP # Comma-separated list of health statuses in order of severity.</span><br><span class="line"></span><br><span class="line"># TRACING ((TraceProperties)</span><br><span class="line">management.trace.include=request-headers,response-headers,errors # Items to be included in the trace.</span><br><span class="line"></span><br><span class="line"># REMOTE SHELL</span><br><span class="line">shell.auth=simple # Authentication type. Auto-detected according to the environment.</span><br><span class="line">shell.auth.jaas.domain=my-domain # JAAS domain.</span><br><span class="line">shell.auth.key.path= # Path to the authentication key. This should point to a valid &quot;.pem&quot; file.</span><br><span class="line">shell.auth.simple.user.name=user # Login user.</span><br><span class="line">shell.auth.simple.user.password= # Login password.</span><br><span class="line">shell.auth.spring.roles=ADMIN # Comma-separated list of required roles to login to the CRaSH console.</span><br><span class="line">shell.command-path-patterns=classpath*:/commands/**,classpath*:/crash/commands/** # Patterns to use to look for commands.</span><br><span class="line">shell.command-refresh-interval=-1 # Scan for changes and update the command if necessary (in seconds).</span><br><span class="line">shell.config-path-patterns=classpath*:/crash/* # Patterns to use to look for configurations.</span><br><span class="line">shell.disabled-commands=jpa*,jdbc*,jndi* # Comma-separated list of commands to disable.</span><br><span class="line">shell.disabled-plugins= # Comma-separated list of plugins to disable. Certain plugins are disabled by default based on the environment.</span><br><span class="line">shell.ssh.auth-timeout = # Number of milliseconds after user will be prompted to login again.</span><br><span class="line">shell.ssh.enabled=true # Enable CRaSH SSH support.</span><br><span class="line">shell.ssh.idle-timeout = # Number of milliseconds after which unused connections are closed.</span><br><span class="line">shell.ssh.key-path= # Path to the SSH server key.</span><br><span class="line">shell.ssh.port=2000 # SSH port.</span><br><span class="line">shell.telnet.enabled=false # Enable CRaSH telnet support. Enabled by default if the TelnetPlugin is  available.</span><br><span class="line">shell.telnet.port=5000 # Telnet port.</span><br><span class="line"></span><br><span class="line"># GIT INFO</span><br><span class="line">spring.git.properties= # Resource reference to a generated git info properties file.</span><br><span class="line"></span><br><span class="line"># METRICS EXPORT (MetricExportProperties)</span><br><span class="line">spring.metrics.export.aggregate.key-pattern= # Pattern that tells the aggregator what to do with the keys from the source repository.</span><br><span class="line">spring.metrics.export.aggregate.prefix= # Prefix for global repository if active.</span><br><span class="line">spring.metrics.export.delay-millis=5000 # Delay in milliseconds between export ticks. Metrics are exported to external sources on a schedule with this delay.</span><br><span class="line">spring.metrics.export.enabled=true # Flag to enable metric export (assuming a MetricWriter is available).</span><br><span class="line">spring.metrics.export.excludes= # List of patterns for metric names to exclude. Applied after the includes.</span><br><span class="line">spring.metrics.export.includes= # List of patterns for metric names to include.</span><br><span class="line">spring.metrics.export.redis.key=keys.spring.metrics # Key for redis repository export (if active).</span><br><span class="line">spring.metrics.export.redis.prefix=spring.metrics # Prefix for redis repository if active.</span><br><span class="line">spring.metrics.export.send-latest= # Flag to switch off any available optimizations based on not exporting unchanged metric values.</span><br><span class="line">spring.metrics.export.statsd.host= # Host of a statsd server to receive exported metrics.</span><br><span class="line">spring.metrics.export.statsd.port=8125 # Port of a statsd server to receive exported metrics.</span><br><span class="line">spring.metrics.export.statsd.prefix= # Prefix for statsd exported metrics.</span><br><span class="line">spring.metrics.export.triggers.*= # Specific trigger properties per MetricWriter bean name.</span><br></pre></td></tr></table></figure>
<h2 id="DEVTOOLS-PROPERTIES"><a href="#DEVTOOLS-PROPERTIES" class="headerlink" title="DEVTOOLS PROPERTIES"></a>DEVTOOLS PROPERTIES</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># ----------------------------------------</span><br><span class="line"># DEVTOOLS PROPERTIES</span><br><span class="line"># ----------------------------------------</span><br><span class="line"></span><br><span class="line"># DEVTOOLS (DevToolsProperties)</span><br><span class="line">spring.devtools.livereload.enabled=true # Enable a livereload.com compatible server.</span><br><span class="line">spring.devtools.livereload.port=35729 # Server port.</span><br><span class="line">spring.devtools.restart.additional-exclude= # Additional patterns that should be excluded from triggering a full restart.</span><br><span class="line">spring.devtools.restart.additional-paths= # Additional paths to watch for changes.</span><br><span class="line">spring.devtools.restart.enabled=true # Enable automatic restart.</span><br><span class="line">spring.devtools.restart.exclude=META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties # Patterns that should be excluded from triggering a full restart.</span><br><span class="line">spring.devtools.restart.poll-interval=1000 # Amount of time (in milliseconds) to wait between polling for classpath changes.</span><br><span class="line">spring.devtools.restart.quiet-period=400 # Amount of quiet time (in milliseconds) required without any classpath changes before a restart is triggered.</span><br><span class="line">spring.devtools.restart.trigger-file= # Name of a specific file that when changed will trigger the restart check. If not specified any classpath file change will trigger the restart.</span><br><span class="line"></span><br><span class="line"># REMOTE DEVTOOLS (RemoteDevToolsProperties)</span><br><span class="line">spring.devtools.remote.context-path=/.~~spring-boot!~ # Context path used to handle the remote connection.</span><br><span class="line">spring.devtools.remote.debug.enabled=true # Enable remote debug support.</span><br><span class="line">spring.devtools.remote.debug.local-port=8000 # Local remote debug server port.</span><br><span class="line">spring.devtools.remote.proxy.host= # The host of the proxy to use to connect to the remote application.</span><br><span class="line">spring.devtools.remote.proxy.port= # The port of the proxy to use to connect to the remote application.</span><br><span class="line">spring.devtools.remote.restart.enabled=true # Enable remote restart.</span><br><span class="line">spring.devtools.remote.secret= # A shared secret required to establish a connection (required to enable remote support).</span><br><span class="line">spring.devtools.remote.secret-header-name=X-AUTH-TOKEN # HTTP header used to transfer the shared secret.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>常用配置</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之show status详解</title>
    <url>/2021/02/04/MySQL%E4%B9%8Bshow-status%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;Variable_name&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;作用域&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;说明&nbsp;&nbsp;&nbsp;</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Aborted_clients&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;由于客户端没有正确关闭连接导致客户端终止而中断的连接数&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Aborted_connects&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;试图连接到MySQL服务器而失败的连接数&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Binlog_cache_disk_use&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用临时二进制日志缓存但超过binlog_cache_size值并使用临时文件来保存事务中的语句的事务数量&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Binlog_cache_use&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用临时二进制日志缓存的事务数量&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Binlog_stmt_cache_disk_use&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Binlog_stmt_cache_use&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Bytes_received&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;从所有客户端接收到的字节数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Bytes_sent&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;发送给所有客户端的字节数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_admin_commands&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_assign_to_keycache&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_alter_db&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_alter_db_upgrade&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_alter_event&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_alter_function&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_alter_instance&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_alter_procedure&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_alter_server&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_alter_table&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_alter_tablespace&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_alter_user&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_analyze&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_begin&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_binlog&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_call_procedure&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_change_db&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_change_master&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_change_repl_filter&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_check&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_checksum&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_commit&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_db&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_event&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_function&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_index&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_procedure&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_server&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_table&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_trigger&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_udf&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_user&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_create_view&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_dealloc_sql&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_delete&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_delete_multi&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_do&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_drop_db&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_drop_event&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_drop_function&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_drop_index&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_drop_procedure&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_drop_server&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_drop_table&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_drop_trigger&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_drop_user&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_drop_view&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_empty_query&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_execute_sql&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_explain_other&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_flush&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_get_diagnostics&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_grant&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_ha_close&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_ha_open&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_ha_read&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_help&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_insert&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_insert_select&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_install_plugin&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_kill&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_load&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_lock_tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_optimize&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_preload_keys&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_prepare_sql&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_purge&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_purge_before_date&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_release_savepoint&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_rename_table&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_rename_user&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_repair&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_replace&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_replace_select&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_reset&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_resignal&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_revoke&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_revoke_all&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_rollback&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_rollback_to_savepoint&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_savepoint&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_select&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_set_option&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_signal&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_binlog_events&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_binlogs&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_charsets&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_collations&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_create_db&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_create_event&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_create_func&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_create_proc&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_create_table&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_create_trigger&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_databases&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_engine_logs&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_engine_mutex&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_engine_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_events&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_errors&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_fields&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_function_code&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_function_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_grants&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_keys&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_master_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_open_tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_plugins&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_privileges&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_procedure_code&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_procedure_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_processlist&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_profile&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_profiles&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_relaylog_events&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_slave_hosts&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_slave_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_storage_engines&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_table_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_triggers&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_variables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_warnings&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_show_create_user&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_shutdown&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_slave_start&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_slave_stop&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_group_replication_start&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_group_replication_stop&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_stmt_execute&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_stmt_close&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_stmt_fetch&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_stmt_prepare&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_stmt_reset&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_stmt_send_long_data&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_truncate&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_uninstall_plugin&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_unlock_tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_update&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_update_multi&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_xa_commit&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_xa_end&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_xa_prepare&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_xa_recover&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_xa_rollback&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_xa_start&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Com_stmt_reprepare&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Compression&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Session&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;客户端与服务器之间是否启用压缩协议&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Connection_errors_accept&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Connection_errors_internal&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Connection_errors_max_connections&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Connection_errors_peer_address&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Connection_errors_select&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Connection_errors_tcpwrap&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Connections&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;试图连接到(不管是否成功)MySQL服务器的连接数&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Created_tmp_disk_tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;服务器执行语句时在硬盘上自动创建的临时表的数量&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Created_tmp_files&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;mysqld已经创建的临时文件的数量&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Created_tmp_tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;服务器执行语句时自动创建的内存中的临时表的数量。如果Created_tmp_disk_tables较大，你可能要增加tmp_table_size值使临时&nbsp;&nbsp;&nbsp;表基于内存而不基于硬盘&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Delayed_errors&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;用INSERT DELAYED写的出现错误的行数(可能为duplicate&nbsp;&nbsp;&nbsp;key)。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Delayed_insert_threads&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;使用的INSERT DELAYED处理器线程数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Delayed_writes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;写入的INSERT DELAYED行数&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Flush_commands&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;执行的FLUSH语句数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_commit&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;内部提交语句数&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_delete&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;行从表中删除的次数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_discover&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;MySQL服务器可以问NDB&nbsp;&nbsp;&nbsp;CLUSTER存储引擎是否知道某一名字的表。这被称作发现。Handler_discover说明通过该方法发现的次数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_external_lock&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_mrr_init&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_prepare&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;counter for the prepare phase of two-phase commit operations.&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_read_first&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;索引中第一条被读的次数。如果较高，它建议服务器正执行大量全索引扫描；例如，SELECT&nbsp;&nbsp;&nbsp;col1 FROM foo，假定col1有索引。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_read_key&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;根据键读一行的请求数。如果较高，说明查询和表的索引正确。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_read_last&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_read_next&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_read_prev&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_read_rnd&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_read_rnd_next&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_rollback&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;内部ROLLBACK语句的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_savepoint&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在一个存储引擎放置一个保存点的请求数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_savepoint_rollback&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在一个存储引擎的要求回滚到一个保存点数目。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_update&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在表内更新一行的请求数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Handler_write&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在表内插入一行的请求数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_dump_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_load_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_resize_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_pages_data&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;包含数据的页数(脏或干净)。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_bytes_data&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_pages_dirty&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;当前的脏页数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_bytes_dirty&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_pages_flushed&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;要求清空的缓冲池页数&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_pages_free&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;空页数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_pages_latched&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在InnoDB缓冲池中锁定的页数。这是当前正读或写或由于其它原因不能清空或删除的页数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_pages_misc&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;忙的页数，因为它们已经被分配优先用作管理，例如行锁定或适用的哈希索引。该值还可以计算为Innodb_buffer_pool_pages_total - Innodb_buffer_pool_pages_free -&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_pages_data。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_pages_total&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;缓冲池总大小（页数）。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_read_ahead_rnd&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;InnoDB初始化的“随机”read-aheads数。当查询以随机顺序扫描表的一大部分时发生。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_read_ahead&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_read_ahead_evicted&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_read_ahead_seq&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;InnoDB初始化的顺序read-aheads数。当InnoDB执行顺序全表扫描时发生。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_read_requests&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;InnoDB已经完成的逻辑读请求数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_reads&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;不能满足InnoDB必须单页读取的缓冲池中的逻辑读数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_wait_free&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;一般情况，通过后台向InnoDB缓冲池写。但是，如果需要读或创建页，并且没有干净的页可用，则它还需要先等待页面清空。该计数器对等待实例进行记数。如果已经适当设置缓冲池大小，该值应小。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_buffer_pool_write_requests&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;向InnoDB缓冲池的写数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_data_fsyncs&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;fsync()操作数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_data_pending_fsyncs&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;当前挂起的fsync()操作数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_data_pending_reads&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;当前挂起的读数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_data_pending_writes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;当前挂起的写数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_data_read&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;至此已经读取的数据数量（字节）。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_data_reads&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;数据读总数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_data_writes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;数据写总数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_data_written&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;至此已经写入的数据量（字节）。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_dblwr_pages_written&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;已经执行的双写操作数量&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_dblwr_writes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;双写操作已经写好的页数&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_log_waits&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;我们必须等待的时间，因为日志缓冲区太小，我们在继续前必须先等待对它清空&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_log_write_requests&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;日志写请求数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_log_writes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;向日志文件的物理写数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_os_log_fsyncs&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;向日志文件完成的fsync()写数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_os_log_pending_fsyncs&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;挂起的日志文件fsync()操作数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_os_log_pending_writes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;挂起的日志文件写操作&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_os_log_written&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;写入日志文件的字节数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_page_size&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;编译的InnoDB页大小(默认16KB)。许多值用页来记数；页的大小很容易转换为字节。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_pages_created&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;创建的页数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_pages_read&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;读取的页数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_pages_written&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;写入的页数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_row_lock_current_waits&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;当前等待的待锁定的行数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_row_lock_time&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;行锁定花费的总时间，单位毫秒。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_row_lock_time_avg&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;行锁定的平均时间，单位毫秒。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_row_lock_time_max&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;行锁定的最长时间，单位毫秒。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_row_lock_waits&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;一行锁定必须等待的时间数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_rows_deleted&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;从InnoDB表删除的行数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_rows_inserted&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;插入到InnoDB表的行数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_rows_read&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;从InnoDB表读取的行数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_rows_updated&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;InnoDB表内更新的行数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_num_open_files&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_truncated_status_writes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Innodb_available_undo_logs&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Key_blocks_not_flushed&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;键缓存内已经更改但还没有清空到硬盘上的键的数据块数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Key_blocks_unused&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;键缓存内未使用的块数量。你可以使用该值来确定使用了多少键缓存&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Key_blocks_used&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;键缓存内使用的块数量。该值为高水平线标记，说明已经同时最多使用了多少块。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Key_read_requests&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;从缓存读键的数据块的请求数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Key_reads&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;从硬盘读取键的数据块的次数。如果Key_reads较大，则Key_buffer_size值可能太小。可以用Key_reads/Key_read_requests计算缓存损失率。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Key_write_requests&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;将键的数据块写入缓存的请求数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Key_writes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;向硬盘写入将键的数据块的物理写操作的次数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Last_query_cost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Session&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;用查询优化器计算的最后编译的查询的总成本。用于对比同一查询的不同查询方案的成本。默认值0表示还没有编译查询。 默认值是0。Last_query_cost具有会话范围。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Last_query_partial_plans&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Locked_connects&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Max_execution_time_exceeded&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Max_execution_time_set&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Max_execution_time_set_failed&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Max_used_connections&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;服务器启动后已经同时使用的连接的最大数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Max_used_connections_time&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Not_flushed_delayed_rows&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;等待写入INSERT DELAY队列的行数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ongoing_anonymous_transaction_count&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Open_files&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;打开的文件的数目。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Open_streams&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;打开的流的数量(主要用于记录)。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Open_table_definitions&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;缓存的.frm文件数量&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Open_tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;当前打开的表的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Opened_files&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;文件打开的数量。不包括诸如套接字或管道其他类型的文件。&nbsp;&nbsp;&nbsp;也不包括存储引擎用来做自己的内部功能的文件。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Opened_table_definitions&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;已经缓存的.frm文件数量&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Opened_tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;已经打开的表的数量。如果Opened_tables较大，table_cache&nbsp;&nbsp;&nbsp;值可能太小。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_accounts_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_cond_classes_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_cond_instances_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_digest_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_file_classes_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_file_handles_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_file_instances_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_hosts_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_index_stat_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_locker_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_memory_classes_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_metadata_lock_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_mutex_classes_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_mutex_instances_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_nested_statement_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_prepared_statements_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_program_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_rwlock_classes_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_rwlock_instances_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_session_connect_attrs_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_socket_classes_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_socket_instances_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_stage_classes_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_statement_classes_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_table_handles_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_table_instances_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_table_lock_stat_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_thread_classes_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_thread_instances_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Performance_schema_users_lost&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Prepared_stmt_count&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;当前的预处理语句的数量。 (最大数为系统变量:&nbsp;&nbsp;&nbsp;max_prepared_stmt_count)&nbsp;&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Qcache_free_blocks&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;查询缓存内自由内存块的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Qcache_free_memory&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;用于查询缓存的自由内存的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Qcache_hits&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;查询缓存被访问的次数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Qcache_inserts&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;加入到缓存的查询数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Qcache_lowmem_prunes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;由于内存较少从缓存删除的查询数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Qcache_not_cached&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;非缓存查询数(不可缓存，或由于query_cache_type设定值未缓存)。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Qcache_queries_in_cache&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;登记到缓存内的查询的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Qcache_total_blocks&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;查询缓存内的总块数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Queries&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;服务器执行的请求个数，包含存储过程中的请求。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Questions&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;已经发送给服务器的查询的个数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Select_full_join&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;没有使用索引的联接的数量。如果该值不为0,你应仔细检查表的索引&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Select_full_range_join&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在引用的表中使用范围搜索的联接的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Select_range&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在第一个表中使用范围的联接的数量。一般情况不是关键问题，即使该值相当大。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Select_range_check&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在每一行数据后对键值进行检查的不带键值的联接的数量。如果不为0，你应仔细检查表的索引。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Select_scan&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;对第一个表进行完全扫描的联接的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Slave_heartbeat_period&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;复制的心跳间隔&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Slave_open_temp_tables&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;从服务器打开的临时表数量&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Slave_received_heartbeats&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;从服务器心跳数&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Slave_retried_transactions&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;本次启动以来从服务器复制线程重试次数&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Slave_running&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;如果该服务器是连接到主服务器的从服务器，则该值为ON。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Slow_launch_threads&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;创建时间超过slow_launch_time秒的线程数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Slow_queries&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;查询时间超过long_query_time秒的查询的个数&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Sort_merge_passes&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;排序算法已经执行的合并的数量。如果这个变量值较大，应考虑增加sort_buffer_size系统变量的值。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Sort_range&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;在范围内执行的排序的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Sort_rows&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;已经排序的行数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Sort_scan&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Both&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;通过扫描表完成的排序的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_accept_renegotiates&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_accepts&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_callback_cache_hits&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_cipher&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_cipher_list&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_client_connects&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_connect_renegotiates&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_ctx_verify_depth&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_ctx_verify_mode&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_default_timeout&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_finished_accepts&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_finished_connects&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_server_not_after&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_server_not_before&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_session_cache_hits&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_session_cache_misses&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_session_cache_mode&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_session_cache_overflows&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_session_cache_size&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_session_cache_timeouts&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_sessions_reused&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_used_session_cache_entries&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_verify_depth&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_verify_mode&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Ssl_version&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Table_locks_immediate&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;立即获得的表的锁的次数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Table_locks_waited&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;不能立即获得的表的锁的次数。如果该值较高，并且有性能问题，你应首先优化查询，然后拆分表或使用复制。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Table_open_cache_hits&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Table_open_cache_misses&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Table_open_cache_overflows&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Tc_log_max_pages_used&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Tc_log_page_size&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Tc_log_page_waits&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Threads_cached&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;线程缓存内的线程的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Threads_connected&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;当前打开的连接的数量。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Threads_created&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;创建用来处理连接的线程数。如果Threads_created较大，你可能要增加thread_cache_size值。缓存访问率的计算方法Threads_created/Connections。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Threads_running&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;激活的（非睡眠状态）线程数。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Uptime&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;服务器已经运行的时间（以秒为单位）。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Uptime_since_flush_status&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;Global&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;最近一次使用FLUSH STATUS 的时间（以秒为单位）。&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/zuxing/articles/7761262.html">MySQL运行状态show status中文详解</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html">Mysql官方文档</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>show status</tag>
      </tags>
  </entry>
</search>
