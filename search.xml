<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hibernate系统化学习之对象状态</title>
    <url>/2021/02/04/Hibernate%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><style type="text/css">
.tg  {border-collapse:collapse;border-color:#C44D58;border-spacing:0;}
.tg td{background-color:#F9CDAD;border-color:#C44D58;border-style:solid;border-width:1px;color:#002b36;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#FE4365;border-color:#C44D58;border-style:solid;border-width:1px;color:#fdf6e3;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;状态&nbsp;&nbsp;&nbsp;</th>
    <th class="tg-0lax">&nbsp;&nbsp;&nbsp;说明&nbsp;&nbsp;&nbsp;</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;临时状态（Transient）&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;刚创建的对象（new）还没有被Session持久化、缓存中不存在这个对象的数据并且数据库中没有这个对象对应的数据为瞬时状态这个时候是没有OID。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;持久状态（Persistent）&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;对象经过Session持久化操作，缓存中存在这个对象的数据为持久状态并且数据库中存在这个对象对应的数据为持久状态这个时候有OID。&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;游离状态（Detached）&nbsp;&nbsp;&nbsp;</td>
    <td class="tg-0lax">&nbsp;&nbsp;&nbsp;已经被持久化，但不处于session的缓存中。&nbsp;&nbsp;&nbsp;当Session关闭，缓存中不存在这个对象数据而数据库中有这个对象的数据并且有OID为游离状态。&nbsp;&nbsp;&nbsp;</td>
  </tr>
</tbody>
</table>

<a id="more"></a>

<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><div align="center">

<img src="/2021/02/04/Hibernate%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81/1588843982557.png" class title="对象状态转换">

</div>

<p>当对象在持久化状态时，它一直位于 Session 的缓存中，对它的任何操作在事务提交时都将同步到数据库，因此，对一个已经持久的对象调用 save() 或 update() 方法是没有意义的。</p>
<blockquote>
<p>save()和persist()将会引发SQL的INSERT，delete()会引发SQLDELETE， 而update()或merge()会引发SQLUPDATE。对持久化（persistent）实例的修改在刷新提交的时候会被检测到， 它也会引起SQLUPDATE。saveOrUpdate()或者replicate()会引发SQLINSERT或者UPDATE</p>
</blockquote>
<h3 id="相关方法说明"><a href="#相关方法说明" class="headerlink" title="相关方法说明"></a>相关方法说明</h3><ol>
<li>get、load、find: 方法的使用上较为类似，他们都是将数据库中对应Id的数据映射为Java对象，此时对象变为持久化状态。</li>
<li>save: 保存，此时Java对象已经与数据库记录建立的关系。将对象从临时状态的变为持久化状态或者将游离状态的数据变为持久状态。</li>
<li>saveOrUpdate: 保存或者更新，如果没有与数据库记录所对应的oid，则执行保存，如果有，则执行更新。将对象从临时状态的变为持久化状态或者将游离状态的数据变为持久状态。</li>
<li>delete: 删除对象，将对象从持久化状态或者游离状态变为临时状态。</li>
<li>close: 关闭session, 先将session清空，然后再关闭。将对象从持久状态变为临时状态。</li>
<li>clear: 清空session缓存。将对象从持久状态变为临时状态。</li>
<li>evict: 清除指定的对象。将对象从持久状态变为临时状态.</li>
</ol>
<h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/flqcchblog/p/4619022.html">hibernate的各种保存方式的区别 (save,persist,update,saveOrUpdte,merge,flush,lock)</a></li>
<li><a href="https://blog.csdn.net/pangqiandou/article/details/53386728">Hibernate一级缓存</a></li>
<li><a href="https://blog.csdn.net/looyo/article/details/6309136">hibernate session的flushMode的区别</a></li>
<li><a href="https://blog.csdn.net/lzm1340458776/article/details/32729127">Hibernate的Session_flush与隔离级别</a></li>
<li><a href="https://blog.csdn.net/chuck_kui/article/details/51531089">Hibernate 中的session 的flush、reflush 和clear 方法 ，及数据库的隔离级别</a></li>
<li><a href="https://blog.csdn.net/oChangWen/article/details/52582958">Hibernate深入理解—-03操作Session缓存方法（flush、refresh、clear，事务隔离级别）</a></li>
<li><a href="http://blog.csdn.net/fg2006/article/details/6436517">Hibernate中对象的三种状态及相互转化</a></li>
<li><a href="https://www.cnblogs.com/xiaoluo501395377/p/3380270.html">深入hibernate的三种状态</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Hibernate</category>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>对象状态</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate系统化学习之常用方法</title>
    <url>/2021/02/04/Hibernate%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="session-find-load"><a href="#session-find-load" class="headerlink" title="session.find/load"></a>session.find/load</h2><p>hibernate中session.find/load方法都能通过指定实体类名和id从数据库中读取指定的记录，并且返回与之对映的实体对象。但是它们也有很大的区别 ,find()和load()方法在执行检索时的区别：</p>
<ol>
<li><p>find()在类检索级别时总是执行立即检索而且如果检索不到相关的对象的话会返回null,load()方法则会抛出一个ObjectNotException</p>
</li>
<li><p>load()方法可返回一个实体代理类类型，而find()方法直接返回的是实体类对象。</p>
</li>
<li><p>load()方法可以充分利用内部缓存和二级缓存，而find()方法会忽略二级缓存，若内部缓存没有查询到会到数据库中去查询。</p>
<a id="more"></a>
<h2 id="Session-get-load"><a href="#Session-get-load" class="headerlink" title="Session.get/load"></a>Session.get/load</h2></li>
<li><p>如果未能发现符合条件的记录，get方法返回null，而load方法会抛出一个ObejctNotFoundException。</p>
</li>
<li><p>Load方法可返回实体的代理类类型，而get方法永远直接返回实体类。</p>
</li>
<li><p>Load方法可以充分利用内部缓存和二级缓存中现有数据，而get方法则仅仅在内部缓存中进行数据查找，如没有发现对应数据，将越过二级缓存，直接调用SQL完成数据读取。</p>
</li>
</ol>
<p>Session 的load(), get() , find() 方法都可实现对业务数据的查询，其中load()会因所要查询的对象类的映射文件（比如Customer.hbm.xml文件）中设置的检索策略，而实现立即检索或延迟检索。get()方法和find()方法却不受这种控制，它们总是会执行立即检索。</p>
<p>那么象load()这样的方法，当其被设置为使用延迟检索时，它会返回什么样的实例呢？当使用延迟检索时返回为这一对象的代理类实例，代理类实例也有一个标志性的OID, 但没有被实例化，其所有属性为默认初始值或为空。提到检索，load() 和get()方法都是用指定了OID的方式检索并返回一个与数据库中记录相对应的实例对象。如Customer customer = (Customer)session.get(Customer.class, new Long(1)) 将会返回一个Customer实例对象customer. 而 find()可以实现批量的检索，其返回类型为List的对象集合。例如：<br>List customerList = session.find( “from Customer as c”);</p>
<p>Load(): 另一种读取数据的方法,和get的区别是: 1.异常处理: load有异常处理,get没有,它返回null,2.get从数据库读数据,load可能去读缓冲区。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>Hibernate</category>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
        <tag>常用方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Javap详解</title>
    <url>/2021/02/04/Javap%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>javap 命令用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息,输出堆栈大小、各方法的 locals 及 args 数。</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -<span class="keyword">public</span>                  仅显示公共类和成员</span><br><span class="line">  -<span class="keyword">protected</span>               显示受保护的/公共类和成员</span><br><span class="line">  -<span class="keyword">package</span>                 显示程序包/受保护的/公共类和成员 (默认)</span><br><span class="line">  -p  -<span class="keyword">private</span>             显示所有类和成员</span><br><span class="line">  -c                       输出类中各方法的未解析的代码，即构成 Java 字节码的指令。</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置,如果设置了该选项，则它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置,缺省情况下，自举类是实现核心 Java 平台的类，位于 jrelibt.jar 和 jrelibi18n.jar 中。</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPassByValue</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> temp1 = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">this</span>.passInt(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passInt</span><span class="params">(<span class="keyword">int</span> abc)</span> </span>&#123; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String temp = <span class="string">&quot;abcddd&quot;</span>;</span><br><span class="line">		PassByValue val = <span class="keyword">new</span> PassByValue();</span><br><span class="line">		<span class="keyword">this</span>.passObject(val, temp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passObject</span><span class="params">(PassByValue passByValue, String value)</span> </span>&#123; </span><br><span class="line">		passByValue = <span class="keyword">null</span>;</span><br><span class="line">		value = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValue</span></span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="javap分析"><a href="#javap分析" class="headerlink" title="javap分析"></a>javap分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.TestPassByValue包含com.sunld.TestPassByValue</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/TestPassByValue.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">4</span>-<span class="number">29</span>; size <span class="number">939</span> bytes</span><br><span class="line">  MD5 checksum ae6cce5733ce01797de9d8ae30359bdd</span><br><span class="line">  Compiled from <span class="string">&quot;TestPassByValue.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">TestPassByValue</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/TestPassByValue</span><br><span class="line">   #2 = Utf8               com/sunld/TestPassByValue</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               temp1</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Methodref          #3.#11         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #11 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #12 = Fieldref           #1.#13         // com/sunld/TestPassByValue.temp1:I</span><br><span class="line">  #13 = NameAndType        #5:#6          // temp1:I</span><br><span class="line">  #14 = Utf8               LineNumberTable</span><br><span class="line">  #15 = Utf8               LocalVariableTable</span><br><span class="line">  #16 = Utf8               this</span><br><span class="line">  #17 = Utf8               Lcom/sunld/TestPassByValue;</span><br><span class="line">  #18 = Utf8               doPassInt</span><br><span class="line">  #19 = Methodref          #1.#20         // com/sunld/TestPassByValue.passInt:(I)V</span><br><span class="line">  #20 = NameAndType        #21:#22        // passInt:(I)V</span><br><span class="line">  #21 = Utf8               passInt</span><br><span class="line">  #22 = Utf8               (I)V</span><br><span class="line">  #23 = Utf8               temp</span><br><span class="line">  #24 = Utf8               abc</span><br><span class="line">  #25 = Utf8               doPassObject</span><br><span class="line">  #26 = String             #27            // abcddd</span><br><span class="line">  #27 = Utf8               abcddd</span><br><span class="line">  #28 = Class              #29            // com/sunld/PassByValue</span><br><span class="line">  #29 = Utf8               com/sunld/PassByValue</span><br><span class="line">  #30 = Methodref          #28.#11        // com/sunld/PassByValue.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #31 = Methodref          #1.#32         // com/sunld/TestPassByValue.passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #32 = NameAndType        #33:#34        // passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #33 = Utf8               passObject</span><br><span class="line">  #34 = Utf8               (Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #35 = Utf8               Ljava/lang/String;</span><br><span class="line">  #36 = Utf8               val</span><br><span class="line">  #37 = Utf8               Lcom/sunld/PassByValue;</span><br><span class="line">  #38 = String             #39            // value</span><br><span class="line">  #39 = Utf8               value</span><br><span class="line">  #40 = Utf8               passByValue</span><br><span class="line">  #41 = Utf8               SourceFile</span><br><span class="line">  #42 = Utf8               TestPassByValue.java</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//默认的构造方法，在构造方法执行时主要完成一些初始化操作，包括一些成员变量的初始化赋值等操作</span></span><br><span class="line">  <span class="keyword">public</span> com.sunld.TestPassByValue();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">//*load_*：将本地变量表中索引为*的局部变量加载到操作栈</span></span><br><span class="line">         <span class="comment">//从本地变量表中加载索引为0的变量的值到操作栈，也即this的引用，压入栈</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="comment">//invokespecial：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）</span></span><br><span class="line">         <span class="comment">//出栈，调用java/lang/Object.&quot;&lt;init&gt;&quot;:()V 初始化对象，就是this指定的对象的init()方法完成初始化</span></span><br><span class="line">         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="comment">// 4到7表示，完成this.temp1 = 10的赋值。这里this引用入栈</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="comment">//将常量10加入到操作数栈</span></span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="comment">//出栈前面压入的两个值（this引用，常量值10）， 将10取出，并赋值给temp1</span></span><br><span class="line">         7: putfield      #12                 // Field temp1:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      <span class="comment">//指令与代码行数的偏移对应关系，每一行第一个数字对应代码行数，第二个数字对应前面code中指令前面的数字</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">3</span>: <span class="number">10</span></span><br><span class="line">      <span class="comment">//局部变量表，start+length表示这个变量在字节码中的生命周期起始和结束的偏移位置（this生命周期从头0到结尾10）</span></span><br><span class="line">      <span class="comment">//slot就是这个变量在局部变量表中的槽位（槽位可复用），name就是变量名称，Signatur局部变量类型描述</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassInt</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// 常量100入栈</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="comment">// 将一个数值从操作数栈存储到局部变量表,存储100给temp</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="comment">// 加载this入栈</span></span><br><span class="line">         <span class="number">3</span>: aload_0</span><br><span class="line">         <span class="comment">// temp入栈</span></span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         5: invokevirtual #19                 // Method passInt:(I)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">3</span>       <span class="number">6</span>     <span class="number">1</span>  temp   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passInt</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">1</span>   abc   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassObject</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// 从常量池取出abcddd入栈</span></span><br><span class="line">         0: ldc           #26                 // String abcddd</span><br><span class="line">         <span class="comment">// 出栈赋值给temp</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="comment">// 创建PassByValue对象，将引用压入栈</span></span><br><span class="line">         3: new           #28                 // class com/sunld/PassByValue</span><br><span class="line">         <span class="comment">// 将操作数栈顶的数据复制一份，并压入栈，此时栈中有两个引用值（目前有两个PassByValue的引用）</span></span><br><span class="line">         <span class="number">6</span>: dup</span><br><span class="line">         7: invokespecial #30                 // Method com/sunld/PassByValue.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="comment">// 出栈栈顶数据（对象PassByValue）复制给val</span></span><br><span class="line">        <span class="number">10</span>: astore_2</span><br><span class="line">        <span class="comment">// 入栈this</span></span><br><span class="line">        <span class="number">11</span>: aload_0</span><br><span class="line">        <span class="comment">// 入栈val</span></span><br><span class="line">        <span class="number">12</span>: aload_2</span><br><span class="line">        <span class="comment">// 入栈temp</span></span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        14: invokevirtual #31                 // Method passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">        <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">18</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">3</span>      <span class="number">15</span>     <span class="number">1</span>  temp   Ljava/lang/String;</span><br><span class="line">           <span class="number">11</span>       <span class="number">7</span>     <span class="number">2</span>   val   Lcom/sunld/PassByValue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passObject</span><span class="params">(com.sunld.PassByValue, java.lang.String)</span></span>;</span><br><span class="line">    descriptor: (Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: aconst_null</span><br><span class="line">         <span class="number">1</span>: astore_1</span><br><span class="line">         2: ldc           #38                 // String value</span><br><span class="line">         <span class="number">4</span>: astore_2</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span> passByValue   Lcom/sunld/PassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">2</span> value   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestPassByValue.java&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.jianshu.com/p/6a8997560b05">通过javap命令分析java汇编指令</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>Javap</tag>
        <tag>Class分析</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate系统化学习之缓存</title>
    <url>/2021/02/04/Hibernate%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="N-1问题"><a href="#N-1问题" class="headerlink" title="N+1问题"></a>N+1问题</h2><p>所谓N+1问题，使用hibernate查询数据，首先返回数据的id信息，并没有返回所有的对象信息，只有在真正使用的时候，在使用这个id对数据库中查询数据，一次查询多次调用数据库（缓存）的情况，就是所谓的N+1问题。以下方法或者策略会出现N+1问题：</p>
<h3 id="使用iterate（）方法"><a href="#使用iterate（）方法" class="headerlink" title="使用iterate（）方法"></a>使用iterate（）方法</h3><p>存在iterator的原因是，有可能会在一个session中查询两次数据，如果使用list每一次都会把所有的对象查询上来，如果使用iterator仅仅只会查询id，此时所有的对象已经存储在一级缓存(session的缓存)中，可以直接获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the query results as an &lt;tt&gt;Iterator&lt;/tt&gt;. If the query</span></span><br><span class="line"><span class="comment">* contains multiple results per row, the results are returned in</span></span><br><span class="line"><span class="comment">* an instance of &lt;tt&gt;Object[]&lt;/tt&gt;.&lt;br&gt;</span></span><br><span class="line"><span class="comment">* &lt;br&gt;</span></span><br><span class="line"><span class="comment">* Entities returned as results are initialized on demand. The first</span></span><br><span class="line"><span class="comment">* SQL query returns identifiers only.&lt;br&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the result iterator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Iterator&lt;R&gt; <span class="title">iterate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="使用查询缓存策略"><a href="#使用查询缓存策略" class="headerlink" title="使用查询缓存策略"></a>使用查询缓存策略</h3><h2 id="一级缓存，session级别缓存"><a href="#一级缓存，session级别缓存" class="headerlink" title="一级缓存，session级别缓存"></a>一级缓存，session级别缓存</h2><p>首次查询数据，会查询数据库返回数据，并且保存到缓存中；再次查询该数据时，直接从缓存中获取（同一个session）。<br>由于一级缓存是session级别的缓存，只有在同一个session中才能起到再次查询从缓存中获取数据。<br>比如：list()放入缓存，load查询从缓存中获取数据。<br>由于Session对象的生命周期通常对应一个数据库事务或者一个应用事务，因此它的缓存是事务范围的缓存。<br>Session级缓存是必需的，不允许而且事实上也无法卸除。在Session级缓存中，持久化类的每个实例都具有唯一的ID<br><strong>调用session的方法会加入一级缓存：save()、update()、savaeOrUpdate()、get()或load()；调用查询接口的list()、iterate()或filter()方法</strong></p>
<h2 id="二级缓存（sessionFactory级别）"><a href="#二级缓存（sessionFactory级别）" class="headerlink" title="二级缓存（sessionFactory级别）"></a>二级缓存（sessionFactory级别）</h2><h3 id="下载ehcache相关包"><a href="#下载ehcache相关包" class="headerlink" title="下载ehcache相关包"></a>下载ehcache相关包</h3><h3 id="在hibernate-cfg-xml配置文件中配置我们二级缓存的一些属性"><a href="#在hibernate-cfg-xml配置文件中配置我们二级缓存的一些属性" class="headerlink" title="在hibernate.cfg.xml配置文件中配置我们二级缓存的一些属性"></a>在hibernate.cfg.xml配置文件中配置我们二级缓存的一些属性</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.use_second_level_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 二级缓存的提供类 在hibernate4.0版本以后我们都是配置这个属性来指定二级缓存的提供类--&gt;</span></span><br><span class="line">&lt;property name=&quot;hibernate.cache.region.factory_class&quot;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property&gt;</span><br><span class="line"><span class="comment">&lt;!-- 4.0之前版本的配置  &lt;property name=&quot;hibernate.cache.provider_class&quot;&gt;net.sf.ehcache.hibernate.EhCacheProvider&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 二级缓存配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.provider_configuration_file_resource_path&quot;</span>&gt;</span>ehcache.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置ehcache-xml"><a href="#配置ehcache-xml" class="headerlink" title="配置ehcache.xml"></a>配置ehcache.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Sets the path to the directory where cache .data files are created.</span></span><br><span class="line"><span class="comment">If the path is a Java System Property it is replaced by</span></span><br><span class="line"><span class="comment">         its value in the running VM.</span></span><br><span class="line"><span class="comment">The following properties are translated:</span></span><br><span class="line"><span class="comment">         user.home - User&#x27;s home directory</span></span><br><span class="line"><span class="comment">         user.dir - User&#x27;s current working directory</span></span><br><span class="line"><span class="comment">         java.io.tmpdir - Default temp file path --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--指定二级缓存存放在磁盘上的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;user.dir&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--我们可以给每个实体类指定一个对应的缓存，如果没有匹配到该类，则使用这个默认的缓存配置--&gt;</span></span><br><span class="line">    &lt;defaultCache</span><br><span class="line">        maxElementsInMemory=&quot;10000&quot;　　//在内存中存放的最大对象数</span><br><span class="line">        eternal=&quot;false&quot;　　　　　　　　　//是否永久保存缓存，设置成false</span><br><span class="line">        timeToIdleSeconds=&quot;120&quot;</span><br><span class="line">        timeToLiveSeconds=&quot;120&quot;</span><br><span class="line">        overflowToDisk=&quot;true&quot;　　　　　//如果对象数量超过内存中最大的数，是否将其保存到磁盘中，设置成true</span><br><span class="line">        /&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1、timeToLiveSeconds的定义是：以创建时间为基准开始计算的超时时长；</span></span><br><span class="line"><span class="comment">2、timeToIdleSeconds的定义是：在创建时间和最近访问时间中取出离现在最近的时间作为基准计算的超时时长；</span></span><br><span class="line"><span class="comment">3、如果仅设置了timeToLiveSeconds，则该对象的超时时间=创建时间+timeToLiveSeconds，假设为A；</span></span><br><span class="line"><span class="comment">4、如果没设置timeToLiveSeconds，则该对象的超时时间=max(创建时间，最近访问时间)+timeToIdleSeconds，假设为B；</span></span><br><span class="line"><span class="comment">5、如果两者都设置了，则取出A、B最少的值，即min(A,B)，表示只要有一个超时成立即算超时。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--可以给每个实体类指定一个配置文件，通过name属性指定，要使用类的全名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;com.sunld.bean.User&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;600&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;sampleCache2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span> --&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="开启缓存"><a href="#开启缓存" class="headerlink" title="开启缓存"></a>开启缓存</h3><ul>
<li>①如果使用xml配置，我们需要在 *.hbm.xml 中加上一下配置<br><code>&lt;cache usage=&quot;read-only&quot;/&gt; </code><br>②如果使用annotation配置，我们需要在类上加上这样一个注解<br><code>@Cache(usage=CacheConcurrencyStrategy.READ_ONLY)</code></li>
</ul>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>read-only、nonstrict-read-write、read-write、transactional</p>
<h3 id="二级缓存触发的方法"><a href="#二级缓存触发的方法" class="headerlink" title="二级缓存触发的方法"></a>二级缓存触发的方法</h3><p>save、update、saveOrupdate、load、get、list、query、Criteria方法都会填充二级缓存<br>get、load、iterate会从二级缓存中取数据<br>session.save(user)<br>如果user主键使用“native”生成，则不放入二级缓存</p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol>
<li>条件查询的时候，总是发出一条<code>select * from table_name where</code> …. （选择所有字段）这样的SQL语句查询数据库，一次获得所有的数据对象。</li>
<li>把获得的所有数据对象根据ID放入到第二级缓存中。</li>
<li>当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；查不到，再查询数据库，把结果按照ID放入到缓存。</li>
<li>删除、更新、增加数据的时候，同时更新缓存。</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>二级缓存缓存的仅仅是对象，如果查询出来的是对象的一些属性，则不会被加到缓存中去<br>Hibernate的二级缓存策略，是针对于ID查询的缓存策略，对于条件查询则毫无作用。为此，Hibernate提供了针对条件查询的查询缓存（Query Cache）。</p>
<h3 id="解决N-1问题"><a href="#解决N-1问题" class="headerlink" title="解决N+1问题"></a>解决N+1问题</h3><p>当我们如果需要查询出两次对象的时候，可以使用二级缓存来解决N+1的问题<br>先list在iterator</p>
<h2 id="查询缓存（sessionFactory级别）"><a href="#查询缓存（sessionFactory级别）" class="headerlink" title="查询缓存（sessionFactory级别）"></a>查询缓存（sessionFactory级别）</h2><h3 id="开启缓存-1"><a href="#开启缓存-1" class="headerlink" title="开启缓存"></a>开启缓存</h3><p>hibernate.cfg.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启查询缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.cache.use_query_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="查询中需要调用方法"><a href="#查询中需要调用方法" class="headerlink" title="查询中需要调用方法"></a>查询中需要调用方法</h3><p>.setCacheable(true) //开启查询缓存，查询缓存也是SessionFactory级别的缓存<br>如果使用注解方式，需要在类上加入在类上加注解：@Cacheable</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ol>
<li>只有当 HQL 查询语句完全相同时，连参数设置都要相同，此时查询缓存才有效</li>
<li>查询缓存也能引起 N+1 的问题，需要开启二级缓存。</li>
<li>查询普通属性，会先到查询缓存中取，如果没有，则查询数据库；</li>
<li>查询实体，会先到查询缓存中取id，如果有，则根据id到缓存(一级/二级)中取实体，如果缓存中取不到实体，再查询数据库。</li>
</ol>
<h2 id="FlushMode与session-flush"><a href="#FlushMode与session-flush" class="headerlink" title="FlushMode与session.flush()"></a>FlushMode与session.flush()</h2><p>在Hibernate中，使用session来操作数据库，session中的存在缓存（一级缓存），当调用session.save或者session.update()等方法的时候，hibernate并不一定会将修改同步到数据库（要看具体的FlushMode），而是先将这些数据存储在session的缓存中，由hibernate自己决定何时同步刷新到数据中。正是由于hibernate的这种缓存机制，<strong>在同一个session中多次修改一个记录</strong>，最终只会向数据库发出一条update语句。由于session缓存以及脏数据检查机制，能够帮助我们尽可能少地发出SQL语句。</p>
<p>hibernate提供了FlushMode接口，能够让我们干预hibernate将脏数据同步到数据库的时机。Session.flush()会触发hibernate将数据同步到数据库。可以通过session.setFlushMode()来修改刷新模式。FlushMode提供了4种缓存模式：MANUAL、COMMIT、AUTO和ALWAYS。源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enumeration extending javax.persistence flush modes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Carlos Gonz lez-Cadenas</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">FlushModeType</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Corresponds to &#123;<span class="doctag">@link</span> org.hibernate.FlushMode#ALWAYS&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ALWAYS,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Corresponds to  &#123;<span class="doctag">@link</span> org.hibernate.FlushMode#AUTO&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	AUTO,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Corresponds to  &#123;<span class="doctag">@link</span> org.hibernate.FlushMode#COMMIT&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	COMMIT,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Corresponds to  &#123;<span class="doctag">@link</span> org.hibernate.FlushMode#NEVER&#125;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@deprecated</span> use MANUAL, will be removed in a subsequent release</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	NEVER,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Corresponds to  &#123;<span class="doctag">@link</span> org.hibernate.FlushMode#MANUAL&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MANUAL,</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Current flush mode of the persistence context at the time the query is executed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PERSISTENCE_CONTEXT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MANUAL"><a href="#MANUAL" class="headerlink" title="MANUAL"></a>MANUAL</h3><p>我们必须在代码中**手动调用session.flush()**，hibernate才会将脏数据同步到数据库。如果我们忘记了手动刷新，那么就算是通过session.getTransaction().commit()提交了事务，也不能将修改同步到数据库。</p>
<h3 id="COMMIT"><a href="#COMMIT" class="headerlink" title="COMMIT"></a>COMMIT</h3><p>当数据库事务提交的时候会刷新缓存，当然手动调用flush()肯定也是可以的，不过没有必要罢了。</p>
<h3 id="AUTO（默认）"><a href="#AUTO（默认）" class="headerlink" title="AUTO（默认）"></a>AUTO（默认）</h3><p>事务提交或者手动刷新，都能将脏数据同步到数据库。除此之外，某些查询出现的时候也会导致缓存刷新。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>you don’t control when Hibernate will decide to execute UPDATE/INSERT/DELETE.</li>
<li>potential performance issues because every object modification may lead to dirty checking + DML statement execution.</li>
<li>you are not taking advantage of batching and other optimizations that Hibernate can perform when it is not trying to avoid ‘stale’ state</li>
</ol>
<h3 id="ALWAYS"><a href="#ALWAYS" class="headerlink" title="ALWAYS"></a>ALWAYS</h3><p>只要有查询出现，或者事务提交，或者手动刷新，都会导致缓存刷新。这个策略性能比较差，实际中不会使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>默认hibernate不会开启查询缓存，这是因为查询缓存只有在hql/hql语句语义完全一致的时候，才能命中。而实际查询场景下，查询条件、分页、排序等构成的复杂查询sql语句很难完全一致。可能是hibernate觉得命中率低，所以默认关闭了查询缓存。我们可以根据实际使用情况，决定是否开启查询缓存，唯一的原则就是命中率要尽可能的高。如果针对A表的查询，查询sql语句基本都是完全一致的情况，就可以针对A使用查询缓存；如果B表的查询条件经常变化，很难命中，那么就不要对B表使用查询缓存。这可能就是hibernate使用查询缓存的时候，既要在hibernate.cfg.xml中进行配置，也需要query.setCacheable(true)的原因。查询缓存只对list有用，对iterate方式无用。iterate不会读也不会写查询缓存，list会读也会写查询缓存。查询缓存中的key是sql语句（这些sql语句会被hibernate解析，保证语义相同的sql，能够命中查询缓存），缓存的value是记录的主键值。</p>
<p>通过开启查询缓存和二级缓存，相同的sql查询可以直接使用查询缓存中的id和二级缓存中的实体对象，可以有效的降低反复的数据库查询，可以提高查询效率。也就是说：同一时候开启查询缓存和二级缓存是有意义的。也是实际使用hibernate的最佳配置。进一步的。我们也能够看出list和iterate方法的差别。list()会将实体对象的id放入查询缓存，将实体对象本身放入二级缓存。iterate不会将实体对象的id放入查询缓存。可是会将实体对象本身存入二级缓存。假设第二次查询可以命中的情况下：list全然不须要查询数据库，可以先从查询缓存中获取到id。再从二级缓存中获取实体对象。iterate一定会发出一条查id的sql，然后去二级缓存中获取实体对象。</p>
<h2 id="缓存策略提供商"><a href="#缓存策略提供商" class="headerlink" title="缓存策略提供商"></a>缓存策略提供商</h2><p>org.hibernate.cache.HashtableCacheProvider(内存)<br>org.hibernate.cache.EhCacheProvider(内存，硬盘)<br>org.hibernate.cache.OSCacheProvider(内存，硬盘)<br>org.hibernate.cache.SwarmCacheProvider(能用于集群环境)<br>org.hibernate.cache.TreeCacheProvider(能用于集群环境)<br>org.hibernate.cache.jbc.JBossCacheRegionFactory(能用于集群环境)</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Hibernate</category>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之传递方式</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在Java中的方法调用使用的都是<strong>值传递</strong>，Java 中的所有自变量或参数传递都是通过传递句柄进行的。也就是说，当我们传递“一个对象”时，<strong>实际传递的只是指向位于方法外部的那个对象的“一个句柄”</strong>。所以一旦要对那个句柄进行任何修改，便相当于修改外部对象。此外：</p>
<ol>
<li>■参数传递过程中会自动产生别名问题</li>
<li>■不存在本地对象，只有本地句柄</li>
<li>■句柄有自己的作用域，而对象没有</li>
<li>■对象的“存在时间”在 Java 里不是个问题</li>
<li>■没有语言上的支持（如常量）可防止对象被修改（以避免别名的副作用）<a id="more"></a>
<h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2></li>
</ol>
<blockquote>
<p>形式参数：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。<br>实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。</p>
</blockquote>
<h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><blockquote>
<p>值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中(<strong>副本的概念</strong>)，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
</blockquote>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-sjuo{background-color:#C2FFD6;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0lax"></th>
    <th class="tg-0lax">值传递</th>
    <th class="tg-0lax">引用传递</th>
  </tr>
  <tr>
    <td class="tg-0lax">根本区别</td>
    <td class="tg-sjuo">会创建副本，或者是直接句柄处理</td>
    <td class="tg-0lax">不创建副本</td>
  </tr>
  <tr>
    <td class="tg-0lax">结论</td>
    <td class="tg-sjuo">方法中无法改变原始对象</td>
    <td class="tg-0lax">方法中可以改变原始对象</td>
  </tr>
</table>

<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>参考《<a href="https://www.sunliaodong.cn/2021/02/04/Javap%E8%AF%A6%E8%A7%A3/">javap详解</a>》</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.toutiao.com/i6813552507239793164/">Java 到底是值传递还是引用传递？</a></li>
<li><a href="https://www.sohu.com/a/158425070_505800">Java 函数调用是传值还是传引用？从字节码角度来看看 ！</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>传递方式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之Type</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BType/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里的Type指java.lang.reflect.Type, 是Java中所有类型的公共高级接口, 代表了Java中的所有类型. Type体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现Type接口.  </p>
<p>Type 表示的全部类型而每个Class对象表示一个具体类型的实例，如String.class仅代表String类型。由此看来Type与 Class 表示类型几乎是相同的（Class实现接口Type），只不过 Type表示的范围比Class要广得多而已。当然Type还有其他子类。</p>
<ol>
<li>参数化类型（ParameterizedType）：有原始类型和具体的类型参数，泛型List<String>、Map；</String></li>
<li>数组类型（GenericArrayType）：不是数组String[] 、byte[]，而是带有泛型的数组，即T[] ；</li>
<li>通配符类型（WildcardType）： 指的是&lt;?&gt;, &lt;? extends T&gt;等等</li>
<li>原始类型（Class）： 不仅仅包含我们平常所指的类，还包括枚举、数组、注解等；</li>
<li>基本类型（Class）, 也就是我们所说的java的基本类型，即int,float,double等</li>
<li>类型变量(TypeVariable)：表示类型参数，可以有上界，比如：T extends Number<a id="more"></a>
<h2 id="JDK定义"><a href="#JDK定义" class="headerlink" title="JDK定义"></a>JDK定义</h2></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Type is the common superinterface for all types in the Java</span></span><br><span class="line"><span class="comment"> * programming language. These include raw types, parameterized types,</span></span><br><span class="line"><span class="comment"> * array types, type variables and primitive types.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string describing this type, including information</span></span><br><span class="line"><span class="comment">     * about any type parameters.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span> The default implementation calls &#123;<span class="doctag">@code</span> toString&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string describing this type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BType/1588062825641.png" class title="Type类结构">

</div>

<h3 id="ParameterizedType"><a href="#ParameterizedType" class="headerlink" title="ParameterizedType"></a>ParameterizedType</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParameterizedType represents a parameterized type such as</span></span><br><span class="line"><span class="comment"> * Collection&amp;lt;String&amp;gt;.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 表示一种参数化类型，比如：Collection&lt;String&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A parameterized type is created the first time it is needed by a</span></span><br><span class="line"><span class="comment"> * reflective method, as specified in this package. When a</span></span><br><span class="line"><span class="comment"> * parameterized type p is created, the generic type declaration that</span></span><br><span class="line"><span class="comment"> * p instantiates is resolved, and all type arguments of p are created</span></span><br><span class="line"><span class="comment"> * recursively. See &#123;<span class="doctag">@link</span> java.lang.reflect.TypeVariable</span></span><br><span class="line"><span class="comment"> * TypeVariable&#125; for details on the creation process for type</span></span><br><span class="line"><span class="comment"> * variables. Repeated creation of a parameterized type has no effect.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 参数化类型在反射方法第一次使用的时候被创建。</span></span><br><span class="line"><span class="comment"> * 3. 当参数化类型p被创建之后，被p实例化的泛型会被解析，并且递归创建p的所有参数化类型</span></span><br><span class="line"><span class="comment"> * 4. 重复创建一个参数化类型不会有影响</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Instances of classes that implement this interface must implement</span></span><br><span class="line"><span class="comment"> * an equals() method that equates any two instances that share the</span></span><br><span class="line"><span class="comment"> * same generic type declaration and have equal type parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of &#123;<span class="doctag">@code</span> Type&#125; objects representing the actual type</span></span><br><span class="line"><span class="comment">     * arguments to this type.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that in some cases, the returned array be empty. This can occur</span></span><br><span class="line"><span class="comment">     * if this type represents a non-parameterized type nested within</span></span><br><span class="line"><span class="comment">     * a parameterized type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of &#123;<span class="doctag">@code</span> Type&#125; objects representing the actual type</span></span><br><span class="line"><span class="comment">     *     arguments to this type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TypeNotPresentException if any of the</span></span><br><span class="line"><span class="comment">     *     actual type arguments refers to a non-existent type declaration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MalformedParameterizedTypeException if any of the</span></span><br><span class="line"><span class="comment">     *     actual type parameters refer to a parameterized type that cannot</span></span><br><span class="line"><span class="comment">     *     be instantiated for any reason</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@code</span> Type&#125; object representing the class or interface</span></span><br><span class="line"><span class="comment">     * that declared this type.</span></span><br><span class="line"><span class="comment">     * 1. 返回当前class或interface声明的类型, 如List&lt;?&gt;返回List</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the &#123;<span class="doctag">@code</span> Type&#125; object representing the class or interface</span></span><br><span class="line"><span class="comment">     *     that declared this type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@code</span> Type&#125; object representing the type that this type</span></span><br><span class="line"><span class="comment">     * is a member of.  For example, if this type is &#123;<span class="doctag">@code</span> O&lt;T&gt;.I&lt;S&gt;&#125;,</span></span><br><span class="line"><span class="comment">     * return a representation of &#123;<span class="doctag">@code</span> O&lt;T&gt;&#125;.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 返回所属类型. 如,当前类型为O&lt;T&gt;.I&lt;S&gt;, 则返回O&lt;T&gt;. 顶级类型将返回null </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If this type is a top-level type, &#123;<span class="doctag">@code</span> null&#125; is returned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Type&#125; object representing the type that</span></span><br><span class="line"><span class="comment">     *     this type is a member of. If this type is a top-level type,</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> null&#125; is returned</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TypeNotPresentException if the owner type</span></span><br><span class="line"><span class="comment">     *     refers to a non-existent type declaration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MalformedParameterizedTypeException if the owner type</span></span><br><span class="line"><span class="comment">     *     refers to a parameterized type that cannot be instantiated</span></span><br><span class="line"><span class="comment">     *     for any reason</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/JustBeauty/article/details/81116144">ParameterizedType详解</a></li>
<li><a href="https://www.jianshu.com/p/cfa74c980b25">Java中与泛型相关的接口 之 ParameterizedType</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Type</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之克隆</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%8B%E9%9A%86/</url>
    <content><![CDATA[<p>所谓克隆就是对原有对象复用的复用，<strong>Java语言中克隆针对的是类的实例（对象）</strong>，在Java中一共有三种方式实现。</p>
<ol>
<li>直接赋值</li>
<li>浅拷贝</li>
<li>深拷贝<a id="more"></a>
<h2 id="java-lang-Cloneable"><a href="#java-lang-Cloneable" class="headerlink" title="java.lang.Cloneable"></a>java.lang.Cloneable</h2></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to</span></span><br><span class="line"><span class="comment"> * indicate to the &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; method that it</span></span><br><span class="line"><span class="comment"> * is legal for that method to make a</span></span><br><span class="line"><span class="comment"> * field-for-field copy of instances of that class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Invoking Object&#x27;s clone method on an instance that does not implement the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * By convention, classes that implement this interface should override</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Object.clone&lt;/tt&gt; (which is protected) with a public method.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> java.lang.Object#clone()&#125; for details on overriding this</span></span><br><span class="line"><span class="comment"> * method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &lt;tt&gt;clone&lt;/tt&gt; method.</span></span><br><span class="line"><span class="comment"> * Therefore, it is not possible to clone an object merely by virtue of the</span></span><br><span class="line"><span class="comment"> * fact that it implements this interface.  Even if the clone method is invoked</span></span><br><span class="line"><span class="comment"> * reflectively, there is no guarantee that it will succeed.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实现该接口类，可以通过java.lang.Object.clone()方法完成对象中属性的赋值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码分析可知：  </p>
<ol>
<li>必须实现Cloneable接口，否则抛出CloneNotSupportedException异常</li>
<li>实现Cloneable的类应该重写clone()，重写时该方法的修饰符为public。</li>
</ol>
<h2 id="java-lang-Object-clone"><a href="#java-lang-Object-clone" class="headerlink" title="java.lang.Object.clone()"></a>java.lang.Object.clone()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates and returns a copy of this object.  The precise meaning</span></span><br><span class="line"><span class="comment">* of &quot;copy&quot; may depend on the class of the object. The general</span></span><br><span class="line"><span class="comment">* intent is that, for any object &#123;<span class="doctag">@code</span> x&#125;, the expression:</span></span><br><span class="line"><span class="comment">* &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">* &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">* will be true, and that the expression:</span></span><br><span class="line"><span class="comment">* &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">* &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">* will be &#123;<span class="doctag">@code</span> true&#125;, but these are not absolute requirements.</span></span><br><span class="line"><span class="comment">* While it is typically the case that:</span></span><br><span class="line"><span class="comment">* &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">* &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">* will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* By convention, the returned object should be obtained by calling</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> super.clone&#125;.  If a class and all of its superclasses (except</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> Object&#125;) obey this convention, it will be the case that</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> x.clone().getClass() == x.getClass()&#125;.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment">* of this object (which is being cloned).  To achieve this independence,</span></span><br><span class="line"><span class="comment">* it may be necessary to modify one or more fields of the object returned</span></span><br><span class="line"><span class="comment">* by &#123;<span class="doctag">@code</span> super.clone&#125; before returning it.  Typically, this means</span></span><br><span class="line"><span class="comment">* copying any mutable objects that comprise the internal &quot;deep structure&quot;</span></span><br><span class="line"><span class="comment">* of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment">* objects with references to the copies.  If a class contains only</span></span><br><span class="line"><span class="comment">* primitive fields or references to immutable objects, then it is usually</span></span><br><span class="line"><span class="comment">* the case that no fields in the object returned by &#123;<span class="doctag">@code</span> super.clone&#125;</span></span><br><span class="line"><span class="comment">* need to be modified.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* The method &#123;<span class="doctag">@code</span> clone&#125; for class &#123;<span class="doctag">@code</span> Object&#125; performs a</span></span><br><span class="line"><span class="comment">* specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment">* not implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> CloneNotSupportedException&#125; is thrown. Note that all arrays</span></span><br><span class="line"><span class="comment">* are considered to implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125; and that</span></span><br><span class="line"><span class="comment">* the return type of the &#123;<span class="doctag">@code</span> clone&#125; method of an array type &#123;<span class="doctag">@code</span> T[]&#125;</span></span><br><span class="line"><span class="comment">* is &#123;<span class="doctag">@code</span> T[]&#125; where T is any reference or primitive type.</span></span><br><span class="line"><span class="comment">* Otherwise, this method creates a new instance of the class of this</span></span><br><span class="line"><span class="comment">* object and initializes all its fields with exactly the contents of</span></span><br><span class="line"><span class="comment">* the corresponding fields of this object, as if by assignment; the</span></span><br><span class="line"><span class="comment">* contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment">* performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* The class &#123;<span class="doctag">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> Cloneable&#125;, so calling the &#123;<span class="doctag">@code</span> clone&#125; method on an object</span></span><br><span class="line"><span class="comment">* whose class is &#123;<span class="doctag">@code</span> Object&#125; will result in throwing an</span></span><br><span class="line"><span class="comment">* exception at run time.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>     a clone of this instance.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  CloneNotSupportedException  if the object&#x27;s class does not</span></span><br><span class="line"><span class="comment">*               support the &#123;<span class="doctag">@code</span> Cloneable&#125; interface. Subclasses</span></span><br><span class="line"><span class="comment">*               that override the &#123;<span class="doctag">@code</span> clone&#125; method can also</span></span><br><span class="line"><span class="comment">*               throw this exception to indicate that an instance cannot</span></span><br><span class="line"><span class="comment">*               be cloned.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> java.lang.Cloneable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="测试代码准备"><a href="#测试代码准备" class="headerlink" title="测试代码准备"></a>测试代码准备</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.clone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		CloneObject co1 = <span class="keyword">new</span> CloneObject();</span><br><span class="line">		co1.setName(<span class="string">&quot;name1&quot;</span>);</span><br><span class="line">		co1.setAge(<span class="number">10</span>);</span><br><span class="line">		CloneObject2 c021 = <span class="keyword">new</span> CloneObject2();</span><br><span class="line">		c021.setName2(<span class="string">&quot;name21&quot;</span>);</span><br><span class="line">		co1.setCloneObject2(c021);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObject</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> CloneObject2 cloneObject2;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject2 <span class="title">getCloneObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCloneObject2</span><span class="params">(CloneObject2 cloneObject2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneObject2 = cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObject2</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name2;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName2</span><span class="params">(String name2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name2 = name2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1.直接赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CloneObject co2 = co1;</span><br><span class="line">System.out.println(co2.getName());</span><br><span class="line">System.out.println(co1.getName());</span><br></pre></td></tr></table></figure>
<p>对象co2和co1在堆内存中的地址一致，所以<strong>两个对象之间会互相影响</strong>。</p>
<h3 id="浅复制（复制引用但不复制引用的对象）"><a href="#浅复制（复制引用但不复制引用的对象）" class="headerlink" title="浅复制（复制引用但不复制引用的对象）"></a>浅复制（复制引用但不复制引用的对象）</h3><p>需要通过实现接口<code>java.lang.Cloneable</code>，并且重新<code>java.lang.Object.clone()</code>的方法进行实现。实现原理：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。<strong>因此，原始对象及其副本引用同一个对象。（对象中的对象）</strong></p>
<p>参考代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObject</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> CloneObject2 cloneObject2;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject2 <span class="title">getCloneObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCloneObject2</span><span class="params">(CloneObject2 cloneObject2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneObject2 = cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * (1) 实现 Cloneable 接口</span></span><br><span class="line"><span class="comment">	 * (2) 覆盖 clone()</span></span><br><span class="line"><span class="comment">	 * (3) 在自己的 clone()中调用 super.clone()</span></span><br><span class="line"><span class="comment">	 * (4) 在自己的 clone()中捕获违例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (CloneObject) <span class="keyword">super</span>.clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 2.浅复制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CloneObject co2 = co1.clone();</span><br><span class="line">co2.setName(<span class="string">&quot;cloneName&quot;</span>);</span><br><span class="line">co2.getCloneObject2().setName2(<span class="string">&quot;cloneName2222&quot;</span>);</span><br><span class="line">System.out.println(co2.getName());</span><br><span class="line">System.out.println(co1.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(co1.getCloneObject2().getName2());</span><br><span class="line">System.out.println(co2.getCloneObject2().getName2());</span><br></pre></td></tr></table></figure>
<h3 id="深复制（复制对象和其应用对象）"><a href="#深复制（复制对象和其应用对象）" class="headerlink" title="深复制（复制对象和其应用对象）"></a>深复制（复制对象和其应用对象）</h3><p>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObject</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> CloneObject2 cloneObject2;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject2 <span class="title">getCloneObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCloneObject2</span><span class="params">(CloneObject2 cloneObject2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneObject2 = cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * (1) 实现 Cloneable 接口</span></span><br><span class="line"><span class="comment">	 * (2) 覆盖 clone()</span></span><br><span class="line"><span class="comment">	 * (3) 在自己的 clone()中调用 super.clone()</span></span><br><span class="line"><span class="comment">	 * (4) 在自己的 clone()中捕获违例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			CloneObject cloneObject = (CloneObject) <span class="keyword">super</span>.clone();</span><br><span class="line">			cloneObject.cloneObject2 = <span class="keyword">this</span>.cloneObject2.clone();</span><br><span class="line">			<span class="keyword">return</span> cloneObject;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObject2</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name2;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName2</span><span class="params">(String name2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name2 = name2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneObject2 <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (CloneObject2) <span class="keyword">super</span>.clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化（深-clone-一中实现）"><a href="#序列化（深-clone-一中实现）" class="headerlink" title="序列化（深 clone 一中实现）"></a>序列化（深 clone 一中实现）</h3><p>在Java 语言里深复制一个对象，常常可以先使对象实现 <code>Serializable 接口</code>(必须)，然后把对象（实际上只是对象的一个拷贝）写到一个流里（<strong>可以实现对象持久化到内存或磁盘中，提高对象的生命周期</strong>），再从流里读出来，便可以重建对象。特点：</p>
<ol>
<li>序列化对象以字节数组保持-静态成员不保存，保存到是对象的“状态”</li>
<li>序列化用户远程对象传输，比如：RMI(远程方法调用)</li>
<li>实现接口<code>java.io.Serializable</code></li>
<li>序列化和反序列化：<code>ObjectOutputStream</code> 和<code>ObjectInputStream</code></li>
<li><code>writeObject</code> 和 <code>readObject</code> 自定义序列化策略，可以实现序列化信息和反序列化的控制</li>
<li>序列化 ID（<code>private static final long serialVersionUID</code>） ：需要保证序列化和反序列化类的ID一致性</li>
<li>Transient  关键字阻止该变量被序列化到文件中<ul>
<li>阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</li>
<li>writeExternal() 使用该方法也可以实现序列信息的控制</li>
</ul>
</li>
</ol>
<h4 id="实现deepclone"><a href="#实现deepclone" class="headerlink" title="实现deepclone"></a>实现deepclone</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.clone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerCloneTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SerCloneObject co1 = <span class="keyword">new</span> SerCloneObject();</span><br><span class="line">		co1.setName(<span class="string">&quot;name1&quot;</span>);</span><br><span class="line">		co1.setAge(<span class="number">10</span>);</span><br><span class="line">		SerCloneObject2 c021 = <span class="keyword">new</span> SerCloneObject2();</span><br><span class="line">		c021.setName2(<span class="string">&quot;name21&quot;</span>);</span><br><span class="line">		co1.setCloneObject2(c021);</span><br><span class="line">		</span><br><span class="line">		SerCloneObject co2 = co1.deepClone();</span><br><span class="line">		co2.setName(<span class="string">&quot;cloneName&quot;</span>);</span><br><span class="line">		co2.getCloneObject2().setName2(<span class="string">&quot;cloneName2222&quot;</span>);</span><br><span class="line">		System.out.println(co2.getName());</span><br><span class="line">		System.out.println(co1.getName());</span><br><span class="line">		</span><br><span class="line">		System.out.println(co1.getCloneObject2().getName2());</span><br><span class="line">		System.out.println(co2.getCloneObject2().getName2());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerCloneObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> SerCloneObject2 cloneObject2;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> SerCloneObject2 <span class="title">getCloneObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCloneObject2</span><span class="params">(SerCloneObject2 cloneObject2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneObject2 = cloneObject2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> SerCloneObject <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//将该对象序列化成流,因为写在流里的是对象的一个拷贝，</span></span><br><span class="line">		<span class="comment">//而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝  </span></span><br><span class="line">		ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line">		ObjectOutputStream oos;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">			oos.writeObject(<span class="keyword">this</span>);  </span><br><span class="line">			<span class="comment">//将流序列化成对象  </span></span><br><span class="line">			ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());  </span><br><span class="line">			ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);  </span><br><span class="line">			<span class="keyword">return</span> (SerCloneObject) ois.readObject();  </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerCloneObject2</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> String name2;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName2</span><span class="params">(String name2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name2 = name2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射（深复制一种）"><a href="#反射（深复制一种）" class="headerlink" title="反射（深复制一种）"></a>反射（深复制一种）</h3><h4 id="org-springframework-beans-BeanUtils"><a href="#org-springframework-beans-BeanUtils" class="headerlink" title="org.springframework.beans.BeanUtils"></a>org.springframework.beans.BeanUtils</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy the property values of the given source bean into the given target bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: The source and target classes do not have to match or even be derived</span></span><br><span class="line"><span class="comment"> * from each other, as long as the properties match. Any bean properties that the</span></span><br><span class="line"><span class="comment"> * source bean exposes but the target bean does not will silently be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the source bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target the target bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> editable the class (or interface) to restrict property setting to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ignoreProperties array of property names to ignore</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the copying failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanWrapper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target, <span class="meta">@Nullable</span> Class&lt;?&gt; editable,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> String... ignoreProperties)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(source, <span class="string">&quot;Source must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(target, <span class="string">&quot;Target must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取目标对象的class</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt; actualEditable = target.getClass();</span><br><span class="line">	<span class="keyword">if</span> (editable != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!editable.isInstance(target)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Target class [&quot;</span> + target.getClass().getName() +</span><br><span class="line">					<span class="string">&quot;] not assignable to Editable class [&quot;</span> + editable.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		actualEditable = editable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取目标对象的属性信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理忽略属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;String&gt; ignoreList = (ignoreProperties != <span class="keyword">null</span> ? Arrays.asList(ignoreProperties) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (PropertyDescriptor targetPd : targetPds) &#123;</span><br><span class="line">		Method writeMethod = targetPd.getWriteMethod();</span><br><span class="line">		<span class="keyword">if</span> (writeMethod != <span class="keyword">null</span> &amp;&amp; (ignoreList == <span class="keyword">null</span> || !ignoreList.contains(targetPd.getName()))) &#123;</span><br><span class="line">			PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</span><br><span class="line">			<span class="keyword">if</span> (sourcePd != <span class="keyword">null</span>) &#123;</span><br><span class="line">				Method readMethod = sourcePd.getReadMethod();</span><br><span class="line">				<span class="keyword">if</span> (readMethod != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						ClassUtils.isAssignable(writeMethod.getParameterTypes()[<span class="number">0</span>], readMethod.getReturnType())) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">							readMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						Object value = readMethod.invoke(source);</span><br><span class="line">						<span class="keyword">if</span> (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">							writeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						writeMethod.invoke(target, value);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(</span><br><span class="line">								<span class="string">&quot;Could not copy property &#x27;&quot;</span> + targetPd.getName() + <span class="string">&quot;&#x27; from source to target&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/Qian123/p/5710533.html">Java提高篇——对象克隆（复制）</a></li>
<li><a href="https://lingcoder.github.io/OnJava8/#/book/Appendix-Object-Serialization">编程思想</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>clone</tag>
        <tag>克隆</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之内部类</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>定义：外部类内部定义的类，类名不需要与文件名不同</li>
<li>static修饰（静态内部类）</li>
<li>作用域（public、default、protected、private）</li>
<li>作用范围：编译期概念，一但编译成功就是有不同的class文件（outer.class和outer$inner.class），所以内部类的成员变量/方法名可以和外部类的相同。</li>
<li>分类：静态内部类，成员内部类，局部内部类，匿名内部类四种。</li>
</ol>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>Ø 在一个方法内部使用<br>Ø 在方法的一个作用域中使用<br>Ø 一个匿名类，用于实现一个接口<br>Ø 一个匿名类，用于扩展拥有非默认构造器的类<br>Ø 一个匿名类，用于执行字段初始化<br>Ø 一个匿名类，通过实例初始化进行构建（匿名内部类不能拥有构造器)  </p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>一个内部类的对象能够访问创建它的对象的实现，包括私有数据。即内部类实例对包含它的哪个类的实例来说，是特权的。</li>
<li>对于同一个包中的其他类来说,内部类能够隐藏起来,换句话说，内部类不管方法的可见性如何，那怕是public，除了包容类，其他类都无法使用它。</li>
<li>匿名内部类可以很方便的定义回调。</li>
<li>使用内部类可以非常方便的编写事件驱动程序。</li>
</ol>
<h2 id="静态内部类-嵌套内部类"><a href="#静态内部类-嵌套内部类" class="headerlink" title="静态内部类/嵌套内部类"></a>静态内部类/嵌套内部类</h2><ol>
<li>被static修饰的内部类</li>
<li>不需要维护与外部类的对象的关系（可以直接引用，比如：outer.inner），一般不会出现内存泄漏的问题</li>
<li>嵌套类和普通的内部类还有一个区别：普通内部类不能有static数据和static属性，也不能包含嵌套类，但嵌套类可以。</li>
<li>作用域修饰符：不能声明为private，一般声明为public，方便调用。</li>
<li>静态内部类可以访问外部类所有的静态变量和方法，包括private</li>
<li>静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</li>
<li>其它类使用静态内部类需要使用“外部类.静态内部类”方式</li>
<li>Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象， HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">11</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.err.println(a);</span><br><span class="line"><span class="comment">//			System.err.println(b); // 编译出错</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printInner1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.err.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StaticInnerClass.Inner.printInner();</span><br><span class="line">		StaticInnerClass.Inner inner = <span class="keyword">new</span> StaticInnerClass.Inner();</span><br><span class="line">		inner.printInner1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员内部类：定义在类内部的非静态类，就是成员内部类"><a href="#成员内部类：定义在类内部的非静态类，就是成员内部类" class="headerlink" title="成员内部类：定义在类内部的非静态类，就是成员内部类"></a>成员内部类：定义在类内部的非静态类，就是成员内部类</h2><ol>
<li>成员内部类，就是作为外部类的成员，可以直接使用外部类的所有成员和方法，即使是private的。</li>
<li>同时外部类要访问内部类的所有成员变量/方法，则需要通过内部类的对象来获取。<br>要注意的是，成员内部类不能含有static的方法和变量（final 修饰的除外）。<strong>因为成员内部类需要先创建了外部类，才能创建它自己的</strong>，成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</li>
<li>在成员内部类要引用外部类对象时，使用outer.this来表示外部类对象；</li>
<li>而需要创建内部类对象，可以使用outer.inner  obj = outerobj.new inner();</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">		Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">		inner.print(<span class="string">&quot;Outer.new&quot;</span>);</span><br><span class="line">		inner = outer.getInner();</span><br><span class="line">		inner.print(<span class="string">&quot;Outer.get&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 个人推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类：内部类定义在方法和作用域内"><a href="#局部内部类：内部类定义在方法和作用域内" class="headerlink" title="局部内部类：内部类定义在方法和作用域内"></a>局部内部类：内部类定义在方法和作用域内</h2><p>定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutScope</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类（要继承一个父类或者实现一个接口、直接使用-new-来生成一个对象的引用）"><a href="#匿名内部类（要继承一个父类或者实现一个接口、直接使用-new-来生成一个对象的引用）" class="headerlink" title="匿名内部类（要继承一个父类或者实现一个接口、直接使用 new 来生成一个对象的引用）"></a>匿名内部类（要继承一个父类或者实现一个接口、直接使用 new 来生成一个对象的引用）</h2><p>匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。<br>有时候我为了免去给内部类命名，便倾向于使用匿名内部类，因为它没有名字。例如：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/screenshot_1587209816208.png" class title="反射知识点">

</div>

<p>匿名内部类是不能加访问修饰符的。<strong>要注意的是，new匿名类，这个类是要先定义的</strong>，看下面例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousOuter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnonymousOuter outer = <span class="keyword">new</span> AnonymousOuter();</span><br><span class="line">		Inner inner = outer.getInner(<span class="string">&quot;Inner&quot;</span>, <span class="string">&quot;gz&quot;</span>);</span><br><span class="line">		System.out.println(inner.getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, String city)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner() &#123;</span><br><span class="line">			<span class="keyword">private</span> String nameStr = name;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> nameStr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注释后，编译时提示类Inner找不到 </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="在使用匿名内部类时，要记住以下几个原则"><a href="#在使用匿名内部类时，要记住以下几个原则" class="headerlink" title="在使用匿名内部类时，要记住以下几个原则"></a>在使用匿名内部类时，要记住以下几个原则</h3><p>Ø 匿名内部类不能有构造方法。<br>Ø 匿名内部类不能定义任何静态成员、方法和类。<br>Ø 匿名内部类不能是public,protected,private,static<br>Ø 只能创建匿名内部类的一个实例。<br>Ø 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。<br>Ø 因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。<br>Ø 当所在的方法的形参需要被内部类里面使用时，该形参必须为final</p>
<h3 id="使用final修饰入参的原因"><a href="#使用final修饰入参的原因" class="headerlink" title="使用final修饰入参的原因"></a>使用final修饰入参的原因</h3><p>“这是一个编译器设计的问题，如果你了解java的编译原理的话很容易理解。<br>首先，内部类被编译的时候会生成一个单独的内部类的.class文件，这个文件并不与外部类在同一class文件中。<br>当外部类传的参数被内部类调用时，从java程序的角度来看是直接的调用例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">(<span class="keyword">final</span> String a,<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123; </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dosome</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;System.out.println(a+b)&#125;&#125;;</span><br><span class="line">  Dosome some=<span class="keyword">new</span> Dosome(); </span><br><span class="line">  some.dosome(); </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>从代码来看好像是那个内部类直接调用的a参数和b参数，但是实际上不是，在java编译器编译以后实际的操作代码是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$<span class="title">Dosome</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dosome</span><span class="params">(<span class="keyword">final</span> String a,<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.Dosome$a=a;</span><br><span class="line">  <span class="keyword">this</span>.Dosome$b=b;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.Dosome$a+<span class="keyword">this</span>.Dosome$b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码看来，内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数。 </p>
<p>这样理解就很容易得出为什么要用final了，因为两者从外表看起来是同一个东西，实际上却不是这样，如果内部类改掉了这些参数的值也不可能影响到原参数，然而这样却失去了参数的一致性，因为从编程人员的角度来看他们是同一个东西，如果编程人员在程序设计的时候在内部类中改掉参数的值，但是外部调用的时候又发现值其实没有被改掉，这就让人非常的难以理解和接受，为了避免这种尴尬的问题存在，所以编译器设计人员把内部类能够使用的参数设定为必须是final来规避这种莫名其妙错误的存在。”</p>
<blockquote>
<p>(简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变)</p>
</blockquote>
<h3 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer1</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Outer1 outer = <span class="keyword">new</span> Outer1(); </span><br><span class="line">		Inner1 inner = outer.getInner(<span class="string">&quot;Inner&quot;</span>, <span class="string">&quot;gz&quot;</span>); </span><br><span class="line">		System.out.println(inner.getName()); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner1 <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, String city)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner1(name, city) &#123; </span><br><span class="line">			<span class="keyword">private</span> String nameStr = name; </span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">return</span> nameStr; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span> </span>&#123; </span><br><span class="line">	Inner1(String name, String city) &#123; </span><br><span class="line">		System.out.println(city); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>注意这里的形参city，由于它没有被匿名内部类直接使用，而是被抽象类Inner的构造函数所使用，所以不必定义为final。<br>而匿名内部类通过实例初始化，可以达到类似构造器的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer2</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Outer2 outer = <span class="keyword">new</span> Outer2(); </span><br><span class="line">		Inner2 inner = outer.getInner(<span class="string">&quot;Inner&quot;</span>, <span class="string">&quot;gz&quot;</span>); </span><br><span class="line">		System.out.println(inner.getName()); </span><br><span class="line">		System.out.println(inner.getProvince()); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner2 <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> String city)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner2() &#123;</span><br><span class="line">			<span class="keyword">private</span> String nameStr = name; </span><br><span class="line">			<span class="keyword">private</span> String province; </span><br><span class="line">			<span class="comment">// 实例初始化 </span></span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">if</span> (city.equals(<span class="string">&quot;gz&quot;</span>)) &#123; </span><br><span class="line">					province = <span class="string">&quot;gd&quot;</span>; </span><br><span class="line">				&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">					province = <span class="string">&quot;&quot;</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">return</span> nameStr; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">return</span> province; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner2</span> </span>&#123; </span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="function">String <span class="title">getProvince</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="内部类继承"><a href="#内部类继承" class="headerlink" title="内部类继承"></a>内部类继承</h2><p>内部类的继承，是指内部类被继承，普通类 extents 内部类。而这时候代码上要有点特别处理，具体看以下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123; </span><br><span class="line">	<span class="comment">// InheritInner() 是不能通过编译的，一定要加上形参 </span></span><br><span class="line">	InheritInner(WithInner wi) &#123; </span><br><span class="line">		wi.<span class="keyword">super</span>(); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		WithInner wi = <span class="keyword">new</span> WithInner(); </span><br><span class="line">		InheritInner obj = <span class="keyword">new</span> InheritInner(wi); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123; </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以看到子类的构造函数里面要使用<strong>父类的外部类对象.super()</strong>;而这个对象需要从外面创建并传给形参.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之泛型</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>泛型在JDK1.5引入，其本质是一种<strong>参数化类型（Parameterized Type），在使用时传入实际类型即可</strong>，即可以将操作的数据类型指定为方法签名中的一种特殊参数,可以作用在类、接口、方法中。泛型是编译期的一种概念，主要是用于编译期类型安全检查（编译之后泛型会被擦除）。</p>
<h3 id="常用泛型类型常量"><a href="#常用泛型类型常量" class="headerlink" title="常用泛型类型常量"></a>常用泛型类型常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E：元素（Element），多用于java集合框架</span><br><span class="line">K：关键字（Key）</span><br><span class="line">N：数字（Number）</span><br><span class="line">T：类型（Type）</span><br><span class="line">V：值（Value）</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="泛型反例"><a href="#泛型反例" class="headerlink" title="泛型反例"></a>泛型反例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		list.add(<span class="number">100</span>);</span><br><span class="line">		list.add(<span class="number">10.09</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">			System.out.println((String)list.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译期通过，并且运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">	at com.sunld.Test1.main(Test1.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>
<p><strong>如何在编译期完成校验？</strong></p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>与泛型类的定义类似，参考代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方式1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类的声明与非泛型类的类似，在类的名称后面增加类型参数。语法如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">className</span>&lt;泛型标识 <span class="keyword">extends</span>|<span class="title">super</span> 上限|下限, ...&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> genericType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。如果上限或下限有多个限制，可以使用<code>&amp;</code>处理。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。简单示例：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>一种可以接受不同参数类型的方法，并且可以根据入参进行参数返回，尤其是反射处理数据转换比较常用。</p>
<blockquote>
<p>注意：方法上是否定义泛型和类上是否定义没有必然的联系</p>
</blockquote>
<p>语法参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 第一个T表示泛型声明，只有声明之后才能使用</span></span><br><span class="line"><span class="comment">* 2. 第二个T表示返回值</span></span><br><span class="line"><span class="comment">* 3.第三个T限制入参的返回需要与第一个T一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">executeGenericMethod</span><span class="params">(Class&lt;T&gt; cls)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cls.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>泛型是编译期的概念，在编译之后的字节码中不包含泛型的信息（为了解决该问题，java在字节码中引入Signature、LocalVariableTypeTable）。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为<strong>类型擦除</strong>。比如：<code>List&lt;Object&gt;</code>和 <code>List&lt;String&gt;</code>等类型，在编译之后都会变成 <code>List</code>。JVM 看到的只是 List，而由泛型附加的类型信息对JVM来说是不可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericType2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> temp1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> temp2 =<span class="number">20</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> temp3=<span class="number">30</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment">//	public T getT() &#123;</span></span><br><span class="line"><span class="comment">//		return t;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public void setT(T t) &#123;</span></span><br><span class="line"><span class="comment">//		this.t = t;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public List&lt;String&gt; getList() &#123;</span></span><br><span class="line"><span class="comment">//		return list;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public void setList(List&lt;String&gt; list) &#123;</span></span><br><span class="line"><span class="comment">//		this.list = list;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">		map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;valueaa&quot;</span>);</span><br><span class="line">		String value = map.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//		TestGenericType2&lt;Integer&gt;[] array = new TestGenericType2&lt;Integer&gt;[10];</span></span><br><span class="line"><span class="comment">//		TestGenericType2&lt;Integer&gt;[] array1 = new TestGenericType2[10];</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后的结果：  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.TestGenericType2包含com.sunld.TestGenericType2</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/TestGenericType2.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">5</span>-<span class="number">14</span>; size <span class="number">1287</span> bytes</span><br><span class="line">  MD5 checksum 7ad53533c7723c97d0ec9bb863b415ca</span><br><span class="line">  Compiled from <span class="string">&quot;TestGenericType2.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">TestGenericType2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span>&gt; <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/TestGenericType2</span><br><span class="line">   #2 = Utf8               com/sunld/TestGenericType2</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               t</span><br><span class="line">   #6 = Utf8               Ljava/lang/Object;</span><br><span class="line">   #7 = Utf8               Signature</span><br><span class="line">   #8 = Utf8               TT;</span><br><span class="line">   #9 = Utf8               list</span><br><span class="line">  #10 = Utf8               Ljava/util/List;</span><br><span class="line">  #11 = Utf8               Ljava/util/List&lt;Ljava/lang/String;&gt;;</span><br><span class="line">  #12 = Utf8               temp1</span><br><span class="line">  #13 = Utf8               I</span><br><span class="line">  #14 = Utf8               temp2</span><br><span class="line">  #15 = Utf8               ConstantValue</span><br><span class="line">  #16 = Integer            20</span><br><span class="line">  #17 = Utf8               temp3</span><br><span class="line">  #18 = Integer            30</span><br><span class="line">  #19 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #20 = Utf8               ()V</span><br><span class="line">  #21 = Utf8               Code</span><br><span class="line">  #22 = Fieldref           #1.#23         // com/sunld/TestGenericType2.temp1:I</span><br><span class="line">  #23 = NameAndType        #12:#13        // temp1:I</span><br><span class="line">  #24 = Utf8               LineNumberTable</span><br><span class="line">  #25 = Utf8               LocalVariableTable</span><br><span class="line">  #26 = Utf8               &lt;init&gt;</span><br><span class="line">  #27 = Methodref          #3.#28         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #28 = NameAndType        #26:#20        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #29 = Fieldref           #1.#30         // com/sunld/TestGenericType2.temp2:I</span><br><span class="line">  #30 = NameAndType        #14:#13        // temp2:I</span><br><span class="line">  #31 = Utf8               this</span><br><span class="line">  #32 = Utf8               Lcom/sunld/TestGenericType2;</span><br><span class="line">  #33 = Utf8               LocalVariableTypeTable</span><br><span class="line">  #34 = Utf8               Lcom/sunld/TestGenericType2&lt;TT;&gt;;</span><br><span class="line">  #35 = Utf8               main</span><br><span class="line">  #36 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #37 = Class              #38            // java/util/HashMap</span><br><span class="line">  #38 = Utf8               java/util/HashMap</span><br><span class="line">  #39 = Methodref          #37.#28        // java/util/HashMap.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #40 = String             #41            // a</span><br><span class="line">  #41 = Utf8               a</span><br><span class="line">  #42 = String             #43            // valueaa</span><br><span class="line">  #43 = Utf8               valueaa</span><br><span class="line">  #44 = InterfaceMethodref #45.#47        // java/util/Map.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #45 = Class              #46            // java/util/Map</span><br><span class="line">  #46 = Utf8               java/util/Map</span><br><span class="line">  #47 = NameAndType        #48:#49        // put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #48 = Utf8               put</span><br><span class="line">  #49 = Utf8               (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #50 = InterfaceMethodref #45.#51        // java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #51 = NameAndType        #52:#53        // get:(Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #52 = Utf8               get</span><br><span class="line">  #53 = Utf8               (Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #54 = Class              #55            // java/lang/String</span><br><span class="line">  #55 = Utf8               java/lang/String</span><br><span class="line">  #56 = Utf8               args</span><br><span class="line">  #57 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #58 = Utf8               map</span><br><span class="line">  #59 = Utf8               Ljava/util/Map;</span><br><span class="line">  #60 = Utf8               value</span><br><span class="line">  #61 = Utf8               Ljava/lang/String;</span><br><span class="line">  #62 = Utf8               Ljava/util/Map&lt;Ljava/lang/String;Ljava/lang/String;&gt;;</span><br><span class="line">  #63 = Utf8               SourceFile</span><br><span class="line">  #64 = Utf8               TestGenericType2.java</span><br><span class="line">  #65 = Utf8               &lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         2: putstatic     #22                 // Field temp1:I</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.sunld.TestGenericType2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #27                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">         7: putfield      #29                 // Field temp2:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">10</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestGenericType2;</span><br><span class="line">      LocalVariableTypeTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestGenericType2&lt;TT;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #37                 // class java/util/HashMap</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #39                 // Method java/util/HashMap.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         9: ldc           #40                 // String a</span><br><span class="line">        11: ldc           #42                 // String valueaa</span><br><span class="line">        13: invokeinterface #44,  3           // InterfaceMethod java/util/Map.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">        <span class="number">18</span>: pop</span><br><span class="line">        <span class="number">19</span>: aload_1</span><br><span class="line">        20: ldc           #40                 // String a</span><br><span class="line">        22: invokeinterface #50,  2           // InterfaceMethod java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">        27: checkcast     #54                 // class java/lang/String</span><br><span class="line">        <span class="number">30</span>: astore_2</span><br><span class="line">        <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">45</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">46</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">47</span>: <span class="number">19</span></span><br><span class="line">        line <span class="number">50</span>: <span class="number">31</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">32</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>   map   Ljava/util/Map;</span><br><span class="line">           <span class="number">31</span>       <span class="number">1</span>     <span class="number">2</span> value   Ljava/lang/String;</span><br><span class="line">      LocalVariableTypeTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>   map   Ljava/util/Map&lt;Ljava/lang/String;Ljava/lang/String;&gt;;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestGenericType2.java&quot;</span></span><br><span class="line">Signature: #65                          // &lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</span><br></pre></td></tr></table></figure>
<p>从Signature属性的得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们在编码时能通过反射手段取得参数化类型的根本依据。</p>
<h3 id="擦除过程"><a href="#擦除过程" class="headerlink" title="擦除过程"></a>擦除过程</h3><p>首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</p>
<h3 id="泛型擦除的问题"><a href="#泛型擦除的问题" class="headerlink" title="泛型擦除的问题"></a>泛型擦除的问题</h3><ol>
<li>用泛型不可以区分方法签名</li>
<li>泛型类的静态变量是共享</li>
</ol>
<h2 id="泛型边界"><a href="#泛型边界" class="headerlink" title="泛型边界"></a>泛型边界</h2><ol>
<li><? extends T>表示该通配符所代表的类型是 T 类型的子类。</li>
<li><? super T>表示该通配符所代表的类型是 T 类型的父类。

</li>
</ol>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符?</h3><p>在java中如果使用泛型，例如<code>List&lt;Interger&gt;和List&lt;Number&gt;</code>其实是两种类型(<strong>类型之间转换会出现转换异常</strong>)，之间没有任务关系，如果想要接收不同类型的参数，则需要引入通配符的概念，<code>List&lt;?&gt;</code>（？表示所有泛型中的父类）<strong>泛型内是不存在父子关系，但是利用通配符可以产生类似的效果</strong>。</p>
<h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><p>假设给定的泛型类型为G,两个具体的泛型参数X、Y，当中Y是X的子类</p>
<ol>
<li>G&lt;? extends Y&gt; 是 G&lt;? extends X&gt;的子类型</li>
<li>G<X> 是 G&lt;? extends X&gt;的子类型</X></li>
<li>G&lt;?&gt; 与 G&lt;? extends Object&gt;等同</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>适用于多种数据类型执行相同的代码（代码复用）</li>
<li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li>
</ol>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol>
<li>不能实例化泛型类：<code>T t = new T();</code></li>
<li>静态变量不能引用泛型变量：<code>private static T t1;</code>；非静态变量可以引用：<code>private T t1;</code></li>
<li>未声明泛型的方法不能引用泛型变量：<code>public static T getT1()&#123;return t1;&#125;</code>；声明之后可以：<code>public static &lt;T&gt; T executeGenericMethod(Class&lt;T&gt; cls)&#123;return null;&#125;</code></li>
<li>基本类型无法作为泛型类型：<code>List&lt;int&gt; list = new ArrayList&lt;&gt;();</code></li>
<li>无法使用instanceof关键字或==判断泛型类的类型：<code>list instanceof List&lt;String&gt;</code> 或者<code>list == List&lt;String&gt;</code></li>
<li>泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的，即类型擦除之后的class信息相同</li>
<li>泛型数组可以声明但无法实例化：<code>Test1&lt;Integer&gt;[] array = new Test1&lt;Integer&gt;[10];</code>，去掉泛型即可<code>Test1&lt;Integer&gt;[] array = new Test1[10];</code></li>
<li>泛型类不能继承Exception或者Throwable</li>
<li>不能捕获泛型类型限定的异常但可以将泛型限定的异常抛出</li>
</ol>
<h3 id="泛型继承规则"><a href="#泛型继承规则" class="headerlink" title="泛型继承规则"></a>泛型继承规则</h3><ol>
<li>对于泛型参数是继承关系的泛型类之间是没有继承关系的：<code>List&lt;Integer&gt;与List&lt;Number&gt;</code></li>
<li>泛型类可以继承其它泛型类，例如: <code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</code></li>
<li>泛型类的继承关系在使用中同样会受到泛型类型的影响</li>
</ol>
<h2 id="泛型与反射"><a href="#泛型与反射" class="headerlink" title="泛型与反射"></a>泛型与反射</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericType1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestGenericType1&lt;Integer&gt; a = <span class="keyword">new</span> TestGenericType1&lt;Integer&gt;() &#123;&#125;;</span><br><span class="line">		Type superclass = a.getClass().getGenericSuperclass();</span><br><span class="line">		System.out.println(superclass);</span><br><span class="line">	    <span class="comment">//getActualTypeArguments 返回确切的泛型参数</span></span><br><span class="line">		Type type = ((ParameterizedType)superclass).getActualTypeArguments()[<span class="number">0</span>]; </span><br><span class="line">	    System.out.println(type);<span class="comment">//class java.lang.Integer</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/ldh-better/p/7127308.html#_label0">Java 泛型在实际开发中的应用</a></li>
<li><a href="https://www.jianshu.com/p/986f732ed2f1">Java泛型详解</a></li>
<li><a href="https://www.cnblogs.com/lwbqqyumidi/p/3837629.html">Java总结篇系列：Java泛型</a></li>
<li><a href="https://www.cnblogs.com/coprince/p/8603492.html">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之注解</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>在jdk1.5中引入了注解的概念，注解是Java提供的一种对类信息（包括：类、属性与方法）进行扩展的一种行为。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation 对象，然后通过该 Annotation 对象来获取注解中的元数据信息。通过使用注解，可以将元数据保存在 Java 源代码中。并拥有如下优势：</p>
<ol>
<li>简单易读的代码，</li>
<li>编译器类型检查，</li>
<li>使用 annotation API 为自己的注解构造处理工具。</li>
</ol>
<a id="more"></a>
<p>JDK中目前引入的注解：</p>
<ul>
<li><strong>@Override</strong>：表示当前的方法定义将覆盖基类的方法。如果你不小心拼写错误，或者方法签名被错误拼写的时候，编译器就会发出错误提示。</li>
<li><strong>@Deprecated</strong>：如果使用该注解的元素被调用，编译器就会发出警告信息。</li>
<li><strong>@SuppressWarnings</strong>：关闭不当的编译器警告信息。</li>
<li><strong>@SafeVarargs</strong>：在 Java 7 中加入用于禁止对具有泛型varargs参数的方法或构造函数的调用方发出警告。</li>
<li><strong>@FunctionalInterface</strong>：Java 8 中加入用于表示类型声明为函数式接口</li>
</ul>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/1588840779124.png" class title="1588840779124.png">

</div>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>jdk中目前定义了5中标准的meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>@Target</td>
<td>表示注解可以用于哪些地方。可能的 <strong>ElementType</strong> 参数包括：<br><strong>CONSTRUCTOR</strong>：构造器的声明<br><strong>FIELD</strong>：字段声明（包括 enum 实例）<br><strong>LOCAL_VARIABLE</strong>：局部变量声明<br><strong>METHOD</strong>：方法声明<br><strong>PACKAGE</strong>：包声明<br><strong>PARAMETER</strong>：参数声明<br><strong>TYPE</strong>：类、接口（包括注解类型）或者 enum 声明</td>
</tr>
<tr>
<td>@Retention</td>
<td>表示注解信息保存的时长。可选的 <strong>RetentionPolicy</strong> 参数包括：<br><strong>SOURCE</strong>：注解将被编译器丢弃<br><strong>CLASS</strong>：注解在 class 文件中可用，但是会被 VM 丢弃。<br><strong>RUNTIME</strong>：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</td>
</tr>
<tr>
<td>@Documented</td>
<td>将此注解保存在 Javadoc 中</td>
</tr>
<tr>
<td>@Inherited</td>
<td>允许子类继承父类的注解</td>
</tr>
<tr>
<td>@Repeatable</td>
<td>允许一个注解可以被使用一次或者多次（Java 8）。</td>
</tr>
</tbody></table>
<h3 id="Target修饰的对象范围"><a href="#Target修饰的对象范围" class="headerlink" title="@Target修饰的对象范围"></a>@Target修饰的对象范围</h3><p><strong>@Target</strong>说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的作用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Retention定义被保留的时间长短"><a href="#Retention定义被保留的时间长短" class="headerlink" title="@Retention定义被保留的时间长短"></a>@Retention定义被保留的时间长短</h3><p><strong>@Retention</strong> 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：</p>
<ol>
<li>SOURCE:在源文件中有效（即源文件保留）</li>
<li>CLASS:在 class 文件中有效（即 class 保留）</li>
<li>RUNTIME:在运行时有效（即运行时保留）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体作用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Documented描述-javadoc"><a href="#Documented描述-javadoc" class="headerlink" title="@Documented描述-javadoc"></a>@Documented描述-javadoc</h3><p><strong>@Documented</strong> 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inherited阐述了某个被标注的类型是被继承的"><a href="#Inherited阐述了某个被标注的类型是被继承的" class="headerlink" title="@Inherited阐述了某个被标注的类型是被继承的"></a>@Inherited阐述了某个被标注的类型是被继承的</h3><p><strong>@Inherited</strong> 元注解是一个标记注解，**@Inherited** 阐述了某个被标注的类型是被继承的。如果一个使用了**@Inherited** 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该 class 的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span></span><br><span class="line"><span class="comment">     * repeatable annotation type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the containing annotation type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过注解实现一种日志记录的方式。</p>
<h3 id="LogAnnotation定义"><a href="#LogAnnotation定义" class="headerlink" title="LogAnnotation定义"></a>LogAnnotation定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation &#123;</span><br><span class="line">	<span class="comment">/** 日志类型 **/</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">	<span class="comment">/** 日志内容 **/</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">content</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@LogAnnotation(content = &quot;用户登录日志信息&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解元数据解析"><a href="#注解元数据解析" class="headerlink" title="注解元数据解析"></a>注解元数据解析</h3><p>getDeclaredMethods() 和 getAnnotation()，它们都属于 AnnotatedElement 接口（Class，Method 与 Field 类都实现了该接口）。getAnnotation() 方法返回指定类型的注解对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationUtil</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getLogInfo</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">		<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">			<span class="keyword">if</span> (method.isAnnotationPresent(LogAnnotation.class)) &#123;</span><br><span class="line">				LogAnnotation annotation = method.getAnnotation(LogAnnotation.class);</span><br><span class="line">				<span class="comment">// 注解信息的处理地方</span></span><br><span class="line">				System.out.println(annotation.content() + <span class="string">&quot; 类型：&quot;</span> + annotation.type());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		AnnotationUtil.getLogInfo(Login.class); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="默认值问题"><a href="#默认值问题" class="headerlink" title="默认值问题"></a>默认值问题</h3><ol>
<li>元素不能有不确定的值：要么使用默认值要么使用代码中定义的值</li>
<li>非基本类型的原始不能定义null，可以使用自定义约束来进行实现</li>
</ol>
<h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>单元测试</li>
<li>数据库相关的ORM操作</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://lingcoder.github.io/OnJava8/#/book/23-Annotations?id=%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95">编程思想</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse使用技巧</title>
    <url>/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="集成javap命令"><a href="#集成javap命令" class="headerlink" title="集成javap命令"></a>集成javap命令</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li>eclipse中点击工具栏: Run &gt; External Tools &gt; External Tools Configuration</li>
<li>双击”程序”</li>
<li>修改配置</li>
</ol>
<div align="center">

<img src="/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1588039059895.png" class title="执行javap">

</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Name: javap(随意)</span><br><span class="line">location: jdk实际路径</span><br><span class="line">Working Directory:$&#123;workspace_loc&#125;\$&#123;project_name&#125; （不要改）</span><br><span class="line">Arguments:-c -verbose  -classpath  $&#123;workspace_loc&#125;/ $&#123;project_name&#125;/bin/$&#123;java_type_name&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><div align="center">

<img src="/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1588039225454.png" class title="eclipse配置">

</div>

<h3 id="javap的命令说明"><a href="#javap的命令说明" class="headerlink" title="javap的命令说明"></a>javap的命令说明</h3><p>参考《<a href="https://www.sunliaodong.cn/2021/02/04/Javap%E8%AF%A6%E8%A7%A3/">javap详解</a>》</p>
<h2 id="debug使用技巧"><a href="#debug使用技巧" class="headerlink" title="debug使用技巧"></a>debug使用技巧</h2><h3 id="常用快捷键说明"><a href="#常用快捷键说明" class="headerlink" title="常用快捷键说明"></a>常用快捷键说明</h3><ol>
<li>Step Into (also F5) 跳入</li>
<li>Step Over (also F6) 跳过</li>
<li>Step Return (also F7) 执行完当前method，然后return跳出此method</li>
<li>step Filter 逐步过滤 一直执行直到遇到未经过滤的位置或断点(设置Filter:window-preferences-java-Debug-step Filtering)</li>
<li>resume 重新开始执行debug,一直运行直到遇到breakpoint</li>
<li>hit count 设置执行次数 适合程序中的for循环(设置 breakpoint view-右键hit count)</li>
<li>inspect 检查 运算。执行一个表达式显示执行值</li>
<li>watch 实时地监视变量的变化</li>
<li>我们常说的断点(breakpoints)是指line breakpoints,除了line breakpoints,还有其他的断点类型：field(watchpoint)breakpoint,method breakpoint,exception breakpoint.</li>
<li>field breakpoint 也叫watchpoint(监视点) 当成员变量被读取或修改时暂挂</li>
<li>添加method breakpoint 进入/离开此方法时暂挂(Run-method breakpoint)</li>
<li>添加Exception breakpoint 捕抓到Execption时暂挂(待续…)</li>
</ol>
<h3 id="断点属性"><a href="#断点属性" class="headerlink" title="断点属性"></a>断点属性</h3><ol>
<li>hit count 执行多少次数后暂挂 用于循环</li>
<li>enable condition 遇到符合你输入条件(为ture\改变时)就暂挂</li>
<li>suspend thread 多线程时暂挂此线程</li>
<li>suspend VM 暂挂虚拟机</li>
<li>variables 视图里的变量可以改变变量值，在variables 视图选择变量点击右键–change value.一次来进行快速调试。</li>
<li>debug 过程中修改了某些code后–〉save&amp;build–&gt;resume–&gt;重新暂挂于断点</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">  MyDate aa = <span class="keyword">new</span> MyDate();</span><br><span class="line">  aa.addDays(day);                      =============》(<span class="number">1</span>)</span><br><span class="line">  System.out.println(<span class="string">&quot;eeeeeeeeeeeeeee&quot;</span>);=============》(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">addDays</span><span class="params">(<span class="keyword">int</span> more_days)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);               =============》(<span class="number">3</span>)</span><br><span class="line">    String result = <span class="string">&quot;&quot;</span>;         =============》(<span class="number">4</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);               =============》(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>你在(1)处加断点，运行到此处时如果Step Into (also F5)为跳入，则接着执行到(3)。再执行Step Over (also F6)执行本行，则执行到(4)。最后执行Step Return (also F7)，则跳出addDays方法，跳到(2)</p>
<h2 id="配置-author"><a href="#配置-author" class="headerlink" title="配置@author"></a>配置@author</h2><ol>
<li>eclipse-&gt;window-&gt;preference-&gt;java-&gt;code  styple-&gt;code template-&gt;Code-&gt;New Java files </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">点击 Edit </span><br><span class="line">$&#123;filecomment&#125;</span><br><span class="line">$&#123;package_declaration&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 孙辽东</span></span><br><span class="line"><span class="comment">* <span class="doctag">@E</span>-mail:sld880311@126.com</span></span><br><span class="line"><span class="comment">* <span class="doctag">@qq</span>:767768553</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 创建时间：$&#123;date&#125; $&#123;time&#125;</span></span><br><span class="line"><span class="comment">* 简单说明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$&#123;typecomment&#125;</span><br><span class="line">$&#123;type_declaration&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在建立类文件的时候输入“/**”的时候自动出来的：eclipse-&gt;window-&gt;preference-&gt;java-&gt;code  styple-&gt;code template-&gt;comments-&gt;typles,点击 Edit ，就可以根据自己需要编写了</li>
</ol>
]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>git详解</title>
    <url>/2021/02/04/git%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="提交本地工程到github"><a href="#提交本地工程到github" class="headerlink" title="提交本地工程到github"></a>提交本地工程到github</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;注释&quot;</span></span><br><span class="line">git remote add origin https://github.com/sld880311/parkspaceagent</span><br><span class="line"></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="comment">#如果出现fatal: refusing to merge unrelated histories</span></span><br><span class="line">使用如下命令 git pull origin master --allow-unrelated-histories</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="代码提交示意图"><a href="#代码提交示意图" class="headerlink" title="代码提交示意图"></a>代码提交示意图</h3><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589535948892.png" class title="git代码提交示意图">

</div>

<h3 id="官方参考图"><a href="#官方参考图" class="headerlink" title="官方参考图"></a>官方参考图</h3><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589535987537.png" class title="git官网提交提示图">

</div>

<h2 id="使用图解"><a href="#使用图解" class="headerlink" title="使用图解"></a>使用图解</h2><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589536030194.png" class title="git命令使用详解">

</div>

<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h3><h4 id="–-filename"><a href="#–-filename" class="headerlink" title="– filename"></a>– filename</h4><p>把filename文件在工作区的修改撤销到最近一次git add 或 git commit时的内容。</p>
<h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。</p>
<p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</p>
<p>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</p>
<p>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p>
<h2 id="分支详解"><a href="#分支详解" class="headerlink" title="分支详解"></a>分支详解</h2><h2 id="忽略文件参考"><a href="#忽略文件参考" class="headerlink" title="忽略文件参考"></a>忽略文件参考</h2><p>在工程下建立文件.gitignore,复制以下内容  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.ear</span><br><span class="line"></span><br><span class="line"># ignore Maven generated target folders</span><br><span class="line">target</span><br><span class="line"></span><br><span class="line"># ignore eclipse files</span><br><span class="line">.project</span><br><span class="line">.classpath</span><br><span class="line">.settings</span><br><span class="line">.metadata</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/shih/p/6826743.html">git重要的三个命令stash, checkout, reset的一些总结</a></li>
<li><a href="https://blog.csdn.net/hughgilbert/article/details/70473348">Git学习（三）——staging area 工作原理</a></li>
<li><a href="https://segmentfault.com/q/1010000007679514">git中stash的工作原理是什么？</a></li>
<li><a href="https://blog.csdn.net/chenj_freedom/article/details/50543152">git教程 - 概念 原理 使用</a></li>
<li><a href="https://www.cnblogs.com/houpeiyong/p/5890748.html">git revert和git reset的区别</a></li>
<li><a href="https://blog.csdn.net/hudashi/article/details/7664460">代码回滚：git reset、git checkout和git revert区别和联系</a></li>
<li><a href="https://blog.csdn.net/ibingow/article/details/7541402">git reflog</a></li>
</ol>
]]></content>
      <categories>
        <category>常用工具</category>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+github+next部署个人博客</title>
    <url>/2021/02/03/%E4%BD%BF%E7%94%A8hexo-github-next%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"><span class="comment"># 修改原</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 改回去</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>
<h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>使用npm安装hexo(<a href="https://hexo.io/zh-cn/">详细文档</a>)，命令是<code>npm install -g hexo-cli</code>,安装完成之后初始化博客,命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir sld880311.github.io</span><br><span class="line"><span class="built_in">cd</span> sld880311.github.io</span><br><span class="line">hexo init </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>初始化完成之后目录结构如下：<a id="more"></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 网站的配置信息，您可以在此配置大部分的参数。 </span></span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds <span class="comment"># 模版文件夹</span></span><br><span class="line">├── <span class="built_in">source</span>  <span class="comment"># 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span></span><br><span class="line">|   ├── _drafts <span class="comment"># 草稿文件</span></span><br><span class="line">|   └── _posts <span class="comment"># 文章Markdowm文件 </span></span><br><span class="line">└── themes  <span class="comment"># 主题文件夹</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s         <span class="comment"># 启动服务，然后可以使用 http://localhost:4000访问</span></span><br><span class="line">hexo init      <span class="comment">#生成文档</span></span><br><span class="line">hexo g         <span class="comment">#生成网页</span></span><br><span class="line">hexo clean     <span class="comment">#清除网页</span></span><br><span class="line">hexo d         <span class="comment">#部署博客</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h2 id="特殊配置"><a href="#特殊配置" class="headerlink" title="特殊配置"></a>特殊配置</h2><h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>获取<code>cat ~/.ssh/id_rsa.pub</code>中的数据，如果没有数据需要按照以下命令配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;sunliaodong&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;sld880311@hotmail.com&quot;</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;sld880311@hotmail.com&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后把生成的key添加中自己的github中即可。</p>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><h4 id="修改根目录下的-config-yml"><a href="#修改根目录下的-config-yml" class="headerlink" title="修改根目录下的_config.yml"></a>修改根目录下的_config.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/sld880311/sld880311.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h4 id="安装部署插件hexo-deployer-git"><a href="#安装部署插件hexo-deployer-git" class="headerlink" title="安装部署插件hexo-deployer-git"></a>安装部署插件hexo-deployer-git</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h4 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<h3 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h3><h4 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<h4 id="修改根目录的-config-yml"><a href="#修改根目录的-config-yml" class="headerlink" title="修改根目录的_config.yml"></a>修改根目录的_config.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章字数统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="修改主题-config-yml"><a href="#修改主题-config-yml" class="headerlink" title="修改主题_config.yml"></a>修改主题_config.yml</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br><span class="line">  item_text_post: <span class="literal">true</span></span><br><span class="line">  item_text_total: <span class="literal">true</span></span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>
<h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章名称&quot;</span>      <span class="comment"># 使用命令创建文章</span></span><br><span class="line">hexo new page categories  <span class="comment"># 定义分类</span></span><br><span class="line">hexo new page tags        <span class="comment"># 定义标签</span></span><br><span class="line">hexo new page about       <span class="comment"># 定义关于</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://theme-next.iissnan.com/">theme-next.iissnan</a></li>
<li><a href="https://theme-next.js.org/docs/">theme-next.js</a></li>
<li><a href="https://www.jianshu.com/p/446ec02bb0a8">Hexo+Next搭建个人博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/185015237">hexo之主题优化篇</a></li>
<li><a href="https://segmentfault.com/a/1190000017986794">超详细Hexo+Github Page搭建技术博客教程【持续更新】</a></li>
<li><a href="https://blog.csdn.net/u014786530/article/details/103548737">Hexo+NexT搭建个人博客</a></li>
<li><a href="https://blog.csdn.net/qq_40930491/article/details/87902310">从头开始搭建hexo+github+hexo-theme-next主题博客（高级设置）</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>（Singleton Pattern、单态模式、单件模式、对象创建型模式），单例模式的特点：</p>
<ol>
<li>构造方法私有化；(不能被实例化和继承)</li>
<li>实例化的变量引用私有化；</li>
<li>获取实例的方法共有。</li>
</ol>
<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><ol>
<li>唯一的对象实例</li>
<li>保证一个类仅有一个实例，并提供一个访问他的全局访问点</li>
<li>有状态（可变的单例对象，可以组成状态仓库）、无状态（工具类）</li>
</ol>
<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>在下面的情况下可以使用Singleton模式：</p>
<ol>
<li>当类只能有一个实例而且客户可以从一个总所周知的访问点访问它时。</li>
<li>当这个唯一实例应该是通过子类可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
<li>系统只需要一个实例的对象，而这个对象又会被经常创建。</li>
</ol>
<a id="more"></a>

<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><div align="center">

<img src="/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1588206615300.png" class title="单例模式结构图">

</div>

<h2 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h2><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><ol>
<li>定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作。</li>
<li>可能负责创建它自己的唯一实例。</li>
</ol>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="懒汉模式（延迟加载）"><a href="#懒汉模式（延迟加载）" class="headerlink" title="懒汉模式（延迟加载）"></a>懒汉模式（延迟加载）</h3><h4 id="普通实现-非线程安全"><a href="#普通实现-非线程安全" class="headerlink" title="普通实现-非线程安全"></a>普通实现-非线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：非线程安全</p>
</blockquote>
<h4 id="锁在方法上-synchronized-线程安全"><a href="#锁在方法上-synchronized-线程安全" class="headerlink" title="锁在方法上(synchronized)-线程安全"></a>锁在方法上(synchronized)-线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：线程安全，效率低</p>
</blockquote>
<h4 id="同步代码块（synchronized）-线程不安全"><a href="#同步代码块（synchronized）-线程不安全" class="headerlink" title="同步代码块（synchronized）-线程不安全"></a>同步代码块（synchronized）-线程不安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton1.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：线程安全，效率低</p>
</blockquote>
<h4 id="DCL模式实现-线程安全"><a href="#DCL模式实现-线程安全" class="headerlink" title="DCL模式实现-线程安全"></a>DCL模式实现-线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 防止重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton1.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++ ) &#123;</span><br><span class="line">			es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() </span><br><span class="line">							+  Singleton1.getInstance());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="为什么需要使用volatile"><a href="#为什么需要使用volatile" class="headerlink" title="为什么需要使用volatile"></a>为什么需要使用volatile</h5><p><code>instance = new Singleton()</code>主要是完成了以下三个事情</p>
<ol>
<li>给instance实例分配内存；</li>
<li>初始化instance的构造器；</li>
<li>将instance对象指向分配的内存空间（注意到这步时instance就非null了）</li>
</ol>
<p>JVM会进行指令优化为：  </p>
<ol>
<li>给instance实例分配内存；</li>
<li>将instance对象指向分配的内存空间；—会出现线程安全问题</li>
<li>初始化instance的构造器；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.Singleton1包含com.sunld.Singleton1</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/Singleton1.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">4</span>-<span class="number">30</span>; size <span class="number">620</span> bytes</span><br><span class="line">  MD5 checksum 69d5cbecd81034e77060fee87c23526c</span><br><span class="line">  Compiled from <span class="string">&quot;Singleton1.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">Singleton1</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/Singleton1</span><br><span class="line">   #2 = Utf8               com/sunld/Singleton1</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               instance</span><br><span class="line">   #6 = Utf8               Lcom/sunld/Singleton1;</span><br><span class="line">   #7 = Utf8               &lt;clinit&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Fieldref           #1.#11         // com/sunld/Singleton1.instance:Lcom/sunld/Singleton1;</span><br><span class="line">  #11 = NameAndType        #5:#6          // instance:Lcom/sunld/Singleton1;</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Methodref          #3.#16         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = NameAndType        #14:#8         // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #17 = Utf8               this</span><br><span class="line">  #18 = Utf8               getInstance</span><br><span class="line">  #19 = Utf8               ()Lcom/sunld/Singleton1;</span><br><span class="line">  #20 = Methodref          #1.#16         // com/sunld/Singleton1.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Utf8               StackMapTable</span><br><span class="line">  #22 = Class              #23            // java/lang/Class</span><br><span class="line">  #23 = Utf8               java/lang/Class</span><br><span class="line">  #24 = Class              #25            // java/lang/Throwable</span><br><span class="line">  #25 = Utf8               java/lang/Throwable</span><br><span class="line">  #26 = Utf8               SourceFile</span><br><span class="line">  #27 = Utf8               Singleton1.java</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: aconst_null</span><br><span class="line">         1: putstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.sunld.<span class="function">Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()Lcom/sunld/Singleton1;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">         <span class="number">3</span>: ifnonnull     <span class="number">35</span></span><br><span class="line">         6: ldc           #1                  // class com/sunld/Singleton1</span><br><span class="line">         <span class="number">8</span>: dup</span><br><span class="line">         <span class="number">9</span>: astore_0</span><br><span class="line">        <span class="number">10</span>: monitorenter</span><br><span class="line">        11: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">14</span>: ifnonnull     <span class="number">27</span></span><br><span class="line">        17: new           #1                  // class com/sunld/Singleton1</span><br><span class="line">        <span class="number">20</span>: dup</span><br><span class="line">        21: invokespecial #20                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        24: putstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">27</span>: aload_0</span><br><span class="line">        <span class="number">28</span>: monitorexit</span><br><span class="line">        <span class="number">29</span>: goto          <span class="number">35</span></span><br><span class="line">        <span class="number">32</span>: aload_0</span><br><span class="line">        <span class="number">33</span>: monitorexit</span><br><span class="line">        <span class="number">34</span>: athrow</span><br><span class="line">        35: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">38</span>: areturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">            <span class="number">11</span>    <span class="number">29</span>    <span class="number">32</span>   any</span><br><span class="line">            <span class="number">32</span>    <span class="number">34</span>    <span class="number">32</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">17</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">27</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">35</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">3</span></span><br><span class="line">        frame_type = <span class="number">252</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">27</span></span><br><span class="line">          locals = [ class java/lang/Class ]</span><br><span class="line">        frame_type = <span class="number">68</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Singleton1.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="饿汉模式（立即加载）"><a href="#饿汉模式（立即加载）" class="headerlink" title="饿汉模式（立即加载）"></a>饿汉模式（立即加载）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论:</p>
<ol>
<li>线程安全</li>
<li>在获取变量的过程中不能有其他操作，以防出现线程安全问题</li>
</ol>
</blockquote>
<h3 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ObjectStreamException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonInner</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner1</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> SingletonInner instance = <span class="keyword">new</span> SingletonInner();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInner1.instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 防止序列化之后变成多例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ObjectStreamException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">readResoObject</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInner1.instance;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++ ) &#123;</span><br><span class="line">			es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() </span><br><span class="line">							+  SingletonInner.getInstance());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举实现单例"><a href="#枚举实现单例" class="headerlink" title="枚举实现单例"></a>枚举实现单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//私有化构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">	<span class="comment">//定义一个静态枚举类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个枚举对象，该对象天生为单例</span></span><br><span class="line">        INSTANCE;</span><br><span class="line">		<span class="keyword">private</span> EnumSingleton enumSingleton;</span><br><span class="line">		<span class="comment">//私有化枚举的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        	enumSingleton = <span class="keyword">new</span> EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enumSingleton;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对外暴露一个获取EnumSingleton对象的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstnce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：<br>枚举可以解决反序列化会破坏单例的问题</p>
<blockquote>
<p>在枚举序列化的时候，Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。</p>
</blockquote>
</blockquote>
<h3 id="单例注册工厂"><a href="#单例注册工厂" class="headerlink" title="单例注册工厂"></a>单例注册工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonRegistryFactory</span> <span class="keyword">implements</span> <span class="title">FactoryInterface</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity = <span class="number">50</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonRegistryFactory singleRegistry = <span class="keyword">new</span> SingletonRegistryFactory();</span><br><span class="line">	<span class="comment">//保证线程安全</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String,Object&gt; singletonCache = Collections.synchronizedMap(<span class="keyword">new</span> LRULinkedHashMap&lt;String, Object&gt;(maxCapacity));</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 私有构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonRegistryFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonRegistryFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> singleRegistry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.singletonCache.get(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object sharedBean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.put(beanName, sharedBean);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.clear();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>客户职能通过Singleton的Instance操作访问一个Singleton的实例。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="对唯一实例的受控访问"><a href="#对唯一实例的受控访问" class="headerlink" title="对唯一实例的受控访问"></a>对唯一实例的受控访问</h3><p>因为Singleton类封装它的唯一实例，所以它可以严格的控制客户怎样以及何时访问它。</p>
<h3 id="缩小名空间"><a href="#缩小名空间" class="headerlink" title="缩小名空间"></a>缩小名空间</h3><p>Singleton模式是对全局变量的一种改进。它避免了那些存储唯一实例的全局变量污染名空间。</p>
<h3 id="允许对操作和表示的精化"><a href="#允许对操作和表示的精化" class="headerlink" title="允许对操作和表示的精化"></a>允许对操作和表示的精化</h3><p>Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时刻配置应用。</p>
<h3 id="允许可变数目的实例"><a href="#允许可变数目的实例" class="headerlink" title="允许可变数目的实例"></a>允许可变数目的实例</h3><p>这个模式使得你易于改变你的想法，并允许Singleton类的多个实例。此外，你可以用相同的方法来控制应用所使用的实例的数目。只允许访问Singleton实例的操作需要改变。</p>
<h3 id="比类操作更灵活"><a href="#比类操作更灵活" class="headerlink" title="比类操作更灵活"></a>比类操作更灵活</h3><p>另一种封装单件功能的方式是使用类操作。但这种语言技术难以改变设计你允许一个类有多个实例。此外，静态成员函数不是虚函数，因此子类不能多态的重定义它们。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>实例控制，保证实例的唯一性</li>
<li>灵活性，因为类控制了实例化过程，所以类可以灵活更改实例化过程。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>需要提供详细文档提供开发者使用，防止开发混乱</li>
<li>不能解决删除单个对象的问题，可以使用缓存管理技术管理单例对象</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="保证一个唯一的实例"><a href="#保证一个唯一的实例" class="headerlink" title="保证一个唯一的实例"></a>保证一个唯一的实例</h3><p>Singleton模式使得这个唯一实例是类的一般实例，但该类被写成只有一个实例能被创建。做到这一点的一个常用方法是将创建这个实例的操作隐藏在一个类操作后面，由它保证只有一个实例被创建。这个操作可以访问保存唯一实例的变量，而且它可以保证这个变量在返回值之前用这个唯一实例初始化。这种方法保证了单件在它的首次使用前被创建和使用。</p>
<h3 id="创建Singleton类的子类"><a href="#创建Singleton类的子类" class="headerlink" title="创建Singleton类的子类"></a>创建Singleton类的子类</h3><p>主要问题与其说是定义子类不如说是建立它的唯一实例，这样客户就可以使用它。事实上，指向单件实例的变量必须用子类的实例进行初始化。最简单的技术是在Singleton的Instance操作中决定你想使用的是哪一个单件。  </p>
<p>另一个选择Singleton的子类的方法是将Instance的实现从父类中分离出来，将它放入子类。<br>一个更灵活的方法是使用一个单件注册表（registry of singleton）。可能的Singleton类的集合不是由Instance定义的，Singleton类可以根据名字在一个众所周知的注册表中注册它们的单件实例。<br>这个注册表在字符串名字和单件之间建立映射。当Instance需要一个单件时，它参考注册表，根据名字请求单件。</p>
<h2 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h2><p>各种工具类的使用，建议使用缓存技术管理单例对象</p>
<h3 id="Spring框架中实现的例子"><a href="#Spring框架中实现的例子" class="headerlink" title="Spring框架中实现的例子"></a>Spring框架中实现的例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework.adapter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Singleton to publish a shared DefaultAdvisorAdapterRegistry instance.</span></span><br><span class="line"><span class="comment"> * 抽象化类使其不可实例化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DefaultAdvisorAdapterRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvisorAdapterRegistry</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Keep track of a single instance so we can return it to classes that request it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AdvisorAdapterRegistry instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the singleton &#123;<span class="doctag">@link</span> DefaultAdvisorAdapterRegistry&#125; instance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AdvisorAdapterRegistry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Reset the singleton &#123;<span class="doctag">@link</span> DefaultAdvisorAdapterRegistry&#125;, removing any</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> AdvisorAdapterRegistry#registerAdvisorAdapter(AdvisorAdapter) registered&#125;</span></span><br><span class="line"><span class="comment">	 * adapters.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h2><ol>
<li>Abstract Factory Pattern中的具体工厂</li>
<li>Builder Pattern中的指导者</li>
<li>Facade Pattern中的Facade参与者</li>
<li>Prototype Pattern中的原型管理器</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/codingmengmeng/p/9846131.html">DCL单例模式</a></li>
<li><a href="https://www.toutiao.com/i6821004595079152141/">被面试官虐过之后，他轻蔑的问我：你还说你了解单例模式吗?</a></li>
</ol>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之反射</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1587523711269.png" class title="反射知识点">

</div>

<a id="more"></a>

<h3 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h3><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。在Java中如果想获取到运行中对象的结构则需要引入反射的概念。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>在java中包括两种时期：编译期和运行期，对应的类型就是编译时类型和运行时类型。编译时类型由声明时的对象决定，运行时类型则由实际的对象类型决定（<strong>主要表现为行为，对于成员变量则编译时确认</strong>）。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中编译时类型为 Person，运行时类型为 Man。  </span></span><br><span class="line">Person p=<span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>
<p>由于编译时类型无法获取具体方法且程序运行过程中可能会接收外部传入的对象该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>反射API用来生成JVM中的类、接口或则对象的信息。  </p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>反射的核心类，可以获取类的属性，方法等信息。class的生成已经加载过程会在JVM章节中进行详细说明。</p>
<h5 id="RTTI（Run-Time-Type-Identification）运行时类型识别"><a href="#RTTI（Run-Time-Type-Identification）运行时类型识别" class="headerlink" title="RTTI（Run-Time Type Identification）运行时类型识别"></a>RTTI（Run-Time Type Identification）运行时类型识别</h5><p><font color="red">RTTI（Run-Time Type Identification）运行时类型识别</font>，其作用是在运行时识别一个对象的类型和类的信息，这里分两种：传统的”RRTI”,它假定我们在编译期已知道了所有类型(在没有反射机制创建和使用类对象时，一般都是编译期已确定其类型，如new对象时该类必须已定义好)，另外一种是反射机制，它允许我们在运行时发现和使用类型的信息。在Java中用来表示运行时类型信息的对应类就是Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中.</p>
<h5 id="Class的特点"><a href="#Class的特点" class="headerlink" title="Class的特点"></a>Class的特点</h5><ul>
<li>在java中万事万物都是对象的概念，使用Class类表示类的对象信息</li>
<li>通过关键字class标识的类，在内存中都会有一个与之对应的Class对象，用来描述具体的类型信息</li>
<li>Class类的构造函数是私有的，因此对应Class对象只能有JVM创建和加载</li>
<li>Class类的对象作用是运行时提供或获得某个对象的类型信息（反射的来源）</li>
<li>类加载器在类被第一次静态调用(比如一个静态方法，一个静态代码块或者new关键字调用构造器，注意contructors其实都是静态的)时会把那个对应的Class对象加载到内存中。</li>
</ul>
<h5 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h5><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1587536833908.png" class title="类与对象的关系">

</div>

<h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><p>Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</p>
<h5 id="class中获取field"><a href="#class中获取field" class="headerlink" title="class中获取field"></a>class中获取field</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field</td>
<td>getDeclaredField(String name)</td>
<td>获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td>
</tr>
<tr>
<td>Field[]</td>
<td>getDeclaredField()</td>
<td>获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td>
</tr>
<tr>
<td>Field</td>
<td>getField(String name)</td>
<td>获取指定name名称、具有public修饰的字段，包含继承字段</td>
</tr>
<tr>
<td>Field[]</td>
<td>getField()</td>
<td>获取修饰符为public的字段，包含继承字段</td>
</tr>
</tbody></table>
<h5 id="field中常用方法"><a href="#field中常用方法" class="headerlink" title="field中常用方法"></a>field中常用方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>set(Object obj, Object value)</td>
<td>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td>
</tr>
<tr>
<td>Object</td>
<td>get(Object obj)</td>
<td>返回指定对象上此 Field 表示的字段的值</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getType()</td>
<td>返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。</td>
</tr>
<tr>
<td>boolean</td>
<td>isEnumConstant()</td>
<td>如果此字段表示枚举类型的元素则返回 true；否则返回 false</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回一个描述此 Field（包括其一般类型）的字符串</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>返回此 Field 对象表示的字段的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getDeclaringClass()</td>
<td>返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td>
</tr>
<tr>
<td>void</td>
<td>setAccessible(boolean flag)</td>
<td>将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</td>
</tr>
</tbody></table>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</p>
<h5 id="class中的method方法"><a href="#class中的method方法" class="headerlink" title="class中的method方法"></a>class中的method方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Method</td>
<td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td>
</tr>
<tr>
<td>Method[]</td>
<td>getDeclaredMethod()</td>
<td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td>
</tr>
<tr>
<td>Method</td>
<td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td>
</tr>
<tr>
<td>Method[]</td>
<td>getMethods()</td>
<td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td>
</tr>
</tbody></table>
<h5 id="method常用的方法"><a href="#method常用的方法" class="headerlink" title="method常用的方法"></a>method常用的方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object</td>
<td>invoke(Object obj, Object… args)</td>
<td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getReturnType()</td>
<td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td>
</tr>
<tr>
<td>Type</td>
<td>getGenericReturnType()</td>
<td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td>
</tr>
<tr>
<td>Class&lt;?&gt;[]</td>
<td>getParameterTypes()</td>
<td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td>
</tr>
<tr>
<td>Type[]</td>
<td>getGenericParameterTypes()</td>
<td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td>
</tr>
<tr>
<td>boolean</td>
<td>isVarArgs()</td>
<td>判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回描述此 Method 的字符串，包括类型参数。</td>
</tr>
</tbody></table>
<h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><p>Java.lang.reflec 包中的类，表示类的构造方法。</p>
<h5 id="class中获取Constructor"><a href="#class中获取Constructor" class="headerlink" title="class中获取Constructor"></a>class中获取Constructor</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Class&lt;?&gt;</td>
<td>forName(String className)</td>
<td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td>
</tr>
<tr>
<td>Constructor<T></T></td>
<td>getConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>返回指定参数类型、具有public访问权限的构造函数对象</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[]</td>
<td>getConstructors()</td>
<td>返回所有具有public访问权限的构造函数的Constructor对象数组</td>
</tr>
<tr>
<td>Constructor<T></T></td>
<td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>返回指定参数类型、所有声明的（包括private）构造函数对象</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[]</td>
<td>getDeclaredConstructor()</td>
<td>返回所有声明的（包括private）构造函数对象</td>
</tr>
<tr>
<td>T</td>
<td>newInstance()</td>
<td>创建此 Class 对象所表示的类的一个新实例。</td>
</tr>
</tbody></table>
<h5 id="Constructor中的常用方法"><a href="#Constructor中的常用方法" class="headerlink" title="Constructor中的常用方法"></a>Constructor中的常用方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Class<T></T></td>
<td>getDeclaringClass()</td>
<td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td>
</tr>
<tr>
<td>Type[]</td>
<td>getGenericParameterTypes()</td>
<td>按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>以字符串形式返回此构造方法的名称。</td>
</tr>
<tr>
<td>Class&lt;?&gt;[]</td>
<td>getParameterTypes()</td>
<td>按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td>
</tr>
<tr>
<td>T</td>
<td>newInstance(Object… initargs)</td>
<td>使用此 Constructor对象表示的构造函数来创建新实例</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回描述此 Constructor 的字符串，其中包括类型参数。</td>
</tr>
</tbody></table>
<h4 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h4><p>参考《<a href="https://www.sunliaodong.cn/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/">JAVA注解</a>》</p>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><h5 id="class中的array"><a href="#class中的array" class="headerlink" title="class中的array"></a>class中的array</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Class&lt;?&gt;</td>
<td>getComponentType()</td>
<td>返回表示数组元素类型的 Class，即数组的类型</td>
</tr>
<tr>
<td>boolean</td>
<td>isArray()</td>
<td>判定此 Class 对象是否表示一个数组类。</td>
</tr>
</tbody></table>
<h5 id="array中常用的方法"><a href="#array中常用的方法" class="headerlink" title="array中常用的方法"></a>array中常用的方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Object</td>
<td>set(Object array, int index)</td>
<td>返回指定数组对象中索引组件的值。</td>
</tr>
<tr>
<td>static int</td>
<td>getLength(Object array)</td>
<td>以 int 形式返回指定数组对象的长度</td>
</tr>
<tr>
<td>static object</td>
<td>newInstance(Class&lt;?&gt; componentType, int… dimensions)</td>
<td>创建一个具有指定类型和维度的新数组。</td>
</tr>
<tr>
<td>static Object</td>
<td>newInstance(Class&lt;?&gt; componentType, int length)</td>
<td>创建一个具有指定的组件类型和长度的新数组。</td>
</tr>
<tr>
<td>static void</td>
<td>set(Object array, int index, Object value)</td>
<td>将指定数组对象中索引组件的值设置为指定的新值。</td>
</tr>
</tbody></table>
<h3 id="使用步骤：获取Class对象、调用对象方法"><a href="#使用步骤：获取Class对象、调用对象方法" class="headerlink" title="使用步骤：获取Class对象、调用对象方法"></a>使用步骤：获取Class对象、调用对象方法</h3><ol>
<li><p>获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。可以通过以下方式获取：</p>
<ul>
<li>调用对象的getClass()：(new Man()).getClass()</li>
<li>调用类的class属性：Man.class</li>
<li>使用Class.forName调用类的全路径（<strong>最安全，性能最好</strong>）：Class.forName(“com.sunld.Man”)</li>
</ul>
</li>
<li><p>调用 Class 类中的方法，既就是反射的使用阶段。</p>
</li>
<li><p>使用反射 API 来操作这些信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 获取 Man 类的 Class 对象</span></span><br><span class="line">         Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.sunld.Man&quot;</span>);</span><br><span class="line">         <span class="comment">// 获取 Man 类的所有方法信息</span></span><br><span class="line">         Method[] method = clazz.getDeclaredMethods();</span><br><span class="line">         <span class="keyword">for</span> (Method m : method) &#123;</span><br><span class="line">             System.out.println(m.toString());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 获取 Man 类的所有成员属性信息</span></span><br><span class="line">         Field[] field = clazz.getDeclaredFields();</span><br><span class="line">         <span class="keyword">for</span> (Field f : field) &#123;</span><br><span class="line">             System.out.println(f.toString());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 获取 Man 类的所有构造方法信息</span></span><br><span class="line">         Constructor[] constructor = clazz.getDeclaredConstructors();</span><br><span class="line">         <span class="keyword">for</span> (Constructor c : constructor) &#123;</span><br><span class="line">             System.out.println(c.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h3></li>
</ol>
<h4 id="Class对象的newInstance"><a href="#Class对象的newInstance" class="headerlink" title="Class对象的newInstance()"></a>Class对象的newInstance()</h4><p>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取 Man 类的 Class 对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.sunld.Man&quot;</span>);</span><br><span class="line"><span class="comment">//使用.newInstane 方法创建对象</span></span><br><span class="line">Man p=(Man) clazz.newInstance();</span><br></pre></td></tr></table></figure>
<h4 id="调用Constructor对象的newInstance"><a href="#调用Constructor对象的newInstance" class="headerlink" title="调用Constructor对象的newInstance()"></a>调用Constructor对象的newInstance()</h4><p>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz=Class.forName(<span class="string">&quot;com.sunld.Man&quot;</span>);  </span><br><span class="line"><span class="comment">//获取构造方法并创建对象</span></span><br><span class="line">Constructor c=clazz.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//创建对象并设置属性</span></span><br><span class="line">Man m=(Man) c.newInstance(<span class="string">&quot;男人&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h5 id="Java的安全模型"><a href="#Java的安全模型" class="headerlink" title="Java的安全模型"></a>Java的安全模型</h5><p>java运行在jvm中，不与外部直接联系，java的安全模型包括：字节码验证器、类加载器、安全管理器、访问控制器等一系列的组件。java通过反射可以处理private方法和属性，说明它绕过了访问控制器。它其实是Java本身为了某种目的而留下的类似于“后门”的东西，它的原理其实是关闭访问安全检查。</p>
<h5 id="Java中访问控制的实现"><a href="#Java中访问控制的实现" class="headerlink" title="Java中访问控制的实现"></a>Java中访问控制的实现</h5><p>Field、Method和Constructor类，它们都有一个共同的父类AccessibleObject 。AccessibleObject 有一个公共方法：void setAccessible(boolean flag)。正是这个方法，让我们可以改变动态的打开或者关闭访问安全检查，从而访问到原本是private的方法或域。另外，访问安全检查是一件比较耗时的操作，关闭它反射的性能也会有较大提升。</p>
<h5 id="Java中的作用域（访问控制）"><a href="#Java中的作用域（访问控制）" class="headerlink" title="Java中的作用域（访问控制）"></a>Java中的作用域（访问控制）</h5><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1587540118382.png" class title="Java中的作用域">

</div>

<h3 id="ClassUtils"><a href="#ClassUtils" class="headerlink" title="ClassUtils"></a>ClassUtils</h3><p>在spring的源码中提供了Class反射使用到的常用封装，可以参考修改或者直接使用。</p>
<h3 id="自定义ClassUtils"><a href="#自定义ClassUtils" class="headerlink" title="自定义ClassUtils"></a>自定义ClassUtils</h3><p><a href="https://github.com/sld880311/Architect-Growth-Manual/tree/master/docs/book/source/ClassUtils.java">ClassUtils代码地址</a></p>
<h3 id="内省Introspector"><a href="#内省Introspector" class="headerlink" title="内省Introspector"></a>内省Introspector</h3><p>一种用于处理javabean的API，提高Java反射的效率</p>
<h4 id="内省Introspector类结构"><a href="#内省Introspector类结构" class="headerlink" title="内省Introspector类结构"></a>内省Introspector类结构</h4><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1589936907736.png" class title="内省Introspector类结构">

</div>

<ol>
<li>Introspector：获取JavaBean的BeanInfo</li>
<li>BeanInfo：通过getPropertyDescriptors 方法和 getMethodDescriptors 方法可以拿到 javaBean 的字段信息列表和 getter 和 setter 方法信息列表</li>
<li>PropertyDescriptors 可以根据字段直接获得该字段的 getter 和 setter 方法。</li>
<li>PropertyDescriptor类表示JavaBean类通过存储器导出一个属性。主要方法：<ul>
<li>getPropertyType()，获得属性的Class对象</li>
<li>getReadMethod()，获得用于读取属性值的方法；getWriteMethod()，获得用于写入属性值的方法;</li>
<li>hashCode()，获取对象的哈希值;</li>
<li>setReadMethod(Method readMethod)，设置用于读取属性值的方法;</li>
<li>setWriteMethod(Method writeMethod)，设置用于写入属性值的方法。</li>
</ul>
</li>
<li>MethodDescriptors 可以获得方法的元信息，比如方法名，参数个数，参数字段类型等。</li>
</ol>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIntrospector</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">findUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">findUser2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser2:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">findUser3</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser3:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">findUser4</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser4:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IntrospectionException </span>&#123;</span><br><span class="line">        TestIntrospector t = <span class="keyword">new</span> TestIntrospector();</span><br><span class="line">        User u = t.n<span class="function">ew <span class="title">User</span><span class="params">()</span></span>;</span><br><span class="line">        u.setAge(<span class="number">20</span>);</span><br><span class="line">        u.setUserName(<span class="string">&quot;dfafda&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取整个Bean的信息</span></span><br><span class="line">        <span class="comment">// 在Object类时候停止检索，可以选择在任意一个父类停止</span></span><br><span class="line">        BeanInfo beanInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取某个对象的BeanInfo信息，并且可以指定上限</span></span><br><span class="line">            beanInfo = Introspector.getBeanInfo(User.class, Object.class);</span><br><span class="line">            System.out.println(beanInfo);</span><br><span class="line">            System.out.println(<span class="string">&quot;所有属性描述：&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取所有的属性描述</span></span><br><span class="line">            PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor propertyDescriptor : pds) &#123;</span><br><span class="line">                System.out.println(propertyDescriptor.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有方法描述：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (MethodDescriptor methodDescriptor : beanInfo.getMethodDescriptors()) &#123;</span><br><span class="line">                System.out.println(methodDescriptor.getName());</span><br><span class="line">                <span class="keyword">if</span>(methodDescriptor.getName().startsWith(<span class="string">&quot;get&quot;</span>))&#123;</span><br><span class="line">                    Method method = methodDescriptor.getMethod();</span><br><span class="line">                    System.out.println(method.invoke(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 自定义</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String propertyName = <span class="string">&quot;userName&quot;</span>;</span><br><span class="line">            PropertyDescriptor namePd = <span class="keyword">new</span> PropertyDescriptor(propertyName, User.class);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;名字：&quot;</span> + namePd.getReadMethod().invoke(u));</span><br><span class="line">            namePd.getWriteMethod().invoke(u, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;名字：&quot;</span> + namePd.getReadMethod().invoke(u));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="org-springframework-beans-BeanUtils"><a href="#org-springframework-beans-BeanUtils" class="headerlink" title="org.springframework.beans.BeanUtils"></a>org.springframework.beans.BeanUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy the property values of the given source bean into the given target bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: The source and target classes do not have to match or even be derived</span></span><br><span class="line"><span class="comment"> * from each other, as long as the properties match. Any bean properties that the</span></span><br><span class="line"><span class="comment"> * source bean exposes but the target bean does not will silently be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the source bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target the target bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> editable the class (or interface) to restrict property setting to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ignoreProperties array of property names to ignore</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the copying failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanWrapper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target, <span class="meta">@Nullable</span> Class&lt;?&gt; editable,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> String... ignoreProperties)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(source, <span class="string">&quot;Source must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(target, <span class="string">&quot;Target must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取目标对象的class</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt; actualEditable = target.getClass();</span><br><span class="line">	<span class="keyword">if</span> (editable != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!editable.isInstance(target)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Target class [&quot;</span> + target.getClass().getName() +</span><br><span class="line">					<span class="string">&quot;] not assignable to Editable class [&quot;</span> + editable.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		actualEditable = editable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取目标对象的属性信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理忽略属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;String&gt; ignoreList = (ignoreProperties != <span class="keyword">null</span> ? Arrays.asList(ignoreProperties) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (PropertyDescriptor targetPd : targetPds) &#123;</span><br><span class="line">		Method writeMethod = targetPd.getWriteMethod();</span><br><span class="line">		<span class="keyword">if</span> (writeMethod != <span class="keyword">null</span> &amp;&amp; (ignoreList == <span class="keyword">null</span> || !ignoreList.contains(targetPd.getName()))) &#123;</span><br><span class="line">			PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</span><br><span class="line">			<span class="keyword">if</span> (sourcePd != <span class="keyword">null</span>) &#123;</span><br><span class="line">				Method readMethod = sourcePd.getReadMethod();</span><br><span class="line">				<span class="keyword">if</span> (readMethod != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						ClassUtils.isAssignable(writeMethod.getParameterTypes()[<span class="number">0</span>], readMethod.getReturnType())) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">							readMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						Object value = readMethod.invoke(source);</span><br><span class="line">						<span class="keyword">if</span> (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">							writeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						writeMethod.invoke(target, value);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(</span><br><span class="line">								<span class="string">&quot;Could not copy property &#x27;&quot;</span> + targetPd.getName() + <span class="string">&quot;&#x27; from source to target&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="instanceof和isInstance区别"><a href="#instanceof和isInstance区别" class="headerlink" title="instanceof和isInstance区别"></a>instanceof和isInstance区别</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0pky">用法</th>
    <th class="tg-0pky">功能</th>
    <th class="tg-0pky">对象本身</th>
    <th class="tg-0pky">父类/接口</th>
    <th class="tg-0pky">Object</th>
    <th class="tg-0lax">null</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">obj instanceof class</td>
    <td class="tg-0pky">判断对象是否是某个类型</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0lax">false</td>
  </tr>
  <tr>
    <td class="tg-0pky">class.isInstance(obj)</td>
    <td class="tg-0pky">判断对象是否可以转换为这个类</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0lax">false</td>
  </tr>
</tbody>
</table>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstanceClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestInstanceClass t = <span class="keyword">new</span> TestInstanceClass();</span><br><span class="line"></span><br><span class="line">        B b = t.n<span class="function">ew <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        A a = t.n<span class="function">ew <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">        A ba = t.n<span class="function">ew <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1------------&quot;</span>);</span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> B);<span class="comment">// true</span></span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> A);<span class="comment">// true</span></span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> Object);<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2------------&quot;</span>);</span><br><span class="line">        System.out.println(b.getClass().isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.getClass().isInstance(a));<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3------------&quot;</span>);</span><br><span class="line">        System.out.println(a.getClass().isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.getClass().isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.getClass().isInstance(<span class="keyword">null</span>));<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4------------&quot;</span>);</span><br><span class="line">        System.out.println(A.class.isInstance(a));<span class="comment">// true</span></span><br><span class="line">        System.out.println(A.class.isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(A.class.isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;5------------&quot;</span>);</span><br><span class="line">        System.out.println(B.class.isInstance(a));<span class="comment">// false</span></span><br><span class="line">        System.out.println(B.class.isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(B.class.isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;6------------&quot;</span>);</span><br><span class="line">        System.out.println(Object.class.isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(Object.class.isInstance(<span class="keyword">null</span>));<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/javazejian/article/details/70768369">深入理解Java类型信息(Class对象)与反射机制</a></li>
<li>《Java并发编程的艺术》</li>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://www.cnblogs.com/greatfish/p/6096038.html">Java中instanceof和isInstance区别详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之异常</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中任务或方法的运行，要不就是正常执行完成(包括虚拟机退出，比如<code>System.exit()</code>)，要不就是出现异常终止(<code>Throwable</code>)。本章节重点讲解在Java中对异常的处理。当程序出现异常之后，Java会抛出一个封装好的异常堆栈信息，并且终止当前的方法，异常处理机制会将代码执行交给异常处理器。整体结构如下图所示：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587714125412.png" class title="Java异常架构图">

</div>

<a id="more"></a>

<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* The &#123;<span class="meta">@code</span> Throwable&#125; <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">the</span> <span class="title">superclass</span> <span class="title">of</span> <span class="title">all</span> <span class="title">errors</span> <span class="title">and</span></span></span><br><span class="line"><span class="class">* <span class="title">exceptions</span> <span class="title">in</span> <span class="title">the</span> <span class="title">Java</span> <span class="title">language</span>. <span class="title">Only</span> <span class="title">objects</span> <span class="title">that</span> <span class="title">are</span> <span class="title">instances</span> <span class="title">of</span> <span class="title">this</span></span></span><br><span class="line"><span class="class">* <span class="title">class</span> (<span class="title">or</span> <span class="title">one</span> <span class="title">of</span> <span class="title">its</span> <span class="title">subclasses</span>) <span class="title">are</span> <span class="title">thrown</span> <span class="title">by</span> <span class="title">the</span> <span class="title">Java</span> <span class="title">Virtual</span> <span class="title">Machine</span> <span class="title">or</span></span></span><br><span class="line"><span class="class">* <span class="title">can</span> <span class="title">be</span> <span class="title">thrown</span> <span class="title">by</span> <span class="title">the</span> <span class="title">Java</span> </span>&#123;<span class="meta">@code</span> <span class="keyword">throw</span>&#125; statement. Similarly, only</span><br><span class="line">* <span class="keyword">this</span> <span class="class"><span class="keyword">class</span> <span class="title">or</span> <span class="title">one</span> <span class="title">of</span> <span class="title">its</span> <span class="title">subclasses</span> <span class="title">can</span> <span class="title">be</span> <span class="title">the</span> <span class="title">argument</span> <span class="title">type</span> <span class="title">in</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">* </span>&#123;<span class="meta">@code</span> <span class="keyword">catch</span>&#125; clause.</span><br></pre></td></tr></table></figure>
<p>在Java中<code>Throwable</code>是所有异常类的父类，只有该类的子类才能被用于Java异常处理。该类的唯一两个子类是<code>Error</code>和<code>Exception</code>。</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* An &#123;<span class="meta">@code</span> Error&#125; is a subclass of &#123;<span class="meta">@code</span> Throwable&#125;</span><br><span class="line">* that indicates serious problems that a reasonable application</span><br><span class="line">* should not <span class="keyword">try</span> to <span class="keyword">catch</span>. Most such errors are abnormal conditions.</span><br><span class="line">* The &#123;<span class="meta">@code</span> ThreadDeath&#125; error, though a <span class="string">&quot;normal&quot;</span> condition,</span><br><span class="line">* is also a subclass of &#123;<span class="meta">@code</span> Error&#125; because most applications</span><br><span class="line">* should not <span class="keyword">try</span> to <span class="keyword">catch</span> it.</span><br><span class="line">* &lt;p&gt;</span><br><span class="line">* A method is not required to declare in its &#123;<span class="meta">@code</span> <span class="keyword">throws</span>&#125;</span><br><span class="line">* clause any subclasses of &#123;<span class="meta">@code</span> Error&#125; that might be thrown</span><br><span class="line">* during the execution of the method but not caught, since these</span><br><span class="line">* errors are abnormal conditions that should never occur.</span><br><span class="line">*</span><br><span class="line">* That is, &#123;<span class="meta">@code</span> Error&#125; and its subclasses are regarded as unchecked</span><br><span class="line">* exceptions <span class="keyword">for</span> the purposes of compile-time checking of exceptions.</span><br></pre></td></tr></table></figure>
<p>Error在正常情况下不应该出现的异常（一般是JVM本身产生的异常，比如JVM运行错误、<code>NoClassDefFoundError</code>或<code>OutOfMemoryError</code>），而且不建议应用程序对其进行捕获。Error被定义为非检查异常。Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。  包括以下类：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587719292555.png" class title="Java Error直接之类">

</div>

<h3 id="Exception（RuntimeException、CheckedException）"><a href="#Exception（RuntimeException、CheckedException）" class="headerlink" title="Exception（RuntimeException、CheckedException）"></a>Exception（RuntimeException、CheckedException）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* &lt;p&gt;The <span class="class"><span class="keyword">class</span> </span>&#123;<span class="meta">@code</span> Exception&#125; and any subclasses that are not also</span><br><span class="line">* subclasses of &#123;<span class="meta">@link</span> RuntimeException&#125; are &lt;em&gt;checked</span><br><span class="line">* exceptions&lt;/em&gt;.  Checked exceptions need to be declared in a</span><br><span class="line">* method or constructor<span class="string">&#x27;s &#123;@code throws&#125; clause if they can be thrown</span></span><br><span class="line"><span class="string">* by the execution of the method or constructor and propagate outside</span></span><br><span class="line"><span class="string">* the method or constructor boundary.</span></span><br></pre></td></tr></table></figure>
<p><code>Exception</code>用于处理应用程序方面的异常定义和处理。分为<code>RuntimeException</code>和<code>CheckedException</code>(非<code>RuntimeException</code>)。检查类异常需要在方法或者构造器中明确的进行处理（throws）。</p>
<h4 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* &#123;<span class="meta">@code</span> RuntimeException&#125; is the superclass of those</span><br><span class="line">* exceptions that can be thrown during the normal operation of the</span><br><span class="line">* Java Virtual Machine.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt;&#123;<span class="meta">@code</span> RuntimeException&#125; and its subclasses are &lt;em&gt;unchecked</span><br><span class="line">* exceptions&lt;/em&gt;.  Unchecked exceptions do &lt;em&gt;not&lt;/em&gt; need to be</span><br><span class="line">* declared in a method or constructor<span class="string">&#x27;s &#123;@code throws&#125; clause if they</span></span><br><span class="line"><span class="string">* can be thrown by the execution of the method or constructor and</span></span><br><span class="line"><span class="string">* propagate outside the method or constructor boundary.</span></span><br></pre></td></tr></table></figure>
<p><code>RuntimeException</code>是在JVM的正常操作期间可以抛出异常的超类。该类都是未检查异常类，未检查异常不需要在方法或构造函数中进行throws，如果他们可以通过该方法或构造函数的执行被抛出和方法或构造边界之外传播。所以通常用不着捕获RuntimeException，但在自己的封装里，也许仍然要选择抛出一部分RuntimeException。常见的类包括：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587718395409.png" class title="RuntimeException直接之类">

</div>

<h4 id="CheckedException"><a href="#CheckedException" class="headerlink" title="CheckedException"></a>CheckedException</h4><p>Exception下除<code>RuntimeException</code>和<code>Error</code>之外的异常类都是<code>CheckedException</code>。它们都在java.lang库内部定义。Java编译器要求程序必须捕获或声明抛出这种异常。常用的类包括： I/O 错误导致的 IOException、SQLException。这类异常的表现形式一般为：</p>
<ol>
<li>试图在文件尾部读取数据  </li>
<li>试图打开一个错误格式的 URL  </li>
<li>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</li>
</ol>
<h4 id="CheckedException与RuntimeException的区别"><a href="#CheckedException与RuntimeException的区别" class="headerlink" title="CheckedException与RuntimeException的区别"></a>CheckedException与RuntimeException的区别</h4><ol>
<li>CheckedException需要显示的处理，throws；RuntimeException不需要。</li>
<li>RuntimeException运行期间的错误，一般都是代码bug；CheckedException编译期间的错误，一般是外部错误。Java 编译器会强制程序去捕获此类异常（ try catch）。</li>
</ol>
<h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><h3 id="抛出"><a href="#抛出" class="headerlink" title="抛出"></a>抛出</h3><p>当程序中出现异常时，如果不进行具体处理，可以使用<code>throw</code>、<code>throws</code> 、系统自动抛出三种方式进行异常抛出处理。</p>
<h4 id="throw与throws的区别"><a href="#throw与throws的区别" class="headerlink" title="throw与throws的区别"></a>throw与throws的区别</h4><ol>
<li>位置不同：throws在函数或构造器定义中，throw是函数或构造器内</li>
<li>功能不同：throws用于异常声明，让调用者知道可能出现的异常；throw抛出异常，业务处理终止，抛出到上层业务</li>
<li>含义不同：throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。  throw需要配合throws使用。</li>
<li>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li>
</ol>
<h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>如果程序中需要进行异常的特殊处理或者进行异常转换，则需要使用try、catch进行处理。</p>
<h3 id="处理的伪代码"><a href="#处理的伪代码" class="headerlink" title="处理的伪代码"></a>处理的伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionType e)&#123;</span><br><span class="line"> <span class="comment">//此违例类型的控制代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"> <span class="comment">//清除回收等工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先执行try中包含的代码块，如果遇到执行错误，程序掷出（throw）一特定类型的违例，你捕捉到此违例并转而执行catch中的违例控制代码。最后，无论程序是否产生违例都必须执行finally中的代码，其主要为一些变量清除、资源回收（1）等工作。</p>
<h2 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h2><ol>
<li>重写一个方法时，只能产生已在方法的基础类版本中定义的异常。</li>
<li>重写的方法可以抛出父类方法所抛出的异常或它的子类型</li>
<li>重写的方法可以不用抛出父类方法所抛出的异常</li>
<li>重写的方法不可以抛出异常如果父类方法没有抛出异常</li>
<li>对异常的限制并不适用于构建器。</li>
</ol>
<h2 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h2><p>掷”出一个异常后，异常控制系统会按当初编写的顺序搜索“最接近”的控制器。一旦找到相符的控制器，就认为异常已得到控制，不再进行更多的搜索工作。在异常和它的控制器之间，并不需要非常精确的匹配。一个衍生类对象可与基础类的一个异常控制器相配，<strong>即我们在写代码时，将子类写在前面</strong>。</p>
<h2 id="JVM中处理异常的原理"><a href="#JVM中处理异常的原理" class="headerlink" title="JVM中处理异常的原理"></a>JVM中处理异常的原理</h2><h3 id="异常的执行顺序"><a href="#异常的执行顺序" class="headerlink" title="异常的执行顺序"></a>异常的执行顺序</h3><p>1、new一个异常对象<br>2、终止当前的执行程序。<br>3、弹出异常对象的引用。<br>4、异常处理机制接管被终止的执行程序。<br>5、寻找一个恰当的地点（异常处理程序）继续执行程序。  </p>
<h3 id="异常处理的理论模型"><a href="#异常处理的理论模型" class="headerlink" title="异常处理的理论模型"></a>异常处理的理论模型</h3><ol>
<li><strong>终止模型</strong>：这种模型将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行，一旦异常抛出错误就意味着世界末日，意味着死亡，意味着GG</li>
<li><strong>恢复模型</strong>：异常处理程序发现了错误，并且修复了错误然后重新调用出问题的方法，并且认为第二次调用该方法会成功。通常可以将try块放入while循环中，不断执行方法，直到得到满意的结果。</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="异常信息构建：Throwable"><a href="#异常信息构建：Throwable" class="headerlink" title="异常信息构建：Throwable"></a>异常信息构建：Throwable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a new throwable with &#123;<span class="doctag">@code</span> null&#125; as its detail message.</span></span><br><span class="line"><span class="comment">* The cause is not initialized, and may subsequently be initialized by a</span></span><br><span class="line"><span class="comment">* call to &#123;<span class="doctag">@link</span> #initCause&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;The &#123;<span class="doctag">@link</span> #fillInStackTrace()&#125; method is called to initialize</span></span><br><span class="line"><span class="comment">* the stack trace data in the newly created throwable.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Throwable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 填充执行过程中的堆栈信息，</span></span><br><span class="line"><span class="comment">    * 此方法在Throwable对象中记录当前线程的栈帧的状态信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fillInStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="核心代码：fillInStackTrace"><a href="#核心代码：fillInStackTrace" class="headerlink" title="核心代码：fillInStackTrace"></a>核心代码：fillInStackTrace</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A shared value for an empty stack.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StackTraceElement[] UNASSIGNED_STACK = <span class="keyword">new</span> StackTraceElement[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The stack trace, as returned by &#123;<span class="doctag">@link</span> #getStackTrace()&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The field is initialized to a zero-length array.  A &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">* null&#125; value of this field indicates subsequent calls to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #setStackTrace(StackTraceElement[])&#125; and &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #fillInStackTrace()&#125; will be be no-ops.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> StackTraceElement[] stackTrace = UNASSIGNED_STACK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Fills in the execution stack trace. This method records within this</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> Throwable&#125; object information about the current state of</span></span><br><span class="line"><span class="comment">* the stack frames for the current thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the stack trace of this &#123;<span class="doctag">@code</span> Throwable&#125; &#123;<span class="doctag">@linkplain</span></span></span><br><span class="line"><span class="comment">* Throwable#Throwable(String, Throwable, boolean, boolean) is not</span></span><br><span class="line"><span class="comment">* writable&#125;, calling this method has no effect.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  a reference to this &#123;<span class="doctag">@code</span> Throwable&#125; instance.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>     java.lang.Throwable#printStackTrace()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackTrace != <span class="keyword">null</span> ||</span><br><span class="line">        backtrace != <span class="keyword">null</span> <span class="comment">/* Out of protocol state */</span> ) &#123;</span><br><span class="line">        fillInStackTrace(<span class="number">0</span>);</span><br><span class="line">        stackTrace = UNASSIGNED_STACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 底层本地方法获取当前线程的堆栈信息</span></span><br><span class="line"><span class="comment">* 2. 执行非常耗时。</span></span><br><span class="line"><span class="comment">* 3.如果只是关系异常的传播性质，而不关心异常的堆栈信息，可重写fillInStackTrace()方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> Throwable <span class="title">fillInStackTrace</span><span class="params">(<span class="keyword">int</span> dummy)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="StackTraceElement"><a href="#StackTraceElement" class="headerlink" title="StackTraceElement"></a>StackTraceElement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An element in a stack trace, as returned by &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Throwable#getStackTrace()&#125;.  Each element represents a single stack frame.</span></span><br><span class="line"><span class="comment"> * All stack frames except for the one at the top of the stack represent</span></span><br><span class="line"><span class="comment"> * a method invocation.  The frame at the top of the stack represents the</span></span><br><span class="line"><span class="comment"> * execution point at which the stack trace was generated.  Typically,</span></span><br><span class="line"><span class="comment"> * this is the point at which the throwable corresponding to the stack trace</span></span><br><span class="line"><span class="comment"> * was created.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Bloch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTraceElement</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Normally initialized by VM (public constructor added in 1.5)</span></span><br><span class="line">    <span class="keyword">private</span> String declaringClass;<span class="comment">// 方法的类名</span></span><br><span class="line">    <span class="keyword">private</span> String methodName; <span class="comment">//方法名</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;<span class="comment">//文件名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>    lineNumber;<span class="comment">// 调用的行数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a stack trace element representing the specified execution</span></span><br><span class="line"><span class="comment">     * point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> declaringClass the fully qualified name of the class containing</span></span><br><span class="line"><span class="comment">     *        the execution point represented by the stack trace element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName the name of the method containing the execution point</span></span><br><span class="line"><span class="comment">     *        represented by the stack trace element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName the name of the file containing the execution point</span></span><br><span class="line"><span class="comment">     *         represented by the stack trace element, or &#123;<span class="doctag">@code</span> null&#125; if</span></span><br><span class="line"><span class="comment">     *         this information is unavailable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lineNumber the line number of the source line containing the</span></span><br><span class="line"><span class="comment">     *         execution point represented by this stack trace element, or</span></span><br><span class="line"><span class="comment">     *         a negative number if this information is unavailable. A value</span></span><br><span class="line"><span class="comment">     *         of -2 indicates that the method containing the execution point</span></span><br><span class="line"><span class="comment">     *         is a native method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> declaringClass&#125; or</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> methodName&#125; is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackTraceElement</span><span class="params">(String declaringClass, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             String fileName, <span class="keyword">int</span> lineNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.declaringClass = Objects.requireNonNull(declaringClass, <span class="string">&quot;Declaring class is null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.methodName     = Objects.requireNonNull(methodName, <span class="string">&quot;Method name is null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.fileName       = fileName;</span><br><span class="line">        <span class="keyword">this</span>.lineNumber     = lineNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="违例的作用"><a href="#违例的作用" class="headerlink" title="违例的作用"></a>违例的作用</h3><p>1)监视程序中的异常情况<br>2)当异常情况发生时，将控制权交给你自己编写的违例控制代码  </p>
<h3 id="使用准则"><a href="#使用准则" class="headerlink" title="使用准则"></a>使用准则</h3><p>(1) 解决问题并再次调用造成违例的方法。<br>(2) 平息事态的发展，并在不重新尝试方法的前提下继续。<br>(3) 计算另一些结果，而不是希望方法产生的结果。<br>(4) 在当前环境中尽可能解决问题，以及将相同的违例重新“掷”出一个更高级的环境。<br>(5) 在当前环境中尽可能解决问题，以及将不同的违例重新“掷”出一个更高级的环境。<br>(6) 中止程序执行。<br>(7) 简化编码。若违例方案使事情变得更加复杂，那就会令人非常烦恼，不如不用。<br>(8) 使自己的库和程序变得更加安全。这既是一种“短期投资”（便于调试），也是一种“长期投资”（改善应用程序的健壮性）  </p>
<p><strong>异常的处理包括业务类处理（给于用户更好的友好提示）和bug类处理（链条式异常信息输出，方便运维人员或研发人员快速定位问题）。</strong></p>
<h3 id="异常相关的关键字"><a href="#异常相关的关键字" class="headerlink" title="异常相关的关键字"></a>异常相关的关键字</h3><p><code>try，catch，throw，throws，finally</code></p>
<h3 id="finally的使用总结"><a href="#finally的使用总结" class="headerlink" title="finally的使用总结"></a>finally的使用总结</h3><h4 id="finally不被执行的场景"><a href="#finally不被执行的场景" class="headerlink" title="finally不被执行的场景"></a>finally不被执行的场景</h4><ol>
<li>与try配套使用，所以只有try执行finally才会执行</li>
<li>如果try中执行System.exit(0);或jvm异常终止，则否finally不会被执行</li>
</ol>
<h4 id="finally语句在return语句执行之后return返回之前执行"><a href="#finally语句在return语句执行之后return返回之前执行" class="headerlink" title="finally语句在return语句执行之后return返回之前执行"></a>finally语句在return语句执行之后return返回之前执行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test1());<span class="comment">//4.输出100</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>; </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test11());<span class="comment">// 4.after return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">           <span class="keyword">return</span> test12();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//3</span></span><br><span class="line">       &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;return statement&quot;</span>);<span class="comment">//2</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;after return&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="finally块中的return语句会覆盖try块中的return返回"><a href="#finally块中的return语句会覆盖try块中的return返回" class="headerlink" title="finally块中的return语句会覆盖try块中的return返回"></a>finally块中的return语句会覆盖try块中的return返回</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test2());<span class="comment">//200</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这说明finally里的return直接返回了，就不管try中是否还有返回语句.</p>
<h4 id="finally语句中没有return语句覆盖返回值，返回值的变化"><a href="#finally语句中没有return语句覆盖返回值，返回值的变化" class="headerlink" title="finally语句中没有return语句覆盖返回值，返回值的变化"></a>finally语句中没有return语句覆盖返回值，返回值的变化</h4><p>用例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test3());<span class="comment">//4:100</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">            b = <span class="number">150</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest6</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(getMap().get(<span class="string">&quot;KEY&quot;</span>).toString());<span class="comment">//FINALLY</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;INIT&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;TRY&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;CATCH&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;FINALLY&quot;</span>);</span><br><span class="line">            map = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="try块里的return语句在异常的情况下不会被执行"><a href="#try块里的return语句在异常的情况下不会被执行" class="headerlink" title="try块里的return语句在异常的情况下不会被执行"></a>try块里的return语句在异常的情况下不会被执行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest5</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test4());<span class="comment">//5:204</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            b = b / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            b += <span class="number">15</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//4</span></span><br><span class="line">            &#125;</span><br><span class="line">            b += <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样"><a href="#当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样" class="headerlink" title="当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样"></a>当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest7</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test5());<span class="comment">//5:35</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            b = b /<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">15</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//4</span></span><br><span class="line">            &#125;</span><br><span class="line">            b += <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//return b;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>finally语句在return语句执行之后return返回之前执行</li>
<li>finally块中的return语句会覆盖try块中的return返回</li>
<li>如果finally语句中没有return语句,且覆盖了返回值，那么原来的返回值原始类型则不覆盖，对象类型则覆盖</li>
<li>try块里的return语句在异常的情况下不会被执行</li>
<li>当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。</li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h4 id="自定义异常的优点"><a href="#自定义异常的优点" class="headerlink" title="自定义异常的优点"></a>自定义异常的优点</h4><ol>
<li>统一了对外异常展示的方式。</li>
<li>方便框架统一处理<code>@ControllerAdvice</code></li>
<li>定义业务类异常</li>
<li>隐藏底层的异常，这样更安全，异常信息也更加的直观</li>
</ol>
<h4 id="自定义异常的注意事项"><a href="#自定义异常的注意事项" class="headerlink" title="自定义异常的注意事项"></a>自定义异常的注意事项</h4><ol>
<li>所有异常都必须是 Throwable 的子类。</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ol>
<h3 id="异常捕获的陷阱"><a href="#异常捕获的陷阱" class="headerlink" title="异常捕获的陷阱"></a>异常捕获的陷阱</h3><h4 id="正确关闭资源的方式"><a href="#正确关闭资源的方式" class="headerlink" title="正确关闭资源的方式"></a>正确关闭资源的方式</h4><p>对于物理资源（数据库连接、网络连接、磁盘文件），JVM是不会进行处理的，因为JVM属于Java内存管理的一部分，只负责回收堆内存中分配的空间。<br><strong>关闭资源：</strong></p>
<ol>
<li>必须要保证一定执行，一次要放在finally中完成</li>
<li>必须保证被关闭的资源不为空</li>
<li>保证资源之间的关闭操作互不影响</li>
</ol>
<h4 id="finally块的陷阱"><a href="#finally块的陷阱" class="headerlink" title="finally块的陷阱"></a>finally块的陷阱</h4><h5 id="finally块的执行规则"><a href="#finally块的执行规则" class="headerlink" title="finally块的执行规则"></a>finally块的执行规则</h5><ol>
<li><p>如果调用了System.exit(0);finally将不再执行，</p>
</li>
<li><p>当System.exit(0)被执行时，虚拟机在退出之前要完成两项工作：</p>
<ol>
<li>执行系统中注册的所有钩子</li>
<li>如果程序调用了System.runFinalizersOnExit(true);那么JVM会对所有未结束的对象调用Finalize</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h5 id="finally块和方法返回值"><a href="#finally块和方法返回值" class="headerlink" title="finally块和方法返回值"></a>finally块和方法返回值</h5></li>
</ol>
<p>当Java程序执行try、catch遇到return语句时，return语句会导致该方法会立即结束；系统执行return语句之后并不会立即结束该方法，而是去寻找异常处理过程中是否有finally，如果有则会执行finally代码块，在执行finally块时如果该块中没有return则会直接返回到try中的return，结束该方法，如果有则会直接返回finally中的数据，而不会调用try中的return。</p>
<h4 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a>catch的用法</h4><ol>
<li>catch的顺序: 先处理小异常在处理大异常</li>
<li>不要用catch代替流程控制</li>
<li>只能catch可能抛出的异常(减少大范围catch异常)</li>
<li>实际的修复<ol>
<li>如果程序知道如何修复这个异常，应该在catch中修复这个异常，修复之后可以再次调用这个方法；</li>
<li>如果程序不知道如何修复并且系统也没有进行任何修复，千万不要再次调用可能导致该异常的方法。（造成内存溢出），不要在finally块中调用可能引起异常的方法，可能会导致无限递归、内存溢出</li>
</ol>
</li>
</ol>
<h4 id="继承得到的异常"><a href="#继承得到的异常" class="headerlink" title="继承得到的异常"></a>继承得到的异常</h4><ol>
<li>子类重写父类方法时，不能抛出比父类方法类型更多、范围更大的异常</li>
<li>抛出的异常只能是父类异常中的交集，否则不能通过编译。</li>
</ol>
<h3 id="异常的处理流程"><a href="#异常的处理流程" class="headerlink" title="异常的处理流程"></a>异常的处理流程</h3><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587727204173.png" class title="异常处理流程">

</div>

<h3 id="异常拦截"><a href="#异常拦截" class="headerlink" title="异常拦截"></a>异常拦截</h3><p>系统的异常处理机制是衡量一个系统设计的关键因素，良好的异常处理机制能在系统出现异常时准确的找到问题的所在。spring aop对异常的处理有良好的支持。spring（spring全家桶中增加了很多异常统一处理的接口和AOP，比如<code>@ControllerAdvice</code>） 提供了一个接口 <code>ThrowsAdvice</code>，该接口里面没有任何方法，但是实现类里面必须的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以处理详细的异常信息</span></span><br><span class="line">afterThrowing(Method method, Object[] args, Object target, RuntimeException  throwable)</span><br><span class="line"><span class="comment">//方便快速记录发生的异常</span></span><br><span class="line">afterThrowing(RuntimeException  throwable)</span><br></pre></td></tr></table></figure>
<h3 id="ClassNotFoundException和NoClassDefFoundError的区别"><a href="#ClassNotFoundException和NoClassDefFoundError的区别" class="headerlink" title="ClassNotFoundException和NoClassDefFoundError的区别"></a>ClassNotFoundException和NoClassDefFoundError的区别</h3><p>NoClassDefFoundError是一个错误(Error)，而ClassNOtFoundException是一个异常，在Java中错误和异常是有区别的，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。</p>
<h4 id="ClassNotFoundException的产生原因"><a href="#ClassNotFoundException的产生原因" class="headerlink" title="ClassNotFoundException的产生原因"></a>ClassNotFoundException的产生原因</h4><ol>
<li>使用<code>Class.forName（ClassLoader.loadClass、ClassLOader.findSystemClass）</code>加载对象时，如果没有找到则会出现该异常</li>
<li>当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。</li>
<li>ClassNotFoundException发生在装入阶段。</li>
<li>加载时从外存储器找不到需要的class就出现ClassNotFoundException</li>
</ol>
<h4 id="NoClassDefFoundError产生的原因"><a href="#NoClassDefFoundError产生的原因" class="headerlink" title="NoClassDefFoundError产生的原因"></a>NoClassDefFoundError产生的原因</h4><ol>
<li>JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。</li>
<li>NoClassDefFoundError： 当目前执行的类已经编译，但是找不到它的定义时</li>
<li>连接时从内存找不到需要的class就出现NoClassDefFoundError</li>
</ol>
<h4 id="NoClassDefFoundError-解决的三种方法"><a href="#NoClassDefFoundError-解决的三种方法" class="headerlink" title="NoClassDefFoundError 解决的三种方法"></a>NoClassDefFoundError 解决的三种方法</h4><ol>
<li><p>Simple example of NoClassDefFoundError is class belongs to a jar and jar was not added into classpath or sometime jar’s name has been changed by someone like in my case one of my colleague has changed tibco.jar into tibco_v3.jar and by program is failing with java.lang.NoClassDefFoundError and I was wondering what’s wrong.<br>首先是类在运行的时候依赖于其它的一个jar包，但是该jar包没有加载到classpath中或者是该jar包的名字被其他人改了，就像我的一个例子tibo.jar改为了tibco_v3.jar……. </p>
</li>
<li><p>Class is not in Classpath, there is no sure shot way of knowing it but many a times you can just have a look to print System.getproperty(”java.classpath“)and it will print the classpath from there you can at least get an idea of your actual runtime classpath.<br>运行的类不在classpath中，这个问题没有一个确定的方法去知道，但是很多时候你可以通过System.getproperty(”java.classpath“)方法，该方法能让你至少可以领略到实际存在的运行期间的classpath。
 </p>
</li>
<li><p>Just try to run with explicitly -classpath option with the classpath you think will work and if its working then it’s sure short sign that some one is overriding java classpath.<br>试着通过-classpath命令明确指出你认为正确的classpath，如果能够正常执行的话就说明你使用的classpath是正确的，而系统中的classpath已经被修该过了。</p>
</li>
</ol>
<h4 id="类装载方式"><a href="#类装载方式" class="headerlink" title="类装载方式"></a>类装载方式</h4><h5 id="显示类装载"><a href="#显示类装载" class="headerlink" title="显示类装载"></a>显示类装载</h5><p>显式 类装入发生在使用以下方法调用装入的类的时候：</p>
<ul>
<li>cl.loadClass()（cl 是 java.lang.ClassLoader 的实例）</li>
<li>Class.forName()（启动的类装入器是当前类定义的类装入器）</li>
</ul>
<p>当调用其中一个方法的时候，指定的类（以类名为参数）由类装入器装入。如果类已经装入，那么只是返回一个引用；否则，装入器会通过委托模型装入类。</p>
<h5 id="隐式类装载"><a href="#隐式类装载" class="headerlink" title="隐式类装载"></a>隐式类装载</h5><p>隐式 类装入发生在由于引用、实例化或继承导致装入类的时候（不是通过显式方法调用）。在每种情况下，装入都是在幕后启动的，JVM 会解析必要的引用并装入类。与显式类装入一样，如果类已经装入了，那么只是返回一个引用；否则，装入器会通过委托模型装入类。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/jygqm/article/details/81364636">JAVA 异常详解</a></li>
<li><a href="https://www.cnblogs.com/hysum/p/7112011.html">JAVA基础——异常详解</a></li>
<li><a href="https://www.cnblogs.com/nwgdk/p/8862353.html">Java 异常基础详解(详细的使用方式，可参考)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/108423001">Java基础篇——异常详解</a></li>
<li><a href="https://blog.csdn.net/qq_31615049/article/details/80952216">Java异常实现及原理</a></li>
<li>《疯狂Java》</li>
<li><a href="https://www.toutiao.com/i6805046770897256974/">finally 到底是在 return 之前还是之后执行的？</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之集合概述</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>使用集合需要考虑几个关注点：</p>
<ol>
<li>线程安全性</li>
<li>是否有序</li>
<li>是否重复</li>
<li>关注查询还是关注写入</li>
<li>equals和hashCode方法的重写需要同步</li>
<li>使用接口返回集合数据<a id="more"></a>

</li>
</ol>
<h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589101774172.png" class title="Java集合知识图谱">

</div>

<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589870092003.png" class title="Java集合类图">

</div>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h3><ol>
<li>数组和集合都是Java中的容器</li>
<li>数组的长度是固定的，集合的长度是可变的</li>
<li>数组只能存储相同数据类型的数据，这里的数据类型可以是基本数据类型，也可以是引用类型</li>
<li>集合可以存储不同数据类型的对象的引用(不建议使用这种方式，需要使用泛型控制)，但不能存储基本数据类型</li>
</ol>
<h3 id="接口继承关系和实现"><a href="#接口继承关系和实现" class="headerlink" title="接口继承关系和实现"></a>接口继承关系和实现</h3><p>集合类存放于 <code>Java.util</code> 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。</p>
<ol>
<li>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。</li>
<li>Iterator：迭代器，可以通过迭代器遍历集合中的数据</li>
<li>Map：是映射表的基础接口</li>
</ol>
<p>通过类图可知得出以下结论：  </p>
<ol>
<li>Java集合的根接口是Collection，它又继承了迭代接口Iterable</li>
<li>List接口和Set接口继承了Collection接口</li>
<li>Map接口是独立的接口，并没有继承Collection接口</li>
<li>List接口常用的实现类有：ArrayList、LinkedList、Vector，有序集合</li>
<li>Set接口常用的实现类有：HashSet、LinkedHashSet、TreeSet，不重复集合</li>
<li>Map接口常用的实现类有：HashMap、HashTable、TreeMap</li>
<li>Queue(队列)接口及其子类，提供了基于队列的集合体系。</li>
</ol>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax">接口</th>
    <th class="tg-0lax">集合类</th>
    <th class="tg-0lax">重复性</th>
    <th class="tg-0lax">有序性</th>
    <th class="tg-0lax">判断方法</th>
    <th class="tg-0lax">数据结构</th>
    <th class="tg-0lax">其他</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax" rowspan="2">Set</td>
    <td class="tg-0lax">HashSet</td>
    <td class="tg-0lax">否</td>
    <td class="tg-0lax">无序</td>
    <td class="tg-0lax">equals()、hashCode()</td>
    <td class="tg-0lax">Hash 表</td>
    <td class="tg-0lax">插入速度快</td>
  </tr>
  <tr>
    <td class="tg-0lax">LinkedHashSet</td>
    <td class="tg-0lax">否</td>
    <td class="tg-0lax">插入有序</td>
    <td class="tg-0lax">equals()、hashCode()</td>
    <td class="tg-0lax">Hash 表和双向链表</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">SortedSet、Set</td>
    <td class="tg-0lax">TreeSet</td>
    <td class="tg-0lax">否</td>
    <td class="tg-0lax">有序</td>
    <td class="tg-0lax">equals()、compareTo()</td>
    <td class="tg-0lax">&平衡树（Balanced tree）</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax" rowspan="3">List</td>
    <td class="tg-0lax">ArrayList</td>
    <td class="tg-0lax">是</td>
    <td class="tg-0lax">插入有序</td>
    <td class="tg-0lax">equals()</td>
    <td class="tg-0lax">数组</td>
    <td class="tg-0lax">
        动态链表<br>
        随机查询
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">LinkedList</td>
    <td class="tg-0lax">是</td>
    <td class="tg-0lax">插入有序</td>
    <td class="tg-0lax">equals()</td>
    <td class="tg-0lax">链表</td>
    <td class="tg-0lax">
        用于链表、队列、堆<br>
        中间写入、删除数据较快
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">Vector</td>
    <td class="tg-0lax">是</td>
    <td class="tg-0lax">插入有序</td>
    <td class="tg-0lax">equals()</td>
    <td class="tg-0lax">数组</td>
    <td class="tg-0lax">线程安全，效率低</td>
  </tr>
  <tr>
    <td class="tg-0lax" rowspan="3">Map</td>
    <td class="tg-0lax">HashMap</td>
    <td class="tg-0lax">key唯一</td>
    <td class="tg-0lax">无序</td>
    <td class="tg-0lax">equals()、hashCode()</td>
    <td class="tg-0lax">Hash 表</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">LinkedHashMap</td>
    <td class="tg-0lax">key唯一</td>
    <td class="tg-0lax">Key插入有序</td>
    <td class="tg-0lax">equals()、hashCode()</td>
    <td class="tg-0lax">Hash 表和双向链表</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">Hashtable</td>
    <td class="tg-0lax">key唯一</td>
    <td class="tg-0lax">无序</td>
    <td class="tg-0lax">equals()、hashCode()</td>
    <td class="tg-0lax">Hash 表</td>
    <td class="tg-0lax"></td>
  </tr>
  <tr>
    <td class="tg-0lax">SortedMap</td>
    <td class="tg-0lax">TreeMap</td>
    <td class="tg-0lax">key唯一</td>
    <td class="tg-0lax">key有序</td>
    <td class="tg-0lax">equals()、compareTo()</td>
    <td class="tg-0lax">平衡树（Balanced tree）</td>
    <td class="tg-0lax"></td>
  </tr>
</tbody>
</table>

<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="Collection类图"><a href="#Collection类图" class="headerlink" title="Collection类图"></a>Collection类图</h3><div style="width:300px;length:400px;align=center;margin:0 auto;">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589875532865.png" class title="Collection类图">

</div>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589871965983.png" class title="List类图">

</div>

<p>List 是<strong>有序</strong>的 Collection。Java List常用的实现类：ArrayList、Vector 和LinkedList。<br>List集合包括List接口以及List接口的所有实现类。List集合具有以下特点：</p>
<ol>
<li>集合中的元素允许重复</li>
<li>集合中的元素是有顺序的，各元素插入的顺序就是各元素的顺序，可以通过索引获取数据</li>
<li>集合中的元素可以通过索引来访问或者设置</li>
<li>提供一个listIterator()方法，返回一个 ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历</li>
</ol>
<h3 id="ArrayList（数组）"><a href="#ArrayList（数组）" class="headerlink" title="ArrayList（数组）"></a>ArrayList（数组）</h3><ol>
<li>内部通过数组实现</li>
<li>元素支持快速随机访问</li>
<li>当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li>
<li>可以为null</li>
<li>size，isEmpty，get，set方法运行时间为常数</li>
<li>add时间复杂度O(n)</li>
<li>动态扩容，使用ensureCapacity方法来增加ArrayList的容量以提高插入效率</li>
</ol>
<h3 id="Vector（数组实现、线程同步）"><a href="#Vector（数组实现、线程同步）" class="headerlink" title="Vector（数组实现、线程同步）"></a>Vector（数组实现、线程同步）</h3><ol>
<li>内部通过数组实现</li>
<li>支持同步，效率慢</li>
<li>如果其他线程在变更链表，使用Iterator将抛出ConcurrentModificationException</li>
</ol>
<h3 id="LinkList（链表）"><a href="#LinkList（链表）" class="headerlink" title="LinkList（链表）"></a>LinkList（链表）</h3><ol>
<li>内部使用链表结构实现</li>
<li>适合数据的动态插入和删除</li>
<li>随机访问和遍历速度较慢</li>
<li>提供额外的get、remove、insert方法作用LinkList的头尾，可以当作堆栈、队列和双向队列使用</li>
<li>允许为null</li>
<li>安全化：List list = Collections.synchronizedList(new LinkedList(…));</li>
</ol>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><ol>
<li>Stack继承自Vector，实现一个后进先出的堆栈</li>
<li>基本的push和pop方法，还有peek方法得到栈顶的元素</li>
<li>empty方法测试堆栈是否为空</li>
<li>search方法检测一个元素在堆栈中的位置</li>
<li>Stack刚创建后是空栈</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ol>
<li>数据不重复（通过对象的hashCode值判断，可重复添加但是最终只有一个）</li>
<li>存储数据无序(存入和取出的顺序不一定相同)</li>
</ol>
<blockquote>
<p>请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题</p>
</blockquote>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589872549181.png" class title="Set类图">

</div>

<h3 id="HashSet（Hash-表）"><a href="#HashSet（Hash-表）" class="headerlink" title="HashSet（Hash 表）"></a>HashSet（Hash 表）</h3><ol>
<li>使用Hash表实现，并且存储的是哈希值</li>
<li>存储的数据顺序无序（不是按照写入顺序定义）</li>
<li>按照哈希值来存储或读取数据，哈希值是通过hashcode获取</li>
<li>判断相同：首先判断哈希值，然后执行equals方法，都通过才认为是同一条数据</li>
<li>哈希碰撞：（哈希值相同，equals不同），可以使用链表进行顺延</li>
<li>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。</li>
</ol>
<h3 id="TreeSet（二叉树）"><a href="#TreeSet（二叉树）" class="headerlink" title="TreeSet（二叉树）"></a>TreeSet（二叉树）</h3><ol>
<li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。</li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</li>
<li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</li>
</ol>
<h3 id="LinkHashSet（HashSet-LinkedHashMap）"><a href="#LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet（HashSet+LinkedHashMap）"></a>LinkHashSet（HashSet+LinkedHashMap）</h3><ol>
<li>通过HashSet+LinkedHashMap实现</li>
<li>使用LinkedHashMap 来保存所有元素</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589873440529.png" class title="Map类图">

</div>

<p>Map集合包括Map接口以及Map接口的所有实现类。Map集合具有以下特点：</p>
<ol>
<li>Map接口并没有继承Collection接口，提供的是key到value的映射</li>
<li>Map中不能包含相同的key</li>
</ol>
<h3 id="Hashmap与hashtable的区别"><a href="#Hashmap与hashtable的区别" class="headerlink" title="Hashmap与hashtable的区别"></a>Hashmap与hashtable的区别</h3><ol>
<li>HashMap 允许 key 和 value 为 null，Hashtable 不允许。</li>
<li>HashMap 的默认初始容量为 16，Hashtable 为 11。</li>
<li>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。</li>
<li>HashMap 是非线程安全的，Hashtable是线程安全的。</li>
<li>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</li>
<li>HashMap 去掉了 Hashtable 中的 contains 方法。</li>
<li>HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。</li>
</ol>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ol>
<li>HashMap 的底层是个 Node 数组（Node&lt;K,V&gt;[] table），在数组的具体索引位置，如果存在多个节点，则可能是以链表或红黑树的形式存在。</li>
<li>增加、删除、查找键值对时，定位到哈希桶数组的位置是很关键的一步，源码中是通过下面3个操作来完成这一步：1）拿到 key 的 hashCode 值；2）将 hashCode 的高位参与运算，重新计算 hash 值；3）将计算出来的 hash 值与 “table.length - 1” 进行 &amp; 运算。</li>
<li>HashMap 的默认初始容量（capacity）是 16，capacity 必须为 2 的幂次方；默认负载因子（load factor）是 0.75；实际能存放的节点个数（threshold，即触发扩容的阈值）= capacity * load factor。</li>
<li>HashMap 在触发扩容后，阈值会变为原来的 2 倍，并且会对所有节点进行重 hash 分布，重 hash 分布后节点的新分布位置只可能有两个：“原索引位置” 或 “原索引+oldCap位置”。例如 capacity 为16，索引位置 5 的节点扩容后，只可能分布在新表 “索引位置5” 和 “索引位置21（5+16）”。</li>
<li>导致 HashMap 扩容后，同一个索引位置的节点重 hash 最多分布在两个位置的根本原因是：1）table的长度始终为 2 的 n 次方；2）索引位置的计算方法为 “(table.length - 1) &amp; hash”。HashMap 扩容是一个比较耗时的操作，定义 HashMap 时尽量给个接近的初始容量值。</li>
<li>HashMap 有 threshold 属性和 loadFactor 属性，但是没有 capacity 属性。初始化时，如果传了初始化容量值，该值是存在 threshold 变量，并且 Node 数组是在第一次 put 时才会进行初始化，初始化时会将此时的 threshold 值作为新表的 capacity 值，然后用 capacity 和 loadFactor 计算新表的真正 threshold 值。</li>
<li>当同一个索引位置的节点在增加后达到 9 个时，并且此时数组的长度大于等于 64，则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。链表节点转红黑树节点的具体方法为源码中的 treeifyBin 方法。而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容。</li>
<li>当同一个索引位置的节点在移除后达到 6 个时，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点。红黑树节点转链表节点的具体方法为源码中的 untreeify 方法。</li>
<li>HashMap 在 JDK 1.8 之后不再有死循环的问题，JDK 1.8 之前存在死循环的根本原因是在扩容后同一索引位置的节点顺序会反掉。</li>
<li>HashMap 是非线程安全的，在并发场景下使用 ConcurrentHashMap 来代替。</li>
</ol>
<p>详细参考：<a href="book/java-collection-map-hashmap.md">JAVA HashMap详解</a></p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="Segment-段"><a href="#Segment-段" class="headerlink" title="Segment 段"></a>Segment 段</h4><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一<br>些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。 </p>
<h4 id="线程安全（Segment-继承-ReentrantLock-加锁）"><a href="#线程安全（Segment-继承-ReentrantLock-加锁）" class="headerlink" title="线程安全（Segment 继承 ReentrantLock 加锁）"></a>线程安全（Segment 继承 ReentrantLock 加锁）</h4><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承<br>ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 </p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589102309296.png" class title="Java7 ConcurrentHashMap结构">

</div>

<h4 id="并行度（默认-16）"><a href="#并行度（默认-16）" class="headerlink" title="并行度（默认 16）"></a>并行度（默认 16）</h4><p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 </p>
<h4 id="Java8-实现-（引入了红黑树）"><a href="#Java8-实现-（引入了红黑树）" class="headerlink" title="Java8 实现 （引入了红黑树）"></a>Java8 实现 （引入了红黑树）</h4><p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。 </p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1589102332640.png" class title="Java8 ConcurrentHashMap结构">

</div>

<h3 id="HashTable（线程安全）"><a href="#HashTable（线程安全）" class="headerlink" title="HashTable（线程安全）"></a>HashTable（线程安全）</h3><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p>
<h3 id="TreeMap（可排序）"><a href="#TreeMap（可排序）" class="headerlink" title="TreeMap（可排序）"></a>TreeMap（可排序）</h3><p>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的<br>Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。<br>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html</a> </p>
<h3 id="LinkHashMap（记录插入顺序）"><a href="#LinkHashMap（记录插入顺序）" class="headerlink" title="LinkHashMap（记录插入顺序）"></a>LinkHashMap（记录插入顺序）</h3><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。参考 1：<a href="http://www.importnew.com/28263.html">http://www.importnew.com/28263.html</a><br>参考 2：<a href="http://www.importnew.com/20386.html#comment-648123">http://www.importnew.com/20386.html#comment-648123</a> </p>
<h2 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h2><p>Iterator是获取集合中元素的过程，实际上帮助获取集合中的元素。<br>迭代器代替了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同：<br>迭代器允许调用方利用定义良好的语义在迭代期间从迭代器所指向的集合移除元素。<br>方法名称得到了改进。<br>Iterator 仅有一个子接口ListIterator，是列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。 ListIterator 没有当前元素；它的光标位置 始终位于调用 previous() 所返回的元素和调用 next() 所返回的元素之间。在长度为 n 的列表中，有 n+1 个有效的索引值，从 0 到 n（包含）。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="Comparable-接口"><a href="#Comparable-接口" class="headerlink" title="Comparable 接口"></a>Comparable 接口</h3><h3 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高效编程技巧</title>
    <url>/2021/02/04/Java%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="Java代码规范"><a href="#Java代码规范" class="headerlink" title="Java代码规范"></a>Java代码规范</h2><h3 id="命名规范（阿里规范）"><a href="#命名规范（阿里规范）" class="headerlink" title="命名规范（阿里规范）"></a>命名规范（阿里规范）</h3><ol>
<li><p>名称只能是有含义的英文，不能出现下划线或美元符号</p>
</li>
<li><p>方法名、参数名、成员变量、局部变量统一使用驼峰方式命名，形如lowerCamelCase</p>
</li>
<li><p>类名使用UpperCamelCase命名，DO/BO/DTO/VO/AO/PO/UID除外</p>
</li>
<li><p>常量或类变量都需要使用大写，并且中间使用下划线分割</p>
</li>
<li><p>抽象类必须以Abstract或Base开头，异常类，必须以Exception结果，测试类必须以待测试代码_Test</p>
</li>
<li><p>类型与中括号紧挨相连来表示数组,形如<code>int[] arrayDemo</code></p>
</li>
<li><p>成员变量不能以is开头</p>
</li>
<li><p>包使用小写定义，并且使用单数，中间使用英文句号分割，并且定义必须有意义和唯一性</p>
</li>
<li><p>子类与父类之间不要使用相同的成员变量命名</p>
</li>
<li><p>完全杜绝不规范的缩写，尽量使用完整的单词</p>
</li>
<li><p>在常量与变量命名时，表示类型的名称放在词尾</p>
</li>
<li><p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式</p>
</li>
<li><p>接口中不要定义变量，方式不需要增加任何修饰符，都必须有注释信息</p>
</li>
<li><p>接口与实现类的命名规范是<strong>Service/**ServiceImpl、</strong>DAO/**DAOImpl</p>
</li>
<li><p>枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开</p>
</li>
<li><p>各层命名规范：</p>
<ul>
<li>Service/DAO 层方法命名规约<ul>
<li>获取单个对象的方法用 get 做前缀。</li>
<li>获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。</li>
<li>获取统计值的方法用 count 做前缀。</li>
<li>插入的方法用 save/insert 做前缀。</li>
<li>删除的方法用 remove/delete 做前缀。</li>
<li>修改的方法用 update 做前缀。</li>
</ul>
</li>
<li>领域模型命名规约<ul>
<li>数据对象：xxxDO，xxx 即为数据表名。</li>
<li>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li>
<li>展示对象：xxxVO，xxx 一般为网页名称。</li>
<li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。<a id="more"></a>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>不允许任何魔法值（即未经预先定义的常量）直接出现在代码中，使用常量替换</p>
</li>
<li><p>定义类型为long或Long的属性时，需要用大写L结尾</p>
</li>
<li><p>常量定义要分类维护，一般分为：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量</p>
</li>
<li><p>如果变量值仅在一个固定范围内变化用 enum 类型来定义</p>
</li>
</ol>
<h2 id="高效能开发的原则"><a href="#高效能开发的原则" class="headerlink" title="高效能开发的原则"></a>高效能开发的原则</h2><h3 id="优化代码的注意事项"><a href="#优化代码的注意事项" class="headerlink" title="优化代码的注意事项"></a>优化代码的注意事项</h3><ol>
<li>除非必须优化，否则不要轻易改动</li>
<li>改动之后要进行仔细的测试</li>
<li>在各个JVM产品中不存在一劳永逸的成本模型</li>
</ol>
<h3 id="Java编码原则"><a href="#Java编码原则" class="headerlink" title="Java编码原则"></a>Java编码原则</h3><ol>
<li>注重设计、数据结构、算法选择</li>
<li>不要过分依赖编译器编译期的优化技术，正确理解Java运行期的实际效果</li>
<li>将对象的创建和使用降到最低：<ul>
<li>StringBuilder的使用</li>
<li>for循环中对象的索引使用</li>
<li>线程或连接的复用</li>
<li>合理设计对象的大小（在类加载过程会完成内存大小的计算）</li>
<li>合理设计继承关系（不多于3层）</li>
<li>构造函数尽可能短小精干</li>
<li>对象创建使用懒加载思想</li>
</ul>
</li>
<li>降低同步的影响范围<ul>
<li>是否需要使用同步控制或者线程安全的类</li>
<li>控制同步范围</li>
<li>合理使用锁变量，做到线程分离，提高并发度和吞吐量</li>
<li>减少锁的使用，避免出现死锁</li>
</ul>
</li>
<li>尽量在栈中完成业务处理</li>
<li>使用static、final、private函数促成inlining</li>
<li>实例变量初始化合适就好，比如单例模式</li>
<li>注意集合的使用<ul>
<li>选择合适的遍历方式</li>
<li>使用大小的控制</li>
<li>数据复制的选择</li>
<li>选择合适的集合类</li>
</ul>
</li>
<li>尽可能重用对象</li>
<li>增加缓存概念</li>
</ol>
<h2 id="集合遍历效率问题"><a href="#集合遍历效率问题" class="headerlink" title="集合遍历效率问题"></a>集合遍历效率问题</h2><h3 id="高效遍历MAP"><a href="#高效遍历MAP" class="headerlink" title="高效遍历MAP"></a>高效遍历MAP</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * keySet的for循环方式：</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetForGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetForGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetForGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	        String value = map.get(key);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetForGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * keySet的iterator迭代器方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetIteratorGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetIteratorGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetIteratorGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next();</span><br><span class="line">	        String value = map.get(iterator.next());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetIteratorGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * entrySet的for循环方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetForGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	        String key = entry.getKey();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetForGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetForGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	        String key = entry.getKey();</span><br><span class="line">	        String value = entry.getValue();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetForGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * entrySet的iterator迭代器方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetIteratorGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next().getKey();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetIteratorGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetIteratorGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next().getKey();</span><br><span class="line">	        String value = iterator.next().getValue();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetIteratorGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		    map.put(i + <span class="string">&quot;&quot;</span>, i + <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		MapTest.keySetForGetKey(map);</span><br><span class="line">		MapTest.keySetIteratorGetKey(map);</span><br><span class="line">		MapTest.entrySetForGetKey(map);</span><br><span class="line">		MapTest.entrySetIteratorGetKey(map);</span><br><span class="line">		</span><br><span class="line">		MapTest.keySetForGetKeyAndValue(map);</span><br><span class="line">		MapTest.keySetIteratorGetKeyAndValue(map);</span><br><span class="line">		MapTest.entrySetForGetKeyAndValue(map);</span><br><span class="line">		MapTest.entrySetIteratorGetKeyAndValue(map);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">keySetForGetKey运行时间<span class="number">96</span></span><br><span class="line">keySetIteratorGetKey运行时间<span class="number">107</span></span><br><span class="line">entrySetForGetKey运行时间<span class="number">112</span></span><br><span class="line">entrySetIteratorGetKey运行时间<span class="number">153</span></span><br><span class="line">keySetForGetKeyAndValue运行时间<span class="number">169</span></span><br><span class="line">keySetIteratorGetKeyAndValue运行时间<span class="number">283</span></span><br><span class="line">entrySetForGetKeyAndValue运行时间<span class="number">109</span></span><br><span class="line">entrySetIteratorGetKeyAndValue运行时间<span class="number">138</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：<br>entrySet的方式整体都是比keySet方式要高一些<br>单纯的获取key来说，两者的差别并不大，但是如果要获取value，还是entrySet的效率会更好，因为keySet需要从map中再次根据key获取value，而entrySet一次都全部获取出来<br>iterator的迭代器方式比foreach的效率高  </p>
</blockquote>
<h3 id="实现RandomAccess接口的集合使用for循环而不是foreach来遍历"><a href="#实现RandomAccess接口的集合使用for循环而不是foreach来遍历" class="headerlink" title="实现RandomAccess接口的集合使用for循环而不是foreach来遍历"></a>实现RandomAccess接口的集合使用for循环而不是foreach来遍历</h3><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其：色nu支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p>
<div align="center">

<img src="/2021/02/04/Java%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/1589105799147.png" class title="参考代码">

</div>

<p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p>
<h2 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h2><ol>
<li>尽量使用同步代码块替代同步方法，提高代码执行效率</li>
<li>尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</li>
</ol>
<h2 id="资源处理注意事项"><a href="#资源处理注意事项" class="headerlink" title="资源处理注意事项"></a>资源处理注意事项</h2><ol>
<li>及时关闭资源：使用资源一般都会建立流的连接，比如文件流，数据库连接等，在使用完成之后要及时关闭打开的连接，防止内存泄露。一般在finally中处理。</li>
<li>关闭多个资源时，需要分开执行，防止由于异常无法关闭所有的资源</li>
</ol>
<h2 id="垃圾信息处理"><a href="#垃圾信息处理" class="headerlink" title="垃圾信息处理"></a>垃圾信息处理</h2><ol>
<li>不要定义、创建不使用的对象，变量；</li>
<li>不要导入不需要的依赖包</li>
<li>公用的集合类中不使用的数据一定要及时remove掉</li>
<li>ThreadLocal中不使用的数据要及时处理掉，防止内存溢出</li>
<li>及时清除不再需要的会话（会话超时设置），防止出现内存不足或内存磁盘之间交互频繁，当会话不再需要时，应当及时调用HttpSession的invalidate方法清除会话。</li>
</ol>
<h2 id="尽量使用局部变量"><a href="#尽量使用局部变量" class="headerlink" title="尽量使用局部变量"></a>尽量使用局部变量</h2><ol>
<li>方法参数和临时临时变量都在栈中分配，速度快</li>
<li>类变量、实例变量存储在堆中速度较慢</li>
<li>栈中的变量随时方法的结束而结束，不需要额外的垃圾回收</li>
</ol>
<h2 id="提高效率，减少内存"><a href="#提高效率，减少内存" class="headerlink" title="提高效率，减少内存"></a>提高效率，减少内存</h2><ol>
<li>使用StringBuilder/StringBuffer替代String</li>
<li>循环内不要创建对象的引用：减少堆栈中的使用，避免出现栈内存溢出或出现栈越界。</li>
<li>尽量采用懒加载的策略，即在需要的时候才创建</li>
<li>尽量避免随意使用静态变量：当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的</li>
<li>尽量在合适的场合使用单例（减轻加载的负担、缩短加载的时间、提高加载的效率）<ul>
<li>控制资源的使用，通过线程同步来控制资源的并发访问</li>
<li>控制实例的产生，以达到节约资源的目的</li>
<li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
</li>
<li>使用数据库连接池和线程池：前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</li>
<li>使用带缓冲的输入输出流进行IO操作</li>
<li>乘法和除法使用移位操作</li>
<li>减少对变量的重复计算：对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。集合中大小的重复获取会消耗内存和时间。</li>
<li>当复制大量数据时，使用System.arraycopy命令</li>
<li>基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</li>
<li>程序运行过程中避免使用反射（根据实际情况定）：反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</li>
<li>顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个</li>
</ol>
<h2 id="关键字和方法的说明"><a href="#关键字和方法的说明" class="headerlink" title="关键字和方法的说明"></a>关键字和方法的说明</h2><h3 id="equals的正确使用"><a href="#equals的正确使用" class="headerlink" title="equals的正确使用"></a>equals的正确使用</h3><ol>
<li>重写equals后需要同时完成hashcode方法的重写</li>
<li>equals中初始代码比对的是对象地址</li>
<li>字符串比对相等时，字符串常量写在字符串变量前面，比如”abc”.equals(abc)</li>
</ol>
<h3 id="final的正确使用"><a href="#final的正确使用" class="headerlink" title="final的正确使用"></a>final的正确使用</h3><ol>
<li>如果类不能被派生，则必须定义为final（该类中的方法都是final的）</li>
<li>如果方法不能被重写，则必须定义为final</li>
<li>常量定义为static final，并且名称使用大写，多个字符使用下划线拼接，比如：USER_NAME</li>
<li>不要将数组声明为public static final（final只是表示引用不变，但是内容还是可以变）</li>
</ol>
<h3 id="方法参数要求"><a href="#方法参数要求" class="headerlink" title="方法参数要求"></a>方法参数要求</h3><p>在Java编程中，要尽量保证面向对象编程，并且达到高内聚，低耦合，实现动态扩展的特性。如果定义参数太多，会有以下缺点：</p>
<ol>
<li>违背面向对象编程</li>
<li>可扩展性低</li>
<li>方法调用出错概率大</li>
</ol>
<p>建议参数保证在3~4个之内，尽量使用有明确意义的对象传参（<strong>减少类似Map对象的使用</strong>）。</p>
<h3 id="不要对数组使用toString方法"><a href="#不要对数组使用toString方法" class="headerlink" title="不要对数组使用toString方法"></a>不要对数组使用toString方法</h3><ol>
<li>数组为空会出现空指针</li>
<li>打印的数据是地址信息，与预期不一致</li>
<li>对集合toString是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString方法。</li>
</ol>
<h2 id="异常使用注意事项"><a href="#异常使用注意事项" class="headerlink" title="异常使用注意事项"></a>异常使用注意事项</h2><ol>
<li>慎用异常：异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace的本地同步方法，fillInStackTrace方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</li>
<li>不要在循环中使用try…catch…，应该把其放在最外层，除非不得已</li>
</ol>
<h2 id="合理使用初始化长度"><a href="#合理使用初始化长度" class="headerlink" title="合理使用初始化长度"></a>合理使用初始化长度</h2><ol>
<li>集合：ArrayList、LinkedLlist等</li>
<li>字符串：StringBuilder、StringBuffer等</li>
<li>Map：HashMap等</li>
<li>Set：HashSet等</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol>
<li>不要对超出范围的基本数据类型做向下强制转型<ul>
<li>整型默认的数据类型是int，long需要在结尾增加<code>L</code></li>
<li>浮点型的默认类型是double，所以定义float的时候要写成<code>float f = 3.5f</code></li>
<li>long+int会自动转型为long</li>
</ul>
</li>
<li>基本类型（包装类）转String：<code>toString &gt; String.valueOf &gt; +</code>，可以通过源码得到原因：<ul>
<li>String.valueOf方法底层调用了Integer.toString方法，但是会在调用前做空判断</li>
<li>Integer.toString，直接调用了</li>
<li>i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString方法获取字符串</li>
</ul>
</li>
</ol>
<h2 id="日志规范"><a href="#日志规范" class="headerlink" title="日志规范"></a>日志规范</h2><ol>
<li>日志级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL，常用级别<strong>ERROR、WARN、INFO和DEBUG</strong></li>
<li>ERROR<ul>
<li>表示不能自己恢复的错误，需要立即关注和解决</li>
<li>比如：数据库连接错误、网络错误、未知系统错误</li>
<li>需要接入监控和报警系统 </li>
</ul>
</li>
<li>WARN<ul>
<li>表示可预知的错误，业务场景类错误</li>
<li>比如：参数验证、权限认证 </li>
</ul>
</li>
<li>INFO<ul>
<li>记录系统的基本运行过程和运行状态</li>
<li>包括：系统状态变化、业务流程的核心处理、关键动作、业务流状态的变化 </li>
</ul>
</li>
<li>DEBUG<ul>
<li>调试信息 </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之HashMap</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>HashMap是一种使用<strong>数组+链表+红黑树</strong>数据结构实现的Map</li>
<li>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序不确定。</li>
<li>HashMap只允许一个key为null，允许多个value为null</li>
<li>HashMap 非线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。<a id="more"></a>

</li>
</ol>
<h2 id="Java7的实现方式"><a href="#Java7的实现方式" class="headerlink" title="Java7的实现方式"></a>Java7的实现方式</h2><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589101907833.png" class title="Java7 HashMap结构">

</div>
数组+单向链表的方式实现，上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。

<ol>
<li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</li>
<li>loadFactor：负载因子，默认为 0.75。</li>
<li>threshold：扩容的阈值，等于 capacity * loadFactor</li>
</ol>
<h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主干数组，是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂。</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure>
<h3 id="Entry静态内部类"><a href="#Entry静态内部类" class="headerlink" title="Entry静态内部类"></a>Entry静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      <span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">      Entry&lt;K,V&gt; next;</span><br><span class="line">      <span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line">      <span class="keyword">int</span> hash;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Creates new entry.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">          value = v;</span><br><span class="line">          next = n;</span><br><span class="line">          key = k;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589101953955.png" class title="Java7 HashMap链表结构">

</div>

<p>HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，<strong>HashMap中的链表出现越少，性能才会越好</strong>。</p>
<h3 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**实际存储的key-value键值对的个数*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；</span></span><br><span class="line"><span class="comment">* 当table被填充时，为table分配内存空间后，threshold一般为 capacity*loadFactory。</span></span><br><span class="line"><span class="comment">* HashMap在进行扩容时需要参考threshold</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 负载因子，代表了table的填充度有多少，默认是0.75</span></span><br><span class="line"><span class="comment">* 为了减缓哈希冲突和自动扩容的临界值</span></span><br><span class="line"><span class="comment">* 当初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。</span></span><br><span class="line"><span class="comment">* 所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**HashMap被改变的次数，</span></span><br><span class="line"><span class="comment">* 由于HashMap非线程安全，在对HashMap进行迭代时，如果数据发生变化</span></span><br><span class="line"><span class="comment">* 抛出ConcurrentModificationException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在常规构造函数中没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组（懒加载）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加数据源码解析"><a href="#添加数据源码解析" class="headerlink" title="添加数据源码解析"></a>添加数据源码解析</h3><h4 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间,入参是threshold）</span></span><br><span class="line">    <span class="comment">//此时threshold为initialCapacity 默认是1&lt;&lt;4(2^4=16)</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//获取在table中的实际位置</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//新增一个entry</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="inflateTable、roundUpToPowerOf2"><a href="#inflateTable、roundUpToPowerOf2" class="headerlink" title="inflateTable、roundUpToPowerOf2"></a>inflateTable、roundUpToPowerOf2</h4><p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//capacity一定是2的次幂</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">/**计算threshold</span></span><br><span class="line"><span class="comment">     * 取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，</span></span><br><span class="line"><span class="comment">     * capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="添加到链表中"><a href="#添加到链表中" class="headerlink" title="添加到链表中"></a>添加到链表中</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法。</p>
<h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//for循环中的代码，逐个遍历链表，重新计算索引位置，</span></span><br><span class="line">    <span class="comment">//将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，</span></span><br><span class="line">            <span class="comment">//有可能也是个entry链，如果是entry链，直接在链表头部插入。</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。  </p>
<p>HashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)。</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102034044.png" class>

</div>
还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102056292.png" class>

</div>

<p>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102083089.png" class>

</div>

<p>如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p>
<h3 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**这是一个神奇的函数，用了很多的异或，移位等运算</span></span><br><span class="line"><span class="comment">* 对key的hashcode进一步进行计算以及二进制位的调整等</span></span><br><span class="line"><span class="comment">* 来保证最终获取的存储位置尽量分布均匀</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回数组下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>h&amp;（length-1）</strong>保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为index=2。位运算对计算机来说，性能更高一些（HashMap中有大量位运算）<br>所以最终存储位置的确定流程是这样的：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102000853.png" class>

</div>

<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果key为null,则直接去table[0]处去检索即可。</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> getForNullKey();</span><br><span class="line">  Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法。</p>
<h4 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过key的hashcode值计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">//indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null。</p>
<p>在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>
<h2 id="JAVA8"><a href="#JAVA8" class="headerlink" title="JAVA8"></a>JAVA8</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了<strong>红黑树</strong>，所以其由 <strong>数组+链表+红黑树</strong> 组成。<br>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102119067.png" class title="Java8 HashMap结构">

</div>

<h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><ol>
<li>源码中的头节点一般是指table表上索引位置的节点，也就是链表的头节点</li>
<li>红黑树中的root节点指最上面的节点（没有父节点的节点），但是根节点不一定是索引位置的头节点（也就是链表的头节点），HashMap 通过 moveRootToFront 方法来维持红黑树的根结点就是索引位置的头结点，但是在 removeTreeNode 方法中，当 movable 为 false 时，不会调用 moveRootToFront 方法，此时红黑树的根节点不一定是索引位置的头节点，该场景发生在 HashIterator 的 remove 方法中。</li>
<li>转为红黑树节点后，链表的结构还存在，通过 next 属性维持，红黑树节点在进行操作时都会维护链表的结构，</li>
<li>在红黑树上，叶子节点也可能有 next 节点，因为红黑树的结构跟链表的结构是互不影响的链表移除操作</li>
</ol>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102145189.png" class>

</div>

<ol>
<li>红黑链表维护结构</li>
</ol>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102168356.png" class>

</div>

<ol>
<li>源码中进行红黑树的查找时，会反复用到以下两条规则：<ul>
<li>如果目标节点的 hash 值小于 p 节点的 hash 值，则向 p 节点的左边遍历；否则向 p 节点的右边遍历。</li>
<li>如果目标节点的 key 值小于 p 节点的 key 值，则向 p 节点的左边遍历；否则向 p 节点的右边遍历。这两条规则是利用了红黑树的特性（左节点 &lt; 根节点 &lt; 右节点）</li>
</ul>
</li>
<li>源码中进行红黑树的查找时，会用 dir（direction）来表示向左还是向右查找，dir 存储的值是目标节点的 hash/key 与 p 节点的 hash/key 的比较结果</li>
</ol>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> * 默认容量，1向左移位4个，00000001变成00010000，</span></span><br><span class="line"><span class="comment"> * 也就是2的4次方为16，使用移位是因为移位是计算机基础运算，效率比加减乘除快。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> * 用于扩容的加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> * 当桶的数量大于该值时，会把链表结构转换成红黑树结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> * 当桶的节点数量小于该值时，会自动转换成链表结构，前天是当前结构为红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> * 当hashmap中元素的数量大于该值时，桶的存储结构也会转换成红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> * 链表结构定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> * 存储实际元素的数组，被transient修饰，表示不被序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> * 将数据转换成set的另一种存储形式，这个变量主要用于迭代功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> * 元素数量,实际存储key-value键值对的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> * 统计map的结构化修改次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> * 扩容的临界值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> * 加载因子，定义为可使用的变量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment"> * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment"> * linked node.</span></span><br><span class="line"><span class="comment"> * -- 红黑树结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>如何在不遍历链表/红黑树的情况下快速定位原始，可以大大优化查询效率，并且通过hash算法可以使数据均匀分布，尽量减少哈希碰撞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment"> * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> * 使用key的hashCode进行移位异或运算，尽量避免hash碰撞</span></span><br><span class="line"><span class="comment"> * 如果在修改某个对象的hashCode方法时需要尽量保障唯一性，</span></span><br><span class="line"><span class="comment"> * 否则在使用map数据结构存储时会出现数据覆盖的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.首先获取key的hashCode值</span></span><br><span class="line"><span class="comment">     * 2.将hashCode值的高16位参与运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到元素的hash值之后通过以下方式完成索引定位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = tab.length;</span><br><span class="line"><span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>
<p>hashmap使用模运算算法均匀分布数据，由于模运算比较消耗系统性能，JDK团队使用位与运算（(table.length -1) &amp; h）来替代模运算。这个优化是基于以下公式：x mod 2^n = x &amp; (2^n - 1)。由于 HashMap 底层数组的长度总是 2 的 n 次方，并且取模运算为 “h mod table.length”，对应上面的公式，可以得到该运算等同于“h &amp; (table.length - 1)”。这是 HashMap 在速度上的优化，因为 &amp; 比 % 具有更高的效率。在 JDK1.8 的实现中，还优化了高位运算的算法，将 hashCode 的高 16 位与 hashCode 进行异或运算，主要是为了在 table 的 length 较小的时候，让高位也参与运算，并且不会有太大的开销。  </p>
<p>举例说明：<br>当 table 长度为 16 时，table.length - 1 = 15 ，用二进制来看，此时低 4 位全是 1，高 28 位全是 0，与 0 进行 &amp; 运算必然为 0，因此此时 hashCode 与 “table.length - 1” 的 &amp; 运算结果只取决于 hashCode 的低 4 位，在这种情况下，hashCode 的高 28 位就没有任何作用，并且由于 hash 结果只取决于 hashCode 的低 4 位，hash 冲突的概率也会增加。因此，在 JDK 1.8 中，将高位也参与计算，目的是为了降低 hash 冲突的概率。</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102211003.png" class>

</div>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有当table不为空，且table长度大于0，</span></span><br><span class="line"><span class="comment">     * 且table索引位置(使用table.length - 1和hash值进行位与运算)的节点不为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * 2.检查first节点的hash值和key是否和入参的一样，</span></span><br><span class="line"><span class="comment">    	 * 如果一样则first即为目标节点，直接返回first节点</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.如果first不是目标节点，并且first的next节点不为空则继续遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            	<span class="comment">/**</span></span><br><span class="line"><span class="comment">            	 * 3.如果first不是目标节点，并且first的next节点不为空则继续遍历</span></span><br><span class="line"><span class="comment">            	 */</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">            	<span class="comment">/**</span></span><br><span class="line"><span class="comment">            	 * 5.执行链表节点的查找，向下遍历链表, 直至找到节点的key和入参的key相等时,返回该节点</span></span><br><span class="line"><span class="comment">            	 */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有查询到数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls find for root node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 首先获取root节点，然后根据root节点进行find</span></span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定位根节点"><a href="#定位根节点" class="headerlink" title="定位根节点"></a>定位根节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment"> * -- 没有父节点的节点为根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用根节点进行find"><a href="#使用根节点进行find" class="headerlink" title="使用根节点进行find"></a>使用根节点进行find</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Finds the node starting at root p with the given hash and key.</span></span><br><span class="line"><span class="comment">     * The kc argument caches comparableClassFor(key) upon first use</span></span><br><span class="line"><span class="comment">     * comparing keys.</span></span><br><span class="line"><span class="comment">     * 从调用此方法的节点开始查找, 通过hash值和key找到对应的节点</span></span><br><span class="line"><span class="comment">     * 此方法是红黑树节点的查找, 红黑树是特殊的自平衡二叉查找树</span></span><br><span class="line"><span class="comment">     * 平衡二叉查找树的特点：左节点&lt;根节点&lt;右节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 1.将p节点赋值为调用此方法的节点，即为红黑树根节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">            <span class="comment">// 3.如果传入的hash值小于p节点的hash值，则往p节点的左边遍历</span></span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                p = pl;</span><br><span class="line">            <span class="comment">// 4.如果传入的hash值大于p节点的hash值，则往p节点的右边遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="comment">// 5.如果传入的hash值和key值等于p节点的hash值和key值,则p节点为目标节点,返回p节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            <span class="comment">// 6.p节点的左节点为空则将向右遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="comment">// 7.p节点的右节点为空则向左遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                p = pl;</span><br><span class="line">            <span class="comment">// 8.将p节点与k进行比较</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp; <span class="comment">// 8.1 kc不为空代表k实现了Comparable</span></span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>) <span class="comment">// 8.2 k&lt;pk则dir&lt;0, k&gt;pk则dir&gt;0</span></span><br><span class="line">            	<span class="comment">// 8.3 k&lt;pk则向左遍历(p赋值为p的左节点), 否则向右遍历</span></span><br><span class="line">            	p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">            <span class="comment">// 9.代码走到此处, 代表key所属类没有实现Comparable, 直接指定向p的右边遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            <span class="comment">// 10.代码走到此处代表“pr.find(h, k, kc)”为空, 因此直接向左遍历</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns x&#x27;s Class if it is of the form &quot;class C implements</span></span><br><span class="line"><span class="comment"> * Comparable&lt;C&gt;&quot;, else null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">	<span class="comment">// 1.判断x是否实现了Comparable接口</span></span><br><span class="line">	<span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="comment">// 2.校验x是否为String类型</span></span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 3.遍历x实现的所有接口</span></span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">        		<span class="comment">// 4.如果x实现了Comparable接口，则返回x的Class</span></span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Put逻辑"><a href="#Put逻辑" class="headerlink" title="Put逻辑"></a>Put逻辑</h3><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap/1589102248734.png" class title="Put处理逻辑">

</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.（初始化时使用false）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * tab 哈希数组，</span></span><br><span class="line"><span class="comment">	 * p 该哈希桶的首节点，</span></span><br><span class="line"><span class="comment">	 * n hashMap的长度，</span></span><br><span class="line"><span class="comment">	 * i 计算出的数组下标</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.使用懒加载的方式完成table的初始化（通过扩容完成：resize方法）</span></span><br><span class="line"><span class="comment">     * 2.如果table为空或者长度为0，则调用resize完成初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过hash值计算索引位置，如果计算出的该哈希桶的位置没有值，</span></span><br><span class="line"><span class="comment">     * 则把新插入的key-value放到此处，并且赋值给p（首节点）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    	<span class="comment">//如果p（首节点）为空，则在该索引位置新增一个节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * table索引位置不为空，及首节点不为空，则进行查找</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">    	<span class="comment">// e 临时节点的作用， k 存放该当前节点的key</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一种：插入的key-value的hash值，key都与当前节点的相等，e = p，</span></span><br><span class="line"><span class="comment">         * 则表示为首节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二种：hash值不等于首节点，判断该p是否属于红黑树的节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        	 * 为红黑树的节点，则在红黑树中进行添加，</span></span><br><span class="line"><span class="comment">        	 * 如果该节点已经存在，则返回该节点（不为null），</span></span><br><span class="line"><span class="comment">        	 * 该值很重要，用来判断put操作是否成功，如果添加成功返回null</span></span><br><span class="line"><span class="comment">        	 */</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第三种，hash值不等于首节点，不为红黑树的节点，则为链表的节点，使用binCount统计链表数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">// 遍历链表</span></span><br><span class="line">            	<span class="comment">/**</span></span><br><span class="line"><span class="comment">            	 * 如果找到尾部，则表明添加的key-value没有重复，在尾部进行添加</span></span><br><span class="line"><span class="comment">            	 */</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断是否转换成红黑树结构，减1，是由于循环从p的下一个节点开始</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果链表中有重复的key，e则为当前重复的节点，结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e; <span class="comment">// 将p指向下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果存在重复key，则使用新值插入，并且返回旧值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在没有重复值的情况下，完成以下操作</span></span><br><span class="line"><span class="comment">     * 1.modCount + 1</span></span><br><span class="line"><span class="comment">     * 2.实际长度size + 1</span></span><br><span class="line"><span class="comment">     * 3.根据实际情况完成扩容</span></span><br><span class="line"><span class="comment">     * 4.返回null，表示添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 该方法目前未具体实现，在LinkedHashMap中有实现</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="红黑树结构维护数据"><a href="#红黑树结构维护数据" class="headerlink" title="红黑树结构维护数据"></a>红黑树结构维护数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tree version of putVal.</span></span><br><span class="line"><span class="comment"> * -- 红黑树的put操作，红黑树插入会同时维护原来的链表属性, 即原来的next属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取根节点，索引位置的头节点不一定是根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将根节点赋值给p，然后进行遍历查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="comment">// 如果传入的hash值小于p节点的hash值，将dir赋值为-1，代表向p的左边查找树</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果传入的hash值大于p节点的hash值， 将dir赋值为1，代表向p的右边查找树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果传入的hash值和key值等于p节点的hash值和key值, 则p节点即为目标节点, 返回p节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果k所属的类没有实现Comparable接口 或者 k和p节点的key相等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        	 * 第一次符合条件, 从p节点的左节点和右节点分别调用find方法进行查找, </span></span><br><span class="line"><span class="comment">        	 * 如果查找到目标节点则返回</span></span><br><span class="line"><span class="comment">        	 */</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 否则使用定义的一套规则来比较k和p节点的key的大小, 用来决定向左还是向右查找</span></span><br><span class="line"><span class="comment">             * dir&lt;0则代表k&lt;pk，则向p左边查找；反之亦然</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xp赋值为x的父节点,中间变量,用于下面给x的父节点赋值</span></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 表示已经找到x的位置，只需要将x放到该位置即可</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            <span class="comment">// 创建新的节点, 其中x的next节点为xpn, 即将x节点插入xp与xpn之间</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 调整x、xp、xpn之间的属性关系</span></span><br><span class="line"><span class="comment">             * 如果时dir &lt;= 0, 则代表x节点为xp的左节点</span></span><br><span class="line"><span class="comment">             * 如果时dir&gt; 0, 则代表x节点为xp的右节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;<span class="comment">// 将xp的next节点设置为x</span></span><br><span class="line">            x.parent = x.prev = xp;<span class="comment">// 将x的parent和prev节点设置为xp</span></span><br><span class="line">            <span class="comment">// 如果xpn不为空,则将xpn的prev节点设置为x节点,与上文的x节点的next节点对应</span></span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            <span class="comment">// 进行红黑树的插入平衡调整</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tie-breaking utility for ordering insertions when equal</span></span><br><span class="line"><span class="comment"> * hashCodes and non-comparable. We don&#x27;t require a total</span></span><br><span class="line"><span class="comment"> * order, just a consistent insertion rule to maintain</span></span><br><span class="line"><span class="comment"> * equivalence across rebalancings. Tie-breaking further than</span></span><br><span class="line"><span class="comment"> * necessary simplifies testing a bit.</span></span><br><span class="line"><span class="comment"> * - 用于不可比较或者hashCode相同时进行比较的方法, </span></span><br><span class="line"><span class="comment"> * - 只是一个一致的插入规则，用来维护重定位的等价性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">         compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">             -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> * -- 链表转换成红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果tab为空，或者长度小于64，则调用resize方法进行扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据hash值计算索引值，将该索引位置的节点赋值给e，从e开始遍历该索引位置的链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        	 * 将链表转换成红黑树</span></span><br><span class="line"><span class="comment">        	 */</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)<span class="comment">// 第一次遍历，将节点赋值给hd</span></span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">/**</span></span><br><span class="line"><span class="comment">            	 * 如果不是第一次遍历，则处理当前节点的prev属性和上一个节点的next属性</span></span><br><span class="line"><span class="comment">            	 */</span></span><br><span class="line">                p.prev = tl; <span class="comment">// 当前节点的prev属性设为上一个节点</span></span><br><span class="line">                tl.next = p; <span class="comment">// 上一个节点的next属性设置为当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 将p节点赋值给tl，用于在下一次循环中作为上一个节点进行一些链表的关联操作</span></span><br><span class="line"><span class="comment">             * （p.prev = tl 和 tl.next = p）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">        	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        	 * 将table该索引位置赋值为新转的TreeNode的头节点，</span></span><br><span class="line"><span class="comment">        	 * 如果该节点不为空，则以以头节点(hd)为根节点, 构建红黑树</span></span><br><span class="line"><span class="comment">        	 */</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For treeifyBin</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之String</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BString/</url>
    <content><![CDATA[<h2 id="String介绍"><a href="#String介绍" class="headerlink" title="String介绍"></a>String介绍</h2><h3 id="API描述"><a href="#API描述" class="headerlink" title="API描述"></a>API描述</h3><blockquote>
<p>在<code>java.lang.String</code>的源码中明确说明，<code>String</code>类表示字符串，Java中所有的字符串传字面值（如：”abc”）都是该类的实例；并且字符串是常量，一旦创建之后则不可以改变，String buffers支持可变的字符串。因为<code>String</code>对象是不可变的，但是可以共享。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * The &#123;<span class="meta">@code</span> String&#125; <span class="class"><span class="keyword">class</span> <span class="title">represents</span> <span class="title">character</span> <span class="title">strings</span>. <span class="title">All</span></span></span><br><span class="line"><span class="class"> * <span class="title">string</span> <span class="title">literals</span> <span class="title">in</span> <span class="title">Java</span> <span class="title">programs</span>, <span class="title">such</span> <span class="title">as</span> </span>&#123;<span class="meta">@code</span> <span class="string">&quot;abc&quot;</span>&#125;, are</span><br><span class="line"> * implemented as instances of <span class="keyword">this</span> class.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Strings are constant; their values cannot be changed after they</span><br><span class="line"> * are created. String buffers support mutable strings.</span><br><span class="line"> * Because String objects are immutable they can be shared.</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通过API定义总结以下信息：</p>
<ol>
<li>使用final修饰，则不能被继承（该类中的成员方法默认都是final）</li>
<li>实现接口<code>Serializable</code>，说明可以进行序列化</li>
<li>实现接口<code>Comparable</code>,说明可以大小比较</li>
<li>实现接口<code>CharSequence</code>,说明String本身就是char类型的数组，而且通过成员变量定义可以进行佐证</li>
<li>通过char字符数组实现<a id="more"></a>

</li>
</ol>
<h2 id="如何创建字符串"><a href="#如何创建字符串" class="headerlink" title="如何创建字符串"></a>如何创建字符串</h2><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><p>直接赋值方式创建对象是在<font color="red">方法区的常量池。</font><br><code>String str = &quot;abc&quot;;</code></p>
<h3 id="使用new"><a href="#使用new" class="headerlink" title="使用new"></a>使用new</h3><p>通过构造方法创建字符串对象是在<font color="red">堆内存.  </font><br><code>String str = new String(&quot;abc&quot;);</code>  </p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p><code>String str = &quot;abc&quot; + &quot;bdc&quot;;</code></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str1 = <span class="string">&quot;sunld&quot;</span>;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;sunld&quot;</span>);</span><br><span class="line">        <span class="comment">//引用传递，str3直接指向st2的堆内存地址</span></span><br><span class="line">        String str3 = str2; </span><br><span class="line">        String str4 = <span class="string">&quot;sunld&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  ==:</span></span><br><span class="line"><span class="comment">         * 1. 基本数据类型：比较的是基本数据类型的值是否相同</span></span><br><span class="line"><span class="comment">         * 2. 引用数据类型：比较的是引用数据类型的地址值是否相同</span></span><br><span class="line"><span class="comment">         * 3. 所以在这里的话：String类对象==比较，比较的是地址，而不是内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">         System.out.println(str1==str3);<span class="comment">//false</span></span><br><span class="line">         System.out.println(str3==str2);<span class="comment">//true</span></span><br><span class="line">         System.out.println(str1==str4);<span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BString/1587630935534.png" class title="内存分配">

</div>

<blockquote>
<p>特殊说明</p>
<blockquote>
<ol>
<li>在使用new创建对象时，首先会在堆中的对象区域创建一个区域分配空间和完成初始化  </li>
<li>在使用字符串时，首先会判断字符串常量池中是否存在，否则则创建，然后堆对象会指向该字符串  </li>
<li>直接赋值：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。  </li>
<li>构造方法:会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public  String intern();方法进行手工入池。  </li>
<li>String类对象一旦声明则不可以改变；而改变的只是地址，原来的字符串还是存在的，并且产生垃圾  </li>
<li>当使用字符串拼接生成字符串时，如果在编译器就可以确定字符串，则使用==判断时则返回true  </li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//对匿名对象&quot;hello&quot;进行手工入池操作</span></span><br><span class="line">     String str =<span class="keyword">new</span> String(<span class="string">&quot;sunld&quot;</span>).intern();</span><br><span class="line">     String str1=<span class="string">&quot;sunld&quot;</span>;</span><br><span class="line">     System.out.println(str==str1);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String 使用final 修饰的字符数组进行存储，</span></span><br><span class="line"><span class="comment">* 并且字符串的长度和是否为空都是通过该数组的长度判断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Class String is special cased within the Serialization Stream Protocol.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* A String instance is written into an ObjectOutputStream according to</span></span><br><span class="line"><span class="comment">* &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../platform/serialization/spec/output.html&quot;&gt;</span></span><br><span class="line"><span class="comment">* Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><p>String内部是以char数组的形式存储，数组的长度是int类型，那么String允许的最大长度就是Integer.MAX_VALUE了。又由于java中的字符是以16位存储的，因此大概需要4GB的内存才能存储最大长度的字符串。不过这仅仅是对字符串变量而言，如果是字符串字面量(string literals)，如“abc”、”1a2b”之类写在代码中的字符串literals，那么允许的最大长度取决于字符串在常量池中的存储大小，也就是字符串在class格式文件中的存储格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">        u1 tag;</span><br><span class="line">        u2 length;</span><br><span class="line">        u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>u2是无符号的16位整数，因此理论上允许的string literal的最大长度是2^16-1=65535。然而实际测试表明，允许的最大长度仅为65534，超过就编译错误了，有兴趣可以写段代码试试，估计是length还不能为0。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;border-color:#bbb;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#bbb;color:#594F4F;background-color:#E0FFEB;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#bbb;color:#493F3F;background-color:#9DE0AD;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0lax">Constructor</th>
    <th class="tg-0lax"><span style="font-weight:400;font-style:normal">Description</span><br></th>
  </tr>
  <tr>
    <td class="tg-0lax">String()</td>
    <td class="tg-0lax">初始化新创建的 String对象，使其表示空字符序列。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes)</td>
    <td class="tg-0lax">通过使用平台的默认字符集解码指定的字节数组来构造新的 String 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes, Charset charset)</td>
    <td class="tg-0lax">构造一个新的String由指定用指定的字节的数组解码charset 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes, int offset, int length)</td>
    <td class="tg-0lax">通过使用平台的默认字符集解码指定的字节子阵列来构造新的 String 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes, int offset, int length, Charset charset)</td>
    <td class="tg-0lax">构造一个新的String通过使用指定的指定字节子阵列解码charset 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes, int offset, int length, String charsetName)</td>
    <td class="tg-0lax">构造一个新的 String通过使用指定的字符集解码指定的字节子阵列。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(byte[] bytes, String charsetName)</td>
    <td class="tg-0lax">构造一个新的String由指定用指定的字节的数组解码charset 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(char[] value)</td>
    <td class="tg-0lax">分配一个新的 String ，以便它表示当前包含在字符数组参数中的字符序列。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(char[] value, int offset, int count)</td>
    <td class="tg-0lax">分配一个新的 String ，其中包含字符数组参数的子阵列中的字符。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(int[] codePoints, int offset, int count)</td>
    <td class="tg-0lax">分配一个新的 String ，其中包含 Unicode code point数组参数的子阵列中的 字符 。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(String original)</td>
    <td class="tg-0lax">初始化新创建的String对象，使其表示与参数相同的字符序列<br>
    换句话说，新创建的字符串是参数字符串的副本。
    </td>
  </tr>
  <tr>
    <td class="tg-0lax">String(StringBuffer buffer)</td>
    <td class="tg-0lax">分配一个新的字符串，其中包含当前包含在字符串缓冲区参数中的字符序列。</td>
  </tr>
  <tr>
    <td class="tg-0lax">String(StringBuilder builder)</td>
    <td class="tg-0lax">分配一个新的字符串，其中包含当前包含在字符串构建器参数中的字符序列。</td>
  </tr>
</table>

<h3 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h3><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>比较字符串内容是否相同。重写Object类中的<code>equals</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Compares this string to the specified object.  The result is &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    * true&#125; if and only if the argument is not &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    * String&#125; object that represents the same sequence of characters as this</span></span><br><span class="line"><span class="comment">    * object.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  anObject</span></span><br><span class="line"><span class="comment">    *         The object to compare this &#123;<span class="doctag">@code</span> String&#125; against</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the given object represents a &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment">    *          equivalent to this string, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>  #compareTo(String)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>  #equalsIgnoreCase(String)</span></span><br><span class="line"><span class="comment">    * 判断对象存储内容是否相同</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;<span class="comment">// 首先判断是否属于同一对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 类型String----长度---数组中的字符</span></span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;<span class="comment">// 循环判断不等</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="equalsIgnoreCase"><a href="#equalsIgnoreCase" class="headerlink" title="equalsIgnoreCase"></a>equalsIgnoreCase</h4><p>比较字符串的内容是否相同,忽略大小写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Compares this &#123;<span class="doctag">@code</span> String&#125; to another &#123;<span class="doctag">@code</span> String&#125;, ignoring case</span></span><br><span class="line"><span class="comment">    * considerations.  Two strings are considered equal ignoring case if they</span></span><br><span class="line"><span class="comment">    * are of the same length and corresponding characters in the two strings</span></span><br><span class="line"><span class="comment">    * are equal ignoring case.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; Two characters &#123;<span class="doctag">@code</span> c1&#125; and &#123;<span class="doctag">@code</span> c2&#125; are considered the same</span></span><br><span class="line"><span class="comment">    * ignoring case if at least one of the following is true:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt; The two characters are the same (as compared by the</span></span><br><span class="line"><span class="comment">    *        &#123;<span class="doctag">@code</span> ==&#125; operator)</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt; Applying the method &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">    *        java.lang.Character#toUpperCase(char)&#125; to each character</span></span><br><span class="line"><span class="comment">    *        produces the same result</span></span><br><span class="line"><span class="comment">    *   &lt;li&gt; Applying the method &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">    *        java.lang.Character#toLowerCase(char)&#125; to each character</span></span><br><span class="line"><span class="comment">    *        produces the same result</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  anotherString</span></span><br><span class="line"><span class="comment">    *         The &#123;<span class="doctag">@code</span> String&#125; to compare this &#123;<span class="doctag">@code</span> String&#125; against</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the argument is not &#123;<span class="doctag">@code</span> null&#125; and it</span></span><br><span class="line"><span class="comment">    *          represents an equivalent &#123;<span class="doctag">@code</span> String&#125; ignoring case; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    *          false&#125; otherwise</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>  #equals(Object)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == anotherString) ? <span class="keyword">true</span></span><br><span class="line">            : (anotherString != <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; (anotherString.value.length == value.length)</span><br><span class="line">            &amp;&amp; regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if two string regions are equal.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * A substring of this &#123;<span class="doctag">@code</span> String&#125; object is compared to a substring</span></span><br><span class="line"><span class="comment">    * of the argument &#123;<span class="doctag">@code</span> other&#125;. The result is &#123;<span class="doctag">@code</span> true&#125; if these</span></span><br><span class="line"><span class="comment">    * substrings represent character sequences that are the same, ignoring</span></span><br><span class="line"><span class="comment">    * case if and only if &#123;<span class="doctag">@code</span> ignoreCase&#125; is true. The substring of</span></span><br><span class="line"><span class="comment">    * this &#123;<span class="doctag">@code</span> String&#125; object to be compared begins at index</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> toffset&#125; and has length &#123;<span class="doctag">@code</span> len&#125;. The substring of</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> other&#125; to be compared begins at index &#123;<span class="doctag">@code</span> ooffset&#125; and</span></span><br><span class="line"><span class="comment">    * has length &#123;<span class="doctag">@code</span> len&#125;. The result is &#123;<span class="doctag">@code</span> false&#125; if and only if</span></span><br><span class="line"><span class="comment">    * at least one of the following is true:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;&lt;li&gt;&#123;<span class="doctag">@code</span> toffset&#125; is negative.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;&#123;<span class="doctag">@code</span> ooffset&#125; is negative.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;&#123;<span class="doctag">@code</span> toffset+len&#125; is greater than the length of this</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> String&#125; object.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;&#123;<span class="doctag">@code</span> ooffset+len&#125; is greater than the length of the other</span></span><br><span class="line"><span class="comment">    * argument.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;&#123;<span class="doctag">@code</span> ignoreCase&#125; is &#123;<span class="doctag">@code</span> false&#125; and there is some nonnegative</span></span><br><span class="line"><span class="comment">    * integer &lt;i&gt;k&lt;/i&gt; less than &#123;<span class="doctag">@code</span> len&#125; such that:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * this.charAt(toffset+k) != other.charAt(ooffset+k)</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;&#123;<span class="doctag">@code</span> ignoreCase&#125; is &#123;<span class="doctag">@code</span> true&#125; and there is some nonnegative</span></span><br><span class="line"><span class="comment">    * integer &lt;i&gt;k&lt;/i&gt; less than &#123;<span class="doctag">@code</span> len&#125; such that:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * Character.toLowerCase(this.charAt(toffset+k)) !=</span></span><br><span class="line"><span class="comment">    Character.toLowerCase(other.charAt(ooffset+k))</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    * and:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * Character.toUpperCase(this.charAt(toffset+k)) !=</span></span><br><span class="line"><span class="comment">    *         Character.toUpperCase(other.charAt(ooffset+k))</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   ignoreCase   if &#123;<span class="doctag">@code</span> true&#125;, ignore case when comparing</span></span><br><span class="line"><span class="comment">    *                       characters.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   toffset      the starting offset of the subregion in this</span></span><br><span class="line"><span class="comment">    *                       string.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   other        the string argument.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   ooffset      the starting offset of the subregion in the string</span></span><br><span class="line"><span class="comment">    *                       argument.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   len          the number of characters to compare.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the specified subregion of this string</span></span><br><span class="line"><span class="comment">    *          matches the specified subregion of the string argument;</span></span><br><span class="line"><span class="comment">    *          &#123;<span class="doctag">@code</span> false&#125; otherwise. Whether the matching is exact</span></span><br><span class="line"><span class="comment">    *          or case insensitive depends on the &#123;<span class="doctag">@code</span> ignoreCase&#125;</span></span><br><span class="line"><span class="comment">    *          argument.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,</span></span></span><br><span class="line"><span class="function"><span class="params">        String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">    <span class="keyword">int</span> po = ooffset;</span><br><span class="line">    <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">            || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">            || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">        <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ignoreCase) &#123;</span><br><span class="line">            <span class="comment">// If characters don&#x27;t match but case may be ignored,</span></span><br><span class="line">            <span class="comment">// try converting both characters to uppercase.</span></span><br><span class="line">            <span class="comment">// If the results match, then the comparison scan should</span></span><br><span class="line">            <span class="comment">// continue.</span></span><br><span class="line">            <span class="keyword">char</span> u1 = Character.toUpperCase(c1);</span><br><span class="line">            <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">            <span class="keyword">if</span> (u1 == u2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Unfortunately, conversion to uppercase does not work properly</span></span><br><span class="line">            <span class="comment">// for the Georgian alphabet, which has strange rules about case</span></span><br><span class="line">            <span class="comment">// conversion.  So we need to make one last check before</span></span><br><span class="line">            <span class="comment">// exiting.</span></span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h4><p>判断字符串对象是否以指定的str开头。源码中表现为按照长度截断之后进行循环比对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if the substring of this string beginning at the</span></span><br><span class="line"><span class="comment">    * specified index starts with the specified prefix.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   prefix    the prefix.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   toffset   where to begin looking in this string.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the character sequence represented by the</span></span><br><span class="line"><span class="comment">    *          argument is a prefix of the substring of this object starting</span></span><br><span class="line"><span class="comment">    *          at index &#123;<span class="doctag">@code</span> toffset&#125;; &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">    *          The result is &#123;<span class="doctag">@code</span> false&#125; if &#123;<span class="doctag">@code</span> toffset&#125; is</span></span><br><span class="line"><span class="comment">    *          negative or greater than the length of this</span></span><br><span class="line"><span class="comment">    *          &#123;<span class="doctag">@code</span> String&#125; object; otherwise the result is the same</span></span><br><span class="line"><span class="comment">    *          as the result of the expression</span></span><br><span class="line"><span class="comment">    *          &lt;pre&gt;</span></span><br><span class="line"><span class="comment">    *          this.substring(toffset).startsWith(prefix)</span></span><br><span class="line"><span class="comment">    *          &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = prefix.value;</span><br><span class="line">    <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">    <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h4><p>判断字符串对象是否以指定的str结尾,源码中转换成<code>startsWith</code>处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if this string ends with the specified suffix.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   suffix   the suffix.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the character sequence represented by the</span></span><br><span class="line"><span class="comment">    *          argument is a suffix of the character sequence represented by</span></span><br><span class="line"><span class="comment">    *          this object; &#123;<span class="doctag">@code</span> false&#125; otherwise. Note that the</span></span><br><span class="line"><span class="comment">    *          result will be &#123;<span class="doctag">@code</span> true&#125; if the argument is the</span></span><br><span class="line"><span class="comment">    *          empty string or is equal to this &#123;<span class="doctag">@code</span> String&#125; object</span></span><br><span class="line"><span class="comment">    *          as determined by the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h3><h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p>获取字符串的长度，其实也就是字符个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the length of this string.</span></span><br><span class="line"><span class="comment">    * The length is equal to the number of &lt;a href=&quot;Character.html#unicode&quot;&gt;Unicode</span></span><br><span class="line"><span class="comment">    * code units&lt;/a&gt; in the string.</span></span><br><span class="line"><span class="comment">    * 返回字符串的长度，长度等于字符串中的Unicode代码单元的数目（UTF-16的代码单元的数目）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the length of the sequence of characters represented by this</span></span><br><span class="line"><span class="comment">    *          object.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h4><p>获取指定索引处的字符</p>
<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><p>获取str在字符串对象中第一次出现的索引</p>
<h4 id="substring-int-start-int-end"><a href="#substring-int-start-int-end" class="headerlink" title="substring(int start,int end)"></a>substring(int start,int end)</h4><p>从start开始，到end结束截取字符串。包括start，不包括end</p>
<h3 id="转换功能"><a href="#转换功能" class="headerlink" title="转换功能"></a>转换功能</h3><h4 id="toCharArray"><a href="#toCharArray" class="headerlink" title="toCharArray"></a>toCharArray</h4><p>把字符串转换为字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Converts this string to a new character array.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  a newly allocated character array whose length is the length</span></span><br><span class="line"><span class="comment">    *          of this string and whose contents are initialized to contain</span></span><br><span class="line"><span class="comment">    *          the character sequence represented by this string.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">    <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1. String 和Arrays 都属于rt.jar中的类，但是BootstrapClassloader在加载这两个类的顺序是不同的。</span></span><br><span class="line"><span class="comment">        * 2. 所以当String.class被加载进内存的时候,Arrays此时没有被加载，所以直接使用肯定会抛异常。</span></span><br><span class="line"><span class="comment">        * 3. 而System.arrayCopy是使用native代码，则不会有这个问题。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];</span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase"></a>toLowerCase</h4><p>把字符串转换为小写字符串</p>
<h4 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h4><p>把字符串转换为大写字符串</p>
<h3 id="其他常用"><a href="#其他常用" class="headerlink" title="其他常用"></a>其他常用</h3><h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><p>去除字符串两端空格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a string whose value is this string, with any leading and trailing</span></span><br><span class="line"><span class="comment">    * whitespace removed.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * If this &#123;<span class="doctag">@code</span> String&#125; object represents an empty character</span></span><br><span class="line"><span class="comment">    * sequence, or the first and last characters of character sequence</span></span><br><span class="line"><span class="comment">    * represented by this &#123;<span class="doctag">@code</span> String&#125; object both have codes</span></span><br><span class="line"><span class="comment">    * greater than &#123;<span class="doctag">@code</span> &#x27;\u005Cu0020&#x27;&#125; (the space character), then a</span></span><br><span class="line"><span class="comment">    * reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Otherwise, if there is no character with a code greater than</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> &#x27;\u005Cu0020&#x27;&#125; in the string, then a</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> String&#125; object representing an empty string is</span></span><br><span class="line"><span class="comment">    * returned.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Otherwise, let &lt;i&gt;k&lt;/i&gt; be the index of the first character in the</span></span><br><span class="line"><span class="comment">    * string whose code is greater than &#123;<span class="doctag">@code</span> &#x27;\u005Cu0020&#x27;&#125;, and let</span></span><br><span class="line"><span class="comment">    * &lt;i&gt;m&lt;/i&gt; be the index of the last character in the string whose code</span></span><br><span class="line"><span class="comment">    * is greater than &#123;<span class="doctag">@code</span> &#x27;\u005Cu0020&#x27;&#125;. A &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment">    * object is returned, representing the substring of this string that</span></span><br><span class="line"><span class="comment">    * begins with the character at index &lt;i&gt;k&lt;/i&gt; and ends with the</span></span><br><span class="line"><span class="comment">    * character at index &lt;i&gt;m&lt;/i&gt;-that is, the result of</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> this.substring(k, m + 1)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * This method may be used to trim whitespace (as defined above) from</span></span><br><span class="line"><span class="comment">    * the beginning and end of a string.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  A string whose value is this string, with any leading and trailing white</span></span><br><span class="line"><span class="comment">    *          space removed, or this string if it has no leading or</span></span><br><span class="line"><span class="comment">    *          trailing white space.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>按照指定符号分割字符串</p>
<h4 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Compares two strings lexicographically.</span></span><br><span class="line"><span class="comment">    * The comparison is based on the Unicode value of each character in</span></span><br><span class="line"><span class="comment">    * the strings. The character sequence represented by this</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> String&#125; object is compared lexicographically to the</span></span><br><span class="line"><span class="comment">    * character sequence represented by the argument string. The result is</span></span><br><span class="line"><span class="comment">    * a negative integer if this &#123;<span class="doctag">@code</span> String&#125; object</span></span><br><span class="line"><span class="comment">    * lexicographically precedes the argument string. The result is a</span></span><br><span class="line"><span class="comment">    * positive integer if this &#123;<span class="doctag">@code</span> String&#125; object lexicographically</span></span><br><span class="line"><span class="comment">    * follows the argument string. The result is zero if the strings</span></span><br><span class="line"><span class="comment">    * are equal; &#123;<span class="doctag">@code</span> compareTo&#125; returns &#123;<span class="doctag">@code</span> 0&#125; exactly when</span></span><br><span class="line"><span class="comment">    * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method would return &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * This is the definition of lexicographic ordering. If two strings are</span></span><br><span class="line"><span class="comment">    * different, then either they have different characters at some index</span></span><br><span class="line"><span class="comment">    * that is a valid index for both strings, or their lengths are different,</span></span><br><span class="line"><span class="comment">    * or both. If they have different characters at one or more index</span></span><br><span class="line"><span class="comment">    * positions, let &lt;i&gt;k&lt;/i&gt; be the smallest such index; then the string</span></span><br><span class="line"><span class="comment">    * whose character at position &lt;i&gt;k&lt;/i&gt; has the smaller value, as</span></span><br><span class="line"><span class="comment">    * determined by using the &amp;lt; operator, lexicographically precedes the</span></span><br><span class="line"><span class="comment">    * other string. In this case, &#123;<span class="doctag">@code</span> compareTo&#125; returns the</span></span><br><span class="line"><span class="comment">    * difference of the two character values at position &#123;<span class="doctag">@code</span> k&#125; in</span></span><br><span class="line"><span class="comment">    * the two string -- that is, the value:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * this.charAt(k)-anotherString.charAt(k)</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    * If there is no index position at which they differ, then the shorter</span></span><br><span class="line"><span class="comment">    * string lexicographically precedes the longer string. In this case,</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> compareTo&#125; returns the difference of the lengths of the</span></span><br><span class="line"><span class="comment">    * strings -- that is, the value:</span></span><br><span class="line"><span class="comment">    * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">    * this.length()-anotherString.length()</span></span><br><span class="line"><span class="comment">    * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   anotherString   the &#123;<span class="doctag">@code</span> String&#125; to be compared.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the value &#123;<span class="doctag">@code</span> 0&#125; if the argument string is equal to</span></span><br><span class="line"><span class="comment">    *          this string; a value less than &#123;<span class="doctag">@code</span> 0&#125; if this string</span></span><br><span class="line"><span class="comment">    *          is lexicographically less than the string argument; and a</span></span><br><span class="line"><span class="comment">    *          value greater than &#123;<span class="doctag">@code</span> 0&#125; if this string is</span></span><br><span class="line"><span class="comment">    *          lexicographically greater than the string argument.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 比较字符串大小，因为String实现了Comparable&lt;String&gt;接口，所有重写了compareTo方法</span></span><br><span class="line"><span class="comment">    * 2. 返回int类型，正数为大，负数为小，基于字符的ASSIC码比较</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2); <span class="comment">//获取长度比较小的字符串长度</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123; <span class="comment">//当前索引小于两个字符串中长度较小的字符串长度时，循环继续</span></span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2; <span class="comment">//从前向后遍历，有一个字符不相同，返回差值</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2; <span class="comment">//如果遍历结束，都相同，比较两个字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h2><p>在定义String时增加了<code>final</code>标记，并且存储数据的数组也被定义为<code>final</code>，则表示String一但创建就注定不可变。<strong>对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</strong></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式,每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。需要说明一点的是，在object中，equals()是用来比较内存地址的，但是String重写了equals()方法，用来比较内容的，即使是不同地址，只要内容一致，也会返回true，这也就是为什么a.equals(c)返回true的原因了。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。</li>
<li>安全性更高</li>
<li>传参与基础类型一样，更加直观</li>
</ol>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>后续会在JVM中进行详细的讲解。</p>
<h3 id="字符串常量池概述"><a href="#字符串常量池概述" class="headerlink" title="字符串常量池概述"></a>字符串常量池概述</h3><h4 id="常量池表（Constant-Pool-table）"><a href="#常量池表（Constant-Pool-table）" class="headerlink" title="常量池表（Constant_Pool table）"></a>常量池表（Constant_Pool table）</h4><ol>
<li>Class文件中存储所有常量（包括字符串）的table。</li>
<li>Class文件中的内容，不是运行内容，表示Class文件中的字节码指令</li>
</ol>
<h4 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h4><ol>
<li>JVM内存中方法区的一部分，这是运行时的内容</li>
<li>这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个Class对应一个运行时常量池</li>
<li>除了 Class中常量池内容，还可能包括动态生成并加入这里的内容</li>
</ol>
<h4 id="字符串常量池（String-Pool）"><a href="#字符串常量池（String-Pool）" class="headerlink" title="字符串常量池（String Pool）"></a>字符串常量池（String Pool）</h4><ol>
<li>这部分也在方法区中，但与Runtime Constant Pool不是一个概念，String Pool是JVM实例全局共享的，全局只有一个</li>
<li>JVM规范要求进入这里的String实例叫“被驻留的interned string”，各个JVM可以有不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。</li>
</ol>
<h3 id="亨元模式"><a href="#亨元模式" class="headerlink" title="亨元模式"></a>亨元模式</h3><p>字符串在使用过程中使用到了享元模式（一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素），而那个存储元素的地方就叫做“字符串常量池 - String Pool”</p>
<h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p><code>String str = &quot;hello&quot;;</code>的执行过程：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8BString/1587636643511.png" class title="String Pool的详细过程">

</div>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="String与StringBuffer、StringBuilder"><a href="#String与StringBuffer、StringBuilder" class="headerlink" title="String与StringBuffer、StringBuilder"></a>String与StringBuffer、StringBuilder</h3><ol>
<li>String是不可变的字符序列</li>
<li>StringBuffer和StringBuilder是可变的字符序列</li>
<li>StringBuffer是线程安全的，效率低</li>
<li>StringBuilder和String是线程不安全的，效率高一些，</li>
<li>效率从高到低：StringBuilder&gt;String&gt;StringBuffer</li>
</ol>
<h4 id="String循环拼接对象"><a href="#String循环拼接对象" class="headerlink" title="String循环拼接对象"></a>String循环拼接对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.string;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String string = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">			string += <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(string);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Test1.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">string</span>.<span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.sunld.string.Test1();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #16                 // String</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: iconst_0</span><br><span class="line">       <span class="number">4</span>: istore_2</span><br><span class="line">       <span class="number">5</span>: goto          <span class="number">31</span></span><br><span class="line">       8: new           #18                 // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">11</span>: dup</span><br><span class="line">      <span class="number">12</span>: aload_1</span><br><span class="line">      13: invokestatic  #20                 // Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">      16: invokespecial #26                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">      19: ldc           #29                 // String hello</span><br><span class="line">      21: invokevirtual #31                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #35                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">27</span>: astore_1</span><br><span class="line">      <span class="number">28</span>: iinc          <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">      <span class="number">31</span>: iload_2</span><br><span class="line">      <span class="number">32</span>: sipush        <span class="number">10000</span></span><br><span class="line">      <span class="number">35</span>: if_icmplt     <span class="number">8</span></span><br><span class="line">      38: getstatic     #39                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">41</span>: aload_1</span><br><span class="line">      42: invokevirtual #45                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">45</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8~35行是整个循环过程，并且每次都会new一个StringBuilder（String拼接被jvm优化为使用StringBuilder处理）</p>
<h4 id="使用StringBuilder"><a href="#使用StringBuilder" class="headerlink" title="使用StringBuilder"></a>使用StringBuilder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StringBuilder string = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">			string.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(string.toString());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Test2.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">string</span>.<span class="title">Test2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.sunld.string.Test2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #16                 // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokespecial #18                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: iconst_0</span><br><span class="line">       <span class="number">9</span>: istore_2</span><br><span class="line">      <span class="number">10</span>: goto          <span class="number">23</span></span><br><span class="line">      <span class="number">13</span>: aload_1</span><br><span class="line">      14: ldc           #19                 // String hello</span><br><span class="line">      16: invokevirtual #21                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      <span class="number">19</span>: pop</span><br><span class="line">      <span class="number">20</span>: iinc          <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">      <span class="number">23</span>: iload_2</span><br><span class="line">      <span class="number">24</span>: sipush        <span class="number">10000</span></span><br><span class="line">      <span class="number">27</span>: if_icmplt     <span class="number">13</span></span><br><span class="line">      30: getstatic     #25                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">33</span>: aload_1</span><br><span class="line">      34: invokevirtual #31                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      37: invokevirtual #35                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">40</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>13~27整个循环处理过程，只创建了一次对象。</p>
<h3 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h3><p>==在对字符串比较的时候，对比的是内存地址，而equals比较的是字符串内容，在开发的过程中，equals()通过接受参数，可以避免空指向<code>&quot;hello&quot;.equals(str)</code>。</p>
<h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>java中的String类是按照Unicode的方式进行编码，并且默认编码方式为UTF-16。使用字节的方式可以指定编码方式，以及编码方式的转换（<strong>转换不对会出现乱码问题</strong>）。并且不能的编码方式对应的数组长度不同。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String b = <span class="string">&quot;𝄞&quot;</span>;</span><br><span class="line">		System.out.println(b.length()); 	<span class="comment">//输出为2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过length的描述:知道返回的字符串长度时Unicode代码单元的数目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the length of this string.</span></span><br><span class="line"><span class="comment">    * The length is equal to the number of &lt;a href=&quot;Character.html#unicode&quot;&gt;Unicode</span></span><br><span class="line"><span class="comment">    * code units&lt;/a&gt; in the string.</span></span><br><span class="line"><span class="comment">    * 返回字符串的长度，长度等于字符串中的Unicode代码单元的数目（UTF-16的代码单元的数目）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the length of the sequence of characters represented by this</span></span><br><span class="line"><span class="comment">    *          object.</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>在java中的编码方式分为内码和外码：</p>
<ol>
<li>内码：char或string在内存中使用的编码方式，java中的使用utf16作为内码</li>
<li>外码：除内码都可以认为是外码，包括class文件的编码</li>
</ol>
<blockquote>
<p>代码单元：一种转换格式（UTF）中最小的一个分隔，称为一个代码单元（code unit），一个转换公式只会包含整数个单元。UTF-X中的X表示各自码单元的位数。<br>UTF-16，可以包含一个单元和两个单元，也就是两个字节和四个字节</p>
</blockquote>
<h4 id="替代方案：codePointCount"><a href="#替代方案：codePointCount" class="headerlink" title="替代方案：codePointCount"></a>替代方案：codePointCount</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the number of Unicode code points in the specified text</span></span><br><span class="line"><span class="comment">    * range of this &#123;<span class="doctag">@code</span> String&#125;. The text range begins at the</span></span><br><span class="line"><span class="comment">    * specified &#123;<span class="doctag">@code</span> beginIndex&#125; and extends to the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> char&#125; at index &#123;<span class="doctag">@code</span> endIndex - 1&#125;. Thus the</span></span><br><span class="line"><span class="comment">    * length (in &#123;<span class="doctag">@code</span> char&#125;s) of the text range is</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> endIndex-beginIndex&#125;. Unpaired surrogates within</span></span><br><span class="line"><span class="comment">    * the text range count as one code point each.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beginIndex the index to the first &#123;<span class="doctag">@code</span> char&#125; of</span></span><br><span class="line"><span class="comment">    * the text range.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> endIndex the index after the last &#123;<span class="doctag">@code</span> char&#125; of</span></span><br><span class="line"><span class="comment">    * the text range.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the number of Unicode code points in the specified text</span></span><br><span class="line"><span class="comment">    * range</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span> IndexOutOfBoundsException if the</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> beginIndex&#125; is negative, or &#123;<span class="doctag">@code</span> endIndex&#125;</span></span><br><span class="line"><span class="comment">    * is larger than the length of this &#123;<span class="doctag">@code</span> String&#125;, or</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> beginIndex&#125; is larger than &#123;<span class="doctag">@code</span> endIndex&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">    * 可以使用该方法返回字符串的准确长度（相对于length方法）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span> || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/zhangyinhua/p/7689974.html#_lab2_0_1">Java常用类（二）String类详解</a></li>
<li><a href="https://blog.csdn.net/qq_34691713/article/details/92572843">String源码分析（基于JDK1.8)</a></li>
<li><a href="https://www.cnblogs.com/benbenalin/p/7152570.html">刨根究底字符编码之十四——UTF-16究竟是怎么编码的</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
</search>
