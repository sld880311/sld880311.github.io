<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Javap详解</title>
    <url>/2021/02/04/Javap%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>javap 命令用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息,输出堆栈大小、各方法的 locals 及 args 数。</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -<span class="keyword">public</span>                  仅显示公共类和成员</span><br><span class="line">  -<span class="keyword">protected</span>               显示受保护的/公共类和成员</span><br><span class="line">  -<span class="keyword">package</span>                 显示程序包/受保护的/公共类和成员 (默认)</span><br><span class="line">  -p  -<span class="keyword">private</span>             显示所有类和成员</span><br><span class="line">  -c                       输出类中各方法的未解析的代码，即构成 Java 字节码的指令。</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置,如果设置了该选项，则它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置,缺省情况下，自举类是实现核心 Java 平台的类，位于 jrelibt.jar 和 jrelibi18n.jar 中。</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPassByValue</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> temp1 = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">this</span>.passInt(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passInt</span><span class="params">(<span class="keyword">int</span> abc)</span> </span>&#123; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String temp = <span class="string">&quot;abcddd&quot;</span>;</span><br><span class="line">		PassByValue val = <span class="keyword">new</span> PassByValue();</span><br><span class="line">		<span class="keyword">this</span>.passObject(val, temp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passObject</span><span class="params">(PassByValue passByValue, String value)</span> </span>&#123; </span><br><span class="line">		passByValue = <span class="keyword">null</span>;</span><br><span class="line">		value = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValue</span></span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="javap分析"><a href="#javap分析" class="headerlink" title="javap分析"></a>javap分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.TestPassByValue包含com.sunld.TestPassByValue</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/TestPassByValue.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">4</span>-<span class="number">29</span>; size <span class="number">939</span> bytes</span><br><span class="line">  MD5 checksum ae6cce5733ce01797de9d8ae30359bdd</span><br><span class="line">  Compiled from <span class="string">&quot;TestPassByValue.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">TestPassByValue</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/TestPassByValue</span><br><span class="line">   #2 = Utf8               com/sunld/TestPassByValue</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               temp1</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Methodref          #3.#11         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #11 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #12 = Fieldref           #1.#13         // com/sunld/TestPassByValue.temp1:I</span><br><span class="line">  #13 = NameAndType        #5:#6          // temp1:I</span><br><span class="line">  #14 = Utf8               LineNumberTable</span><br><span class="line">  #15 = Utf8               LocalVariableTable</span><br><span class="line">  #16 = Utf8               this</span><br><span class="line">  #17 = Utf8               Lcom/sunld/TestPassByValue;</span><br><span class="line">  #18 = Utf8               doPassInt</span><br><span class="line">  #19 = Methodref          #1.#20         // com/sunld/TestPassByValue.passInt:(I)V</span><br><span class="line">  #20 = NameAndType        #21:#22        // passInt:(I)V</span><br><span class="line">  #21 = Utf8               passInt</span><br><span class="line">  #22 = Utf8               (I)V</span><br><span class="line">  #23 = Utf8               temp</span><br><span class="line">  #24 = Utf8               abc</span><br><span class="line">  #25 = Utf8               doPassObject</span><br><span class="line">  #26 = String             #27            // abcddd</span><br><span class="line">  #27 = Utf8               abcddd</span><br><span class="line">  #28 = Class              #29            // com/sunld/PassByValue</span><br><span class="line">  #29 = Utf8               com/sunld/PassByValue</span><br><span class="line">  #30 = Methodref          #28.#11        // com/sunld/PassByValue.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #31 = Methodref          #1.#32         // com/sunld/TestPassByValue.passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #32 = NameAndType        #33:#34        // passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #33 = Utf8               passObject</span><br><span class="line">  #34 = Utf8               (Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #35 = Utf8               Ljava/lang/String;</span><br><span class="line">  #36 = Utf8               val</span><br><span class="line">  #37 = Utf8               Lcom/sunld/PassByValue;</span><br><span class="line">  #38 = String             #39            // value</span><br><span class="line">  #39 = Utf8               value</span><br><span class="line">  #40 = Utf8               passByValue</span><br><span class="line">  #41 = Utf8               SourceFile</span><br><span class="line">  #42 = Utf8               TestPassByValue.java</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//默认的构造方法，在构造方法执行时主要完成一些初始化操作，包括一些成员变量的初始化赋值等操作</span></span><br><span class="line">  <span class="keyword">public</span> com.sunld.TestPassByValue();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">//*load_*：将本地变量表中索引为*的局部变量加载到操作栈</span></span><br><span class="line">         <span class="comment">//从本地变量表中加载索引为0的变量的值到操作栈，也即this的引用，压入栈</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="comment">//invokespecial：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）</span></span><br><span class="line">         <span class="comment">//出栈，调用java/lang/Object.&quot;&lt;init&gt;&quot;:()V 初始化对象，就是this指定的对象的init()方法完成初始化</span></span><br><span class="line">         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="comment">// 4到7表示，完成this.temp1 = 10的赋值。这里this引用入栈</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="comment">//将常量10加入到操作数栈</span></span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="comment">//出栈前面压入的两个值（this引用，常量值10）， 将10取出，并赋值给temp1</span></span><br><span class="line">         7: putfield      #12                 // Field temp1:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      <span class="comment">//指令与代码行数的偏移对应关系，每一行第一个数字对应代码行数，第二个数字对应前面code中指令前面的数字</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">3</span>: <span class="number">10</span></span><br><span class="line">      <span class="comment">//局部变量表，start+length表示这个变量在字节码中的生命周期起始和结束的偏移位置（this生命周期从头0到结尾10）</span></span><br><span class="line">      <span class="comment">//slot就是这个变量在局部变量表中的槽位（槽位可复用），name就是变量名称，Signatur局部变量类型描述</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassInt</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// 常量100入栈</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="comment">// 将一个数值从操作数栈存储到局部变量表,存储100给temp</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="comment">// 加载this入栈</span></span><br><span class="line">         <span class="number">3</span>: aload_0</span><br><span class="line">         <span class="comment">// temp入栈</span></span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         5: invokevirtual #19                 // Method passInt:(I)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">3</span>       <span class="number">6</span>     <span class="number">1</span>  temp   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passInt</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">1</span>   abc   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassObject</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// 从常量池取出abcddd入栈</span></span><br><span class="line">         0: ldc           #26                 // String abcddd</span><br><span class="line">         <span class="comment">// 出栈赋值给temp</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="comment">// 创建PassByValue对象，将引用压入栈</span></span><br><span class="line">         3: new           #28                 // class com/sunld/PassByValue</span><br><span class="line">         <span class="comment">// 将操作数栈顶的数据复制一份，并压入栈，此时栈中有两个引用值（目前有两个PassByValue的引用）</span></span><br><span class="line">         <span class="number">6</span>: dup</span><br><span class="line">         7: invokespecial #30                 // Method com/sunld/PassByValue.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="comment">// 出栈栈顶数据（对象PassByValue）复制给val</span></span><br><span class="line">        <span class="number">10</span>: astore_2</span><br><span class="line">        <span class="comment">// 入栈this</span></span><br><span class="line">        <span class="number">11</span>: aload_0</span><br><span class="line">        <span class="comment">// 入栈val</span></span><br><span class="line">        <span class="number">12</span>: aload_2</span><br><span class="line">        <span class="comment">// 入栈temp</span></span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        14: invokevirtual #31                 // Method passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">        <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">18</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">3</span>      <span class="number">15</span>     <span class="number">1</span>  temp   Ljava/lang/String;</span><br><span class="line">           <span class="number">11</span>       <span class="number">7</span>     <span class="number">2</span>   val   Lcom/sunld/PassByValue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passObject</span><span class="params">(com.sunld.PassByValue, java.lang.String)</span></span>;</span><br><span class="line">    descriptor: (Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: aconst_null</span><br><span class="line">         <span class="number">1</span>: astore_1</span><br><span class="line">         2: ldc           #38                 // String value</span><br><span class="line">         <span class="number">4</span>: astore_2</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span> passByValue   Lcom/sunld/PassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">2</span> value   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestPassByValue.java&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.jianshu.com/p/6a8997560b05">通过javap命令分析java汇编指令</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>Javap</tag>
        <tag>Class分析</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之内部类</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>定义：外部类内部定义的类，类名不需要与文件名不同</li>
<li>static修饰（静态内部类）</li>
<li>作用域（public、default、protected、private）</li>
<li>作用范围：编译期概念，一但编译成功就是有不同的class文件（outer.class和outer$inner.class），所以内部类的成员变量/方法名可以和外部类的相同。</li>
<li>分类：静态内部类，成员内部类，局部内部类，匿名内部类四种。</li>
</ol>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>Ø 在一个方法内部使用<br>Ø 在方法的一个作用域中使用<br>Ø 一个匿名类，用于实现一个接口<br>Ø 一个匿名类，用于扩展拥有非默认构造器的类<br>Ø 一个匿名类，用于执行字段初始化<br>Ø 一个匿名类，通过实例初始化进行构建（匿名内部类不能拥有构造器)  </p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>一个内部类的对象能够访问创建它的对象的实现，包括私有数据。即内部类实例对包含它的哪个类的实例来说，是特权的。</li>
<li>对于同一个包中的其他类来说,内部类能够隐藏起来,换句话说，内部类不管方法的可见性如何，那怕是public，除了包容类，其他类都无法使用它。</li>
<li>匿名内部类可以很方便的定义回调。</li>
<li>使用内部类可以非常方便的编写事件驱动程序。</li>
</ol>
<h2 id="静态内部类-嵌套内部类"><a href="#静态内部类-嵌套内部类" class="headerlink" title="静态内部类/嵌套内部类"></a>静态内部类/嵌套内部类</h2><ol>
<li>被static修饰的内部类</li>
<li>不需要维护与外部类的对象的关系（可以直接引用，比如：outer.inner），一般不会出现内存泄漏的问题</li>
<li>嵌套类和普通的内部类还有一个区别：普通内部类不能有static数据和static属性，也不能包含嵌套类，但嵌套类可以。</li>
<li>作用域修饰符：不能声明为private，一般声明为public，方便调用。</li>
<li>静态内部类可以访问外部类所有的静态变量和方法，包括private</li>
<li>静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</li>
<li>其它类使用静态内部类需要使用“外部类.静态内部类”方式</li>
<li>Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象， HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">11</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.err.println(a);</span><br><span class="line"><span class="comment">//			System.err.println(b); // 编译出错</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printInner1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.err.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StaticInnerClass.Inner.printInner();</span><br><span class="line">		StaticInnerClass.Inner inner = <span class="keyword">new</span> StaticInnerClass.Inner();</span><br><span class="line">		inner.printInner1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员内部类：定义在类内部的非静态类，就是成员内部类"><a href="#成员内部类：定义在类内部的非静态类，就是成员内部类" class="headerlink" title="成员内部类：定义在类内部的非静态类，就是成员内部类"></a>成员内部类：定义在类内部的非静态类，就是成员内部类</h2><ol>
<li>成员内部类，就是作为外部类的成员，可以直接使用外部类的所有成员和方法，即使是private的。</li>
<li>同时外部类要访问内部类的所有成员变量/方法，则需要通过内部类的对象来获取。<br>要注意的是，成员内部类不能含有static的方法和变量（final 修饰的除外）。<strong>因为成员内部类需要先创建了外部类，才能创建它自己的</strong>，成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</li>
<li>在成员内部类要引用外部类对象时，使用outer.this来表示外部类对象；</li>
<li>而需要创建内部类对象，可以使用outer.inner  obj = outerobj.new inner();</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">		Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">		inner.print(<span class="string">&quot;Outer.new&quot;</span>);</span><br><span class="line">		inner = outer.getInner();</span><br><span class="line">		inner.print(<span class="string">&quot;Outer.get&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 个人推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类：内部类定义在方法和作用域内"><a href="#局部内部类：内部类定义在方法和作用域内" class="headerlink" title="局部内部类：内部类定义在方法和作用域内"></a>局部内部类：内部类定义在方法和作用域内</h2><p>定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutScope</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类（要继承一个父类或者实现一个接口、直接使用-new-来生成一个对象的引用）"><a href="#匿名内部类（要继承一个父类或者实现一个接口、直接使用-new-来生成一个对象的引用）" class="headerlink" title="匿名内部类（要继承一个父类或者实现一个接口、直接使用 new 来生成一个对象的引用）"></a>匿名内部类（要继承一个父类或者实现一个接口、直接使用 new 来生成一个对象的引用）</h2><p>匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。<br>有时候我为了免去给内部类命名，便倾向于使用匿名内部类，因为它没有名字。例如：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/screenshot_1587209816208.png" class title="反射知识点">

</div>

<p>匿名内部类是不能加访问修饰符的。<strong>要注意的是，new匿名类，这个类是要先定义的</strong>，看下面例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousOuter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnonymousOuter outer = <span class="keyword">new</span> AnonymousOuter();</span><br><span class="line">		Inner inner = outer.getInner(<span class="string">&quot;Inner&quot;</span>, <span class="string">&quot;gz&quot;</span>);</span><br><span class="line">		System.out.println(inner.getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, String city)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner() &#123;</span><br><span class="line">			<span class="keyword">private</span> String nameStr = name;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> nameStr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注释后，编译时提示类Inner找不到 </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="在使用匿名内部类时，要记住以下几个原则"><a href="#在使用匿名内部类时，要记住以下几个原则" class="headerlink" title="在使用匿名内部类时，要记住以下几个原则"></a>在使用匿名内部类时，要记住以下几个原则</h3><p>Ø 匿名内部类不能有构造方法。<br>Ø 匿名内部类不能定义任何静态成员、方法和类。<br>Ø 匿名内部类不能是public,protected,private,static<br>Ø 只能创建匿名内部类的一个实例。<br>Ø 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。<br>Ø 因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。<br>Ø 当所在的方法的形参需要被内部类里面使用时，该形参必须为final</p>
<h3 id="使用final修饰入参的原因"><a href="#使用final修饰入参的原因" class="headerlink" title="使用final修饰入参的原因"></a>使用final修饰入参的原因</h3><p>“这是一个编译器设计的问题，如果你了解java的编译原理的话很容易理解。<br>首先，内部类被编译的时候会生成一个单独的内部类的.class文件，这个文件并不与外部类在同一class文件中。<br>当外部类传的参数被内部类调用时，从java程序的角度来看是直接的调用例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">(<span class="keyword">final</span> String a,<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123; </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dosome</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;System.out.println(a+b)&#125;&#125;;</span><br><span class="line">  Dosome some=<span class="keyword">new</span> Dosome(); </span><br><span class="line">  some.dosome(); </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>从代码来看好像是那个内部类直接调用的a参数和b参数，但是实际上不是，在java编译器编译以后实际的操作代码是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$<span class="title">Dosome</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dosome</span><span class="params">(<span class="keyword">final</span> String a,<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.Dosome$a=a;</span><br><span class="line">  <span class="keyword">this</span>.Dosome$b=b;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.Dosome$a+<span class="keyword">this</span>.Dosome$b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码看来，内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数。 </p>
<p>这样理解就很容易得出为什么要用final了，因为两者从外表看起来是同一个东西，实际上却不是这样，如果内部类改掉了这些参数的值也不可能影响到原参数，然而这样却失去了参数的一致性，因为从编程人员的角度来看他们是同一个东西，如果编程人员在程序设计的时候在内部类中改掉参数的值，但是外部调用的时候又发现值其实没有被改掉，这就让人非常的难以理解和接受，为了避免这种尴尬的问题存在，所以编译器设计人员把内部类能够使用的参数设定为必须是final来规避这种莫名其妙错误的存在。”</p>
<blockquote>
<p>(简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变)</p>
</blockquote>
<h3 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer1</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Outer1 outer = <span class="keyword">new</span> Outer1(); </span><br><span class="line">		Inner1 inner = outer.getInner(<span class="string">&quot;Inner&quot;</span>, <span class="string">&quot;gz&quot;</span>); </span><br><span class="line">		System.out.println(inner.getName()); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner1 <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, String city)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner1(name, city) &#123; </span><br><span class="line">			<span class="keyword">private</span> String nameStr = name; </span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">return</span> nameStr; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span> </span>&#123; </span><br><span class="line">	Inner1(String name, String city) &#123; </span><br><span class="line">		System.out.println(city); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>注意这里的形参city，由于它没有被匿名内部类直接使用，而是被抽象类Inner的构造函数所使用，所以不必定义为final。<br>而匿名内部类通过实例初始化，可以达到类似构造器的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer2</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Outer2 outer = <span class="keyword">new</span> Outer2(); </span><br><span class="line">		Inner2 inner = outer.getInner(<span class="string">&quot;Inner&quot;</span>, <span class="string">&quot;gz&quot;</span>); </span><br><span class="line">		System.out.println(inner.getName()); </span><br><span class="line">		System.out.println(inner.getProvince()); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner2 <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> String city)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner2() &#123;</span><br><span class="line">			<span class="keyword">private</span> String nameStr = name; </span><br><span class="line">			<span class="keyword">private</span> String province; </span><br><span class="line">			<span class="comment">// 实例初始化 </span></span><br><span class="line">			&#123; </span><br><span class="line">				<span class="keyword">if</span> (city.equals(<span class="string">&quot;gz&quot;</span>)) &#123; </span><br><span class="line">					province = <span class="string">&quot;gd&quot;</span>; </span><br><span class="line">				&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">					province = <span class="string">&quot;&quot;</span>; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">return</span> nameStr; </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">return</span> province; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner2</span> </span>&#123; </span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="function">String <span class="title">getProvince</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="内部类继承"><a href="#内部类继承" class="headerlink" title="内部类继承"></a>内部类继承</h2><p>内部类的继承，是指内部类被继承，普通类 extents 内部类。而这时候代码上要有点特别处理，具体看以下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.class1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123; </span><br><span class="line">	<span class="comment">// InheritInner() 是不能通过编译的，一定要加上形参 </span></span><br><span class="line">	InheritInner(WithInner wi) &#123; </span><br><span class="line">		wi.<span class="keyword">super</span>(); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		WithInner wi = <span class="keyword">new</span> WithInner(); </span><br><span class="line">		InheritInner obj = <span class="keyword">new</span> InheritInner(wi); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123; </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以看到子类的构造函数里面要使用<strong>父类的外部类对象.super()</strong>;而这个对象需要从外面创建并传给形参.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之泛型</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>泛型在JDK1.5引入，其本质是一种<strong>参数化类型（Parameterized Type），在使用时传入实际类型即可</strong>，即可以将操作的数据类型指定为方法签名中的一种特殊参数,可以作用在类、接口、方法中。泛型是编译期的一种概念，主要是用于编译期类型安全检查（编译之后泛型会被擦除）。</p>
<h3 id="常用泛型类型常量"><a href="#常用泛型类型常量" class="headerlink" title="常用泛型类型常量"></a>常用泛型类型常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E：元素（Element），多用于java集合框架</span><br><span class="line">K：关键字（Key）</span><br><span class="line">N：数字（Number）</span><br><span class="line">T：类型（Type）</span><br><span class="line">V：值（Value）</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="泛型反例"><a href="#泛型反例" class="headerlink" title="泛型反例"></a>泛型反例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		list.add(<span class="number">100</span>);</span><br><span class="line">		list.add(<span class="number">10.09</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">			System.out.println((String)list.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译期通过，并且运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">	at com.sunld.Test1.main(Test1.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>
<p><strong>如何在编译期完成校验？</strong></p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>与泛型类的定义类似，参考代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方式1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类的声明与非泛型类的类似，在类的名称后面增加类型参数。语法如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">className</span>&lt;泛型标识 <span class="keyword">extends</span>|<span class="title">super</span> 上限|下限, ...&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> genericType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。如果上限或下限有多个限制，可以使用<code>&amp;</code>处理。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。简单示例：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>一种可以接受不同参数类型的方法，并且可以根据入参进行参数返回，尤其是反射处理数据转换比较常用。</p>
<blockquote>
<p>注意：方法上是否定义泛型和类上是否定义没有必然的联系</p>
</blockquote>
<p>语法参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 第一个T表示泛型声明，只有声明之后才能使用</span></span><br><span class="line"><span class="comment">* 2. 第二个T表示返回值</span></span><br><span class="line"><span class="comment">* 3.第三个T限制入参的返回需要与第一个T一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">executeGenericMethod</span><span class="params">(Class&lt;T&gt; cls)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cls.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>泛型是编译期的概念，在编译之后的字节码中不包含泛型的信息（为了解决该问题，java在字节码中引入Signature、LocalVariableTypeTable）。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为<strong>类型擦除</strong>。比如：<code>List&lt;Object&gt;</code>和 <code>List&lt;String&gt;</code>等类型，在编译之后都会变成 <code>List</code>。JVM 看到的只是 List，而由泛型附加的类型信息对JVM来说是不可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericType2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> temp1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> temp2 =<span class="number">20</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> temp3=<span class="number">30</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment">//	public T getT() &#123;</span></span><br><span class="line"><span class="comment">//		return t;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public void setT(T t) &#123;</span></span><br><span class="line"><span class="comment">//		this.t = t;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public List&lt;String&gt; getList() &#123;</span></span><br><span class="line"><span class="comment">//		return list;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public void setList(List&lt;String&gt; list) &#123;</span></span><br><span class="line"><span class="comment">//		this.list = list;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">		map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;valueaa&quot;</span>);</span><br><span class="line">		String value = map.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//		TestGenericType2&lt;Integer&gt;[] array = new TestGenericType2&lt;Integer&gt;[10];</span></span><br><span class="line"><span class="comment">//		TestGenericType2&lt;Integer&gt;[] array1 = new TestGenericType2[10];</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后的结果：  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.TestGenericType2包含com.sunld.TestGenericType2</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/TestGenericType2.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">5</span>-<span class="number">14</span>; size <span class="number">1287</span> bytes</span><br><span class="line">  MD5 checksum 7ad53533c7723c97d0ec9bb863b415ca</span><br><span class="line">  Compiled from <span class="string">&quot;TestGenericType2.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">TestGenericType2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span>&gt; <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/TestGenericType2</span><br><span class="line">   #2 = Utf8               com/sunld/TestGenericType2</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               t</span><br><span class="line">   #6 = Utf8               Ljava/lang/Object;</span><br><span class="line">   #7 = Utf8               Signature</span><br><span class="line">   #8 = Utf8               TT;</span><br><span class="line">   #9 = Utf8               list</span><br><span class="line">  #10 = Utf8               Ljava/util/List;</span><br><span class="line">  #11 = Utf8               Ljava/util/List&lt;Ljava/lang/String;&gt;;</span><br><span class="line">  #12 = Utf8               temp1</span><br><span class="line">  #13 = Utf8               I</span><br><span class="line">  #14 = Utf8               temp2</span><br><span class="line">  #15 = Utf8               ConstantValue</span><br><span class="line">  #16 = Integer            20</span><br><span class="line">  #17 = Utf8               temp3</span><br><span class="line">  #18 = Integer            30</span><br><span class="line">  #19 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #20 = Utf8               ()V</span><br><span class="line">  #21 = Utf8               Code</span><br><span class="line">  #22 = Fieldref           #1.#23         // com/sunld/TestGenericType2.temp1:I</span><br><span class="line">  #23 = NameAndType        #12:#13        // temp1:I</span><br><span class="line">  #24 = Utf8               LineNumberTable</span><br><span class="line">  #25 = Utf8               LocalVariableTable</span><br><span class="line">  #26 = Utf8               &lt;init&gt;</span><br><span class="line">  #27 = Methodref          #3.#28         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #28 = NameAndType        #26:#20        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #29 = Fieldref           #1.#30         // com/sunld/TestGenericType2.temp2:I</span><br><span class="line">  #30 = NameAndType        #14:#13        // temp2:I</span><br><span class="line">  #31 = Utf8               this</span><br><span class="line">  #32 = Utf8               Lcom/sunld/TestGenericType2;</span><br><span class="line">  #33 = Utf8               LocalVariableTypeTable</span><br><span class="line">  #34 = Utf8               Lcom/sunld/TestGenericType2&lt;TT;&gt;;</span><br><span class="line">  #35 = Utf8               main</span><br><span class="line">  #36 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #37 = Class              #38            // java/util/HashMap</span><br><span class="line">  #38 = Utf8               java/util/HashMap</span><br><span class="line">  #39 = Methodref          #37.#28        // java/util/HashMap.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #40 = String             #41            // a</span><br><span class="line">  #41 = Utf8               a</span><br><span class="line">  #42 = String             #43            // valueaa</span><br><span class="line">  #43 = Utf8               valueaa</span><br><span class="line">  #44 = InterfaceMethodref #45.#47        // java/util/Map.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #45 = Class              #46            // java/util/Map</span><br><span class="line">  #46 = Utf8               java/util/Map</span><br><span class="line">  #47 = NameAndType        #48:#49        // put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #48 = Utf8               put</span><br><span class="line">  #49 = Utf8               (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #50 = InterfaceMethodref #45.#51        // java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #51 = NameAndType        #52:#53        // get:(Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #52 = Utf8               get</span><br><span class="line">  #53 = Utf8               (Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">  #54 = Class              #55            // java/lang/String</span><br><span class="line">  #55 = Utf8               java/lang/String</span><br><span class="line">  #56 = Utf8               args</span><br><span class="line">  #57 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #58 = Utf8               map</span><br><span class="line">  #59 = Utf8               Ljava/util/Map;</span><br><span class="line">  #60 = Utf8               value</span><br><span class="line">  #61 = Utf8               Ljava/lang/String;</span><br><span class="line">  #62 = Utf8               Ljava/util/Map&lt;Ljava/lang/String;Ljava/lang/String;&gt;;</span><br><span class="line">  #63 = Utf8               SourceFile</span><br><span class="line">  #64 = Utf8               TestGenericType2.java</span><br><span class="line">  #65 = Utf8               &lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         2: putstatic     #22                 // Field temp1:I</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.sunld.TestGenericType2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #27                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">         7: putfield      #29                 // Field temp2:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">10</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestGenericType2;</span><br><span class="line">      LocalVariableTypeTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestGenericType2&lt;TT;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #37                 // class java/util/HashMap</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #39                 // Method java/util/HashMap.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         9: ldc           #40                 // String a</span><br><span class="line">        11: ldc           #42                 // String valueaa</span><br><span class="line">        13: invokeinterface #44,  3           // InterfaceMethod java/util/Map.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">        <span class="number">18</span>: pop</span><br><span class="line">        <span class="number">19</span>: aload_1</span><br><span class="line">        20: ldc           #40                 // String a</span><br><span class="line">        22: invokeinterface #50,  2           // InterfaceMethod java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">        27: checkcast     #54                 // class java/lang/String</span><br><span class="line">        <span class="number">30</span>: astore_2</span><br><span class="line">        <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">45</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">46</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">47</span>: <span class="number">19</span></span><br><span class="line">        line <span class="number">50</span>: <span class="number">31</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">32</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>   map   Ljava/util/Map;</span><br><span class="line">           <span class="number">31</span>       <span class="number">1</span>     <span class="number">2</span> value   Ljava/lang/String;</span><br><span class="line">      LocalVariableTypeTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>   map   Ljava/util/Map&lt;Ljava/lang/String;Ljava/lang/String;&gt;;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestGenericType2.java&quot;</span></span><br><span class="line">Signature: #65                          // &lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</span><br></pre></td></tr></table></figure>
<p>从Signature属性的得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们在编码时能通过反射手段取得参数化类型的根本依据。</p>
<h3 id="擦除过程"><a href="#擦除过程" class="headerlink" title="擦除过程"></a>擦除过程</h3><p>首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</p>
<h3 id="泛型擦除的问题"><a href="#泛型擦除的问题" class="headerlink" title="泛型擦除的问题"></a>泛型擦除的问题</h3><ol>
<li>用泛型不可以区分方法签名</li>
<li>泛型类的静态变量是共享</li>
</ol>
<h2 id="泛型边界"><a href="#泛型边界" class="headerlink" title="泛型边界"></a>泛型边界</h2><ol>
<li><? extends T>表示该通配符所代表的类型是 T 类型的子类。</li>
<li><? super T>表示该通配符所代表的类型是 T 类型的父类。

</li>
</ol>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符?</h3><p>在java中如果使用泛型，例如<code>List&lt;Interger&gt;和List&lt;Number&gt;</code>其实是两种类型(<strong>类型之间转换会出现转换异常</strong>)，之间没有任务关系，如果想要接收不同类型的参数，则需要引入通配符的概念，<code>List&lt;?&gt;</code>（？表示所有泛型中的父类）<strong>泛型内是不存在父子关系，但是利用通配符可以产生类似的效果</strong>。</p>
<h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><p>假设给定的泛型类型为G,两个具体的泛型参数X、Y，当中Y是X的子类</p>
<ol>
<li>G&lt;? extends Y&gt; 是 G&lt;? extends X&gt;的子类型</li>
<li>G<X> 是 G&lt;? extends X&gt;的子类型</X></li>
<li>G&lt;?&gt; 与 G&lt;? extends Object&gt;等同</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>适用于多种数据类型执行相同的代码（代码复用）</li>
<li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li>
</ol>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol>
<li>不能实例化泛型类：<code>T t = new T();</code></li>
<li>静态变量不能引用泛型变量：<code>private static T t1;</code>；非静态变量可以引用：<code>private T t1;</code></li>
<li>未声明泛型的方法不能引用泛型变量：<code>public static T getT1()&#123;return t1;&#125;</code>；声明之后可以：<code>public static &lt;T&gt; T executeGenericMethod(Class&lt;T&gt; cls)&#123;return null;&#125;</code></li>
<li>基本类型无法作为泛型类型：<code>List&lt;int&gt; list = new ArrayList&lt;&gt;();</code></li>
<li>无法使用instanceof关键字或==判断泛型类的类型：<code>list instanceof List&lt;String&gt;</code> 或者<code>list == List&lt;String&gt;</code></li>
<li>泛型类的原生类型与所传递的泛型无关，无论传递什么类型，原生类是一样的，即类型擦除之后的class信息相同</li>
<li>泛型数组可以声明但无法实例化：<code>Test1&lt;Integer&gt;[] array = new Test1&lt;Integer&gt;[10];</code>，去掉泛型即可<code>Test1&lt;Integer&gt;[] array = new Test1[10];</code></li>
<li>泛型类不能继承Exception或者Throwable</li>
<li>不能捕获泛型类型限定的异常但可以将泛型限定的异常抛出</li>
</ol>
<h3 id="泛型继承规则"><a href="#泛型继承规则" class="headerlink" title="泛型继承规则"></a>泛型继承规则</h3><ol>
<li>对于泛型参数是继承关系的泛型类之间是没有继承关系的：<code>List&lt;Integer&gt;与List&lt;Number&gt;</code></li>
<li>泛型类可以继承其它泛型类，例如: <code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</code></li>
<li>泛型类的继承关系在使用中同样会受到泛型类型的影响</li>
</ol>
<h2 id="泛型与反射"><a href="#泛型与反射" class="headerlink" title="泛型与反射"></a>泛型与反射</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericType1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestGenericType1&lt;Integer&gt; a = <span class="keyword">new</span> TestGenericType1&lt;Integer&gt;() &#123;&#125;;</span><br><span class="line">		Type superclass = a.getClass().getGenericSuperclass();</span><br><span class="line">		System.out.println(superclass);</span><br><span class="line">	    <span class="comment">//getActualTypeArguments 返回确切的泛型参数</span></span><br><span class="line">		Type type = ((ParameterizedType)superclass).getActualTypeArguments()[<span class="number">0</span>]; </span><br><span class="line">	    System.out.println(type);<span class="comment">//class java.lang.Integer</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/ldh-better/p/7127308.html#_label0">Java 泛型在实际开发中的应用</a></li>
<li><a href="https://www.jianshu.com/p/986f732ed2f1">Java泛型详解</a></li>
<li><a href="https://www.cnblogs.com/lwbqqyumidi/p/3837629.html">Java总结篇系列：Java泛型</a></li>
<li><a href="https://www.cnblogs.com/coprince/p/8603492.html">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之注解</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>在jdk1.5中引入了注解的概念，注解是Java提供的一种对类信息（包括：类、属性与方法）进行扩展的一种行为。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation 对象，然后通过该 Annotation 对象来获取注解中的元数据信息。通过使用注解，可以将元数据保存在 Java 源代码中。并拥有如下优势：</p>
<ol>
<li>简单易读的代码，</li>
<li>编译器类型检查，</li>
<li>使用 annotation API 为自己的注解构造处理工具。</li>
</ol>
<a id="more"></a>
<p>JDK中目前引入的注解：</p>
<ul>
<li><strong>@Override</strong>：表示当前的方法定义将覆盖基类的方法。如果你不小心拼写错误，或者方法签名被错误拼写的时候，编译器就会发出错误提示。</li>
<li><strong>@Deprecated</strong>：如果使用该注解的元素被调用，编译器就会发出警告信息。</li>
<li><strong>@SuppressWarnings</strong>：关闭不当的编译器警告信息。</li>
<li><strong>@SafeVarargs</strong>：在 Java 7 中加入用于禁止对具有泛型varargs参数的方法或构造函数的调用方发出警告。</li>
<li><strong>@FunctionalInterface</strong>：Java 8 中加入用于表示类型声明为函数式接口</li>
</ul>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/1588840779124.png" class title="1588840779124.png">

</div>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>jdk中目前定义了5中标准的meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>@Target</td>
<td>表示注解可以用于哪些地方。可能的 <strong>ElementType</strong> 参数包括：<br><strong>CONSTRUCTOR</strong>：构造器的声明<br><strong>FIELD</strong>：字段声明（包括 enum 实例）<br><strong>LOCAL_VARIABLE</strong>：局部变量声明<br><strong>METHOD</strong>：方法声明<br><strong>PACKAGE</strong>：包声明<br><strong>PARAMETER</strong>：参数声明<br><strong>TYPE</strong>：类、接口（包括注解类型）或者 enum 声明</td>
</tr>
<tr>
<td>@Retention</td>
<td>表示注解信息保存的时长。可选的 <strong>RetentionPolicy</strong> 参数包括：<br><strong>SOURCE</strong>：注解将被编译器丢弃<br><strong>CLASS</strong>：注解在 class 文件中可用，但是会被 VM 丢弃。<br><strong>RUNTIME</strong>：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</td>
</tr>
<tr>
<td>@Documented</td>
<td>将此注解保存在 Javadoc 中</td>
</tr>
<tr>
<td>@Inherited</td>
<td>允许子类继承父类的注解</td>
</tr>
<tr>
<td>@Repeatable</td>
<td>允许一个注解可以被使用一次或者多次（Java 8）。</td>
</tr>
</tbody></table>
<h3 id="Target修饰的对象范围"><a href="#Target修饰的对象范围" class="headerlink" title="@Target修饰的对象范围"></a>@Target修饰的对象范围</h3><p><strong>@Target</strong>说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的作用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Retention定义被保留的时间长短"><a href="#Retention定义被保留的时间长短" class="headerlink" title="@Retention定义被保留的时间长短"></a>@Retention定义被保留的时间长短</h3><p><strong>@Retention</strong> 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：</p>
<ol>
<li>SOURCE:在源文件中有效（即源文件保留）</li>
<li>CLASS:在 class 文件中有效（即 class 保留）</li>
<li>RUNTIME:在运行时有效（即运行时保留）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体作用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Documented描述-javadoc"><a href="#Documented描述-javadoc" class="headerlink" title="@Documented描述-javadoc"></a>@Documented描述-javadoc</h3><p><strong>@Documented</strong> 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inherited阐述了某个被标注的类型是被继承的"><a href="#Inherited阐述了某个被标注的类型是被继承的" class="headerlink" title="@Inherited阐述了某个被标注的类型是被继承的"></a>@Inherited阐述了某个被标注的类型是被继承的</h3><p><strong>@Inherited</strong> 元注解是一个标记注解，**@Inherited** 阐述了某个被标注的类型是被继承的。如果一个使用了**@Inherited** 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该 class 的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span></span><br><span class="line"><span class="comment">     * repeatable annotation type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the containing annotation type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过注解实现一种日志记录的方式。</p>
<h3 id="LogAnnotation定义"><a href="#LogAnnotation定义" class="headerlink" title="LogAnnotation定义"></a>LogAnnotation定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation &#123;</span><br><span class="line">	<span class="comment">/** 日志类型 **/</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">	<span class="comment">/** 日志内容 **/</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">content</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@LogAnnotation(content = &quot;用户登录日志信息&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解元数据解析"><a href="#注解元数据解析" class="headerlink" title="注解元数据解析"></a>注解元数据解析</h3><p>getDeclaredMethods() 和 getAnnotation()，它们都属于 AnnotatedElement 接口（Class，Method 与 Field 类都实现了该接口）。getAnnotation() 方法返回指定类型的注解对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationUtil</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getLogInfo</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">		<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">			<span class="keyword">if</span> (method.isAnnotationPresent(LogAnnotation.class)) &#123;</span><br><span class="line">				LogAnnotation annotation = method.getAnnotation(LogAnnotation.class);</span><br><span class="line">				<span class="comment">// 注解信息的处理地方</span></span><br><span class="line">				System.out.println(annotation.content() + <span class="string">&quot; 类型：&quot;</span> + annotation.type());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		AnnotationUtil.getLogInfo(Login.class); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="默认值问题"><a href="#默认值问题" class="headerlink" title="默认值问题"></a>默认值问题</h3><ol>
<li>元素不能有不确定的值：要么使用默认值要么使用代码中定义的值</li>
<li>非基本类型的原始不能定义null，可以使用自定义约束来进行实现</li>
</ol>
<h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>单元测试</li>
<li>数据库相关的ORM操作</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://lingcoder.github.io/OnJava8/#/book/23-Annotations?id=%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95">编程思想</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse使用技巧</title>
    <url>/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="集成javap命令"><a href="#集成javap命令" class="headerlink" title="集成javap命令"></a>集成javap命令</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li>eclipse中点击工具栏: Run &gt; External Tools &gt; External Tools Configuration</li>
<li>双击”程序”</li>
<li>修改配置</li>
</ol>
<div align="center">

<img src="/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1588039059895.png" class title="执行javap">

</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Name: javap(随意)</span><br><span class="line">location: jdk实际路径</span><br><span class="line">Working Directory:$&#123;workspace_loc&#125;\$&#123;project_name&#125; （不要改）</span><br><span class="line">Arguments:-c -verbose  -classpath  $&#123;workspace_loc&#125;/ $&#123;project_name&#125;/bin/$&#123;java_type_name&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><div align="center">

<img src="/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1588039225454.png" class title="eclipse配置">

</div>

<h3 id="javap的命令说明"><a href="#javap的命令说明" class="headerlink" title="javap的命令说明"></a>javap的命令说明</h3><p>参考《<a href="https://www.sunliaodong.cn/2021/02/04/Javap%E8%AF%A6%E8%A7%A3/">javap详解</a>》</p>
<h2 id="debug使用技巧"><a href="#debug使用技巧" class="headerlink" title="debug使用技巧"></a>debug使用技巧</h2><h3 id="常用快捷键说明"><a href="#常用快捷键说明" class="headerlink" title="常用快捷键说明"></a>常用快捷键说明</h3><ol>
<li>Step Into (also F5) 跳入</li>
<li>Step Over (also F6) 跳过</li>
<li>Step Return (also F7) 执行完当前method，然后return跳出此method</li>
<li>step Filter 逐步过滤 一直执行直到遇到未经过滤的位置或断点(设置Filter:window-preferences-java-Debug-step Filtering)</li>
<li>resume 重新开始执行debug,一直运行直到遇到breakpoint</li>
<li>hit count 设置执行次数 适合程序中的for循环(设置 breakpoint view-右键hit count)</li>
<li>inspect 检查 运算。执行一个表达式显示执行值</li>
<li>watch 实时地监视变量的变化</li>
<li>我们常说的断点(breakpoints)是指line breakpoints,除了line breakpoints,还有其他的断点类型：field(watchpoint)breakpoint,method breakpoint,exception breakpoint.</li>
<li>field breakpoint 也叫watchpoint(监视点) 当成员变量被读取或修改时暂挂</li>
<li>添加method breakpoint 进入/离开此方法时暂挂(Run-method breakpoint)</li>
<li>添加Exception breakpoint 捕抓到Execption时暂挂(待续…)</li>
</ol>
<h3 id="断点属性"><a href="#断点属性" class="headerlink" title="断点属性"></a>断点属性</h3><ol>
<li>hit count 执行多少次数后暂挂 用于循环</li>
<li>enable condition 遇到符合你输入条件(为ture\改变时)就暂挂</li>
<li>suspend thread 多线程时暂挂此线程</li>
<li>suspend VM 暂挂虚拟机</li>
<li>variables 视图里的变量可以改变变量值，在variables 视图选择变量点击右键–change value.一次来进行快速调试。</li>
<li>debug 过程中修改了某些code后–〉save&amp;build–&gt;resume–&gt;重新暂挂于断点</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">  MyDate aa = <span class="keyword">new</span> MyDate();</span><br><span class="line">  aa.addDays(day);                      =============》(<span class="number">1</span>)</span><br><span class="line">  System.out.println(<span class="string">&quot;eeeeeeeeeeeeeee&quot;</span>);=============》(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">addDays</span><span class="params">(<span class="keyword">int</span> more_days)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);               =============》(<span class="number">3</span>)</span><br><span class="line">    String result = <span class="string">&quot;&quot;</span>;         =============》(<span class="number">4</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);               =============》(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>你在(1)处加断点，运行到此处时如果Step Into (also F5)为跳入，则接着执行到(3)。再执行Step Over (also F6)执行本行，则执行到(4)。最后执行Step Return (also F7)，则跳出addDays方法，跳到(2)</p>
<h2 id="配置-author"><a href="#配置-author" class="headerlink" title="配置@author"></a>配置@author</h2><ol>
<li>eclipse-&gt;window-&gt;preference-&gt;java-&gt;code  styple-&gt;code template-&gt;Code-&gt;New Java files </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">点击 Edit </span><br><span class="line">$&#123;filecomment&#125;</span><br><span class="line">$&#123;package_declaration&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 孙辽东</span></span><br><span class="line"><span class="comment">* <span class="doctag">@E</span>-mail:sld880311@126.com</span></span><br><span class="line"><span class="comment">* <span class="doctag">@qq</span>:767768553</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 创建时间：$&#123;date&#125; $&#123;time&#125;</span></span><br><span class="line"><span class="comment">* 简单说明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$&#123;typecomment&#125;</span><br><span class="line">$&#123;type_declaration&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在建立类文件的时候输入“/**”的时候自动出来的：eclipse-&gt;window-&gt;preference-&gt;java-&gt;code  styple-&gt;code template-&gt;comments-&gt;typles,点击 Edit ，就可以根据自己需要编写了</li>
</ol>
]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>git详解</title>
    <url>/2021/02/04/git%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="提交本地工程到github"><a href="#提交本地工程到github" class="headerlink" title="提交本地工程到github"></a>提交本地工程到github</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;注释&quot;</span></span><br><span class="line">git remote add origin https://github.com/sld880311/parkspaceagent</span><br><span class="line"></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="comment">#如果出现fatal: refusing to merge unrelated histories</span></span><br><span class="line">使用如下命令 git pull origin master --allow-unrelated-histories</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="代码提交示意图"><a href="#代码提交示意图" class="headerlink" title="代码提交示意图"></a>代码提交示意图</h3><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589535948892.png" class title="git代码提交示意图">

</div>

<h3 id="官方参考图"><a href="#官方参考图" class="headerlink" title="官方参考图"></a>官方参考图</h3><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589535987537.png" class title="git官网提交提示图">

</div>

<h2 id="使用图解"><a href="#使用图解" class="headerlink" title="使用图解"></a>使用图解</h2><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589536030194.png" class title="git命令使用详解">

</div>

<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h3><h4 id="–-filename"><a href="#–-filename" class="headerlink" title="– filename"></a>– filename</h4><p>把filename文件在工作区的修改撤销到最近一次git add 或 git commit时的内容。</p>
<h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。</p>
<p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</p>
<p>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</p>
<p>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p>
<h2 id="分支详解"><a href="#分支详解" class="headerlink" title="分支详解"></a>分支详解</h2><h2 id="忽略文件参考"><a href="#忽略文件参考" class="headerlink" title="忽略文件参考"></a>忽略文件参考</h2><p>在工程下建立文件.gitignore,复制以下内容  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.ear</span><br><span class="line"></span><br><span class="line"># ignore Maven generated target folders</span><br><span class="line">target</span><br><span class="line"></span><br><span class="line"># ignore eclipse files</span><br><span class="line">.project</span><br><span class="line">.classpath</span><br><span class="line">.settings</span><br><span class="line">.metadata</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/shih/p/6826743.html">git重要的三个命令stash, checkout, reset的一些总结</a></li>
<li><a href="https://blog.csdn.net/hughgilbert/article/details/70473348">Git学习（三）——staging area 工作原理</a></li>
<li><a href="https://segmentfault.com/q/1010000007679514">git中stash的工作原理是什么？</a></li>
<li><a href="https://blog.csdn.net/chenj_freedom/article/details/50543152">git教程 - 概念 原理 使用</a></li>
<li><a href="https://www.cnblogs.com/houpeiyong/p/5890748.html">git revert和git reset的区别</a></li>
<li><a href="https://blog.csdn.net/hudashi/article/details/7664460">代码回滚：git reset、git checkout和git revert区别和联系</a></li>
<li><a href="https://blog.csdn.net/ibingow/article/details/7541402">git reflog</a></li>
</ol>
]]></content>
      <categories>
        <category>常用工具</category>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+github+next部署个人博客</title>
    <url>/2021/02/03/%E4%BD%BF%E7%94%A8hexo-github-next%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"><span class="comment"># 修改原</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 改回去</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>
<h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>使用npm安装hexo(<a href="https://hexo.io/zh-cn/">详细文档</a>)，命令是<code>npm install -g hexo-cli</code>,安装完成之后初始化博客,命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir sld880311.github.io</span><br><span class="line"><span class="built_in">cd</span> sld880311.github.io</span><br><span class="line">hexo init </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>初始化完成之后目录结构如下：<a id="more"></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 网站的配置信息，您可以在此配置大部分的参数。 </span></span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds <span class="comment"># 模版文件夹</span></span><br><span class="line">├── <span class="built_in">source</span>  <span class="comment"># 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span></span><br><span class="line">|   ├── _drafts <span class="comment"># 草稿文件</span></span><br><span class="line">|   └── _posts <span class="comment"># 文章Markdowm文件 </span></span><br><span class="line">└── themes  <span class="comment"># 主题文件夹</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s         <span class="comment"># 启动服务，然后可以使用 http://localhost:4000访问</span></span><br><span class="line">hexo init      <span class="comment">#生成文档</span></span><br><span class="line">hexo g         <span class="comment">#生成网页</span></span><br><span class="line">hexo clean     <span class="comment">#清除网页</span></span><br><span class="line">hexo d         <span class="comment">#部署博客</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h2 id="特殊配置"><a href="#特殊配置" class="headerlink" title="特殊配置"></a>特殊配置</h2><h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>获取<code>cat ~/.ssh/id_rsa.pub</code>中的数据，如果没有数据需要按照以下命令配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;sunliaodong&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;sld880311@hotmail.com&quot;</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;sld880311@hotmail.com&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后把生成的key添加中自己的github中即可。</p>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><h4 id="修改根目录下的-config-yml"><a href="#修改根目录下的-config-yml" class="headerlink" title="修改根目录下的_config.yml"></a>修改根目录下的_config.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/sld880311/sld880311.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h4 id="安装部署插件hexo-deployer-git"><a href="#安装部署插件hexo-deployer-git" class="headerlink" title="安装部署插件hexo-deployer-git"></a>安装部署插件hexo-deployer-git</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h4 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<h3 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h3><h4 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<h4 id="修改根目录的-config-yml"><a href="#修改根目录的-config-yml" class="headerlink" title="修改根目录的_config.yml"></a>修改根目录的_config.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章字数统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="修改主题-config-yml"><a href="#修改主题-config-yml" class="headerlink" title="修改主题_config.yml"></a>修改主题_config.yml</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br><span class="line">  item_text_post: <span class="literal">true</span></span><br><span class="line">  item_text_total: <span class="literal">true</span></span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>
<h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章名称&quot;</span>      <span class="comment"># 使用命令创建文章</span></span><br><span class="line">hexo new page categories  <span class="comment"># 定义分类</span></span><br><span class="line">hexo new page tags        <span class="comment"># 定义标签</span></span><br><span class="line">hexo new page about       <span class="comment"># 定义关于</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://theme-next.iissnan.com/">theme-next.iissnan</a></li>
<li><a href="https://theme-next.js.org/docs/">theme-next.js</a></li>
<li><a href="https://www.jianshu.com/p/446ec02bb0a8">Hexo+Next搭建个人博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/185015237">hexo之主题优化篇</a></li>
<li><a href="https://segmentfault.com/a/1190000017986794">超详细Hexo+Github Page搭建技术博客教程【持续更新】</a></li>
<li><a href="https://blog.csdn.net/u014786530/article/details/103548737">Hexo+NexT搭建个人博客</a></li>
<li><a href="https://blog.csdn.net/qq_40930491/article/details/87902310">从头开始搭建hexo+github+hexo-theme-next主题博客（高级设置）</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>（Singleton Pattern、单态模式、单件模式、对象创建型模式），单例模式的特点：</p>
<ol>
<li>构造方法私有化；(不能被实例化和继承)</li>
<li>实例化的变量引用私有化；</li>
<li>获取实例的方法共有。</li>
</ol>
<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><ol>
<li>唯一的对象实例</li>
<li>保证一个类仅有一个实例，并提供一个访问他的全局访问点</li>
<li>有状态（可变的单例对象，可以组成状态仓库）、无状态（工具类）</li>
</ol>
<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>在下面的情况下可以使用Singleton模式：</p>
<ol>
<li>当类只能有一个实例而且客户可以从一个总所周知的访问点访问它时。</li>
<li>当这个唯一实例应该是通过子类可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
<li>系统只需要一个实例的对象，而这个对象又会被经常创建。</li>
</ol>
<a id="more"></a>

<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><div align="center">

<img src="/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1588206615300.png" class title="单例模式结构图">

</div>

<h2 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h2><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><ol>
<li>定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作。</li>
<li>可能负责创建它自己的唯一实例。</li>
</ol>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="懒汉模式（延迟加载）"><a href="#懒汉模式（延迟加载）" class="headerlink" title="懒汉模式（延迟加载）"></a>懒汉模式（延迟加载）</h3><h4 id="普通实现-非线程安全"><a href="#普通实现-非线程安全" class="headerlink" title="普通实现-非线程安全"></a>普通实现-非线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：非线程安全</p>
</blockquote>
<h4 id="锁在方法上-synchronized-线程安全"><a href="#锁在方法上-synchronized-线程安全" class="headerlink" title="锁在方法上(synchronized)-线程安全"></a>锁在方法上(synchronized)-线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：线程安全，效率低</p>
</blockquote>
<h4 id="同步代码块（synchronized）-线程不安全"><a href="#同步代码块（synchronized）-线程不安全" class="headerlink" title="同步代码块（synchronized）-线程不安全"></a>同步代码块（synchronized）-线程不安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton1.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：线程安全，效率低</p>
</blockquote>
<h4 id="DCL模式实现-线程安全"><a href="#DCL模式实现-线程安全" class="headerlink" title="DCL模式实现-线程安全"></a>DCL模式实现-线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 防止重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton1.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++ ) &#123;</span><br><span class="line">			es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() </span><br><span class="line">							+  Singleton1.getInstance());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="为什么需要使用volatile"><a href="#为什么需要使用volatile" class="headerlink" title="为什么需要使用volatile"></a>为什么需要使用volatile</h5><p><code>instance = new Singleton()</code>主要是完成了以下三个事情</p>
<ol>
<li>给instance实例分配内存；</li>
<li>初始化instance的构造器；</li>
<li>将instance对象指向分配的内存空间（注意到这步时instance就非null了）</li>
</ol>
<p>JVM会进行指令优化为：  </p>
<ol>
<li>给instance实例分配内存；</li>
<li>将instance对象指向分配的内存空间；—会出现线程安全问题</li>
<li>初始化instance的构造器；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.Singleton1包含com.sunld.Singleton1</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/Singleton1.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">4</span>-<span class="number">30</span>; size <span class="number">620</span> bytes</span><br><span class="line">  MD5 checksum 69d5cbecd81034e77060fee87c23526c</span><br><span class="line">  Compiled from <span class="string">&quot;Singleton1.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">Singleton1</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/Singleton1</span><br><span class="line">   #2 = Utf8               com/sunld/Singleton1</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               instance</span><br><span class="line">   #6 = Utf8               Lcom/sunld/Singleton1;</span><br><span class="line">   #7 = Utf8               &lt;clinit&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Fieldref           #1.#11         // com/sunld/Singleton1.instance:Lcom/sunld/Singleton1;</span><br><span class="line">  #11 = NameAndType        #5:#6          // instance:Lcom/sunld/Singleton1;</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Methodref          #3.#16         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = NameAndType        #14:#8         // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #17 = Utf8               this</span><br><span class="line">  #18 = Utf8               getInstance</span><br><span class="line">  #19 = Utf8               ()Lcom/sunld/Singleton1;</span><br><span class="line">  #20 = Methodref          #1.#16         // com/sunld/Singleton1.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Utf8               StackMapTable</span><br><span class="line">  #22 = Class              #23            // java/lang/Class</span><br><span class="line">  #23 = Utf8               java/lang/Class</span><br><span class="line">  #24 = Class              #25            // java/lang/Throwable</span><br><span class="line">  #25 = Utf8               java/lang/Throwable</span><br><span class="line">  #26 = Utf8               SourceFile</span><br><span class="line">  #27 = Utf8               Singleton1.java</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: aconst_null</span><br><span class="line">         1: putstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.sunld.<span class="function">Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()Lcom/sunld/Singleton1;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">         <span class="number">3</span>: ifnonnull     <span class="number">35</span></span><br><span class="line">         6: ldc           #1                  // class com/sunld/Singleton1</span><br><span class="line">         <span class="number">8</span>: dup</span><br><span class="line">         <span class="number">9</span>: astore_0</span><br><span class="line">        <span class="number">10</span>: monitorenter</span><br><span class="line">        11: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">14</span>: ifnonnull     <span class="number">27</span></span><br><span class="line">        17: new           #1                  // class com/sunld/Singleton1</span><br><span class="line">        <span class="number">20</span>: dup</span><br><span class="line">        21: invokespecial #20                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        24: putstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">27</span>: aload_0</span><br><span class="line">        <span class="number">28</span>: monitorexit</span><br><span class="line">        <span class="number">29</span>: goto          <span class="number">35</span></span><br><span class="line">        <span class="number">32</span>: aload_0</span><br><span class="line">        <span class="number">33</span>: monitorexit</span><br><span class="line">        <span class="number">34</span>: athrow</span><br><span class="line">        35: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">38</span>: areturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">            <span class="number">11</span>    <span class="number">29</span>    <span class="number">32</span>   any</span><br><span class="line">            <span class="number">32</span>    <span class="number">34</span>    <span class="number">32</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">17</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">27</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">35</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">3</span></span><br><span class="line">        frame_type = <span class="number">252</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">27</span></span><br><span class="line">          locals = [ class java/lang/Class ]</span><br><span class="line">        frame_type = <span class="number">68</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Singleton1.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="饿汉模式（立即加载）"><a href="#饿汉模式（立即加载）" class="headerlink" title="饿汉模式（立即加载）"></a>饿汉模式（立即加载）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论:</p>
<ol>
<li>线程安全</li>
<li>在获取变量的过程中不能有其他操作，以防出现线程安全问题</li>
</ol>
</blockquote>
<h3 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ObjectStreamException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonInner</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner1</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> SingletonInner instance = <span class="keyword">new</span> SingletonInner();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInner1.instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 防止序列化之后变成多例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ObjectStreamException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">readResoObject</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInner1.instance;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++ ) &#123;</span><br><span class="line">			es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() </span><br><span class="line">							+  SingletonInner.getInstance());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举实现单例"><a href="#枚举实现单例" class="headerlink" title="枚举实现单例"></a>枚举实现单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//私有化构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">	<span class="comment">//定义一个静态枚举类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个枚举对象，该对象天生为单例</span></span><br><span class="line">        INSTANCE;</span><br><span class="line">		<span class="keyword">private</span> EnumSingleton enumSingleton;</span><br><span class="line">		<span class="comment">//私有化枚举的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        	enumSingleton = <span class="keyword">new</span> EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enumSingleton;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对外暴露一个获取EnumSingleton对象的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstnce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：<br>枚举可以解决反序列化会破坏单例的问题</p>
<blockquote>
<p>在枚举序列化的时候，Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。</p>
</blockquote>
</blockquote>
<h3 id="单例注册工厂"><a href="#单例注册工厂" class="headerlink" title="单例注册工厂"></a>单例注册工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonRegistryFactory</span> <span class="keyword">implements</span> <span class="title">FactoryInterface</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity = <span class="number">50</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonRegistryFactory singleRegistry = <span class="keyword">new</span> SingletonRegistryFactory();</span><br><span class="line">	<span class="comment">//保证线程安全</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String,Object&gt; singletonCache = Collections.synchronizedMap(<span class="keyword">new</span> LRULinkedHashMap&lt;String, Object&gt;(maxCapacity));</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 私有构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonRegistryFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonRegistryFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> singleRegistry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.singletonCache.get(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object sharedBean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.put(beanName, sharedBean);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.clear();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>客户职能通过Singleton的Instance操作访问一个Singleton的实例。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="对唯一实例的受控访问"><a href="#对唯一实例的受控访问" class="headerlink" title="对唯一实例的受控访问"></a>对唯一实例的受控访问</h3><p>因为Singleton类封装它的唯一实例，所以它可以严格的控制客户怎样以及何时访问它。</p>
<h3 id="缩小名空间"><a href="#缩小名空间" class="headerlink" title="缩小名空间"></a>缩小名空间</h3><p>Singleton模式是对全局变量的一种改进。它避免了那些存储唯一实例的全局变量污染名空间。</p>
<h3 id="允许对操作和表示的精化"><a href="#允许对操作和表示的精化" class="headerlink" title="允许对操作和表示的精化"></a>允许对操作和表示的精化</h3><p>Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时刻配置应用。</p>
<h3 id="允许可变数目的实例"><a href="#允许可变数目的实例" class="headerlink" title="允许可变数目的实例"></a>允许可变数目的实例</h3><p>这个模式使得你易于改变你的想法，并允许Singleton类的多个实例。此外，你可以用相同的方法来控制应用所使用的实例的数目。只允许访问Singleton实例的操作需要改变。</p>
<h3 id="比类操作更灵活"><a href="#比类操作更灵活" class="headerlink" title="比类操作更灵活"></a>比类操作更灵活</h3><p>另一种封装单件功能的方式是使用类操作。但这种语言技术难以改变设计你允许一个类有多个实例。此外，静态成员函数不是虚函数，因此子类不能多态的重定义它们。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>实例控制，保证实例的唯一性</li>
<li>灵活性，因为类控制了实例化过程，所以类可以灵活更改实例化过程。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>需要提供详细文档提供开发者使用，防止开发混乱</li>
<li>不能解决删除单个对象的问题，可以使用缓存管理技术管理单例对象</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="保证一个唯一的实例"><a href="#保证一个唯一的实例" class="headerlink" title="保证一个唯一的实例"></a>保证一个唯一的实例</h3><p>Singleton模式使得这个唯一实例是类的一般实例，但该类被写成只有一个实例能被创建。做到这一点的一个常用方法是将创建这个实例的操作隐藏在一个类操作后面，由它保证只有一个实例被创建。这个操作可以访问保存唯一实例的变量，而且它可以保证这个变量在返回值之前用这个唯一实例初始化。这种方法保证了单件在它的首次使用前被创建和使用。</p>
<h3 id="创建Singleton类的子类"><a href="#创建Singleton类的子类" class="headerlink" title="创建Singleton类的子类"></a>创建Singleton类的子类</h3><p>主要问题与其说是定义子类不如说是建立它的唯一实例，这样客户就可以使用它。事实上，指向单件实例的变量必须用子类的实例进行初始化。最简单的技术是在Singleton的Instance操作中决定你想使用的是哪一个单件。  </p>
<p>另一个选择Singleton的子类的方法是将Instance的实现从父类中分离出来，将它放入子类。<br>一个更灵活的方法是使用一个单件注册表（registry of singleton）。可能的Singleton类的集合不是由Instance定义的，Singleton类可以根据名字在一个众所周知的注册表中注册它们的单件实例。<br>这个注册表在字符串名字和单件之间建立映射。当Instance需要一个单件时，它参考注册表，根据名字请求单件。</p>
<h2 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h2><p>各种工具类的使用，建议使用缓存技术管理单例对象</p>
<h3 id="Spring框架中实现的例子"><a href="#Spring框架中实现的例子" class="headerlink" title="Spring框架中实现的例子"></a>Spring框架中实现的例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework.adapter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Singleton to publish a shared DefaultAdvisorAdapterRegistry instance.</span></span><br><span class="line"><span class="comment"> * 抽象化类使其不可实例化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DefaultAdvisorAdapterRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvisorAdapterRegistry</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Keep track of a single instance so we can return it to classes that request it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AdvisorAdapterRegistry instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the singleton &#123;<span class="doctag">@link</span> DefaultAdvisorAdapterRegistry&#125; instance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AdvisorAdapterRegistry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Reset the singleton &#123;<span class="doctag">@link</span> DefaultAdvisorAdapterRegistry&#125;, removing any</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> AdvisorAdapterRegistry#registerAdvisorAdapter(AdvisorAdapter) registered&#125;</span></span><br><span class="line"><span class="comment">	 * adapters.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h2><ol>
<li>Abstract Factory Pattern中的具体工厂</li>
<li>Builder Pattern中的指导者</li>
<li>Facade Pattern中的Facade参与者</li>
<li>Prototype Pattern中的原型管理器</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/codingmengmeng/p/9846131.html">DCL单例模式</a></li>
<li><a href="https://www.toutiao.com/i6821004595079152141/">被面试官虐过之后，他轻蔑的问我：你还说你了解单例模式吗?</a></li>
</ol>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之反射</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1587523711269.png" class title="反射知识点">

</div>

<a id="more"></a>

<h3 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h3><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。在Java中如果想获取到运行中对象的结构则需要引入反射的概念。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>在java中包括两种时期：编译期和运行期，对应的类型就是编译时类型和运行时类型。编译时类型由声明时的对象决定，运行时类型则由实际的对象类型决定（<strong>主要表现为行为，对于成员变量则编译时确认</strong>）。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中编译时类型为 Person，运行时类型为 Man。  </span></span><br><span class="line">Person p=<span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>
<p>由于编译时类型无法获取具体方法且程序运行过程中可能会接收外部传入的对象该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>反射API用来生成JVM中的类、接口或则对象的信息。  </p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>反射的核心类，可以获取类的属性，方法等信息。class的生成已经加载过程会在JVM章节中进行详细说明。</p>
<h5 id="RTTI（Run-Time-Type-Identification）运行时类型识别"><a href="#RTTI（Run-Time-Type-Identification）运行时类型识别" class="headerlink" title="RTTI（Run-Time Type Identification）运行时类型识别"></a>RTTI（Run-Time Type Identification）运行时类型识别</h5><p><font color="red">RTTI（Run-Time Type Identification）运行时类型识别</font>，其作用是在运行时识别一个对象的类型和类的信息，这里分两种：传统的”RRTI”,它假定我们在编译期已知道了所有类型(在没有反射机制创建和使用类对象时，一般都是编译期已确定其类型，如new对象时该类必须已定义好)，另外一种是反射机制，它允许我们在运行时发现和使用类型的信息。在Java中用来表示运行时类型信息的对应类就是Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中.</p>
<h5 id="Class的特点"><a href="#Class的特点" class="headerlink" title="Class的特点"></a>Class的特点</h5><ul>
<li>在java中万事万物都是对象的概念，使用Class类表示类的对象信息</li>
<li>通过关键字class标识的类，在内存中都会有一个与之对应的Class对象，用来描述具体的类型信息</li>
<li>Class类的构造函数是私有的，因此对应Class对象只能有JVM创建和加载</li>
<li>Class类的对象作用是运行时提供或获得某个对象的类型信息（反射的来源）</li>
<li>类加载器在类被第一次静态调用(比如一个静态方法，一个静态代码块或者new关键字调用构造器，注意contructors其实都是静态的)时会把那个对应的Class对象加载到内存中。</li>
</ul>
<h5 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h5><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1587536833908.png" class title="类与对象的关系">

</div>

<h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><p>Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</p>
<h5 id="class中获取field"><a href="#class中获取field" class="headerlink" title="class中获取field"></a>class中获取field</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field</td>
<td>getDeclaredField(String name)</td>
<td>获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td>
</tr>
<tr>
<td>Field[]</td>
<td>getDeclaredField()</td>
<td>获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td>
</tr>
<tr>
<td>Field</td>
<td>getField(String name)</td>
<td>获取指定name名称、具有public修饰的字段，包含继承字段</td>
</tr>
<tr>
<td>Field[]</td>
<td>getField()</td>
<td>获取修饰符为public的字段，包含继承字段</td>
</tr>
</tbody></table>
<h5 id="field中常用方法"><a href="#field中常用方法" class="headerlink" title="field中常用方法"></a>field中常用方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>set(Object obj, Object value)</td>
<td>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td>
</tr>
<tr>
<td>Object</td>
<td>get(Object obj)</td>
<td>返回指定对象上此 Field 表示的字段的值</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getType()</td>
<td>返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。</td>
</tr>
<tr>
<td>boolean</td>
<td>isEnumConstant()</td>
<td>如果此字段表示枚举类型的元素则返回 true；否则返回 false</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回一个描述此 Field（包括其一般类型）的字符串</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>返回此 Field 对象表示的字段的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getDeclaringClass()</td>
<td>返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td>
</tr>
<tr>
<td>void</td>
<td>setAccessible(boolean flag)</td>
<td>将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</td>
</tr>
</tbody></table>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</p>
<h5 id="class中的method方法"><a href="#class中的method方法" class="headerlink" title="class中的method方法"></a>class中的method方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Method</td>
<td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td>
</tr>
<tr>
<td>Method[]</td>
<td>getDeclaredMethod()</td>
<td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td>
</tr>
<tr>
<td>Method</td>
<td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td>
</tr>
<tr>
<td>Method[]</td>
<td>getMethods()</td>
<td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td>
</tr>
</tbody></table>
<h5 id="method常用的方法"><a href="#method常用的方法" class="headerlink" title="method常用的方法"></a>method常用的方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object</td>
<td>invoke(Object obj, Object… args)</td>
<td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td>
</tr>
<tr>
<td>Class&lt;?&gt;</td>
<td>getReturnType()</td>
<td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td>
</tr>
<tr>
<td>Type</td>
<td>getGenericReturnType()</td>
<td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td>
</tr>
<tr>
<td>Class&lt;?&gt;[]</td>
<td>getParameterTypes()</td>
<td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td>
</tr>
<tr>
<td>Type[]</td>
<td>getGenericParameterTypes()</td>
<td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td>
</tr>
<tr>
<td>boolean</td>
<td>isVarArgs()</td>
<td>判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回描述此 Method 的字符串，包括类型参数。</td>
</tr>
</tbody></table>
<h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><p>Java.lang.reflec 包中的类，表示类的构造方法。</p>
<h5 id="class中获取Constructor"><a href="#class中获取Constructor" class="headerlink" title="class中获取Constructor"></a>class中获取Constructor</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Class&lt;?&gt;</td>
<td>forName(String className)</td>
<td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td>
</tr>
<tr>
<td>Constructor<T></T></td>
<td>getConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>返回指定参数类型、具有public访问权限的构造函数对象</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[]</td>
<td>getConstructors()</td>
<td>返回所有具有public访问权限的构造函数的Constructor对象数组</td>
</tr>
<tr>
<td>Constructor<T></T></td>
<td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td>
<td>返回指定参数类型、所有声明的（包括private）构造函数对象</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[]</td>
<td>getDeclaredConstructor()</td>
<td>返回所有声明的（包括private）构造函数对象</td>
</tr>
<tr>
<td>T</td>
<td>newInstance()</td>
<td>创建此 Class 对象所表示的类的一个新实例。</td>
</tr>
</tbody></table>
<h5 id="Constructor中的常用方法"><a href="#Constructor中的常用方法" class="headerlink" title="Constructor中的常用方法"></a>Constructor中的常用方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Class<T></T></td>
<td>getDeclaringClass()</td>
<td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td>
</tr>
<tr>
<td>Type[]</td>
<td>getGenericParameterTypes()</td>
<td>按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>以字符串形式返回此构造方法的名称。</td>
</tr>
<tr>
<td>Class&lt;?&gt;[]</td>
<td>getParameterTypes()</td>
<td>按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td>
</tr>
<tr>
<td>T</td>
<td>newInstance(Object… initargs)</td>
<td>使用此 Constructor对象表示的构造函数来创建新实例</td>
</tr>
<tr>
<td>String</td>
<td>toGenericString()</td>
<td>返回描述此 Constructor 的字符串，其中包括类型参数。</td>
</tr>
</tbody></table>
<h4 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h4><p>参考《<a href="https://www.sunliaodong.cn/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/">JAVA注解</a>》</p>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><h5 id="class中的array"><a href="#class中的array" class="headerlink" title="class中的array"></a>class中的array</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Class&lt;?&gt;</td>
<td>getComponentType()</td>
<td>返回表示数组元素类型的 Class，即数组的类型</td>
</tr>
<tr>
<td>boolean</td>
<td>isArray()</td>
<td>判定此 Class 对象是否表示一个数组类。</td>
</tr>
</tbody></table>
<h5 id="array中常用的方法"><a href="#array中常用的方法" class="headerlink" title="array中常用的方法"></a>array中常用的方法</h5><table>
<thead>
<tr>
<th>方法返回值</th>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Object</td>
<td>set(Object array, int index)</td>
<td>返回指定数组对象中索引组件的值。</td>
</tr>
<tr>
<td>static int</td>
<td>getLength(Object array)</td>
<td>以 int 形式返回指定数组对象的长度</td>
</tr>
<tr>
<td>static object</td>
<td>newInstance(Class&lt;?&gt; componentType, int… dimensions)</td>
<td>创建一个具有指定类型和维度的新数组。</td>
</tr>
<tr>
<td>static Object</td>
<td>newInstance(Class&lt;?&gt; componentType, int length)</td>
<td>创建一个具有指定的组件类型和长度的新数组。</td>
</tr>
<tr>
<td>static void</td>
<td>set(Object array, int index, Object value)</td>
<td>将指定数组对象中索引组件的值设置为指定的新值。</td>
</tr>
</tbody></table>
<h3 id="使用步骤：获取Class对象、调用对象方法"><a href="#使用步骤：获取Class对象、调用对象方法" class="headerlink" title="使用步骤：获取Class对象、调用对象方法"></a>使用步骤：获取Class对象、调用对象方法</h3><ol>
<li><p>获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。可以通过以下方式获取：</p>
<ul>
<li>调用对象的getClass()：(new Man()).getClass()</li>
<li>调用类的class属性：Man.class</li>
<li>使用Class.forName调用类的全路径（<strong>最安全，性能最好</strong>）：Class.forName(“com.sunld.Man”)</li>
</ul>
</li>
<li><p>调用 Class 类中的方法，既就是反射的使用阶段。</p>
</li>
<li><p>使用反射 API 来操作这些信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 获取 Man 类的 Class 对象</span></span><br><span class="line">         Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.sunld.Man&quot;</span>);</span><br><span class="line">         <span class="comment">// 获取 Man 类的所有方法信息</span></span><br><span class="line">         Method[] method = clazz.getDeclaredMethods();</span><br><span class="line">         <span class="keyword">for</span> (Method m : method) &#123;</span><br><span class="line">             System.out.println(m.toString());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 获取 Man 类的所有成员属性信息</span></span><br><span class="line">         Field[] field = clazz.getDeclaredFields();</span><br><span class="line">         <span class="keyword">for</span> (Field f : field) &#123;</span><br><span class="line">             System.out.println(f.toString());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 获取 Man 类的所有构造方法信息</span></span><br><span class="line">         Constructor[] constructor = clazz.getDeclaredConstructors();</span><br><span class="line">         <span class="keyword">for</span> (Constructor c : constructor) &#123;</span><br><span class="line">             System.out.println(c.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h3></li>
</ol>
<h4 id="Class对象的newInstance"><a href="#Class对象的newInstance" class="headerlink" title="Class对象的newInstance()"></a>Class对象的newInstance()</h4><p>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取 Man 类的 Class 对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.sunld.Man&quot;</span>);</span><br><span class="line"><span class="comment">//使用.newInstane 方法创建对象</span></span><br><span class="line">Man p=(Man) clazz.newInstance();</span><br></pre></td></tr></table></figure>
<h4 id="调用Constructor对象的newInstance"><a href="#调用Constructor对象的newInstance" class="headerlink" title="调用Constructor对象的newInstance()"></a>调用Constructor对象的newInstance()</h4><p>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz=Class.forName(<span class="string">&quot;com.sunld.Man&quot;</span>);  </span><br><span class="line"><span class="comment">//获取构造方法并创建对象</span></span><br><span class="line">Constructor c=clazz.getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//创建对象并设置属性</span></span><br><span class="line">Man m=(Man) c.newInstance(<span class="string">&quot;男人&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h5 id="Java的安全模型"><a href="#Java的安全模型" class="headerlink" title="Java的安全模型"></a>Java的安全模型</h5><p>java运行在jvm中，不与外部直接联系，java的安全模型包括：字节码验证器、类加载器、安全管理器、访问控制器等一系列的组件。java通过反射可以处理private方法和属性，说明它绕过了访问控制器。它其实是Java本身为了某种目的而留下的类似于“后门”的东西，它的原理其实是关闭访问安全检查。</p>
<h5 id="Java中访问控制的实现"><a href="#Java中访问控制的实现" class="headerlink" title="Java中访问控制的实现"></a>Java中访问控制的实现</h5><p>Field、Method和Constructor类，它们都有一个共同的父类AccessibleObject 。AccessibleObject 有一个公共方法：void setAccessible(boolean flag)。正是这个方法，让我们可以改变动态的打开或者关闭访问安全检查，从而访问到原本是private的方法或域。另外，访问安全检查是一件比较耗时的操作，关闭它反射的性能也会有较大提升。</p>
<h5 id="Java中的作用域（访问控制）"><a href="#Java中的作用域（访问控制）" class="headerlink" title="Java中的作用域（访问控制）"></a>Java中的作用域（访问控制）</h5><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1587540118382.png" class title="Java中的作用域">

</div>

<h3 id="ClassUtils"><a href="#ClassUtils" class="headerlink" title="ClassUtils"></a>ClassUtils</h3><p>在spring的源码中提供了Class反射使用到的常用封装，可以参考修改或者直接使用。</p>
<h3 id="自定义ClassUtils"><a href="#自定义ClassUtils" class="headerlink" title="自定义ClassUtils"></a>自定义ClassUtils</h3><p><a href="https://github.com/sld880311/Architect-Growth-Manual/tree/master/docs/book/source/ClassUtils.java">ClassUtils代码地址</a></p>
<h3 id="内省Introspector"><a href="#内省Introspector" class="headerlink" title="内省Introspector"></a>内省Introspector</h3><p>一种用于处理javabean的API，提高Java反射的效率</p>
<h4 id="内省Introspector类结构"><a href="#内省Introspector类结构" class="headerlink" title="内省Introspector类结构"></a>内省Introspector类结构</h4><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%8D%E5%B0%84/1589936907736.png" class title="内省Introspector类结构">

</div>

<ol>
<li>Introspector：获取JavaBean的BeanInfo</li>
<li>BeanInfo：通过getPropertyDescriptors 方法和 getMethodDescriptors 方法可以拿到 javaBean 的字段信息列表和 getter 和 setter 方法信息列表</li>
<li>PropertyDescriptors 可以根据字段直接获得该字段的 getter 和 setter 方法。</li>
<li>PropertyDescriptor类表示JavaBean类通过存储器导出一个属性。主要方法：<ul>
<li>getPropertyType()，获得属性的Class对象</li>
<li>getReadMethod()，获得用于读取属性值的方法；getWriteMethod()，获得用于写入属性值的方法;</li>
<li>hashCode()，获取对象的哈希值;</li>
<li>setReadMethod(Method readMethod)，设置用于读取属性值的方法;</li>
<li>setWriteMethod(Method writeMethod)，设置用于写入属性值的方法。</li>
</ul>
</li>
<li>MethodDescriptors 可以获得方法的元信息，比如方法名，参数个数，参数字段类型等。</li>
</ol>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIntrospector</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">findUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">findUser2</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser2:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">findUser3</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser3:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">findUser4</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;findUser4:zhangs : 100age&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IntrospectionException </span>&#123;</span><br><span class="line">        TestIntrospector t = <span class="keyword">new</span> TestIntrospector();</span><br><span class="line">        User u = t.n<span class="function">ew <span class="title">User</span><span class="params">()</span></span>;</span><br><span class="line">        u.setAge(<span class="number">20</span>);</span><br><span class="line">        u.setUserName(<span class="string">&quot;dfafda&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取整个Bean的信息</span></span><br><span class="line">        <span class="comment">// 在Object类时候停止检索，可以选择在任意一个父类停止</span></span><br><span class="line">        BeanInfo beanInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取某个对象的BeanInfo信息，并且可以指定上限</span></span><br><span class="line">            beanInfo = Introspector.getBeanInfo(User.class, Object.class);</span><br><span class="line">            System.out.println(beanInfo);</span><br><span class="line">            System.out.println(<span class="string">&quot;所有属性描述：&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取所有的属性描述</span></span><br><span class="line">            PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor propertyDescriptor : pds) &#123;</span><br><span class="line">                System.out.println(propertyDescriptor.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有方法描述：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (MethodDescriptor methodDescriptor : beanInfo.getMethodDescriptors()) &#123;</span><br><span class="line">                System.out.println(methodDescriptor.getName());</span><br><span class="line">                <span class="keyword">if</span>(methodDescriptor.getName().startsWith(<span class="string">&quot;get&quot;</span>))&#123;</span><br><span class="line">                    Method method = methodDescriptor.getMethod();</span><br><span class="line">                    System.out.println(method.invoke(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 自定义</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String propertyName = <span class="string">&quot;userName&quot;</span>;</span><br><span class="line">            PropertyDescriptor namePd = <span class="keyword">new</span> PropertyDescriptor(propertyName, User.class);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;名字：&quot;</span> + namePd.getReadMethod().invoke(u));</span><br><span class="line">            namePd.getWriteMethod().invoke(u, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;名字：&quot;</span> + namePd.getReadMethod().invoke(u));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="org-springframework-beans-BeanUtils"><a href="#org-springframework-beans-BeanUtils" class="headerlink" title="org.springframework.beans.BeanUtils"></a>org.springframework.beans.BeanUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy the property values of the given source bean into the given target bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: The source and target classes do not have to match or even be derived</span></span><br><span class="line"><span class="comment"> * from each other, as long as the properties match. Any bean properties that the</span></span><br><span class="line"><span class="comment"> * source bean exposes but the target bean does not will silently be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the source bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target the target bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> editable the class (or interface) to restrict property setting to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ignoreProperties array of property names to ignore</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the copying failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanWrapper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target, <span class="meta">@Nullable</span> Class&lt;?&gt; editable,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="meta">@Nullable</span> String... ignoreProperties)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(source, <span class="string">&quot;Source must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(target, <span class="string">&quot;Target must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取目标对象的class</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt; actualEditable = target.getClass();</span><br><span class="line">	<span class="keyword">if</span> (editable != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!editable.isInstance(target)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Target class [&quot;</span> + target.getClass().getName() +</span><br><span class="line">					<span class="string">&quot;] not assignable to Editable class [&quot;</span> + editable.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		actualEditable = editable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取目标对象的属性信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理忽略属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;String&gt; ignoreList = (ignoreProperties != <span class="keyword">null</span> ? Arrays.asList(ignoreProperties) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (PropertyDescriptor targetPd : targetPds) &#123;</span><br><span class="line">		Method writeMethod = targetPd.getWriteMethod();</span><br><span class="line">		<span class="keyword">if</span> (writeMethod != <span class="keyword">null</span> &amp;&amp; (ignoreList == <span class="keyword">null</span> || !ignoreList.contains(targetPd.getName()))) &#123;</span><br><span class="line">			PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</span><br><span class="line">			<span class="keyword">if</span> (sourcePd != <span class="keyword">null</span>) &#123;</span><br><span class="line">				Method readMethod = sourcePd.getReadMethod();</span><br><span class="line">				<span class="keyword">if</span> (readMethod != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						ClassUtils.isAssignable(writeMethod.getParameterTypes()[<span class="number">0</span>], readMethod.getReturnType())) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">							readMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						Object value = readMethod.invoke(source);</span><br><span class="line">						<span class="keyword">if</span> (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">							writeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						writeMethod.invoke(target, value);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(</span><br><span class="line">								<span class="string">&quot;Could not copy property &#x27;&quot;</span> + targetPd.getName() + <span class="string">&quot;&#x27; from source to target&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="instanceof和isInstance区别"><a href="#instanceof和isInstance区别" class="headerlink" title="instanceof和isInstance区别"></a>instanceof和isInstance区别</h3><style type="text/css">
.tg  {border-collapse:collapse;border-color:#bbb;border-spacing:0;}
.tg td{background-color:#E0FFEB;border-color:#bbb;border-style:solid;border-width:1px;color:#594F4F;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#9DE0AD;border-color:#bbb;border-style:solid;border-width:1px;color:#493F3F;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0pky">用法</th>
    <th class="tg-0pky">功能</th>
    <th class="tg-0pky">对象本身</th>
    <th class="tg-0pky">父类/接口</th>
    <th class="tg-0pky">Object</th>
    <th class="tg-0lax">null</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">obj instanceof class</td>
    <td class="tg-0pky">判断对象是否是某个类型</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0lax">false</td>
  </tr>
  <tr>
    <td class="tg-0pky">class.isInstance(obj)</td>
    <td class="tg-0pky">判断对象是否可以转换为这个类</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0pky">true</td>
    <td class="tg-0lax">false</td>
  </tr>
</tbody>
</table>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstanceClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestInstanceClass t = <span class="keyword">new</span> TestInstanceClass();</span><br><span class="line"></span><br><span class="line">        B b = t.n<span class="function">ew <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        A a = t.n<span class="function">ew <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">        A ba = t.n<span class="function">ew <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1------------&quot;</span>);</span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> B);<span class="comment">// true</span></span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> A);<span class="comment">// true</span></span><br><span class="line">        System.out.println(b <span class="keyword">instanceof</span> Object);<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2------------&quot;</span>);</span><br><span class="line">        System.out.println(b.getClass().isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.getClass().isInstance(a));<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3------------&quot;</span>);</span><br><span class="line">        System.out.println(a.getClass().isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.getClass().isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.getClass().isInstance(<span class="keyword">null</span>));<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4------------&quot;</span>);</span><br><span class="line">        System.out.println(A.class.isInstance(a));<span class="comment">// true</span></span><br><span class="line">        System.out.println(A.class.isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(A.class.isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;5------------&quot;</span>);</span><br><span class="line">        System.out.println(B.class.isInstance(a));<span class="comment">// false</span></span><br><span class="line">        System.out.println(B.class.isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(B.class.isInstance(ba));<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;6------------&quot;</span>);</span><br><span class="line">        System.out.println(Object.class.isInstance(b));<span class="comment">// true</span></span><br><span class="line">        System.out.println(Object.class.isInstance(<span class="keyword">null</span>));<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/javazejian/article/details/70768369">深入理解Java类型信息(Class对象)与反射机制</a></li>
<li>《Java并发编程的艺术》</li>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://www.cnblogs.com/greatfish/p/6096038.html">Java中instanceof和isInstance区别详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之异常</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中任务或方法的运行，要不就是正常执行完成(包括虚拟机退出，比如<code>System.exit()</code>)，要不就是出现异常终止(<code>Throwable</code>)。本章节重点讲解在Java中对异常的处理。当程序出现异常之后，Java会抛出一个封装好的异常堆栈信息，并且终止当前的方法，异常处理机制会将代码执行交给异常处理器。整体结构如下图所示：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587714125412.png" class title="Java异常架构图">

</div>

<a id="more"></a>

<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* The &#123;<span class="meta">@code</span> Throwable&#125; <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">the</span> <span class="title">superclass</span> <span class="title">of</span> <span class="title">all</span> <span class="title">errors</span> <span class="title">and</span></span></span><br><span class="line"><span class="class">* <span class="title">exceptions</span> <span class="title">in</span> <span class="title">the</span> <span class="title">Java</span> <span class="title">language</span>. <span class="title">Only</span> <span class="title">objects</span> <span class="title">that</span> <span class="title">are</span> <span class="title">instances</span> <span class="title">of</span> <span class="title">this</span></span></span><br><span class="line"><span class="class">* <span class="title">class</span> (<span class="title">or</span> <span class="title">one</span> <span class="title">of</span> <span class="title">its</span> <span class="title">subclasses</span>) <span class="title">are</span> <span class="title">thrown</span> <span class="title">by</span> <span class="title">the</span> <span class="title">Java</span> <span class="title">Virtual</span> <span class="title">Machine</span> <span class="title">or</span></span></span><br><span class="line"><span class="class">* <span class="title">can</span> <span class="title">be</span> <span class="title">thrown</span> <span class="title">by</span> <span class="title">the</span> <span class="title">Java</span> </span>&#123;<span class="meta">@code</span> <span class="keyword">throw</span>&#125; statement. Similarly, only</span><br><span class="line">* <span class="keyword">this</span> <span class="class"><span class="keyword">class</span> <span class="title">or</span> <span class="title">one</span> <span class="title">of</span> <span class="title">its</span> <span class="title">subclasses</span> <span class="title">can</span> <span class="title">be</span> <span class="title">the</span> <span class="title">argument</span> <span class="title">type</span> <span class="title">in</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">* </span>&#123;<span class="meta">@code</span> <span class="keyword">catch</span>&#125; clause.</span><br></pre></td></tr></table></figure>
<p>在Java中<code>Throwable</code>是所有异常类的父类，只有该类的子类才能被用于Java异常处理。该类的唯一两个子类是<code>Error</code>和<code>Exception</code>。</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* An &#123;<span class="meta">@code</span> Error&#125; is a subclass of &#123;<span class="meta">@code</span> Throwable&#125;</span><br><span class="line">* that indicates serious problems that a reasonable application</span><br><span class="line">* should not <span class="keyword">try</span> to <span class="keyword">catch</span>. Most such errors are abnormal conditions.</span><br><span class="line">* The &#123;<span class="meta">@code</span> ThreadDeath&#125; error, though a <span class="string">&quot;normal&quot;</span> condition,</span><br><span class="line">* is also a subclass of &#123;<span class="meta">@code</span> Error&#125; because most applications</span><br><span class="line">* should not <span class="keyword">try</span> to <span class="keyword">catch</span> it.</span><br><span class="line">* &lt;p&gt;</span><br><span class="line">* A method is not required to declare in its &#123;<span class="meta">@code</span> <span class="keyword">throws</span>&#125;</span><br><span class="line">* clause any subclasses of &#123;<span class="meta">@code</span> Error&#125; that might be thrown</span><br><span class="line">* during the execution of the method but not caught, since these</span><br><span class="line">* errors are abnormal conditions that should never occur.</span><br><span class="line">*</span><br><span class="line">* That is, &#123;<span class="meta">@code</span> Error&#125; and its subclasses are regarded as unchecked</span><br><span class="line">* exceptions <span class="keyword">for</span> the purposes of compile-time checking of exceptions.</span><br></pre></td></tr></table></figure>
<p>Error在正常情况下不应该出现的异常（一般是JVM本身产生的异常，比如JVM运行错误、<code>NoClassDefFoundError</code>或<code>OutOfMemoryError</code>），而且不建议应用程序对其进行捕获。Error被定义为非检查异常。Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。  包括以下类：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587719292555.png" class title="Java Error直接之类">

</div>

<h3 id="Exception（RuntimeException、CheckedException）"><a href="#Exception（RuntimeException、CheckedException）" class="headerlink" title="Exception（RuntimeException、CheckedException）"></a>Exception（RuntimeException、CheckedException）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* &lt;p&gt;The <span class="class"><span class="keyword">class</span> </span>&#123;<span class="meta">@code</span> Exception&#125; and any subclasses that are not also</span><br><span class="line">* subclasses of &#123;<span class="meta">@link</span> RuntimeException&#125; are &lt;em&gt;checked</span><br><span class="line">* exceptions&lt;/em&gt;.  Checked exceptions need to be declared in a</span><br><span class="line">* method or constructor<span class="string">&#x27;s &#123;@code throws&#125; clause if they can be thrown</span></span><br><span class="line"><span class="string">* by the execution of the method or constructor and propagate outside</span></span><br><span class="line"><span class="string">* the method or constructor boundary.</span></span><br></pre></td></tr></table></figure>
<p><code>Exception</code>用于处理应用程序方面的异常定义和处理。分为<code>RuntimeException</code>和<code>CheckedException</code>(非<code>RuntimeException</code>)。检查类异常需要在方法或者构造器中明确的进行处理（throws）。</p>
<h4 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* &#123;<span class="meta">@code</span> RuntimeException&#125; is the superclass of those</span><br><span class="line">* exceptions that can be thrown during the normal operation of the</span><br><span class="line">* Java Virtual Machine.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt;&#123;<span class="meta">@code</span> RuntimeException&#125; and its subclasses are &lt;em&gt;unchecked</span><br><span class="line">* exceptions&lt;/em&gt;.  Unchecked exceptions do &lt;em&gt;not&lt;/em&gt; need to be</span><br><span class="line">* declared in a method or constructor<span class="string">&#x27;s &#123;@code throws&#125; clause if they</span></span><br><span class="line"><span class="string">* can be thrown by the execution of the method or constructor and</span></span><br><span class="line"><span class="string">* propagate outside the method or constructor boundary.</span></span><br></pre></td></tr></table></figure>
<p><code>RuntimeException</code>是在JVM的正常操作期间可以抛出异常的超类。该类都是未检查异常类，未检查异常不需要在方法或构造函数中进行throws，如果他们可以通过该方法或构造函数的执行被抛出和方法或构造边界之外传播。所以通常用不着捕获RuntimeException，但在自己的封装里，也许仍然要选择抛出一部分RuntimeException。常见的类包括：</p>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587718395409.png" class title="RuntimeException直接之类">

</div>

<h4 id="CheckedException"><a href="#CheckedException" class="headerlink" title="CheckedException"></a>CheckedException</h4><p>Exception下除<code>RuntimeException</code>和<code>Error</code>之外的异常类都是<code>CheckedException</code>。它们都在java.lang库内部定义。Java编译器要求程序必须捕获或声明抛出这种异常。常用的类包括： I/O 错误导致的 IOException、SQLException。这类异常的表现形式一般为：</p>
<ol>
<li>试图在文件尾部读取数据  </li>
<li>试图打开一个错误格式的 URL  </li>
<li>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</li>
</ol>
<h4 id="CheckedException与RuntimeException的区别"><a href="#CheckedException与RuntimeException的区别" class="headerlink" title="CheckedException与RuntimeException的区别"></a>CheckedException与RuntimeException的区别</h4><ol>
<li>CheckedException需要显示的处理，throws；RuntimeException不需要。</li>
<li>RuntimeException运行期间的错误，一般都是代码bug；CheckedException编译期间的错误，一般是外部错误。Java 编译器会强制程序去捕获此类异常（ try catch）。</li>
</ol>
<h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><h3 id="抛出"><a href="#抛出" class="headerlink" title="抛出"></a>抛出</h3><p>当程序中出现异常时，如果不进行具体处理，可以使用<code>throw</code>、<code>throws</code> 、系统自动抛出三种方式进行异常抛出处理。</p>
<h4 id="throw与throws的区别"><a href="#throw与throws的区别" class="headerlink" title="throw与throws的区别"></a>throw与throws的区别</h4><ol>
<li>位置不同：throws在函数或构造器定义中，throw是函数或构造器内</li>
<li>功能不同：throws用于异常声明，让调用者知道可能出现的异常；throw抛出异常，业务处理终止，抛出到上层业务</li>
<li>含义不同：throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。  throw需要配合throws使用。</li>
<li>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li>
</ol>
<h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>如果程序中需要进行异常的特殊处理或者进行异常转换，则需要使用try、catch进行处理。</p>
<h3 id="处理的伪代码"><a href="#处理的伪代码" class="headerlink" title="处理的伪代码"></a>处理的伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionType e)&#123;</span><br><span class="line"> <span class="comment">//此违例类型的控制代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"> <span class="comment">//清除回收等工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先执行try中包含的代码块，如果遇到执行错误，程序掷出（throw）一特定类型的违例，你捕捉到此违例并转而执行catch中的违例控制代码。最后，无论程序是否产生违例都必须执行finally中的代码，其主要为一些变量清除、资源回收（1）等工作。</p>
<h2 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h2><ol>
<li>重写一个方法时，只能产生已在方法的基础类版本中定义的异常。</li>
<li>重写的方法可以抛出父类方法所抛出的异常或它的子类型</li>
<li>重写的方法可以不用抛出父类方法所抛出的异常</li>
<li>重写的方法不可以抛出异常如果父类方法没有抛出异常</li>
<li>对异常的限制并不适用于构建器。</li>
</ol>
<h2 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h2><p>掷”出一个异常后，异常控制系统会按当初编写的顺序搜索“最接近”的控制器。一旦找到相符的控制器，就认为异常已得到控制，不再进行更多的搜索工作。在异常和它的控制器之间，并不需要非常精确的匹配。一个衍生类对象可与基础类的一个异常控制器相配，<strong>即我们在写代码时，将子类写在前面</strong>。</p>
<h2 id="JVM中处理异常的原理"><a href="#JVM中处理异常的原理" class="headerlink" title="JVM中处理异常的原理"></a>JVM中处理异常的原理</h2><h3 id="异常的执行顺序"><a href="#异常的执行顺序" class="headerlink" title="异常的执行顺序"></a>异常的执行顺序</h3><p>1、new一个异常对象<br>2、终止当前的执行程序。<br>3、弹出异常对象的引用。<br>4、异常处理机制接管被终止的执行程序。<br>5、寻找一个恰当的地点（异常处理程序）继续执行程序。  </p>
<h3 id="异常处理的理论模型"><a href="#异常处理的理论模型" class="headerlink" title="异常处理的理论模型"></a>异常处理的理论模型</h3><ol>
<li><strong>终止模型</strong>：这种模型将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行，一旦异常抛出错误就意味着世界末日，意味着死亡，意味着GG</li>
<li><strong>恢复模型</strong>：异常处理程序发现了错误，并且修复了错误然后重新调用出问题的方法，并且认为第二次调用该方法会成功。通常可以将try块放入while循环中，不断执行方法，直到得到满意的结果。</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="异常信息构建：Throwable"><a href="#异常信息构建：Throwable" class="headerlink" title="异常信息构建：Throwable"></a>异常信息构建：Throwable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a new throwable with &#123;<span class="doctag">@code</span> null&#125; as its detail message.</span></span><br><span class="line"><span class="comment">* The cause is not initialized, and may subsequently be initialized by a</span></span><br><span class="line"><span class="comment">* call to &#123;<span class="doctag">@link</span> #initCause&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;The &#123;<span class="doctag">@link</span> #fillInStackTrace()&#125; method is called to initialize</span></span><br><span class="line"><span class="comment">* the stack trace data in the newly created throwable.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Throwable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 填充执行过程中的堆栈信息，</span></span><br><span class="line"><span class="comment">    * 此方法在Throwable对象中记录当前线程的栈帧的状态信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fillInStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="核心代码：fillInStackTrace"><a href="#核心代码：fillInStackTrace" class="headerlink" title="核心代码：fillInStackTrace"></a>核心代码：fillInStackTrace</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A shared value for an empty stack.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StackTraceElement[] UNASSIGNED_STACK = <span class="keyword">new</span> StackTraceElement[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The stack trace, as returned by &#123;<span class="doctag">@link</span> #getStackTrace()&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The field is initialized to a zero-length array.  A &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">* null&#125; value of this field indicates subsequent calls to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #setStackTrace(StackTraceElement[])&#125; and &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #fillInStackTrace()&#125; will be be no-ops.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> StackTraceElement[] stackTrace = UNASSIGNED_STACK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Fills in the execution stack trace. This method records within this</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> Throwable&#125; object information about the current state of</span></span><br><span class="line"><span class="comment">* the stack frames for the current thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the stack trace of this &#123;<span class="doctag">@code</span> Throwable&#125; &#123;<span class="doctag">@linkplain</span></span></span><br><span class="line"><span class="comment">* Throwable#Throwable(String, Throwable, boolean, boolean) is not</span></span><br><span class="line"><span class="comment">* writable&#125;, calling this method has no effect.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  a reference to this &#123;<span class="doctag">@code</span> Throwable&#125; instance.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>     java.lang.Throwable#printStackTrace()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackTrace != <span class="keyword">null</span> ||</span><br><span class="line">        backtrace != <span class="keyword">null</span> <span class="comment">/* Out of protocol state */</span> ) &#123;</span><br><span class="line">        fillInStackTrace(<span class="number">0</span>);</span><br><span class="line">        stackTrace = UNASSIGNED_STACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 底层本地方法获取当前线程的堆栈信息</span></span><br><span class="line"><span class="comment">* 2. 执行非常耗时。</span></span><br><span class="line"><span class="comment">* 3.如果只是关系异常的传播性质，而不关心异常的堆栈信息，可重写fillInStackTrace()方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> Throwable <span class="title">fillInStackTrace</span><span class="params">(<span class="keyword">int</span> dummy)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="StackTraceElement"><a href="#StackTraceElement" class="headerlink" title="StackTraceElement"></a>StackTraceElement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An element in a stack trace, as returned by &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Throwable#getStackTrace()&#125;.  Each element represents a single stack frame.</span></span><br><span class="line"><span class="comment"> * All stack frames except for the one at the top of the stack represent</span></span><br><span class="line"><span class="comment"> * a method invocation.  The frame at the top of the stack represents the</span></span><br><span class="line"><span class="comment"> * execution point at which the stack trace was generated.  Typically,</span></span><br><span class="line"><span class="comment"> * this is the point at which the throwable corresponding to the stack trace</span></span><br><span class="line"><span class="comment"> * was created.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Bloch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTraceElement</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Normally initialized by VM (public constructor added in 1.5)</span></span><br><span class="line">    <span class="keyword">private</span> String declaringClass;<span class="comment">// 方法的类名</span></span><br><span class="line">    <span class="keyword">private</span> String methodName; <span class="comment">//方法名</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;<span class="comment">//文件名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>    lineNumber;<span class="comment">// 调用的行数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a stack trace element representing the specified execution</span></span><br><span class="line"><span class="comment">     * point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> declaringClass the fully qualified name of the class containing</span></span><br><span class="line"><span class="comment">     *        the execution point represented by the stack trace element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName the name of the method containing the execution point</span></span><br><span class="line"><span class="comment">     *        represented by the stack trace element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName the name of the file containing the execution point</span></span><br><span class="line"><span class="comment">     *         represented by the stack trace element, or &#123;<span class="doctag">@code</span> null&#125; if</span></span><br><span class="line"><span class="comment">     *         this information is unavailable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lineNumber the line number of the source line containing the</span></span><br><span class="line"><span class="comment">     *         execution point represented by this stack trace element, or</span></span><br><span class="line"><span class="comment">     *         a negative number if this information is unavailable. A value</span></span><br><span class="line"><span class="comment">     *         of -2 indicates that the method containing the execution point</span></span><br><span class="line"><span class="comment">     *         is a native method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> declaringClass&#125; or</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> methodName&#125; is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackTraceElement</span><span class="params">(String declaringClass, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             String fileName, <span class="keyword">int</span> lineNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.declaringClass = Objects.requireNonNull(declaringClass, <span class="string">&quot;Declaring class is null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.methodName     = Objects.requireNonNull(methodName, <span class="string">&quot;Method name is null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.fileName       = fileName;</span><br><span class="line">        <span class="keyword">this</span>.lineNumber     = lineNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="违例的作用"><a href="#违例的作用" class="headerlink" title="违例的作用"></a>违例的作用</h3><p>1)监视程序中的异常情况<br>2)当异常情况发生时，将控制权交给你自己编写的违例控制代码  </p>
<h3 id="使用准则"><a href="#使用准则" class="headerlink" title="使用准则"></a>使用准则</h3><p>(1) 解决问题并再次调用造成违例的方法。<br>(2) 平息事态的发展，并在不重新尝试方法的前提下继续。<br>(3) 计算另一些结果，而不是希望方法产生的结果。<br>(4) 在当前环境中尽可能解决问题，以及将相同的违例重新“掷”出一个更高级的环境。<br>(5) 在当前环境中尽可能解决问题，以及将不同的违例重新“掷”出一个更高级的环境。<br>(6) 中止程序执行。<br>(7) 简化编码。若违例方案使事情变得更加复杂，那就会令人非常烦恼，不如不用。<br>(8) 使自己的库和程序变得更加安全。这既是一种“短期投资”（便于调试），也是一种“长期投资”（改善应用程序的健壮性）  </p>
<p><strong>异常的处理包括业务类处理（给于用户更好的友好提示）和bug类处理（链条式异常信息输出，方便运维人员或研发人员快速定位问题）。</strong></p>
<h3 id="异常相关的关键字"><a href="#异常相关的关键字" class="headerlink" title="异常相关的关键字"></a>异常相关的关键字</h3><p><code>try，catch，throw，throws，finally</code></p>
<h3 id="finally的使用总结"><a href="#finally的使用总结" class="headerlink" title="finally的使用总结"></a>finally的使用总结</h3><h4 id="finally不被执行的场景"><a href="#finally不被执行的场景" class="headerlink" title="finally不被执行的场景"></a>finally不被执行的场景</h4><ol>
<li>与try配套使用，所以只有try执行finally才会执行</li>
<li>如果try中执行System.exit(0);或jvm异常终止，则否finally不会被执行</li>
</ol>
<h4 id="finally语句在return语句执行之后return返回之前执行"><a href="#finally语句在return语句执行之后return返回之前执行" class="headerlink" title="finally语句在return语句执行之后return返回之前执行"></a>finally语句在return语句执行之后return返回之前执行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test1());<span class="comment">//4.输出100</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>; </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test11());<span class="comment">// 4.after return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">           <span class="keyword">return</span> test12();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//3</span></span><br><span class="line">       &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;return statement&quot;</span>);<span class="comment">//2</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;after return&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="finally块中的return语句会覆盖try块中的return返回"><a href="#finally块中的return语句会覆盖try块中的return返回" class="headerlink" title="finally块中的return语句会覆盖try块中的return返回"></a>finally块中的return语句会覆盖try块中的return返回</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test2());<span class="comment">//200</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这说明finally里的return直接返回了，就不管try中是否还有返回语句.</p>
<h4 id="finally语句中没有return语句覆盖返回值，返回值的变化"><a href="#finally语句中没有return语句覆盖返回值，返回值的变化" class="headerlink" title="finally语句中没有return语句覆盖返回值，返回值的变化"></a>finally语句中没有return语句覆盖返回值，返回值的变化</h4><p>用例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test3());<span class="comment">//4:100</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">            b = <span class="number">150</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest6</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(getMap().get(<span class="string">&quot;KEY&quot;</span>).toString());<span class="comment">//FINALLY</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;INIT&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;TRY&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;CATCH&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;KEY&quot;</span>, <span class="string">&quot;FINALLY&quot;</span>);</span><br><span class="line">            map = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="try块里的return语句在异常的情况下不会被执行"><a href="#try块里的return语句在异常的情况下不会被执行" class="headerlink" title="try块里的return语句在异常的情况下不会被执行"></a>try块里的return语句在异常的情况下不会被执行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest5</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test4());<span class="comment">//5:204</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            b = b / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            b += <span class="number">15</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//4</span></span><br><span class="line">            &#125;</span><br><span class="line">            b += <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样"><a href="#当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样" class="headerlink" title="当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样"></a>当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld.finally1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest7</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test5());<span class="comment">//5:35</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try block&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            b = b /<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch block&quot;</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">return</span> b += <span class="number">15</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally block&quot;</span>);<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b&gt;25, b = &quot;</span> + b);<span class="comment">//4</span></span><br><span class="line">            &#125;</span><br><span class="line">            b += <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//return b;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>finally语句在return语句执行之后return返回之前执行</li>
<li>finally块中的return语句会覆盖try块中的return返回</li>
<li>如果finally语句中没有return语句,且覆盖了返回值，那么原来的返回值原始类型则不覆盖，对象类型则覆盖</li>
<li>try块里的return语句在异常的情况下不会被执行</li>
<li>当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。</li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h4 id="自定义异常的优点"><a href="#自定义异常的优点" class="headerlink" title="自定义异常的优点"></a>自定义异常的优点</h4><ol>
<li>统一了对外异常展示的方式。</li>
<li>方便框架统一处理<code>@ControllerAdvice</code></li>
<li>定义业务类异常</li>
<li>隐藏底层的异常，这样更安全，异常信息也更加的直观</li>
</ol>
<h4 id="自定义异常的注意事项"><a href="#自定义异常的注意事项" class="headerlink" title="自定义异常的注意事项"></a>自定义异常的注意事项</h4><ol>
<li>所有异常都必须是 Throwable 的子类。</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ol>
<h3 id="异常捕获的陷阱"><a href="#异常捕获的陷阱" class="headerlink" title="异常捕获的陷阱"></a>异常捕获的陷阱</h3><h4 id="正确关闭资源的方式"><a href="#正确关闭资源的方式" class="headerlink" title="正确关闭资源的方式"></a>正确关闭资源的方式</h4><p>对于物理资源（数据库连接、网络连接、磁盘文件），JVM是不会进行处理的，因为JVM属于Java内存管理的一部分，只负责回收堆内存中分配的空间。<br><strong>关闭资源：</strong></p>
<ol>
<li>必须要保证一定执行，一次要放在finally中完成</li>
<li>必须保证被关闭的资源不为空</li>
<li>保证资源之间的关闭操作互不影响</li>
</ol>
<h4 id="finally块的陷阱"><a href="#finally块的陷阱" class="headerlink" title="finally块的陷阱"></a>finally块的陷阱</h4><h5 id="finally块的执行规则"><a href="#finally块的执行规则" class="headerlink" title="finally块的执行规则"></a>finally块的执行规则</h5><ol>
<li><p>如果调用了System.exit(0);finally将不再执行，</p>
</li>
<li><p>当System.exit(0)被执行时，虚拟机在退出之前要完成两项工作：</p>
<ol>
<li>执行系统中注册的所有钩子</li>
<li>如果程序调用了System.runFinalizersOnExit(true);那么JVM会对所有未结束的对象调用Finalize</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h5 id="finally块和方法返回值"><a href="#finally块和方法返回值" class="headerlink" title="finally块和方法返回值"></a>finally块和方法返回值</h5></li>
</ol>
<p>当Java程序执行try、catch遇到return语句时，return语句会导致该方法会立即结束；系统执行return语句之后并不会立即结束该方法，而是去寻找异常处理过程中是否有finally，如果有则会执行finally代码块，在执行finally块时如果该块中没有return则会直接返回到try中的return，结束该方法，如果有则会直接返回finally中的数据，而不会调用try中的return。</p>
<h4 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a>catch的用法</h4><ol>
<li>catch的顺序: 先处理小异常在处理大异常</li>
<li>不要用catch代替流程控制</li>
<li>只能catch可能抛出的异常(减少大范围catch异常)</li>
<li>实际的修复<ol>
<li>如果程序知道如何修复这个异常，应该在catch中修复这个异常，修复之后可以再次调用这个方法；</li>
<li>如果程序不知道如何修复并且系统也没有进行任何修复，千万不要再次调用可能导致该异常的方法。（造成内存溢出），不要在finally块中调用可能引起异常的方法，可能会导致无限递归、内存溢出</li>
</ol>
</li>
</ol>
<h4 id="继承得到的异常"><a href="#继承得到的异常" class="headerlink" title="继承得到的异常"></a>继承得到的异常</h4><ol>
<li>子类重写父类方法时，不能抛出比父类方法类型更多、范围更大的异常</li>
<li>抛出的异常只能是父类异常中的交集，否则不能通过编译。</li>
</ol>
<h3 id="异常的处理流程"><a href="#异常的处理流程" class="headerlink" title="异常的处理流程"></a>异常的处理流程</h3><div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E5%B8%B8/1587727204173.png" class title="异常处理流程">

</div>

<h3 id="异常拦截"><a href="#异常拦截" class="headerlink" title="异常拦截"></a>异常拦截</h3><p>系统的异常处理机制是衡量一个系统设计的关键因素，良好的异常处理机制能在系统出现异常时准确的找到问题的所在。spring aop对异常的处理有良好的支持。spring（spring全家桶中增加了很多异常统一处理的接口和AOP，比如<code>@ControllerAdvice</code>） 提供了一个接口 <code>ThrowsAdvice</code>，该接口里面没有任何方法，但是实现类里面必须的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以处理详细的异常信息</span></span><br><span class="line">afterThrowing(Method method, Object[] args, Object target, RuntimeException  throwable)</span><br><span class="line"><span class="comment">//方便快速记录发生的异常</span></span><br><span class="line">afterThrowing(RuntimeException  throwable)</span><br></pre></td></tr></table></figure>
<h3 id="ClassNotFoundException和NoClassDefFoundError的区别"><a href="#ClassNotFoundException和NoClassDefFoundError的区别" class="headerlink" title="ClassNotFoundException和NoClassDefFoundError的区别"></a>ClassNotFoundException和NoClassDefFoundError的区别</h3><p>NoClassDefFoundError是一个错误(Error)，而ClassNOtFoundException是一个异常，在Java中错误和异常是有区别的，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。</p>
<h4 id="ClassNotFoundException的产生原因"><a href="#ClassNotFoundException的产生原因" class="headerlink" title="ClassNotFoundException的产生原因"></a>ClassNotFoundException的产生原因</h4><ol>
<li>使用<code>Class.forName（ClassLoader.loadClass、ClassLOader.findSystemClass）</code>加载对象时，如果没有找到则会出现该异常</li>
<li>当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。</li>
<li>ClassNotFoundException发生在装入阶段。</li>
<li>加载时从外存储器找不到需要的class就出现ClassNotFoundException</li>
</ol>
<h4 id="NoClassDefFoundError产生的原因"><a href="#NoClassDefFoundError产生的原因" class="headerlink" title="NoClassDefFoundError产生的原因"></a>NoClassDefFoundError产生的原因</h4><ol>
<li>JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。</li>
<li>NoClassDefFoundError： 当目前执行的类已经编译，但是找不到它的定义时</li>
<li>连接时从内存找不到需要的class就出现NoClassDefFoundError</li>
</ol>
<h4 id="NoClassDefFoundError-解决的三种方法"><a href="#NoClassDefFoundError-解决的三种方法" class="headerlink" title="NoClassDefFoundError 解决的三种方法"></a>NoClassDefFoundError 解决的三种方法</h4><ol>
<li><p>Simple example of NoClassDefFoundError is class belongs to a jar and jar was not added into classpath or sometime jar’s name has been changed by someone like in my case one of my colleague has changed tibco.jar into tibco_v3.jar and by program is failing with java.lang.NoClassDefFoundError and I was wondering what’s wrong.<br>首先是类在运行的时候依赖于其它的一个jar包，但是该jar包没有加载到classpath中或者是该jar包的名字被其他人改了，就像我的一个例子tibo.jar改为了tibco_v3.jar……. </p>
</li>
<li><p>Class is not in Classpath, there is no sure shot way of knowing it but many a times you can just have a look to print System.getproperty(”java.classpath“)and it will print the classpath from there you can at least get an idea of your actual runtime classpath.<br>运行的类不在classpath中，这个问题没有一个确定的方法去知道，但是很多时候你可以通过System.getproperty(”java.classpath“)方法，该方法能让你至少可以领略到实际存在的运行期间的classpath。
 </p>
</li>
<li><p>Just try to run with explicitly -classpath option with the classpath you think will work and if its working then it’s sure short sign that some one is overriding java classpath.<br>试着通过-classpath命令明确指出你认为正确的classpath，如果能够正常执行的话就说明你使用的classpath是正确的，而系统中的classpath已经被修该过了。</p>
</li>
</ol>
<h4 id="类装载方式"><a href="#类装载方式" class="headerlink" title="类装载方式"></a>类装载方式</h4><h5 id="显示类装载"><a href="#显示类装载" class="headerlink" title="显示类装载"></a>显示类装载</h5><p>显式 类装入发生在使用以下方法调用装入的类的时候：</p>
<ul>
<li>cl.loadClass()（cl 是 java.lang.ClassLoader 的实例）</li>
<li>Class.forName()（启动的类装入器是当前类定义的类装入器）</li>
</ul>
<p>当调用其中一个方法的时候，指定的类（以类名为参数）由类装入器装入。如果类已经装入，那么只是返回一个引用；否则，装入器会通过委托模型装入类。</p>
<h5 id="隐式类装载"><a href="#隐式类装载" class="headerlink" title="隐式类装载"></a>隐式类装载</h5><p>隐式 类装入发生在由于引用、实例化或继承导致装入类的时候（不是通过显式方法调用）。在每种情况下，装入都是在幕后启动的，JVM 会解析必要的引用并装入类。与显式类装入一样，如果类已经装入了，那么只是返回一个引用；否则，装入器会通过委托模型装入类。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/jygqm/article/details/81364636">JAVA 异常详解</a></li>
<li><a href="https://www.cnblogs.com/hysum/p/7112011.html">JAVA基础——异常详解</a></li>
<li><a href="https://www.cnblogs.com/nwgdk/p/8862353.html">Java 异常基础详解(详细的使用方式，可参考)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/108423001">Java基础篇——异常详解</a></li>
<li><a href="https://blog.csdn.net/qq_31615049/article/details/80952216">Java异常实现及原理</a></li>
<li>《疯狂Java》</li>
<li><a href="https://www.toutiao.com/i6805046770897256974/">finally 到底是在 return 之前还是之后执行的？</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高效编程技巧</title>
    <url>/2021/02/04/Java%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="Java代码规范"><a href="#Java代码规范" class="headerlink" title="Java代码规范"></a>Java代码规范</h2><h3 id="命名规范（阿里规范）"><a href="#命名规范（阿里规范）" class="headerlink" title="命名规范（阿里规范）"></a>命名规范（阿里规范）</h3><ol>
<li><p>名称只能是有含义的英文，不能出现下划线或美元符号</p>
</li>
<li><p>方法名、参数名、成员变量、局部变量统一使用驼峰方式命名，形如lowerCamelCase</p>
</li>
<li><p>类名使用UpperCamelCase命名，DO/BO/DTO/VO/AO/PO/UID除外</p>
</li>
<li><p>常量或类变量都需要使用大写，并且中间使用下划线分割</p>
</li>
<li><p>抽象类必须以Abstract或Base开头，异常类，必须以Exception结果，测试类必须以待测试代码_Test</p>
</li>
<li><p>类型与中括号紧挨相连来表示数组,形如<code>int[] arrayDemo</code></p>
</li>
<li><p>成员变量不能以is开头</p>
</li>
<li><p>包使用小写定义，并且使用单数，中间使用英文句号分割，并且定义必须有意义和唯一性</p>
</li>
<li><p>子类与父类之间不要使用相同的成员变量命名</p>
</li>
<li><p>完全杜绝不规范的缩写，尽量使用完整的单词</p>
</li>
<li><p>在常量与变量命名时，表示类型的名称放在词尾</p>
</li>
<li><p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式</p>
</li>
<li><p>接口中不要定义变量，方式不需要增加任何修饰符，都必须有注释信息</p>
</li>
<li><p>接口与实现类的命名规范是<strong>Service/**ServiceImpl、</strong>DAO/**DAOImpl</p>
</li>
<li><p>枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开</p>
</li>
<li><p>各层命名规范：</p>
<ul>
<li>Service/DAO 层方法命名规约<ul>
<li>获取单个对象的方法用 get 做前缀。</li>
<li>获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。</li>
<li>获取统计值的方法用 count 做前缀。</li>
<li>插入的方法用 save/insert 做前缀。</li>
<li>删除的方法用 remove/delete 做前缀。</li>
<li>修改的方法用 update 做前缀。</li>
</ul>
</li>
<li>领域模型命名规约<ul>
<li>数据对象：xxxDO，xxx 即为数据表名。</li>
<li>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li>
<li>展示对象：xxxVO，xxx 一般为网页名称。</li>
<li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。<a id="more"></a>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>不允许任何魔法值（即未经预先定义的常量）直接出现在代码中，使用常量替换</p>
</li>
<li><p>定义类型为long或Long的属性时，需要用大写L结尾</p>
</li>
<li><p>常量定义要分类维护，一般分为：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量</p>
</li>
<li><p>如果变量值仅在一个固定范围内变化用 enum 类型来定义</p>
</li>
</ol>
<h2 id="高效能开发的原则"><a href="#高效能开发的原则" class="headerlink" title="高效能开发的原则"></a>高效能开发的原则</h2><h3 id="优化代码的注意事项"><a href="#优化代码的注意事项" class="headerlink" title="优化代码的注意事项"></a>优化代码的注意事项</h3><ol>
<li>除非必须优化，否则不要轻易改动</li>
<li>改动之后要进行仔细的测试</li>
<li>在各个JVM产品中不存在一劳永逸的成本模型</li>
</ol>
<h3 id="Java编码原则"><a href="#Java编码原则" class="headerlink" title="Java编码原则"></a>Java编码原则</h3><ol>
<li>注重设计、数据结构、算法选择</li>
<li>不要过分依赖编译器编译期的优化技术，正确理解Java运行期的实际效果</li>
<li>将对象的创建和使用降到最低：<ul>
<li>StringBuilder的使用</li>
<li>for循环中对象的索引使用</li>
<li>线程或连接的复用</li>
<li>合理设计对象的大小（在类加载过程会完成内存大小的计算）</li>
<li>合理设计继承关系（不多于3层）</li>
<li>构造函数尽可能短小精干</li>
<li>对象创建使用懒加载思想</li>
</ul>
</li>
<li>降低同步的影响范围<ul>
<li>是否需要使用同步控制或者线程安全的类</li>
<li>控制同步范围</li>
<li>合理使用锁变量，做到线程分离，提高并发度和吞吐量</li>
<li>减少锁的使用，避免出现死锁</li>
</ul>
</li>
<li>尽量在栈中完成业务处理</li>
<li>使用static、final、private函数促成inlining</li>
<li>实例变量初始化合适就好，比如单例模式</li>
<li>注意集合的使用<ul>
<li>选择合适的遍历方式</li>
<li>使用大小的控制</li>
<li>数据复制的选择</li>
<li>选择合适的集合类</li>
</ul>
</li>
<li>尽可能重用对象</li>
<li>增加缓存概念</li>
</ol>
<h2 id="集合遍历效率问题"><a href="#集合遍历效率问题" class="headerlink" title="集合遍历效率问题"></a>集合遍历效率问题</h2><h3 id="高效遍历MAP"><a href="#高效遍历MAP" class="headerlink" title="高效遍历MAP"></a>高效遍历MAP</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * keySet的for循环方式：</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetForGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetForGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetForGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	        String value = map.get(key);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetForGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * keySet的iterator迭代器方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetIteratorGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetIteratorGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetIteratorGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next();</span><br><span class="line">	        String value = map.get(iterator.next());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetIteratorGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * entrySet的for循环方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetForGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	        String key = entry.getKey();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetForGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetForGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	        String key = entry.getKey();</span><br><span class="line">	        String value = entry.getValue();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetForGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * entrySet的iterator迭代器方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetIteratorGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next().getKey();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetIteratorGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetIteratorGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next().getKey();</span><br><span class="line">	        String value = iterator.next().getValue();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetIteratorGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		    map.put(i + <span class="string">&quot;&quot;</span>, i + <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		MapTest.keySetForGetKey(map);</span><br><span class="line">		MapTest.keySetIteratorGetKey(map);</span><br><span class="line">		MapTest.entrySetForGetKey(map);</span><br><span class="line">		MapTest.entrySetIteratorGetKey(map);</span><br><span class="line">		</span><br><span class="line">		MapTest.keySetForGetKeyAndValue(map);</span><br><span class="line">		MapTest.keySetIteratorGetKeyAndValue(map);</span><br><span class="line">		MapTest.entrySetForGetKeyAndValue(map);</span><br><span class="line">		MapTest.entrySetIteratorGetKeyAndValue(map);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">keySetForGetKey运行时间<span class="number">96</span></span><br><span class="line">keySetIteratorGetKey运行时间<span class="number">107</span></span><br><span class="line">entrySetForGetKey运行时间<span class="number">112</span></span><br><span class="line">entrySetIteratorGetKey运行时间<span class="number">153</span></span><br><span class="line">keySetForGetKeyAndValue运行时间<span class="number">169</span></span><br><span class="line">keySetIteratorGetKeyAndValue运行时间<span class="number">283</span></span><br><span class="line">entrySetForGetKeyAndValue运行时间<span class="number">109</span></span><br><span class="line">entrySetIteratorGetKeyAndValue运行时间<span class="number">138</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：<br>entrySet的方式整体都是比keySet方式要高一些<br>单纯的获取key来说，两者的差别并不大，但是如果要获取value，还是entrySet的效率会更好，因为keySet需要从map中再次根据key获取value，而entrySet一次都全部获取出来<br>iterator的迭代器方式比foreach的效率高  </p>
</blockquote>
<h3 id="实现RandomAccess接口的集合使用for循环而不是foreach来遍历"><a href="#实现RandomAccess接口的集合使用for循环而不是foreach来遍历" class="headerlink" title="实现RandomAccess接口的集合使用for循环而不是foreach来遍历"></a>实现RandomAccess接口的集合使用for循环而不是foreach来遍历</h3><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其：色nu支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p>
<div align="center">

<img src="/2021/02/04/Java%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/1589105799147.png" class title="参考代码">

</div>

<p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p>
<h2 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h2><ol>
<li>尽量使用同步代码块替代同步方法，提高代码执行效率</li>
<li>尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</li>
</ol>
<h2 id="资源处理注意事项"><a href="#资源处理注意事项" class="headerlink" title="资源处理注意事项"></a>资源处理注意事项</h2><ol>
<li>及时关闭资源：使用资源一般都会建立流的连接，比如文件流，数据库连接等，在使用完成之后要及时关闭打开的连接，防止内存泄露。一般在finally中处理。</li>
<li>关闭多个资源时，需要分开执行，防止由于异常无法关闭所有的资源</li>
</ol>
<h2 id="垃圾信息处理"><a href="#垃圾信息处理" class="headerlink" title="垃圾信息处理"></a>垃圾信息处理</h2><ol>
<li>不要定义、创建不使用的对象，变量；</li>
<li>不要导入不需要的依赖包</li>
<li>公用的集合类中不使用的数据一定要及时remove掉</li>
<li>ThreadLocal中不使用的数据要及时处理掉，防止内存溢出</li>
<li>及时清除不再需要的会话（会话超时设置），防止出现内存不足或内存磁盘之间交互频繁，当会话不再需要时，应当及时调用HttpSession的invalidate方法清除会话。</li>
</ol>
<h2 id="尽量使用局部变量"><a href="#尽量使用局部变量" class="headerlink" title="尽量使用局部变量"></a>尽量使用局部变量</h2><ol>
<li>方法参数和临时临时变量都在栈中分配，速度快</li>
<li>类变量、实例变量存储在堆中速度较慢</li>
<li>栈中的变量随时方法的结束而结束，不需要额外的垃圾回收</li>
</ol>
<h2 id="提高效率，减少内存"><a href="#提高效率，减少内存" class="headerlink" title="提高效率，减少内存"></a>提高效率，减少内存</h2><ol>
<li>使用StringBuilder/StringBuffer替代String</li>
<li>循环内不要创建对象的引用：减少堆栈中的使用，避免出现栈内存溢出或出现栈越界。</li>
<li>尽量采用懒加载的策略，即在需要的时候才创建</li>
<li>尽量避免随意使用静态变量：当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的</li>
<li>尽量在合适的场合使用单例（减轻加载的负担、缩短加载的时间、提高加载的效率）<ul>
<li>控制资源的使用，通过线程同步来控制资源的并发访问</li>
<li>控制实例的产生，以达到节约资源的目的</li>
<li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
</li>
<li>使用数据库连接池和线程池：前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</li>
<li>使用带缓冲的输入输出流进行IO操作</li>
<li>乘法和除法使用移位操作</li>
<li>减少对变量的重复计算：对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。集合中大小的重复获取会消耗内存和时间。</li>
<li>当复制大量数据时，使用System.arraycopy命令</li>
<li>基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</li>
<li>程序运行过程中避免使用反射（根据实际情况定）：反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</li>
<li>顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个</li>
</ol>
<h2 id="关键字和方法的说明"><a href="#关键字和方法的说明" class="headerlink" title="关键字和方法的说明"></a>关键字和方法的说明</h2><h3 id="equals的正确使用"><a href="#equals的正确使用" class="headerlink" title="equals的正确使用"></a>equals的正确使用</h3><ol>
<li>重写equals后需要同时完成hashcode方法的重写</li>
<li>equals中初始代码比对的是对象地址</li>
<li>字符串比对相等时，字符串常量写在字符串变量前面，比如”abc”.equals(abc)</li>
</ol>
<h3 id="final的正确使用"><a href="#final的正确使用" class="headerlink" title="final的正确使用"></a>final的正确使用</h3><ol>
<li>如果类不能被派生，则必须定义为final（该类中的方法都是final的）</li>
<li>如果方法不能被重写，则必须定义为final</li>
<li>常量定义为static final，并且名称使用大写，多个字符使用下划线拼接，比如：USER_NAME</li>
<li>不要将数组声明为public static final（final只是表示引用不变，但是内容还是可以变）</li>
</ol>
<h3 id="方法参数要求"><a href="#方法参数要求" class="headerlink" title="方法参数要求"></a>方法参数要求</h3><p>在Java编程中，要尽量保证面向对象编程，并且达到高内聚，低耦合，实现动态扩展的特性。如果定义参数太多，会有以下缺点：</p>
<ol>
<li>违背面向对象编程</li>
<li>可扩展性低</li>
<li>方法调用出错概率大</li>
</ol>
<p>建议参数保证在3~4个之内，尽量使用有明确意义的对象传参（<strong>减少类似Map对象的使用</strong>）。</p>
<h3 id="不要对数组使用toString方法"><a href="#不要对数组使用toString方法" class="headerlink" title="不要对数组使用toString方法"></a>不要对数组使用toString方法</h3><ol>
<li>数组为空会出现空指针</li>
<li>打印的数据是地址信息，与预期不一致</li>
<li>对集合toString是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString方法。</li>
</ol>
<h2 id="异常使用注意事项"><a href="#异常使用注意事项" class="headerlink" title="异常使用注意事项"></a>异常使用注意事项</h2><ol>
<li>慎用异常：异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace的本地同步方法，fillInStackTrace方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</li>
<li>不要在循环中使用try…catch…，应该把其放在最外层，除非不得已</li>
</ol>
<h2 id="合理使用初始化长度"><a href="#合理使用初始化长度" class="headerlink" title="合理使用初始化长度"></a>合理使用初始化长度</h2><ol>
<li>集合：ArrayList、LinkedLlist等</li>
<li>字符串：StringBuilder、StringBuffer等</li>
<li>Map：HashMap等</li>
<li>Set：HashSet等</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol>
<li>不要对超出范围的基本数据类型做向下强制转型<ul>
<li>整型默认的数据类型是int，long需要在结尾增加<code>L</code></li>
<li>浮点型的默认类型是double，所以定义float的时候要写成<code>float f = 3.5f</code></li>
<li>long+int会自动转型为long</li>
</ul>
</li>
<li>基本类型（包装类）转String：<code>toString &gt; String.valueOf &gt; +</code>，可以通过源码得到原因：<ul>
<li>String.valueOf方法底层调用了Integer.toString方法，但是会在调用前做空判断</li>
<li>Integer.toString，直接调用了</li>
<li>i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString方法获取字符串</li>
</ul>
</li>
</ol>
<h2 id="日志规范"><a href="#日志规范" class="headerlink" title="日志规范"></a>日志规范</h2><ol>
<li>日志级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL，常用级别<strong>ERROR、WARN、INFO和DEBUG</strong></li>
<li>ERROR<ul>
<li>表示不能自己恢复的错误，需要立即关注和解决</li>
<li>比如：数据库连接错误、网络错误、未知系统错误</li>
<li>需要接入监控和报警系统 </li>
</ul>
</li>
<li>WARN<ul>
<li>表示可预知的错误，业务场景类错误</li>
<li>比如：参数验证、权限认证 </li>
</ul>
</li>
<li>INFO<ul>
<li>记录系统的基本运行过程和运行状态</li>
<li>包括：系统状态变化、业务流程的核心处理、关键动作、业务流状态的变化 </li>
</ul>
</li>
<li>DEBUG<ul>
<li>调试信息 </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程技巧</tag>
      </tags>
  </entry>
</search>
