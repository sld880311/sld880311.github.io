<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Javap详解</title>
    <url>/2021/02/04/Javap%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>javap 命令用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息,输出堆栈大小、各方法的 locals 及 args 数。</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -<span class="keyword">public</span>                  仅显示公共类和成员</span><br><span class="line">  -<span class="keyword">protected</span>               显示受保护的/公共类和成员</span><br><span class="line">  -<span class="keyword">package</span>                 显示程序包/受保护的/公共类和成员 (默认)</span><br><span class="line">  -p  -<span class="keyword">private</span>             显示所有类和成员</span><br><span class="line">  -c                       输出类中各方法的未解析的代码，即构成 Java 字节码的指令。</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置,如果设置了该选项，则它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置,缺省情况下，自举类是实现核心 Java 平台的类，位于 jrelibt.jar 和 jrelibi18n.jar 中。</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPassByValue</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> temp1 = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">this</span>.passInt(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passInt</span><span class="params">(<span class="keyword">int</span> abc)</span> </span>&#123; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String temp = <span class="string">&quot;abcddd&quot;</span>;</span><br><span class="line">		PassByValue val = <span class="keyword">new</span> PassByValue();</span><br><span class="line">		<span class="keyword">this</span>.passObject(val, temp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passObject</span><span class="params">(PassByValue passByValue, String value)</span> </span>&#123; </span><br><span class="line">		passByValue = <span class="keyword">null</span>;</span><br><span class="line">		value = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValue</span></span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="javap分析"><a href="#javap分析" class="headerlink" title="javap分析"></a>javap分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.TestPassByValue包含com.sunld.TestPassByValue</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/TestPassByValue.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">4</span>-<span class="number">29</span>; size <span class="number">939</span> bytes</span><br><span class="line">  MD5 checksum ae6cce5733ce01797de9d8ae30359bdd</span><br><span class="line">  Compiled from <span class="string">&quot;TestPassByValue.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">TestPassByValue</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/TestPassByValue</span><br><span class="line">   #2 = Utf8               com/sunld/TestPassByValue</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               temp1</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Methodref          #3.#11         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #11 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #12 = Fieldref           #1.#13         // com/sunld/TestPassByValue.temp1:I</span><br><span class="line">  #13 = NameAndType        #5:#6          // temp1:I</span><br><span class="line">  #14 = Utf8               LineNumberTable</span><br><span class="line">  #15 = Utf8               LocalVariableTable</span><br><span class="line">  #16 = Utf8               this</span><br><span class="line">  #17 = Utf8               Lcom/sunld/TestPassByValue;</span><br><span class="line">  #18 = Utf8               doPassInt</span><br><span class="line">  #19 = Methodref          #1.#20         // com/sunld/TestPassByValue.passInt:(I)V</span><br><span class="line">  #20 = NameAndType        #21:#22        // passInt:(I)V</span><br><span class="line">  #21 = Utf8               passInt</span><br><span class="line">  #22 = Utf8               (I)V</span><br><span class="line">  #23 = Utf8               temp</span><br><span class="line">  #24 = Utf8               abc</span><br><span class="line">  #25 = Utf8               doPassObject</span><br><span class="line">  #26 = String             #27            // abcddd</span><br><span class="line">  #27 = Utf8               abcddd</span><br><span class="line">  #28 = Class              #29            // com/sunld/PassByValue</span><br><span class="line">  #29 = Utf8               com/sunld/PassByValue</span><br><span class="line">  #30 = Methodref          #28.#11        // com/sunld/PassByValue.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #31 = Methodref          #1.#32         // com/sunld/TestPassByValue.passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #32 = NameAndType        #33:#34        // passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #33 = Utf8               passObject</span><br><span class="line">  #34 = Utf8               (Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">  #35 = Utf8               Ljava/lang/String;</span><br><span class="line">  #36 = Utf8               val</span><br><span class="line">  #37 = Utf8               Lcom/sunld/PassByValue;</span><br><span class="line">  #38 = String             #39            // value</span><br><span class="line">  #39 = Utf8               value</span><br><span class="line">  #40 = Utf8               passByValue</span><br><span class="line">  #41 = Utf8               SourceFile</span><br><span class="line">  #42 = Utf8               TestPassByValue.java</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//默认的构造方法，在构造方法执行时主要完成一些初始化操作，包括一些成员变量的初始化赋值等操作</span></span><br><span class="line">  <span class="keyword">public</span> com.sunld.TestPassByValue();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">//*load_*：将本地变量表中索引为*的局部变量加载到操作栈</span></span><br><span class="line">         <span class="comment">//从本地变量表中加载索引为0的变量的值到操作栈，也即this的引用，压入栈</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="comment">//invokespecial：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）</span></span><br><span class="line">         <span class="comment">//出栈，调用java/lang/Object.&quot;&lt;init&gt;&quot;:()V 初始化对象，就是this指定的对象的init()方法完成初始化</span></span><br><span class="line">         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="comment">// 4到7表示，完成this.temp1 = 10的赋值。这里this引用入栈</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="comment">//将常量10加入到操作数栈</span></span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="comment">//出栈前面压入的两个值（this引用，常量值10）， 将10取出，并赋值给temp1</span></span><br><span class="line">         7: putfield      #12                 // Field temp1:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      <span class="comment">//指令与代码行数的偏移对应关系，每一行第一个数字对应代码行数，第二个数字对应前面code中指令前面的数字</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">3</span>: <span class="number">10</span></span><br><span class="line">      <span class="comment">//局部变量表，start+length表示这个变量在字节码中的生命周期起始和结束的偏移位置（this生命周期从头0到结尾10）</span></span><br><span class="line">      <span class="comment">//slot就是这个变量在局部变量表中的槽位（槽位可复用），name就是变量名称，Signatur局部变量类型描述</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassInt</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// 常量100入栈</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="comment">// 将一个数值从操作数栈存储到局部变量表,存储100给temp</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="comment">// 加载this入栈</span></span><br><span class="line">         <span class="number">3</span>: aload_0</span><br><span class="line">         <span class="comment">// temp入栈</span></span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         5: invokevirtual #19                 // Method passInt:(I)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">3</span>       <span class="number">6</span>     <span class="number">1</span>  temp   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passInt</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">1</span>   abc   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPassObject</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// 从常量池取出abcddd入栈</span></span><br><span class="line">         0: ldc           #26                 // String abcddd</span><br><span class="line">         <span class="comment">// 出栈赋值给temp</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="comment">// 创建PassByValue对象，将引用压入栈</span></span><br><span class="line">         3: new           #28                 // class com/sunld/PassByValue</span><br><span class="line">         <span class="comment">// 将操作数栈顶的数据复制一份，并压入栈，此时栈中有两个引用值（目前有两个PassByValue的引用）</span></span><br><span class="line">         <span class="number">6</span>: dup</span><br><span class="line">         7: invokespecial #30                 // Method com/sunld/PassByValue.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="comment">// 出栈栈顶数据（对象PassByValue）复制给val</span></span><br><span class="line">        <span class="number">10</span>: astore_2</span><br><span class="line">        <span class="comment">// 入栈this</span></span><br><span class="line">        <span class="number">11</span>: aload_0</span><br><span class="line">        <span class="comment">// 入栈val</span></span><br><span class="line">        <span class="number">12</span>: aload_2</span><br><span class="line">        <span class="comment">// 入栈temp</span></span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        14: invokevirtual #31                 // Method passObject:(Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">        <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">18</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">3</span>      <span class="number">15</span>     <span class="number">1</span>  temp   Ljava/lang/String;</span><br><span class="line">           <span class="number">11</span>       <span class="number">7</span>     <span class="number">2</span>   val   Lcom/sunld/PassByValue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passObject</span><span class="params">(com.sunld.PassByValue, java.lang.String)</span></span>;</span><br><span class="line">    descriptor: (Lcom/sunld/PassByValue;Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: aconst_null</span><br><span class="line">         <span class="number">1</span>: astore_1</span><br><span class="line">         2: ldc           #38                 // String value</span><br><span class="line">         <span class="number">4</span>: astore_2</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/sunld/TestPassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span> passByValue   Lcom/sunld/PassByValue;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">2</span> value   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestPassByValue.java&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.jianshu.com/p/6a8997560b05">通过javap命令分析java汇编指令</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>Javap</tag>
        <tag>Class分析</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系统化学习之注解</title>
    <url>/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>在jdk1.5中引入了注解的概念，注解是Java提供的一种对类信息（包括：类、属性与方法）进行扩展的一种行为。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation 对象，然后通过该 Annotation 对象来获取注解中的元数据信息。通过使用注解，可以将元数据保存在 Java 源代码中。并拥有如下优势：</p>
<ol>
<li>简单易读的代码，</li>
<li>编译器类型检查，</li>
<li>使用 annotation API 为自己的注解构造处理工具。</li>
</ol>
<a id="more"></a>
<p>JDK中目前引入的注解：</p>
<ul>
<li><strong>@Override</strong>：表示当前的方法定义将覆盖基类的方法。如果你不小心拼写错误，或者方法签名被错误拼写的时候，编译器就会发出错误提示。</li>
<li><strong>@Deprecated</strong>：如果使用该注解的元素被调用，编译器就会发出警告信息。</li>
<li><strong>@SuppressWarnings</strong>：关闭不当的编译器警告信息。</li>
<li><strong>@SafeVarargs</strong>：在 Java 7 中加入用于禁止对具有泛型varargs参数的方法或构造函数的调用方发出警告。</li>
<li><strong>@FunctionalInterface</strong>：Java 8 中加入用于表示类型声明为函数式接口</li>
</ul>
<div align="center">

<img src="/2021/02/04/Java%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E8%A7%A3/1588840779124.png" class title="1588840779124.png">

</div>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>jdk中目前定义了5中标准的meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>@Target</td>
<td>表示注解可以用于哪些地方。可能的 <strong>ElementType</strong> 参数包括：<br><strong>CONSTRUCTOR</strong>：构造器的声明<br><strong>FIELD</strong>：字段声明（包括 enum 实例）<br><strong>LOCAL_VARIABLE</strong>：局部变量声明<br><strong>METHOD</strong>：方法声明<br><strong>PACKAGE</strong>：包声明<br><strong>PARAMETER</strong>：参数声明<br><strong>TYPE</strong>：类、接口（包括注解类型）或者 enum 声明</td>
</tr>
<tr>
<td>@Retention</td>
<td>表示注解信息保存的时长。可选的 <strong>RetentionPolicy</strong> 参数包括：<br><strong>SOURCE</strong>：注解将被编译器丢弃<br><strong>CLASS</strong>：注解在 class 文件中可用，但是会被 VM 丢弃。<br><strong>RUNTIME</strong>：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</td>
</tr>
<tr>
<td>@Documented</td>
<td>将此注解保存在 Javadoc 中</td>
</tr>
<tr>
<td>@Inherited</td>
<td>允许子类继承父类的注解</td>
</tr>
<tr>
<td>@Repeatable</td>
<td>允许一个注解可以被使用一次或者多次（Java 8）。</td>
</tr>
</tbody></table>
<h3 id="Target修饰的对象范围"><a href="#Target修饰的对象范围" class="headerlink" title="@Target修饰的对象范围"></a>@Target修饰的对象范围</h3><p><strong>@Target</strong>说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的作用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Retention定义被保留的时间长短"><a href="#Retention定义被保留的时间长短" class="headerlink" title="@Retention定义被保留的时间长短"></a>@Retention定义被保留的时间长短</h3><p><strong>@Retention</strong> 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：</p>
<ol>
<li>SOURCE:在源文件中有效（即源文件保留）</li>
<li>CLASS:在 class 文件中有效（即 class 保留）</li>
<li>RUNTIME:在运行时有效（即运行时保留）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体作用范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Documented描述-javadoc"><a href="#Documented描述-javadoc" class="headerlink" title="@Documented描述-javadoc"></a>@Documented描述-javadoc</h3><p><strong>@Documented</strong> 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inherited阐述了某个被标注的类型是被继承的"><a href="#Inherited阐述了某个被标注的类型是被继承的" class="headerlink" title="@Inherited阐述了某个被标注的类型是被继承的"></a>@Inherited阐述了某个被标注的类型是被继承的</h3><p><strong>@Inherited</strong> 元注解是一个标记注解，**@Inherited** 阐述了某个被标注的类型是被继承的。如果一个使用了**@Inherited** 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该 class 的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span></span><br><span class="line"><span class="comment">     * repeatable annotation type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the containing annotation type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过注解实现一种日志记录的方式。</p>
<h3 id="LogAnnotation定义"><a href="#LogAnnotation定义" class="headerlink" title="LogAnnotation定义"></a>LogAnnotation定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation &#123;</span><br><span class="line">	<span class="comment">/** 日志类型 **/</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">	<span class="comment">/** 日志内容 **/</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">content</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@LogAnnotation(content = &quot;用户登录日志信息&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解元数据解析"><a href="#注解元数据解析" class="headerlink" title="注解元数据解析"></a>注解元数据解析</h3><p>getDeclaredMethods() 和 getAnnotation()，它们都属于 AnnotatedElement 接口（Class，Method 与 Field 类都实现了该接口）。getAnnotation() 方法返回指定类型的注解对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationUtil</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getLogInfo</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">		<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">			<span class="keyword">if</span> (method.isAnnotationPresent(LogAnnotation.class)) &#123;</span><br><span class="line">				LogAnnotation annotation = method.getAnnotation(LogAnnotation.class);</span><br><span class="line">				<span class="comment">// 注解信息的处理地方</span></span><br><span class="line">				System.out.println(annotation.content() + <span class="string">&quot; 类型：&quot;</span> + annotation.type());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		AnnotationUtil.getLogInfo(Login.class); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="默认值问题"><a href="#默认值问题" class="headerlink" title="默认值问题"></a>默认值问题</h3><ol>
<li>元素不能有不确定的值：要么使用默认值要么使用代码中定义的值</li>
<li>非基本类型的原始不能定义null，可以使用自定义约束来进行实现</li>
</ol>
<h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>单元测试</li>
<li>数据库相关的ORM操作</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://lingcoder.github.io/OnJava8/#/book/23-Annotations?id=%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95">编程思想</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse使用技巧</title>
    <url>/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="集成javap命令"><a href="#集成javap命令" class="headerlink" title="集成javap命令"></a>集成javap命令</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li>eclipse中点击工具栏: Run &gt; External Tools &gt; External Tools Configuration</li>
<li>双击”程序”</li>
<li>修改配置</li>
</ol>
<div align="center">

<img src="/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1588039059895.png" class title="执行javap">

</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Name: javap(随意)</span><br><span class="line">location: jdk实际路径</span><br><span class="line">Working Directory:$&#123;workspace_loc&#125;\$&#123;project_name&#125; （不要改）</span><br><span class="line">Arguments:-c -verbose  -classpath  $&#123;workspace_loc&#125;/ $&#123;project_name&#125;/bin/$&#123;java_type_name&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><div align="center">

<img src="/2021/02/04/eclipse%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1588039225454.png" class title="eclipse配置">

</div>

<h3 id="javap的命令说明"><a href="#javap的命令说明" class="headerlink" title="javap的命令说明"></a>javap的命令说明</h3><p>参考《<a href="%5BJavap%E8%AF%A6%E8%A7%A3.md%5D(https://www.sunliaodong.cn/2021/02/04/Javap%E8%AF%A6%E8%A7%A3/)">javap详解</a>》</p>
<h2 id="debug使用技巧"><a href="#debug使用技巧" class="headerlink" title="debug使用技巧"></a>debug使用技巧</h2><h3 id="常用快捷键说明"><a href="#常用快捷键说明" class="headerlink" title="常用快捷键说明"></a>常用快捷键说明</h3><ol>
<li>Step Into (also F5) 跳入</li>
<li>Step Over (also F6) 跳过</li>
<li>Step Return (also F7) 执行完当前method，然后return跳出此method</li>
<li>step Filter 逐步过滤 一直执行直到遇到未经过滤的位置或断点(设置Filter:window-preferences-java-Debug-step Filtering)</li>
<li>resume 重新开始执行debug,一直运行直到遇到breakpoint</li>
<li>hit count 设置执行次数 适合程序中的for循环(设置 breakpoint view-右键hit count)</li>
<li>inspect 检查 运算。执行一个表达式显示执行值</li>
<li>watch 实时地监视变量的变化</li>
<li>我们常说的断点(breakpoints)是指line breakpoints,除了line breakpoints,还有其他的断点类型：field(watchpoint)breakpoint,method breakpoint,exception breakpoint.</li>
<li>field breakpoint 也叫watchpoint(监视点) 当成员变量被读取或修改时暂挂</li>
<li>添加method breakpoint 进入/离开此方法时暂挂(Run-method breakpoint)</li>
<li>添加Exception breakpoint 捕抓到Execption时暂挂(待续…)</li>
</ol>
<h3 id="断点属性"><a href="#断点属性" class="headerlink" title="断点属性"></a>断点属性</h3><ol>
<li>hit count 执行多少次数后暂挂 用于循环</li>
<li>enable condition 遇到符合你输入条件(为ture\改变时)就暂挂</li>
<li>suspend thread 多线程时暂挂此线程</li>
<li>suspend VM 暂挂虚拟机</li>
<li>variables 视图里的变量可以改变变量值，在variables 视图选择变量点击右键–change value.一次来进行快速调试。</li>
<li>debug 过程中修改了某些code后–〉save&amp;build–&gt;resume–&gt;重新暂挂于断点</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">  MyDate aa = <span class="keyword">new</span> MyDate();</span><br><span class="line">  aa.addDays(day);                      =============》(<span class="number">1</span>)</span><br><span class="line">  System.out.println(<span class="string">&quot;eeeeeeeeeeeeeee&quot;</span>);=============》(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">addDays</span><span class="params">(<span class="keyword">int</span> more_days)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);               =============》(<span class="number">3</span>)</span><br><span class="line">    String result = <span class="string">&quot;&quot;</span>;         =============》(<span class="number">4</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);               =============》(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>你在(1)处加断点，运行到此处时如果Step Into (also F5)为跳入，则接着执行到(3)。再执行Step Over (also F6)执行本行，则执行到(4)。最后执行Step Return (also F7)，则跳出addDays方法，跳到(2)</p>
<h2 id="配置-author"><a href="#配置-author" class="headerlink" title="配置@author"></a>配置@author</h2><ol>
<li>eclipse-&gt;window-&gt;preference-&gt;java-&gt;code  styple-&gt;code template-&gt;Code-&gt;New Java files </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">点击 Edit </span><br><span class="line">$&#123;filecomment&#125;</span><br><span class="line">$&#123;package_declaration&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 孙辽东</span></span><br><span class="line"><span class="comment">* <span class="doctag">@E</span>-mail:sld880311@126.com</span></span><br><span class="line"><span class="comment">* <span class="doctag">@qq</span>:767768553</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 创建时间：$&#123;date&#125; $&#123;time&#125;</span></span><br><span class="line"><span class="comment">* 简单说明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$&#123;typecomment&#125;</span><br><span class="line">$&#123;type_declaration&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在建立类文件的时候输入“/**”的时候自动出来的：eclipse-&gt;window-&gt;preference-&gt;java-&gt;code  styple-&gt;code template-&gt;comments-&gt;typles,点击 Edit ，就可以根据自己需要编写了</li>
</ol>
]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>git详解</title>
    <url>/2021/02/04/git%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="提交本地工程到github"><a href="#提交本地工程到github" class="headerlink" title="提交本地工程到github"></a>提交本地工程到github</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;注释&quot;</span></span><br><span class="line">git remote add origin https://github.com/sld880311/parkspaceagent</span><br><span class="line"></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="comment">#如果出现fatal: refusing to merge unrelated histories</span></span><br><span class="line">使用如下命令 git pull origin master --allow-unrelated-histories</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="代码提交示意图"><a href="#代码提交示意图" class="headerlink" title="代码提交示意图"></a>代码提交示意图</h3><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589535948892.png" class title="git代码提交示意图">

</div>

<h3 id="官方参考图"><a href="#官方参考图" class="headerlink" title="官方参考图"></a>官方参考图</h3><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589535987537.png" class title="git官网提交提示图">

</div>

<h2 id="使用图解"><a href="#使用图解" class="headerlink" title="使用图解"></a>使用图解</h2><div align="center">

<img src="/2021/02/04/git%E8%AF%A6%E8%A7%A3/1589536030194.png" class title="git命令使用详解">

</div>

<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h3><h4 id="–-filename"><a href="#–-filename" class="headerlink" title="– filename"></a>– filename</h4><p>把filename文件在工作区的修改撤销到最近一次git add 或 git commit时的内容。</p>
<h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。</p>
<p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</p>
<p>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</p>
<p>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p>
<h2 id="分支详解"><a href="#分支详解" class="headerlink" title="分支详解"></a>分支详解</h2><h2 id="忽略文件参考"><a href="#忽略文件参考" class="headerlink" title="忽略文件参考"></a>忽略文件参考</h2><p>在工程下建立文件.gitignore,复制以下内容  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.ear</span><br><span class="line"></span><br><span class="line"># ignore Maven generated target folders</span><br><span class="line">target</span><br><span class="line"></span><br><span class="line"># ignore eclipse files</span><br><span class="line">.project</span><br><span class="line">.classpath</span><br><span class="line">.settings</span><br><span class="line">.metadata</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/shih/p/6826743.html">git重要的三个命令stash, checkout, reset的一些总结</a></li>
<li><a href="https://blog.csdn.net/hughgilbert/article/details/70473348">Git学习（三）——staging area 工作原理</a></li>
<li><a href="https://segmentfault.com/q/1010000007679514">git中stash的工作原理是什么？</a></li>
<li><a href="https://blog.csdn.net/chenj_freedom/article/details/50543152">git教程 - 概念 原理 使用</a></li>
<li><a href="https://www.cnblogs.com/houpeiyong/p/5890748.html">git revert和git reset的区别</a></li>
<li><a href="https://blog.csdn.net/hudashi/article/details/7664460">代码回滚：git reset、git checkout和git revert区别和联系</a></li>
<li><a href="https://blog.csdn.net/ibingow/article/details/7541402">git reflog</a></li>
</ol>
]]></content>
      <categories>
        <category>常用工具</category>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+github+next部署个人博客</title>
    <url>/2021/02/03/%E4%BD%BF%E7%94%A8hexo-github-next%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"><span class="comment"># 修改原</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 改回去</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>
<h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>使用npm安装hexo(<a href="https://hexo.io/zh-cn/">详细文档</a>)，命令是<code>npm install -g hexo-cli</code>,安装完成之后初始化博客,命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir sld880311.github.io</span><br><span class="line"><span class="built_in">cd</span> sld880311.github.io</span><br><span class="line">hexo init </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>初始化完成之后目录结构如下：<a id="more"></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 网站的配置信息，您可以在此配置大部分的参数。 </span></span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds <span class="comment"># 模版文件夹</span></span><br><span class="line">├── <span class="built_in">source</span>  <span class="comment"># 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span></span><br><span class="line">|   ├── _drafts <span class="comment"># 草稿文件</span></span><br><span class="line">|   └── _posts <span class="comment"># 文章Markdowm文件 </span></span><br><span class="line">└── themes  <span class="comment"># 主题文件夹</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s         <span class="comment"># 启动服务，然后可以使用 http://localhost:4000访问</span></span><br><span class="line">hexo init      <span class="comment">#生成文档</span></span><br><span class="line">hexo g         <span class="comment">#生成网页</span></span><br><span class="line">hexo clean     <span class="comment">#清除网页</span></span><br><span class="line">hexo d         <span class="comment">#部署博客</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h2 id="特殊配置"><a href="#特殊配置" class="headerlink" title="特殊配置"></a>特殊配置</h2><h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>获取<code>cat ~/.ssh/id_rsa.pub</code>中的数据，如果没有数据需要按照以下命令配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;sunliaodong&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;sld880311@hotmail.com&quot;</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;sld880311@hotmail.com&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后把生成的key添加中自己的github中即可。</p>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><h4 id="修改根目录下的-config-yml"><a href="#修改根目录下的-config-yml" class="headerlink" title="修改根目录下的_config.yml"></a>修改根目录下的_config.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/sld880311/sld880311.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h4 id="安装部署插件hexo-deployer-git"><a href="#安装部署插件hexo-deployer-git" class="headerlink" title="安装部署插件hexo-deployer-git"></a>安装部署插件hexo-deployer-git</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h4 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<h3 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h3><h4 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<h4 id="修改根目录的-config-yml"><a href="#修改根目录的-config-yml" class="headerlink" title="修改根目录的_config.yml"></a>修改根目录的_config.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章字数统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="修改主题-config-yml"><a href="#修改主题-config-yml" class="headerlink" title="修改主题_config.yml"></a>修改主题_config.yml</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br><span class="line">  item_text_post: <span class="literal">true</span></span><br><span class="line">  item_text_total: <span class="literal">true</span></span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>
<h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章名称&quot;</span>      <span class="comment"># 使用命令创建文章</span></span><br><span class="line">hexo new page categories  <span class="comment"># 定义分类</span></span><br><span class="line">hexo new page tags        <span class="comment"># 定义标签</span></span><br><span class="line">hexo new page about       <span class="comment"># 定义关于</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://theme-next.iissnan.com/">theme-next.iissnan</a></li>
<li><a href="https://theme-next.js.org/docs/">theme-next.js</a></li>
<li><a href="https://www.jianshu.com/p/446ec02bb0a8">Hexo+Next搭建个人博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/185015237">hexo之主题优化篇</a></li>
<li><a href="https://segmentfault.com/a/1190000017986794">超详细Hexo+Github Page搭建技术博客教程【持续更新】</a></li>
<li><a href="https://blog.csdn.net/u014786530/article/details/103548737">Hexo+NexT搭建个人博客</a></li>
<li><a href="https://blog.csdn.net/qq_40930491/article/details/87902310">从头开始搭建hexo+github+hexo-theme-next主题博客（高级设置）</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>（Singleton Pattern、单态模式、单件模式、对象创建型模式），单例模式的特点：</p>
<ol>
<li>构造方法私有化；(不能被实例化和继承)</li>
<li>实例化的变量引用私有化；</li>
<li>获取实例的方法共有。</li>
</ol>
<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><ol>
<li>唯一的对象实例</li>
<li>保证一个类仅有一个实例，并提供一个访问他的全局访问点</li>
<li>有状态（可变的单例对象，可以组成状态仓库）、无状态（工具类）</li>
</ol>
<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>在下面的情况下可以使用Singleton模式：</p>
<ol>
<li>当类只能有一个实例而且客户可以从一个总所周知的访问点访问它时。</li>
<li>当这个唯一实例应该是通过子类可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
<li>系统只需要一个实例的对象，而这个对象又会被经常创建。</li>
</ol>
<a id="more"></a>

<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><div align="center">

<img src="/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1588206615300.png" class title="单例模式结构图">

</div>

<h2 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h2><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><ol>
<li>定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作。</li>
<li>可能负责创建它自己的唯一实例。</li>
</ol>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="懒汉模式（延迟加载）"><a href="#懒汉模式（延迟加载）" class="headerlink" title="懒汉模式（延迟加载）"></a>懒汉模式（延迟加载）</h3><h4 id="普通实现-非线程安全"><a href="#普通实现-非线程安全" class="headerlink" title="普通实现-非线程安全"></a>普通实现-非线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：非线程安全</p>
</blockquote>
<h4 id="锁在方法上-synchronized-线程安全"><a href="#锁在方法上-synchronized-线程安全" class="headerlink" title="锁在方法上(synchronized)-线程安全"></a>锁在方法上(synchronized)-线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：线程安全，效率低</p>
</blockquote>
<h4 id="同步代码块（synchronized）-线程不安全"><a href="#同步代码块（synchronized）-线程不安全" class="headerlink" title="同步代码块（synchronized）-线程不安全"></a>同步代码块（synchronized）-线程不安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton1.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：线程安全，效率低</p>
</blockquote>
<h4 id="DCL模式实现-线程安全"><a href="#DCL模式实现-线程安全" class="headerlink" title="DCL模式实现-线程安全"></a>DCL模式实现-线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 防止重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton1.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++ ) &#123;</span><br><span class="line">			es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() </span><br><span class="line">							+  Singleton1.getInstance());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="为什么需要使用volatile"><a href="#为什么需要使用volatile" class="headerlink" title="为什么需要使用volatile"></a>为什么需要使用volatile</h5><p><code>instance = new Singleton()</code>主要是完成了以下三个事情</p>
<ol>
<li>给instance实例分配内存；</li>
<li>初始化instance的构造器；</li>
<li>将instance对象指向分配的内存空间（注意到这步时instance就非null了）</li>
</ol>
<p>JVM会进行指令优化为：  </p>
<ol>
<li>给instance实例分配内存；</li>
<li>将instance对象指向分配的内存空间；—会出现线程安全问题</li>
<li>初始化instance的构造器；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">警告: 二进制文件Test/bin/com.sunld.Singleton1包含com.sunld.Singleton1</span><br><span class="line">Classfile /D:/Workspaces/java/TestJVM/Test/bin/com/sunld/Singleton1.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">4</span>-<span class="number">30</span>; size <span class="number">620</span> bytes</span><br><span class="line">  MD5 checksum 69d5cbecd81034e77060fee87c23526c</span><br><span class="line">  Compiled from <span class="string">&quot;Singleton1.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sunld</span>.<span class="title">Singleton1</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/sunld/Singleton1</span><br><span class="line">   #2 = Utf8               com/sunld/Singleton1</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               instance</span><br><span class="line">   #6 = Utf8               Lcom/sunld/Singleton1;</span><br><span class="line">   #7 = Utf8               &lt;clinit&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Fieldref           #1.#11         // com/sunld/Singleton1.instance:Lcom/sunld/Singleton1;</span><br><span class="line">  #11 = NameAndType        #5:#6          // instance:Lcom/sunld/Singleton1;</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Methodref          #3.#16         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = NameAndType        #14:#8         // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #17 = Utf8               this</span><br><span class="line">  #18 = Utf8               getInstance</span><br><span class="line">  #19 = Utf8               ()Lcom/sunld/Singleton1;</span><br><span class="line">  #20 = Methodref          #1.#16         // com/sunld/Singleton1.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Utf8               StackMapTable</span><br><span class="line">  #22 = Class              #23            // java/lang/Class</span><br><span class="line">  #23 = Utf8               java/lang/Class</span><br><span class="line">  #24 = Class              #25            // java/lang/Throwable</span><br><span class="line">  #25 = Utf8               java/lang/Throwable</span><br><span class="line">  #26 = Utf8               SourceFile</span><br><span class="line">  #27 = Utf8               Singleton1.java</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: aconst_null</span><br><span class="line">         1: putstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.sunld.<span class="function">Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()Lcom/sunld/Singleton1;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">         <span class="number">3</span>: ifnonnull     <span class="number">35</span></span><br><span class="line">         6: ldc           #1                  // class com/sunld/Singleton1</span><br><span class="line">         <span class="number">8</span>: dup</span><br><span class="line">         <span class="number">9</span>: astore_0</span><br><span class="line">        <span class="number">10</span>: monitorenter</span><br><span class="line">        11: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">14</span>: ifnonnull     <span class="number">27</span></span><br><span class="line">        17: new           #1                  // class com/sunld/Singleton1</span><br><span class="line">        <span class="number">20</span>: dup</span><br><span class="line">        21: invokespecial #20                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        24: putstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">27</span>: aload_0</span><br><span class="line">        <span class="number">28</span>: monitorexit</span><br><span class="line">        <span class="number">29</span>: goto          <span class="number">35</span></span><br><span class="line">        <span class="number">32</span>: aload_0</span><br><span class="line">        <span class="number">33</span>: monitorexit</span><br><span class="line">        <span class="number">34</span>: athrow</span><br><span class="line">        35: getstatic     #10                 // Field instance:Lcom/sunld/Singleton1;</span><br><span class="line">        <span class="number">38</span>: areturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">            <span class="number">11</span>    <span class="number">29</span>    <span class="number">32</span>   any</span><br><span class="line">            <span class="number">32</span>    <span class="number">34</span>    <span class="number">32</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">17</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">27</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">35</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">3</span></span><br><span class="line">        frame_type = <span class="number">252</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">27</span></span><br><span class="line">          locals = [ class java/lang/Class ]</span><br><span class="line">        frame_type = <span class="number">68</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Singleton1.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="饿汉模式（立即加载）"><a href="#饿汉模式（立即加载）" class="headerlink" title="饿汉模式（立即加载）"></a>饿汉模式（立即加载）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论:</p>
<ol>
<li>线程安全</li>
<li>在获取变量的过程中不能有其他操作，以防出现线程安全问题</li>
</ol>
</blockquote>
<h3 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ObjectStreamException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonInner</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner1</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> SingletonInner instance = <span class="keyword">new</span> SingletonInner();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInner1.instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 防止序列化之后变成多例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ObjectStreamException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">readResoObject</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInner1.instance;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++ ) &#123;</span><br><span class="line">			es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() </span><br><span class="line">							+  SingletonInner.getInstance());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举实现单例"><a href="#枚举实现单例" class="headerlink" title="枚举实现单例"></a>枚举实现单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//私有化构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">	<span class="comment">//定义一个静态枚举类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个枚举对象，该对象天生为单例</span></span><br><span class="line">        INSTANCE;</span><br><span class="line">		<span class="keyword">private</span> EnumSingleton enumSingleton;</span><br><span class="line">		<span class="comment">//私有化枚举的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        	enumSingleton = <span class="keyword">new</span> EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enumSingleton;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对外暴露一个获取EnumSingleton对象的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstnce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：<br>枚举可以解决反序列化会破坏单例的问题</p>
<blockquote>
<p>在枚举序列化的时候，Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。</p>
</blockquote>
</blockquote>
<h3 id="单例注册工厂"><a href="#单例注册工厂" class="headerlink" title="单例注册工厂"></a>单例注册工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonRegistryFactory</span> <span class="keyword">implements</span> <span class="title">FactoryInterface</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity = <span class="number">50</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonRegistryFactory singleRegistry = <span class="keyword">new</span> SingletonRegistryFactory();</span><br><span class="line">	<span class="comment">//保证线程安全</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String,Object&gt; singletonCache = Collections.synchronizedMap(<span class="keyword">new</span> LRULinkedHashMap&lt;String, Object&gt;(maxCapacity));</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 私有构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingletonRegistryFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonRegistryFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> singleRegistry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.singletonCache.get(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object sharedBean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.put(beanName, sharedBean);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroySingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonCache) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonCache.clear();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>客户职能通过Singleton的Instance操作访问一个Singleton的实例。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="对唯一实例的受控访问"><a href="#对唯一实例的受控访问" class="headerlink" title="对唯一实例的受控访问"></a>对唯一实例的受控访问</h3><p>因为Singleton类封装它的唯一实例，所以它可以严格的控制客户怎样以及何时访问它。</p>
<h3 id="缩小名空间"><a href="#缩小名空间" class="headerlink" title="缩小名空间"></a>缩小名空间</h3><p>Singleton模式是对全局变量的一种改进。它避免了那些存储唯一实例的全局变量污染名空间。</p>
<h3 id="允许对操作和表示的精化"><a href="#允许对操作和表示的精化" class="headerlink" title="允许对操作和表示的精化"></a>允许对操作和表示的精化</h3><p>Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时刻配置应用。</p>
<h3 id="允许可变数目的实例"><a href="#允许可变数目的实例" class="headerlink" title="允许可变数目的实例"></a>允许可变数目的实例</h3><p>这个模式使得你易于改变你的想法，并允许Singleton类的多个实例。此外，你可以用相同的方法来控制应用所使用的实例的数目。只允许访问Singleton实例的操作需要改变。</p>
<h3 id="比类操作更灵活"><a href="#比类操作更灵活" class="headerlink" title="比类操作更灵活"></a>比类操作更灵活</h3><p>另一种封装单件功能的方式是使用类操作。但这种语言技术难以改变设计你允许一个类有多个实例。此外，静态成员函数不是虚函数，因此子类不能多态的重定义它们。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>实例控制，保证实例的唯一性</li>
<li>灵活性，因为类控制了实例化过程，所以类可以灵活更改实例化过程。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>需要提供详细文档提供开发者使用，防止开发混乱</li>
<li>不能解决删除单个对象的问题，可以使用缓存管理技术管理单例对象</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="保证一个唯一的实例"><a href="#保证一个唯一的实例" class="headerlink" title="保证一个唯一的实例"></a>保证一个唯一的实例</h3><p>Singleton模式使得这个唯一实例是类的一般实例，但该类被写成只有一个实例能被创建。做到这一点的一个常用方法是将创建这个实例的操作隐藏在一个类操作后面，由它保证只有一个实例被创建。这个操作可以访问保存唯一实例的变量，而且它可以保证这个变量在返回值之前用这个唯一实例初始化。这种方法保证了单件在它的首次使用前被创建和使用。</p>
<h3 id="创建Singleton类的子类"><a href="#创建Singleton类的子类" class="headerlink" title="创建Singleton类的子类"></a>创建Singleton类的子类</h3><p>主要问题与其说是定义子类不如说是建立它的唯一实例，这样客户就可以使用它。事实上，指向单件实例的变量必须用子类的实例进行初始化。最简单的技术是在Singleton的Instance操作中决定你想使用的是哪一个单件。  </p>
<p>另一个选择Singleton的子类的方法是将Instance的实现从父类中分离出来，将它放入子类。<br>一个更灵活的方法是使用一个单件注册表（registry of singleton）。可能的Singleton类的集合不是由Instance定义的，Singleton类可以根据名字在一个众所周知的注册表中注册它们的单件实例。<br>这个注册表在字符串名字和单件之间建立映射。当Instance需要一个单件时，它参考注册表，根据名字请求单件。</p>
<h2 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h2><p>各种工具类的使用，建议使用缓存技术管理单例对象</p>
<h3 id="Spring框架中实现的例子"><a href="#Spring框架中实现的例子" class="headerlink" title="Spring框架中实现的例子"></a>Spring框架中实现的例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework.adapter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Singleton to publish a shared DefaultAdvisorAdapterRegistry instance.</span></span><br><span class="line"><span class="comment"> * 抽象化类使其不可实例化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DefaultAdvisorAdapterRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvisorAdapterRegistry</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Keep track of a single instance so we can return it to classes that request it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AdvisorAdapterRegistry instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the singleton &#123;<span class="doctag">@link</span> DefaultAdvisorAdapterRegistry&#125; instance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AdvisorAdapterRegistry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Reset the singleton &#123;<span class="doctag">@link</span> DefaultAdvisorAdapterRegistry&#125;, removing any</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> AdvisorAdapterRegistry#registerAdvisorAdapter(AdvisorAdapter) registered&#125;</span></span><br><span class="line"><span class="comment">	 * adapters.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h2><ol>
<li>Abstract Factory Pattern中的具体工厂</li>
<li>Builder Pattern中的指导者</li>
<li>Facade Pattern中的Facade参与者</li>
<li>Prototype Pattern中的原型管理器</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/codingmengmeng/p/9846131.html">DCL单例模式</a></li>
<li><a href="https://www.toutiao.com/i6821004595079152141/">被面试官虐过之后，他轻蔑的问我：你还说你了解单例模式吗?</a></li>
</ol>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高效编程技巧</title>
    <url>/2021/02/04/Java%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="Java代码规范"><a href="#Java代码规范" class="headerlink" title="Java代码规范"></a>Java代码规范</h2><h3 id="命名规范（阿里规范）"><a href="#命名规范（阿里规范）" class="headerlink" title="命名规范（阿里规范）"></a>命名规范（阿里规范）</h3><ol>
<li><p>名称只能是有含义的英文，不能出现下划线或美元符号</p>
</li>
<li><p>方法名、参数名、成员变量、局部变量统一使用驼峰方式命名，形如lowerCamelCase</p>
</li>
<li><p>类名使用UpperCamelCase命名，DO/BO/DTO/VO/AO/PO/UID除外</p>
</li>
<li><p>常量或类变量都需要使用大写，并且中间使用下划线分割</p>
</li>
<li><p>抽象类必须以Abstract或Base开头，异常类，必须以Exception结果，测试类必须以待测试代码_Test</p>
</li>
<li><p>类型与中括号紧挨相连来表示数组,形如<code>int[] arrayDemo</code></p>
</li>
<li><p>成员变量不能以is开头</p>
</li>
<li><p>包使用小写定义，并且使用单数，中间使用英文句号分割，并且定义必须有意义和唯一性</p>
</li>
<li><p>子类与父类之间不要使用相同的成员变量命名</p>
</li>
<li><p>完全杜绝不规范的缩写，尽量使用完整的单词</p>
</li>
<li><p>在常量与变量命名时，表示类型的名称放在词尾</p>
</li>
<li><p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式</p>
</li>
<li><p>接口中不要定义变量，方式不需要增加任何修饰符，都必须有注释信息</p>
</li>
<li><p>接口与实现类的命名规范是<strong>Service/**ServiceImpl、</strong>DAO/**DAOImpl</p>
</li>
<li><p>枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开</p>
</li>
<li><p>各层命名规范：</p>
<ul>
<li>Service/DAO 层方法命名规约<ul>
<li>获取单个对象的方法用 get 做前缀。</li>
<li>获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。</li>
<li>获取统计值的方法用 count 做前缀。</li>
<li>插入的方法用 save/insert 做前缀。</li>
<li>删除的方法用 remove/delete 做前缀。</li>
<li>修改的方法用 update 做前缀。</li>
</ul>
</li>
<li>领域模型命名规约<ul>
<li>数据对象：xxxDO，xxx 即为数据表名。</li>
<li>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li>
<li>展示对象：xxxVO，xxx 一般为网页名称。</li>
<li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。<a id="more"></a>
<h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>不允许任何魔法值（即未经预先定义的常量）直接出现在代码中，使用常量替换</p>
</li>
<li><p>定义类型为long或Long的属性时，需要用大写L结尾</p>
</li>
<li><p>常量定义要分类维护，一般分为：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量</p>
</li>
<li><p>如果变量值仅在一个固定范围内变化用 enum 类型来定义</p>
</li>
</ol>
<h2 id="高效能开发的原则"><a href="#高效能开发的原则" class="headerlink" title="高效能开发的原则"></a>高效能开发的原则</h2><h3 id="优化代码的注意事项"><a href="#优化代码的注意事项" class="headerlink" title="优化代码的注意事项"></a>优化代码的注意事项</h3><ol>
<li>除非必须优化，否则不要轻易改动</li>
<li>改动之后要进行仔细的测试</li>
<li>在各个JVM产品中不存在一劳永逸的成本模型</li>
</ol>
<h3 id="Java编码原则"><a href="#Java编码原则" class="headerlink" title="Java编码原则"></a>Java编码原则</h3><ol>
<li>注重设计、数据结构、算法选择</li>
<li>不要过分依赖编译器编译期的优化技术，正确理解Java运行期的实际效果</li>
<li>将对象的创建和使用降到最低：<ul>
<li>StringBuilder的使用</li>
<li>for循环中对象的索引使用</li>
<li>线程或连接的复用</li>
<li>合理设计对象的大小（在类加载过程会完成内存大小的计算）</li>
<li>合理设计继承关系（不多于3层）</li>
<li>构造函数尽可能短小精干</li>
<li>对象创建使用懒加载思想</li>
</ul>
</li>
<li>降低同步的影响范围<ul>
<li>是否需要使用同步控制或者线程安全的类</li>
<li>控制同步范围</li>
<li>合理使用锁变量，做到线程分离，提高并发度和吞吐量</li>
<li>减少锁的使用，避免出现死锁</li>
</ul>
</li>
<li>尽量在栈中完成业务处理</li>
<li>使用static、final、private函数促成inlining</li>
<li>实例变量初始化合适就好，比如单例模式</li>
<li>注意集合的使用<ul>
<li>选择合适的遍历方式</li>
<li>使用大小的控制</li>
<li>数据复制的选择</li>
<li>选择合适的集合类</li>
</ul>
</li>
<li>尽可能重用对象</li>
<li>增加缓存概念</li>
</ol>
<h2 id="集合遍历效率问题"><a href="#集合遍历效率问题" class="headerlink" title="集合遍历效率问题"></a>集合遍历效率问题</h2><h3 id="高效遍历MAP"><a href="#高效遍历MAP" class="headerlink" title="高效遍历MAP"></a>高效遍历MAP</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * keySet的for循环方式：</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetForGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetForGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetForGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	        String value = map.get(key);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetForGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * keySet的iterator迭代器方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetIteratorGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetIteratorGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySetIteratorGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next();</span><br><span class="line">	        String value = map.get(iterator.next());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;keySetIteratorGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * entrySet的for循环方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetForGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	        String key = entry.getKey();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetForGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetForGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	        String key = entry.getKey();</span><br><span class="line">	        String value = entry.getValue();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetForGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * entrySet的iterator迭代器方式：</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//只获取key</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetIteratorGetKey</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next().getKey();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetIteratorGetKey运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取key和value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySetIteratorGetKeyAndValue</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">	    Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">	    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	        String key = iterator.next().getKey();</span><br><span class="line">	        String value = iterator.next().getValue();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">	    System.out.println(<span class="string">&quot;entrySetIteratorGetKeyAndValue运行时间&quot;</span> + (endTime - startTime));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		    map.put(i + <span class="string">&quot;&quot;</span>, i + <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		MapTest.keySetForGetKey(map);</span><br><span class="line">		MapTest.keySetIteratorGetKey(map);</span><br><span class="line">		MapTest.entrySetForGetKey(map);</span><br><span class="line">		MapTest.entrySetIteratorGetKey(map);</span><br><span class="line">		</span><br><span class="line">		MapTest.keySetForGetKeyAndValue(map);</span><br><span class="line">		MapTest.keySetIteratorGetKeyAndValue(map);</span><br><span class="line">		MapTest.entrySetForGetKeyAndValue(map);</span><br><span class="line">		MapTest.entrySetIteratorGetKeyAndValue(map);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">keySetForGetKey运行时间<span class="number">96</span></span><br><span class="line">keySetIteratorGetKey运行时间<span class="number">107</span></span><br><span class="line">entrySetForGetKey运行时间<span class="number">112</span></span><br><span class="line">entrySetIteratorGetKey运行时间<span class="number">153</span></span><br><span class="line">keySetForGetKeyAndValue运行时间<span class="number">169</span></span><br><span class="line">keySetIteratorGetKeyAndValue运行时间<span class="number">283</span></span><br><span class="line">entrySetForGetKeyAndValue运行时间<span class="number">109</span></span><br><span class="line">entrySetIteratorGetKeyAndValue运行时间<span class="number">138</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：<br>entrySet的方式整体都是比keySet方式要高一些<br>单纯的获取key来说，两者的差别并不大，但是如果要获取value，还是entrySet的效率会更好，因为keySet需要从map中再次根据key获取value，而entrySet一次都全部获取出来<br>iterator的迭代器方式比foreach的效率高  </p>
</blockquote>
<h3 id="实现RandomAccess接口的集合使用for循环而不是foreach来遍历"><a href="#实现RandomAccess接口的集合使用for循环而不是foreach来遍历" class="headerlink" title="实现RandomAccess接口的集合使用for循环而不是foreach来遍历"></a>实现RandomAccess接口的集合使用for循环而不是foreach来遍历</h3><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其：色nu支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p>
<div align="center">

<img src="/2021/02/04/Java%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/1589105799147.png" class title="参考代码">

</div>

<p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p>
<h2 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h2><ol>
<li>尽量使用同步代码块替代同步方法，提高代码执行效率</li>
<li>尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</li>
</ol>
<h2 id="资源处理注意事项"><a href="#资源处理注意事项" class="headerlink" title="资源处理注意事项"></a>资源处理注意事项</h2><ol>
<li>及时关闭资源：使用资源一般都会建立流的连接，比如文件流，数据库连接等，在使用完成之后要及时关闭打开的连接，防止内存泄露。一般在finally中处理。</li>
<li>关闭多个资源时，需要分开执行，防止由于异常无法关闭所有的资源</li>
</ol>
<h2 id="垃圾信息处理"><a href="#垃圾信息处理" class="headerlink" title="垃圾信息处理"></a>垃圾信息处理</h2><ol>
<li>不要定义、创建不使用的对象，变量；</li>
<li>不要导入不需要的依赖包</li>
<li>公用的集合类中不使用的数据一定要及时remove掉</li>
<li>ThreadLocal中不使用的数据要及时处理掉，防止内存溢出</li>
<li>及时清除不再需要的会话（会话超时设置），防止出现内存不足或内存磁盘之间交互频繁，当会话不再需要时，应当及时调用HttpSession的invalidate方法清除会话。</li>
</ol>
<h2 id="尽量使用局部变量"><a href="#尽量使用局部变量" class="headerlink" title="尽量使用局部变量"></a>尽量使用局部变量</h2><ol>
<li>方法参数和临时临时变量都在栈中分配，速度快</li>
<li>类变量、实例变量存储在堆中速度较慢</li>
<li>栈中的变量随时方法的结束而结束，不需要额外的垃圾回收</li>
</ol>
<h2 id="提高效率，减少内存"><a href="#提高效率，减少内存" class="headerlink" title="提高效率，减少内存"></a>提高效率，减少内存</h2><ol>
<li>使用StringBuilder/StringBuffer替代String</li>
<li>循环内不要创建对象的引用：减少堆栈中的使用，避免出现栈内存溢出或出现栈越界。</li>
<li>尽量采用懒加载的策略，即在需要的时候才创建</li>
<li>尽量避免随意使用静态变量：当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的</li>
<li>尽量在合适的场合使用单例（减轻加载的负担、缩短加载的时间、提高加载的效率）<ul>
<li>控制资源的使用，通过线程同步来控制资源的并发访问</li>
<li>控制实例的产生，以达到节约资源的目的</li>
<li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
</li>
<li>使用数据库连接池和线程池：前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</li>
<li>使用带缓冲的输入输出流进行IO操作</li>
<li>乘法和除法使用移位操作</li>
<li>减少对变量的重复计算：对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。集合中大小的重复获取会消耗内存和时间。</li>
<li>当复制大量数据时，使用System.arraycopy命令</li>
<li>基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</li>
<li>程序运行过程中避免使用反射（根据实际情况定）：反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</li>
<li>顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个</li>
</ol>
<h2 id="关键字和方法的说明"><a href="#关键字和方法的说明" class="headerlink" title="关键字和方法的说明"></a>关键字和方法的说明</h2><h3 id="equals的正确使用"><a href="#equals的正确使用" class="headerlink" title="equals的正确使用"></a>equals的正确使用</h3><ol>
<li>重写equals后需要同时完成hashcode方法的重写</li>
<li>equals中初始代码比对的是对象地址</li>
<li>字符串比对相等时，字符串常量写在字符串变量前面，比如”abc”.equals(abc)</li>
</ol>
<h3 id="final的正确使用"><a href="#final的正确使用" class="headerlink" title="final的正确使用"></a>final的正确使用</h3><ol>
<li>如果类不能被派生，则必须定义为final（该类中的方法都是final的）</li>
<li>如果方法不能被重写，则必须定义为final</li>
<li>常量定义为static final，并且名称使用大写，多个字符使用下划线拼接，比如：USER_NAME</li>
<li>不要将数组声明为public static final（final只是表示引用不变，但是内容还是可以变）</li>
</ol>
<h3 id="方法参数要求"><a href="#方法参数要求" class="headerlink" title="方法参数要求"></a>方法参数要求</h3><p>在Java编程中，要尽量保证面向对象编程，并且达到高内聚，低耦合，实现动态扩展的特性。如果定义参数太多，会有以下缺点：</p>
<ol>
<li>违背面向对象编程</li>
<li>可扩展性低</li>
<li>方法调用出错概率大</li>
</ol>
<p>建议参数保证在3~4个之内，尽量使用有明确意义的对象传参（<strong>减少类似Map对象的使用</strong>）。</p>
<h3 id="不要对数组使用toString方法"><a href="#不要对数组使用toString方法" class="headerlink" title="不要对数组使用toString方法"></a>不要对数组使用toString方法</h3><ol>
<li>数组为空会出现空指针</li>
<li>打印的数据是地址信息，与预期不一致</li>
<li>对集合toString是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString方法。</li>
</ol>
<h2 id="异常使用注意事项"><a href="#异常使用注意事项" class="headerlink" title="异常使用注意事项"></a>异常使用注意事项</h2><ol>
<li>慎用异常：异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace的本地同步方法，fillInStackTrace方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</li>
<li>不要在循环中使用try…catch…，应该把其放在最外层，除非不得已</li>
</ol>
<h2 id="合理使用初始化长度"><a href="#合理使用初始化长度" class="headerlink" title="合理使用初始化长度"></a>合理使用初始化长度</h2><ol>
<li>集合：ArrayList、LinkedLlist等</li>
<li>字符串：StringBuilder、StringBuffer等</li>
<li>Map：HashMap等</li>
<li>Set：HashSet等</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol>
<li>不要对超出范围的基本数据类型做向下强制转型<ul>
<li>整型默认的数据类型是int，long需要在结尾增加<code>L</code></li>
<li>浮点型的默认类型是double，所以定义float的时候要写成<code>float f = 3.5f</code></li>
<li>long+int会自动转型为long</li>
</ul>
</li>
<li>基本类型（包装类）转String：<code>toString &gt; String.valueOf &gt; +</code>，可以通过源码得到原因：<ul>
<li>String.valueOf方法底层调用了Integer.toString方法，但是会在调用前做空判断</li>
<li>Integer.toString，直接调用了</li>
<li>i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString方法获取字符串</li>
</ul>
</li>
</ol>
<h2 id="日志规范"><a href="#日志规范" class="headerlink" title="日志规范"></a>日志规范</h2><ol>
<li>日志级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL，常用级别<strong>ERROR、WARN、INFO和DEBUG</strong></li>
<li>ERROR<ul>
<li>表示不能自己恢复的错误，需要立即关注和解决</li>
<li>比如：数据库连接错误、网络错误、未知系统错误</li>
<li>需要接入监控和报警系统 </li>
</ul>
</li>
<li>WARN<ul>
<li>表示可预知的错误，业务场景类错误</li>
<li>比如：参数验证、权限认证 </li>
</ul>
</li>
<li>INFO<ul>
<li>记录系统的基本运行过程和运行状态</li>
<li>包括：系统状态变化、业务流程的核心处理、关键动作、业务流状态的变化 </li>
</ul>
</li>
<li>DEBUG<ul>
<li>调试信息 </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程技巧</tag>
      </tags>
  </entry>
</search>
